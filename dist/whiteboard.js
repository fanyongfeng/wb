var bundle = (function () {
  'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  var findDom = function findDom(sel) {
    var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
    return el.querySelector(sel);
  };

  var log = {
    'log': function log(logMsg) {
      console.log(logMsg);
    },
    'error': function error(msg) {
      console.error(msg);
    }
  };

  var global$1 = (typeof global !== "undefined" ? global :
              typeof self !== "undefined" ? self :
              typeof window !== "undefined" ? window : {});

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var inited = false;
  function init () {
    inited = true;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;
  }

  function toByteArray (b64) {
    if (!inited) {
      init();
    }
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice
    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

    // base64 is 4/3 + up to two characters of the original data
    arr = new Arr(len * 3 / 4 - placeHolders);

    // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? len - 4 : len;

    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = (tmp >> 16) & 0xFF;
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr
  }

  function tripletToBase64 (num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
  }

  function encodeChunk (uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
      output.push(tripletToBase64(tmp));
    }
    return output.join('')
  }

  function fromByteArray (uint8) {
    if (!inited) {
      init();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[(tmp << 4) & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
      output += lookup[tmp >> 10];
      output += lookup[(tmp >> 4) & 0x3F];
      output += lookup[(tmp << 2) & 0x3F];
      output += '=';
    }

    parts.push(output);

    return parts.join('')
  }

  function read (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  }

  function write (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  }

  var toString = {}.toString;

  var isArray = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
  };

  var INSPECT_MAX_BYTES = 50;

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.

   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
    ? global$1.TYPED_ARRAY_SUPPORT
    : true;

  function kMaxLength () {
    return Buffer.TYPED_ARRAY_SUPPORT
      ? 0x7fffffff
      : 0x3fffffff
  }

  function createBuffer (that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length')
    }
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer(length);
      }
      that.length = length;
    }

    return that
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer (arg, encodingOrOffset, length) {
    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
      return new Buffer(arg, encodingOrOffset, length)
    }

    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error(
          'If encoding is specified then the first argument must be a string'
        )
      }
      return allocUnsafe(this, arg)
    }
    return from(this, arg, encodingOrOffset, length)
  }

  Buffer.poolSize = 8192; // not used by this implementation

  // TODO: Legacy, not needed anymore. Remove in next major version.
  Buffer._augment = function (arr) {
    arr.__proto__ = Buffer.prototype;
    return arr
  };

  function from (that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number')
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length)
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset)
    }

    return fromObject(that, value)
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length)
  };

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  }

  function assertSize (size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number')
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative')
    }
  }

  function alloc (that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size)
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(that, size).fill(fill, encoding)
        : createBuffer(that, size).fill(fill)
    }
    return createBuffer(that, size)
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding)
  };

  function allocUnsafe (that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(null, size)
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size)
  };

  function fromString (that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding')
    }

    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);

    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that
  }

  function fromArrayLike (that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that
  }

  function fromArrayBuffer (that, array, byteOffset, length) {
    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds')
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds')
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array);
    }
    return that
  }

  function fromObject (that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that
      }

      obj.copy(that, 0, 0, len);
      return that
    }

    if (obj) {
      if ((typeof ArrayBuffer !== 'undefined' &&
          obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0)
        }
        return fromArrayLike(that, obj)
      }

      if (obj.type === 'Buffer' && isArray(obj.data)) {
        return fromArrayLike(that, obj.data)
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
  }

  function checked (length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                           'size: 0x' + kMaxLength().toString(16) + ' bytes')
    }
    return length | 0
  }
  Buffer.isBuffer = isBuffer;
  function internalIsBuffer (b) {
    return !!(b != null && b._isBuffer)
  }

  Buffer.compare = function compare (a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError('Arguments must be Buffers')
    }

    if (a === b) return 0

    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  Buffer.isEncoding = function isEncoding (encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  };

  Buffer.concat = function concat (list, length) {
    if (!isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }

    if (list.length === 0) {
      return Buffer.alloc(0)
    }

    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer
  };

  function byteLength (string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length
    }
    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength
    }
    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string).length
        default:
          if (loweredCase) return utf8ToBytes(string).length // assume utf8
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;

  function slowToString (encoding, start, end) {
    var loweredCase = false;

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return ''
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return ''
    }

    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return ''
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)

        case 'ascii':
          return asciiSlice(this, start, end)

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)

        case 'base64':
          return base64Slice(this, start, end)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.
  Buffer.prototype._isBuffer = true;

  function swap (b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16 () {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this
  };

  Buffer.prototype.swap32 = function swap32 () {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this
  };

  Buffer.prototype.swap64 = function swap64 () {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this
  };

  Buffer.prototype.toString = function toString () {
    var length = this.length | 0;
    if (length === 0) return ''
    if (arguments.length === 0) return utf8Slice(this, 0, length)
    return slowToString.apply(this, arguments)
  };

  Buffer.prototype.equals = function equals (b) {
    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
    if (this === b) return true
    return Buffer.compare(this, b) === 0
  };

  Buffer.prototype.inspect = function inspect () {
    var str = '';
    var max = INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }
    return '<Buffer ' + str + '>'
  };

  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError('Argument must be a Buffer')
    }

    if (start === undefined) {
      start = 0;
    }
    if (end === undefined) {
      end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
      thisStart = 0;
    }
    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;

    if (this === target) return 0

    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);

    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;  // Coerce to Number.
    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : (buffer.length - 1);
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1
      else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (internalIsBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]
      if (Buffer.TYPED_ARRAY_SUPPORT &&
          typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
    }

    throw new TypeError('val must be string, number or Buffer')
  }

  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read$$1 (buf, i) {
      if (indexSize === 1) {
        return buf[i]
      } else {
        return buf.readUInt16BE(i * indexSize)
      }
    }

    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read$$1(arr, i) === read$$1(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read$$1(arr, i + j) !== read$$1(val, j)) {
            found = false;
            break
          }
        }
        if (found) return i
      }
    }

    return -1
  }

  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  };

  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  };

  function hexWrite (buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    // must be an even number of digits
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i
      buf[offset + i] = parsed;
    }
    return i
  }

  function utf8Write (buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  }

  function asciiWrite (buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length)
  }

  function latin1Write (buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length)
  }

  function base64Write (buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length)
  }

  function ucs2Write (buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  }

  Buffer.prototype.write = function write$$1 (string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }

    if (!encoding) encoding = 'utf8';

    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length)

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length)

        case 'ascii':
          return asciiWrite(this, string, offset, length)

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length)

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON () {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    }
  };

  function base64Slice (buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf)
    } else {
      return fromByteArray(buf.slice(start, end))
    }
  }

  function utf8Slice (buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];

    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4
        : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
        : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res)
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray (codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res
  }

  function asciiSlice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret
  }

  function latin1Slice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret
  }

  function hexSlice (buf, start, end) {
    var len = buf.length;

    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;

    var out = '';
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out
  }

  function utf16leSlice (buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res
  }

  Buffer.prototype.slice = function slice (start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;

    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset (offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  }

  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val
  };

  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val
  };

  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset]
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8)
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1]
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
  };

  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return (this[offset])
    return ((0xff - this[offset] + 1) * -1)
  };

  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
  };

  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
  };

  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4)
  };

  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4)
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8)
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8)
  };

  function checkInt (buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = (value & 0xff);
    return offset + 1
  };

  function objectWriteUInt16 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
        (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  function objectWriteUInt32 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  function checkIEEE754 (buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
    if (offset < 0) throw new RangeError('Index out of range')
  }

  function writeFloat (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  };

  function writeDouble (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy (target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart
      );
    }

    return len
  };

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer.prototype.fill = function fill (val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }

    if (end <= start) {
      return this
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;

    if (!val) val = 0;

    var i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val)
        ? val
        : utf8ToBytes(new Buffer(val, encoding).toString());
      var len = bytes.length;
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this
  };

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean (str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return ''
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str
  }

  function stringtrim (str) {
    if (str.trim) return str.trim()
    return str.replace(/^\s+|\s+$/g, '')
  }

  function toHex (n) {
    if (n < 16) return '0' + n.toString(16)
    return n.toString(16)
  }

  function utf8ToBytes (string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          }

          // valid lead
          leadSurrogate = codePoint;

          continue
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break
        bytes.push(
          codePoint >> 0x6 | 0xC0,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break
        bytes.push(
          codePoint >> 0xC | 0xE0,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break
        bytes.push(
          codePoint >> 0x12 | 0xF0,
          codePoint >> 0xC & 0x3F | 0x80,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else {
        throw new Error('Invalid code point')
      }
    }

    return bytes
  }

  function asciiToBytes (str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray
  }

  function utf16leToBytes (str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray
  }


  function base64ToBytes (str) {
    return toByteArray(base64clean(str))
  }

  function blitBuffer (src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if ((i + offset >= dst.length) || (i >= src.length)) break
      dst[i + offset] = src[i];
    }
    return i
  }

  function isnan (val) {
    return val !== val // eslint-disable-line no-self-compare
  }


  // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually
  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
  }

  function isFastBuffer (obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  }

  // For Node v0.10 support. Remove this eventually.
  function isSlowBuffer (obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
  }

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var empty = {};

  var empty$1 = /*#__PURE__*/Object.freeze({
    default: empty
  });

  var require$$3 = ( empty$1 && empty ) || empty$1;

  var fabric_1 = createCommonjsModule(function (module, exports) {
  /* build: `node build.js modules=ALL exclude=gestures,accessors requirejs minifier=uglifyjs` */
  /*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */

  var fabric = fabric || { version: '2.3.3' };
  {
    exports.fabric = fabric;
  }
  /* _AMD_END_ */
  if (typeof document !== 'undefined' && typeof window !== 'undefined') {
    fabric.document = document;
    fabric.window = window;
  }
  else {
    // assume we're running under node.js when document/window are not present
    fabric.document = require$$3
      .jsdom(
        decodeURIComponent('%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E'),
        { features: {
          FetchExternalResources: ['img']
        }
        });
    fabric.jsdomImplForWrapper = require$$3.implForWrapper;
    fabric.nodeCanvas = require$$3.Canvas;
    fabric.window = fabric.document.defaultView;
    DOMParser = require$$3.DOMParser;
  }

  /**
   * True when in environment that supports touch events
   * @type boolean
   */
  fabric.isTouchSupported = 'ontouchstart' in fabric.window;

  /**
   * True when in environment that's probably Node.js
   * @type boolean
   */
  fabric.isLikelyNode = typeof Buffer !== 'undefined' &&
                        typeof window === 'undefined';

  /* _FROM_SVG_START_ */
  /**
   * Attributes parsed from all SVG elements
   * @type array
   */
  fabric.SHARED_ATTRIBUTES = [
    "display",
    "transform",
    "fill", "fill-opacity", "fill-rule",
    "opacity",
    "stroke", "stroke-dasharray", "stroke-linecap",
    "stroke-linejoin", "stroke-miterlimit",
    "stroke-opacity", "stroke-width",
    "id", "paint-order",
    "instantiated_by_use"
  ];
  /* _FROM_SVG_END_ */

  /**
   * Pixel per Inch as a default value set to 96. Can be changed for more realistic conversion.
   */
  fabric.DPI = 96;
  fabric.reNum = '(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:e[-+]?\\d+)?)';
  fabric.fontPaths = { };
  fabric.iMatrix = [1, 0, 0, 1, 0, 0];
  fabric.canvasModule = 'canvas';

  /**
   * Pixel limit for cache canvases. 1Mpx , 4Mpx should be fine.
   * @since 1.7.14
   * @type Number
   * @default
   */
  fabric.perfLimitSizeTotal = 2097152;

  /**
   * Pixel limit for cache canvases width or height. IE fixes the maximum at 5000
   * @since 1.7.14
   * @type Number
   * @default
   */
  fabric.maxCacheSideLimit = 4096;

  /**
   * Lowest pixel limit for cache canvases, set at 256PX
   * @since 1.7.14
   * @type Number
   * @default
   */
  fabric.minCacheSideLimit = 256;

  /**
   * Cache Object for widths of chars in text rendering.
   */
  fabric.charWidthsCache = { };

  /**
   * if webgl is enabled and available, textureSize will determine the size
   * of the canvas backend
   * @since 2.0.0
   * @type Number
   * @default
   */
  fabric.textureSize = 2048;

  /**
   * Enable webgl for filtering picture is available
   * A filtering backend will be initialized, this will both take memory and
   * time since a default 2048x2048 canvas will be created for the gl context
   * @since 2.0.0
   * @type Boolean
   * @default
   */
  fabric.enableGLFiltering = true;

  /**
   * Device Pixel Ratio
   * @see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html
   */
  fabric.devicePixelRatio = fabric.window.devicePixelRatio ||
                            fabric.window.webkitDevicePixelRatio ||
                            fabric.window.mozDevicePixelRatio ||
                            1;
  /**
   * Browser-specific constant to adjust CanvasRenderingContext2D.shadowBlur value,
   * which is unitless and not rendered equally across browsers.
   *
   * Values that work quite well (as of October 2017) are:
   * - Chrome: 1.5
   * - Edge: 1.75
   * - Firefox: 0.9
   * - Safari: 0.95
   *
   * @since 2.0.0
   * @type Number
   * @default 1
   */
  fabric.browserShadowBlurConstant = 1;

  fabric.initFilterBackend = function() {
    if (fabric.enableGLFiltering && fabric.isWebglSupported && fabric.isWebglSupported(fabric.textureSize)) {
      console.log('max texture size: ' + fabric.maxTextureSize);
      return (new fabric.WebglFilterBackend({ tileSize: fabric.textureSize }));
    }
    else if (fabric.Canvas2dFilterBackend) {
      return (new fabric.Canvas2dFilterBackend());
    }
  };


  if (typeof document !== 'undefined' && typeof window !== 'undefined') {
    // ensure globality even if entire library were function wrapped (as in Meteor.js packaging system)
    window.fabric = fabric;
  }


  (function() {

    /**
     * @private
     * @param {String} eventName
     * @param {Function} handler
     */
    function _removeEventListener(eventName, handler) {
      if (!this.__eventListeners[eventName]) {
        return;
      }
      var eventListener = this.__eventListeners[eventName];
      if (handler) {
        eventListener[eventListener.indexOf(handler)] = false;
      }
      else {
        fabric.util.array.fill(eventListener, false);
      }
    }

    /**
     * Observes specified event
     * @deprecated `observe` deprecated since 0.8.34 (use `on` instead)
     * @memberOf fabric.Observable
     * @alias on
     * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
     * @param {Function} handler Function that receives a notification when an event of the specified type occurs
     * @return {Self} thisArg
     * @chainable
     */
    function observe(eventName, handler) {
      if (!this.__eventListeners) {
        this.__eventListeners = { };
      }
      // one object with key/value pairs was passed
      if (arguments.length === 1) {
        for (var prop in eventName) {
          this.on(prop, eventName[prop]);
        }
      }
      else {
        if (!this.__eventListeners[eventName]) {
          this.__eventListeners[eventName] = [];
        }
        this.__eventListeners[eventName].push(handler);
      }
      return this;
    }

    /**
     * Stops event observing for a particular event handler. Calling this method
     * without arguments removes all handlers for all events
     * @deprecated `stopObserving` deprecated since 0.8.34 (use `off` instead)
     * @memberOf fabric.Observable
     * @alias off
     * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
     * @param {Function} handler Function to be deleted from EventListeners
     * @return {Self} thisArg
     * @chainable
     */
    function stopObserving(eventName, handler) {
      if (!this.__eventListeners) {
        return;
      }

      // remove all key/value pairs (event name -> event handler)
      if (arguments.length === 0) {
        for (eventName in this.__eventListeners) {
          _removeEventListener.call(this, eventName);
        }
      }
      // one object with key/value pairs was passed
      else if (arguments.length === 1 && typeof arguments[0] === 'object') {
        for (var prop in eventName) {
          _removeEventListener.call(this, prop, eventName[prop]);
        }
      }
      else {
        _removeEventListener.call(this, eventName, handler);
      }
      return this;
    }

    /**
     * Fires event with an optional options object
     * @deprecated `fire` deprecated since 1.0.7 (use `trigger` instead)
     * @memberOf fabric.Observable
     * @alias trigger
     * @param {String} eventName Event name to fire
     * @param {Object} [options] Options object
     * @return {Self} thisArg
     * @chainable
     */
    function fire(eventName, options) {
      if (!this.__eventListeners) {
        return;
      }

      var listenersForEvent = this.__eventListeners[eventName];
      if (!listenersForEvent) {
        return;
      }

      for (var i = 0, len = listenersForEvent.length; i < len; i++) {
        listenersForEvent[i] && listenersForEvent[i].call(this, options || { });
      }
      this.__eventListeners[eventName] = listenersForEvent.filter(function(value) {
        return value !== false;
      });
      return this;
    }

    /**
     * @namespace fabric.Observable
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#events}
     * @see {@link http://fabricjs.com/events|Events demo}
     */
    fabric.Observable = {
      observe: observe,
      stopObserving: stopObserving,
      fire: fire,

      on: observe,
      off: stopObserving,
      trigger: fire
    };
  })();


  /**
   * @namespace fabric.Collection
   */
  fabric.Collection = {

    _objects: [],

    /**
     * Adds objects to collection, Canvas or Group, then renders canvas
     * (if `renderOnAddRemove` is not `false`).
     * in case of Group no changes to bounding box are made.
     * Objects should be instances of (or inherit from) fabric.Object
     * Use of this function is highly discouraged for groups.
     * you can add a bunch of objects with the add method but then you NEED
     * to run a addWithUpdate call for the Group class or position/bbox will be wrong.
     * @param {...fabric.Object} object Zero or more fabric instances
     * @return {Self} thisArg
     * @chainable
     */
    add: function () {
      this._objects.push.apply(this._objects, arguments);
      if (this._onObjectAdded) {
        for (var i = 0, length = arguments.length; i < length; i++) {
          this._onObjectAdded(arguments[i]);
        }
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)
     * An object should be an instance of (or inherit from) fabric.Object
     * Use of this function is highly discouraged for groups.
     * you can add a bunch of objects with the insertAt method but then you NEED
     * to run a addWithUpdate call for the Group class or position/bbox will be wrong.
     * @param {Object} object Object to insert
     * @param {Number} index Index to insert object at
     * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs
     * @return {Self} thisArg
     * @chainable
     */
    insertAt: function (object, index, nonSplicing) {
      var objects = this.getObjects();
      if (nonSplicing) {
        objects[index] = object;
      }
      else {
        objects.splice(index, 0, object);
      }
      this._onObjectAdded && this._onObjectAdded(object);
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)
     * @param {...fabric.Object} object Zero or more fabric instances
     * @return {Self} thisArg
     * @chainable
     */
    remove: function() {
      var objects = this.getObjects(),
          index, somethingRemoved = false;

      for (var i = 0, length = arguments.length; i < length; i++) {
        index = objects.indexOf(arguments[i]);

        // only call onObjectRemoved if an object was actually removed
        if (index !== -1) {
          somethingRemoved = true;
          objects.splice(index, 1);
          this._onObjectRemoved && this._onObjectRemoved(arguments[i]);
        }
      }

      this.renderOnAddRemove && somethingRemoved && this.requestRenderAll();
      return this;
    },

    /**
     * Executes given function for each object in this group
     * @param {Function} callback
     *                   Callback invoked with current object as first argument,
     *                   index - as second and an array of all objects - as third.
     *                   Callback is invoked in a context of Global Object (e.g. `window`)
     *                   when no `context` argument is given
     *
     * @param {Object} context Context (aka thisObject)
     * @return {Self} thisArg
     * @chainable
     */
    forEachObject: function(callback, context) {
      var objects = this.getObjects();
      for (var i = 0, len = objects.length; i < len; i++) {
        callback.call(context, objects[i], i, objects);
      }
      return this;
    },

    /**
     * Returns an array of children objects of this instance
     * Type parameter introduced in 1.3.10
     * @param {String} [type] When specified, only objects of this type are returned
     * @return {Array}
     */
    getObjects: function(type) {
      if (typeof type === 'undefined') {
        return this._objects;
      }
      return this._objects.filter(function(o) {
        return o.type === type;
      });
    },

    /**
     * Returns object at specified index
     * @param {Number} index
     * @return {Self} thisArg
     */
    item: function (index) {
      return this.getObjects()[index];
    },

    /**
     * Returns true if collection contains no objects
     * @return {Boolean} true if collection is empty
     */
    isEmpty: function () {
      return this.getObjects().length === 0;
    },

    /**
     * Returns a size of a collection (i.e: length of an array containing its objects)
     * @return {Number} Collection size
     */
    size: function() {
      return this.getObjects().length;
    },

    /**
     * Returns true if collection contains an object
     * @param {Object} object Object to check against
     * @return {Boolean} `true` if collection contains an object
     */
    contains: function(object) {
      return this.getObjects().indexOf(object) > -1;
    },

    /**
     * Returns number representation of a collection complexity
     * @return {Number} complexity
     */
    complexity: function () {
      return this.getObjects().reduce(function (memo, current) {
        memo += current.complexity ? current.complexity() : 0;
        return memo;
      }, 0);
    }
  };


  /**
   * @namespace fabric.CommonMethods
   */
  fabric.CommonMethods = {

    /**
     * Sets object's properties from options
     * @param {Object} [options] Options object
     */
    _setOptions: function(options) {
      for (var prop in options) {
        this.set(prop, options[prop]);
      }
    },

    /**
     * @private
     * @param {Object} [filler] Options object
     * @param {String} [property] property to set the Gradient to
     */
    _initGradient: function(filler, property) {
      if (filler && filler.colorStops && !(filler instanceof fabric.Gradient)) {
        this.set(property, new fabric.Gradient(filler));
      }
    },

    /**
     * @private
     * @param {Object} [filler] Options object
     * @param {String} [property] property to set the Pattern to
     * @param {Function} [callback] callback to invoke after pattern load
     */
    _initPattern: function(filler, property, callback) {
      if (filler && filler.source && !(filler instanceof fabric.Pattern)) {
        this.set(property, new fabric.Pattern(filler, callback));
      }
      else {
        callback && callback();
      }
    },

    /**
     * @private
     * @param {Object} [options] Options object
     */
    _initClipping: function(options) {
      if (!options.clipTo || typeof options.clipTo !== 'string') {
        return;
      }

      var functionBody = fabric.util.getFunctionBody(options.clipTo);
      if (typeof functionBody !== 'undefined') {
        this.clipTo = new Function('ctx', functionBody);
      }
    },

    /**
     * @private
     */
    _setObject: function(obj) {
      for (var prop in obj) {
        this._set(prop, obj[prop]);
      }
    },

    /**
     * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
     * @param {String|Object} key Property name or object (if object, iterate over the object properties)
     * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
     * @return {fabric.Object} thisArg
     * @chainable
     */
    set: function(key, value) {
      if (typeof key === 'object') {
        this._setObject(key);
      }
      else {
        if (typeof value === 'function' && key !== 'clipTo') {
          this._set(key, value(this.get(key)));
        }
        else {
          this._set(key, value);
        }
      }
      return this;
    },

    _set: function(key, value) {
      this[key] = value;
    },

    /**
     * Toggles specified property from `true` to `false` or from `false` to `true`
     * @param {String} property Property to toggle
     * @return {fabric.Object} thisArg
     * @chainable
     */
    toggle: function(property) {
      var value = this.get(property);
      if (typeof value === 'boolean') {
        this.set(property, !value);
      }
      return this;
    },

    /**
     * Basic getter
     * @param {String} property Property name
     * @return {*} value of a property
     */
    get: function(property) {
      return this[property];
    }
  };


  (function(global) {

    var sqrt = Math.sqrt,
        atan2 = Math.atan2,
        pow = Math.pow,
        abs = Math.abs,
        PiBy180 = Math.PI / 180,
        PiBy2 = Math.PI / 2;

    /**
     * @namespace fabric.util
     */
    fabric.util = {

      /**
       * Calculate the cos of an angle, avoiding returning floats for known results
       * @static
       * @memberOf fabric.util
       * @param {Number} angle the angle in radians or in degree
       * @return {Number}
       */
      cos: function(angle) {
        if (angle === 0) { return 1; }
        if (angle < 0) {
          // cos(a) = cos(-a)
          angle = -angle;
        }
        var angleSlice = angle / PiBy2;
        switch (angleSlice) {
          case 1: case 3: return 0;
          case 2: return -1;
        }
        return Math.cos(angle);
      },

      /**
       * Calculate the sin of an angle, avoiding returning floats for known results
       * @static
       * @memberOf fabric.util
       * @param {Number} angle the angle in radians or in degree
       * @return {Number}
       */
      sin: function(angle) {
        if (angle === 0) { return 0; }
        var angleSlice = angle / PiBy2, sign = 1;
        if (angle < 0) {
          // sin(-a) = -sin(a)
          sign = -1;
        }
        switch (angleSlice) {
          case 1: return sign;
          case 2: return 0;
          case 3: return -sign;
        }
        return Math.sin(angle);
      },

      /**
       * Removes value from an array.
       * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`
       * @static
       * @memberOf fabric.util
       * @param {Array} array
       * @param {*} value
       * @return {Array} original array
       */
      removeFromArray: function(array, value) {
        var idx = array.indexOf(value);
        if (idx !== -1) {
          array.splice(idx, 1);
        }
        return array;
      },

      /**
       * Returns random number between 2 specified ones.
       * @static
       * @memberOf fabric.util
       * @param {Number} min lower limit
       * @param {Number} max upper limit
       * @return {Number} random value (between min and max)
       */
      getRandomInt: function(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      },

      /**
       * Transforms degrees to radians.
       * @static
       * @memberOf fabric.util
       * @param {Number} degrees value in degrees
       * @return {Number} value in radians
       */
      degreesToRadians: function(degrees) {
        return degrees * PiBy180;
      },

      /**
       * Transforms radians to degrees.
       * @static
       * @memberOf fabric.util
       * @param {Number} radians value in radians
       * @return {Number} value in degrees
       */
      radiansToDegrees: function(radians) {
        return radians / PiBy180;
      },

      /**
       * Rotates `point` around `origin` with `radians`
       * @static
       * @memberOf fabric.util
       * @param {fabric.Point} point The point to rotate
       * @param {fabric.Point} origin The origin of the rotation
       * @param {Number} radians The radians of the angle for the rotation
       * @return {fabric.Point} The new rotated point
       */
      rotatePoint: function(point, origin, radians) {
        point.subtractEquals(origin);
        var v = fabric.util.rotateVector(point, radians);
        return new fabric.Point(v.x, v.y).addEquals(origin);
      },

      /**
       * Rotates `vector` with `radians`
       * @static
       * @memberOf fabric.util
       * @param {Object} vector The vector to rotate (x and y)
       * @param {Number} radians The radians of the angle for the rotation
       * @return {Object} The new rotated point
       */
      rotateVector: function(vector, radians) {
        var sin = fabric.util.sin(radians),
            cos = fabric.util.cos(radians),
            rx = vector.x * cos - vector.y * sin,
            ry = vector.x * sin + vector.y * cos;
        return {
          x: rx,
          y: ry
        };
      },

      /**
       * Apply transform t to point p
       * @static
       * @memberOf fabric.util
       * @param  {fabric.Point} p The point to transform
       * @param  {Array} t The transform
       * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied
       * @return {fabric.Point} The transformed point
       */
      transformPoint: function(p, t, ignoreOffset) {
        if (ignoreOffset) {
          return new fabric.Point(
            t[0] * p.x + t[2] * p.y,
            t[1] * p.x + t[3] * p.y
          );
        }
        return new fabric.Point(
          t[0] * p.x + t[2] * p.y + t[4],
          t[1] * p.x + t[3] * p.y + t[5]
        );
      },

      /**
       * Returns coordinates of points's bounding rectangle (left, top, width, height)
       * @param {Array} points 4 points array
       * @return {Object} Object with left, top, width, height properties
       */
      makeBoundingBoxFromPoints: function(points) {
        var xPoints = [points[0].x, points[1].x, points[2].x, points[3].x],
            minX = fabric.util.array.min(xPoints),
            maxX = fabric.util.array.max(xPoints),
            width = maxX - minX,
            yPoints = [points[0].y, points[1].y, points[2].y, points[3].y],
            minY = fabric.util.array.min(yPoints),
            maxY = fabric.util.array.max(yPoints),
            height = maxY - minY;

        return {
          left: minX,
          top: minY,
          width: width,
          height: height
        };
      },

      /**
       * Invert transformation t
       * @static
       * @memberOf fabric.util
       * @param {Array} t The transform
       * @return {Array} The inverted transform
       */
      invertTransform: function(t) {
        var a = 1 / (t[0] * t[3] - t[1] * t[2]),
            r = [a * t[3], -a * t[1], -a * t[2], a * t[0]],
            o = fabric.util.transformPoint({ x: t[4], y: t[5] }, r, true);
        r[4] = -o.x;
        r[5] = -o.y;
        return r;
      },

      /**
       * A wrapper around Number#toFixed, which contrary to native method returns number, not string.
       * @static
       * @memberOf fabric.util
       * @param {Number|String} number number to operate on
       * @param {Number} fractionDigits number of fraction digits to "leave"
       * @return {Number}
       */
      toFixed: function(number, fractionDigits) {
        return parseFloat(Number(number).toFixed(fractionDigits));
      },

      /**
       * Converts from attribute value to pixel value if applicable.
       * Returns converted pixels or original value not converted.
       * @param {Number|String} value number to operate on
       * @param {Number} fontSize
       * @return {Number|String}
       */
      parseUnit: function(value, fontSize) {
        var unit = /\D{0,2}$/.exec(value),
            number = parseFloat(value);
        if (!fontSize) {
          fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
        }
        switch (unit[0]) {
          case 'mm':
            return number * fabric.DPI / 25.4;

          case 'cm':
            return number * fabric.DPI / 2.54;

          case 'in':
            return number * fabric.DPI;

          case 'pt':
            return number * fabric.DPI / 72; // or * 4 / 3

          case 'pc':
            return number * fabric.DPI / 72 * 12; // or * 16

          case 'em':
            return number * fontSize;

          default:
            return number;
        }
      },

      /**
       * Function which always returns `false`.
       * @static
       * @memberOf fabric.util
       * @return {Boolean}
       */
      falseFunction: function() {
        return false;
      },

      /**
       * Returns klass "Class" object of given namespace
       * @memberOf fabric.util
       * @param {String} type Type of object (eg. 'circle')
       * @param {String} namespace Namespace to get klass "Class" object from
       * @return {Object} klass "Class"
       */
      getKlass: function(type, namespace) {
        // capitalize first letter only
        type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));
        return fabric.util.resolveNamespace(namespace)[type];
      },

      /**
       * Returns array of attributes for given svg that fabric parses
       * @memberOf fabric.util
       * @param {String} type Type of svg element (eg. 'circle')
       * @return {Array} string names of supported attributes
       */
      getSvgAttributes: function(type) {
        var attributes = [
          'instantiated_by_use',
          'style',
          'id',
          'class'
        ];
        switch (type) {
          case 'linearGradient':
            attributes = attributes.concat(['x1', 'y1', 'x2', 'y2', 'gradientUnits', 'gradientTransform']);
            break;
          case 'radialGradient':
            attributes = attributes.concat(['gradientUnits', 'gradientTransform', 'cx', 'cy', 'r', 'fx', 'fy', 'fr']);
            break;
          case 'stop':
            attributes = attributes.concat(['offset', 'stop-color', 'stop-opacity']);
            break;
        }
        return attributes;
      },

      /**
       * Returns object of given namespace
       * @memberOf fabric.util
       * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'
       * @return {Object} Object for given namespace (default fabric)
       */
      resolveNamespace: function(namespace) {
        if (!namespace) {
          return fabric;
        }

        var parts = namespace.split('.'),
            len = parts.length, i,
            obj = global || fabric.window;

        for (i = 0; i < len; ++i) {
          obj = obj[parts[i]];
        }

        return obj;
      },

      /**
       * Loads image element from given url and passes it to a callback
       * @memberOf fabric.util
       * @param {String} url URL representing an image
       * @param {Function} callback Callback; invoked with loaded image
       * @param {*} [context] Context to invoke callback in
       * @param {Object} [crossOrigin] crossOrigin value to set image element to
       */
      loadImage: function(url, callback, context, crossOrigin) {
        if (!url) {
          callback && callback.call(context, url);
          return;
        }

        var img = fabric.util.createImage();

        /** @ignore */
        var onLoadCallback = function () {
          callback && callback.call(context, img);
          img = img.onload = img.onerror = null;
        };

        img.onload = onLoadCallback;
        /** @ignore */
        img.onerror = function() {
          fabric.log('Error loading ' + img.src);
          callback && callback.call(context, null, true);
          img = img.onload = img.onerror = null;
        };

        // data-urls appear to be buggy with crossOrigin
        // https://github.com/kangax/fabric.js/commit/d0abb90f1cd5c5ef9d2a94d3fb21a22330da3e0a#commitcomment-4513767
        // see https://code.google.com/p/chromium/issues/detail?id=315152
        //     https://bugzilla.mozilla.org/show_bug.cgi?id=935069
        if (url.indexOf('data') !== 0 && crossOrigin) {
          img.crossOrigin = crossOrigin;
        }

        // IE10 / IE11-Fix: SVG contents from data: URI
        // will only be available if the IMG is present
        // in the DOM (and visible)
        if (url.substring(0,14) === 'data:image/svg') {
          img.onload = null;
          fabric.util.loadImageInDom(img, onLoadCallback);
        }

        img.src = url;
      },

      /**
       * Attaches SVG image with data: URL to the dom
       * @memberOf fabric.util
       * @param {Object} img Image object with data:image/svg src
       * @param {Function} callback Callback; invoked with loaded image
       * @return {Object} DOM element (div containing the SVG image)
       */
      loadImageInDom: function(img, onLoadCallback) {
        var div = fabric.document.createElement('div');
        div.style.width = div.style.height = '1px';
        div.style.left = div.style.top = '-100%';
        div.style.position = 'absolute';
        div.appendChild(img);
        fabric.document.querySelector('body').appendChild(div);
        /**
         * Wrap in function to:
         *   1. Call existing callback
         *   2. Cleanup DOM
         */
        img.onload = function () {
          onLoadCallback();
          div.parentNode.removeChild(div);
          div = null;
        };
      },

      /**
       * Creates corresponding fabric instances from their object representations
       * @static
       * @memberOf fabric.util
       * @param {Array} objects Objects to enliven
       * @param {Function} callback Callback to invoke when all objects are created
       * @param {String} namespace Namespace to get klass "Class" object from
       * @param {Function} reviver Method for further parsing of object elements,
       * called after each fabric object created.
       */
      enlivenObjects: function(objects, callback, namespace, reviver) {
        objects = objects || [];

        function onLoaded() {
          if (++numLoadedObjects === numTotalObjects) {
            callback && callback(enlivenedObjects);
          }
        }

        var enlivenedObjects = [],
            numLoadedObjects = 0,
            numTotalObjects = objects.length;

        if (!numTotalObjects) {
          callback && callback(enlivenedObjects);
          return;
        }

        objects.forEach(function (o, index) {
          // if sparse array
          if (!o || !o.type) {
            onLoaded();
            return;
          }
          var klass = fabric.util.getKlass(o.type, namespace);
          klass.fromObject(o, function (obj, error) {
            error || (enlivenedObjects[index] = obj);
            reviver && reviver(o, obj, error);
            onLoaded();
          });
        });
      },

      /**
       * Create and wait for loading of patterns
       * @static
       * @memberOf fabric.util
       * @param {Array} patterns Objects to enliven
       * @param {Function} callback Callback to invoke when all objects are created
       * called after each fabric object created.
       */
      enlivenPatterns: function(patterns, callback) {
        patterns = patterns || [];

        function onLoaded() {
          if (++numLoadedPatterns === numPatterns) {
            callback && callback(enlivenedPatterns);
          }
        }

        var enlivenedPatterns = [],
            numLoadedPatterns = 0,
            numPatterns = patterns.length;

        if (!numPatterns) {
          callback && callback(enlivenedPatterns);
          return;
        }

        patterns.forEach(function (p, index) {
          if (p && p.source) {
            new fabric.Pattern(p, function(pattern) {
              enlivenedPatterns[index] = pattern;
              onLoaded();
            });
          }
          else {
            enlivenedPatterns[index] = p;
            onLoaded();
          }
        });
      },

      /**
       * Groups SVG elements (usually those retrieved from SVG document)
       * @static
       * @memberOf fabric.util
       * @param {Array} elements SVG elements to group
       * @param {Object} [options] Options object
       * @param {String} path Value to set sourcePath to
       * @return {fabric.Object|fabric.Group}
       */
      groupSVGElements: function(elements, options, path) {
        var object;
        if (elements.length === 1) {
          return elements[0];
        }
        if (options) {
          if (options.width && options.height) {
            options.centerPoint = {
              x: options.width / 2,
              y: options.height / 2
            };
          }
          else {
            delete options.width;
            delete options.height;
          }
        }
        object = new fabric.Group(elements, options);
        if (typeof path !== 'undefined') {
          object.sourcePath = path;
        }
        return object;
      },

      /**
       * Populates an object with properties of another object
       * @static
       * @memberOf fabric.util
       * @param {Object} source Source object
       * @param {Object} destination Destination object
       * @return {Array} properties Properties names to include
       */
      populateWithProperties: function(source, destination, properties) {
        if (properties && Object.prototype.toString.call(properties) === '[object Array]') {
          for (var i = 0, len = properties.length; i < len; i++) {
            if (properties[i] in source) {
              destination[properties[i]] = source[properties[i]];
            }
          }
        }
      },

      /**
       * Draws a dashed line between two points
       *
       * This method is used to draw dashed line around selection area.
       * See <a href="http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas">dotted stroke in canvas</a>
       *
       * @param {CanvasRenderingContext2D} ctx context
       * @param {Number} x  start x coordinate
       * @param {Number} y start y coordinate
       * @param {Number} x2 end x coordinate
       * @param {Number} y2 end y coordinate
       * @param {Array} da dash array pattern
       */
      drawDashedLine: function(ctx, x, y, x2, y2, da) {
        var dx = x2 - x,
            dy = y2 - y,
            len = sqrt(dx * dx + dy * dy),
            rot = atan2(dy, dx),
            dc = da.length,
            di = 0,
            draw = true;

        ctx.save();
        ctx.translate(x, y);
        ctx.moveTo(0, 0);
        ctx.rotate(rot);

        x = 0;
        while (len > x) {
          x += da[di++ % dc];
          if (x > len) {
            x = len;
          }
          ctx[draw ? 'lineTo' : 'moveTo'](x, 0);
          draw = !draw;
        }

        ctx.restore();
      },

      /**
       * Creates canvas element
       * @static
       * @memberOf fabric.util
       * @return {CanvasElement} initialized canvas element
       */
      createCanvasElement: function() {
        return fabric.document.createElement('canvas');
      },

      /**
       * Creates image element (works on client and node)
       * @static
       * @memberOf fabric.util
       * @return {HTMLImageElement} HTML image element
       */
      createImage: function() {
        return fabric.document.createElement('img');
      },

      /**
       * @static
       * @memberOf fabric.util
       * @deprecated since 2.0.0
       * @param {fabric.Object} receiver Object implementing `clipTo` method
       * @param {CanvasRenderingContext2D} ctx Context to clip
       */
      clipContext: function(receiver, ctx) {
        ctx.save();
        ctx.beginPath();
        receiver.clipTo(ctx);
        ctx.clip();
      },

      /**
       * Multiply matrix A by matrix B to nest transformations
       * @static
       * @memberOf fabric.util
       * @param  {Array} a First transformMatrix
       * @param  {Array} b Second transformMatrix
       * @param  {Boolean} is2x2 flag to multiply matrices as 2x2 matrices
       * @return {Array} The product of the two transform matrices
       */
      multiplyTransformMatrices: function(a, b, is2x2) {
        // Matrix multiply a * b
        return [
          a[0] * b[0] + a[2] * b[1],
          a[1] * b[0] + a[3] * b[1],
          a[0] * b[2] + a[2] * b[3],
          a[1] * b[2] + a[3] * b[3],
          is2x2 ? 0 : a[0] * b[4] + a[2] * b[5] + a[4],
          is2x2 ? 0 : a[1] * b[4] + a[3] * b[5] + a[5]
        ];
      },

      /**
       * Decomposes standard 2x2 matrix into transform componentes
       * @static
       * @memberOf fabric.util
       * @param  {Array} a transformMatrix
       * @return {Object} Components of transform
       */
      qrDecompose: function(a) {
        var angle = atan2(a[1], a[0]),
            denom = pow(a[0], 2) + pow(a[1], 2),
            scaleX = sqrt(denom),
            scaleY = (a[0] * a[3] - a[2] * a [1]) / scaleX,
            skewX = atan2(a[0] * a[2] + a[1] * a [3], denom);
        return {
          angle: angle  / PiBy180,
          scaleX: scaleX,
          scaleY: scaleY,
          skewX: skewX / PiBy180,
          skewY: 0,
          translateX: a[4],
          translateY: a[5]
        };
      },

      customTransformMatrix: function(scaleX, scaleY, skewX) {
        var skewMatrixX = [1, 0, abs(Math.tan(skewX * PiBy180)), 1],
            scaleMatrix = [abs(scaleX), 0, 0, abs(scaleY)];
        return fabric.util.multiplyTransformMatrices(scaleMatrix, skewMatrixX, true);
      },

      resetObjectTransform: function (target) {
        target.scaleX = 1;
        target.scaleY = 1;
        target.skewX = 0;
        target.skewY = 0;
        target.flipX = false;
        target.flipY = false;
        target.rotate(0);
      },

      /**
       * Returns string representation of function body
       * @param {Function} fn Function to get body of
       * @return {String} Function body
       */
      getFunctionBody: function(fn) {
        return (String(fn).match(/function[^{]*\{([\s\S]*)\}/) || {})[1];
      },

      /**
       * Returns true if context has transparent pixel
       * at specified location (taking tolerance into account)
       * @param {CanvasRenderingContext2D} ctx context
       * @param {Number} x x coordinate
       * @param {Number} y y coordinate
       * @param {Number} tolerance Tolerance
       */
      isTransparent: function(ctx, x, y, tolerance) {

        // If tolerance is > 0 adjust start coords to take into account.
        // If moves off Canvas fix to 0
        if (tolerance > 0) {
          if (x > tolerance) {
            x -= tolerance;
          }
          else {
            x = 0;
          }
          if (y > tolerance) {
            y -= tolerance;
          }
          else {
            y = 0;
          }
        }

        var _isTransparent = true, i, temp,
            imageData = ctx.getImageData(x, y, (tolerance * 2) || 1, (tolerance * 2) || 1),
            l = imageData.data.length;

        // Split image data - for tolerance > 1, pixelDataSize = 4;
        for (i = 3; i < l; i += 4) {
          temp = imageData.data[i];
          _isTransparent = temp <= 0;
          if (_isTransparent === false) {
            break; // Stop if colour found
          }
        }

        imageData = null;

        return _isTransparent;
      },

      /**
       * Parse preserveAspectRatio attribute from element
       * @param {string} attribute to be parsed
       * @return {Object} an object containing align and meetOrSlice attribute
       */
      parsePreserveAspectRatioAttribute: function(attribute) {
        var meetOrSlice = 'meet', alignX = 'Mid', alignY = 'Mid',
            aspectRatioAttrs = attribute.split(' '), align;

        if (aspectRatioAttrs && aspectRatioAttrs.length) {
          meetOrSlice = aspectRatioAttrs.pop();
          if (meetOrSlice !== 'meet' && meetOrSlice !== 'slice') {
            align = meetOrSlice;
            meetOrSlice = 'meet';
          }
          else if (aspectRatioAttrs.length) {
            align = aspectRatioAttrs.pop();
          }
        }
        //divide align in alignX and alignY
        alignX = align !== 'none' ? align.slice(1, 4) : 'none';
        alignY = align !== 'none' ? align.slice(5, 8) : 'none';
        return {
          meetOrSlice: meetOrSlice,
          alignX: alignX,
          alignY: alignY
        };
      },

      /**
       * Clear char widths cache for the given font family or all the cache if no
       * fontFamily is specified.
       * Use it if you know you are loading fonts in a lazy way and you are not waiting
       * for custom fonts to load properly when adding text objects to the canvas.
       * If a text object is added when its own font is not loaded yet, you will get wrong
       * measurement and so wrong bounding boxes.
       * After the font cache is cleared, either change the textObject text content or call
       * initDimensions() to trigger a recalculation
       * @memberOf fabric.util
       * @param {String} [fontFamily] font family to clear
       */
      clearFabricFontCache: function(fontFamily) {
        fontFamily = (fontFamily || '').toLowerCase();
        if (!fontFamily) {
          fabric.charWidthsCache = { };
        }
        else if (fabric.charWidthsCache[fontFamily]) {
          delete fabric.charWidthsCache[fontFamily];
        }
      },

      /**
       * Given current aspect ratio, determines the max width and height that can
       * respect the total allowed area for the cache.
       * @memberOf fabric.util
       * @param {Number} ar aspect ratio
       * @param {Number} maximumArea Maximum area you want to achieve
       * @return {Object.x} Limited dimensions by X
       * @return {Object.y} Limited dimensions by Y
       */
      limitDimsByArea: function(ar, maximumArea) {
        var roughWidth = Math.sqrt(maximumArea * ar),
            perfLimitSizeY = Math.floor(maximumArea / roughWidth);
        return { x: Math.floor(roughWidth), y: perfLimitSizeY };
      },

      capValue: function(min, value, max) {
        return Math.max(min, Math.min(value, max));
      },

      findScaleToFit: function(source, destination) {
        return Math.min(destination.width / source.width, destination.height / source.height);
      },

      findScaleToCover: function(source, destination) {
        return Math.max(destination.width / source.width, destination.height / source.height);
      }
    };
  })(exports);


  (function() {

    var arcToSegmentsCache = { },
        segmentToBezierCache = { },
        boundsOfCurveCache = { },
        _join = Array.prototype.join;

    /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp
     * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here
     * http://mozilla.org/MPL/2.0/
     */
    function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {
      var argsString = _join.call(arguments);
      if (arcToSegmentsCache[argsString]) {
        return arcToSegmentsCache[argsString];
      }

      var PI = Math.PI, th = rotateX * PI / 180,
          sinTh = fabric.util.sin(th),
          cosTh = fabric.util.cos(th),
          fromX = 0, fromY = 0;

      rx = Math.abs(rx);
      ry = Math.abs(ry);

      var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5,
          py = -cosTh * toY * 0.5 + sinTh * toX * 0.5,
          rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px,
          pl = rx2 * ry2 - rx2 * py2 - ry2 * px2,
          root = 0;

      if (pl < 0) {
        var s = Math.sqrt(1 - pl / (rx2 * ry2));
        rx *= s;
        ry *= s;
      }
      else {
        root = (large === sweep ? -1.0 : 1.0) *
                Math.sqrt( pl / (rx2 * py2 + ry2 * px2));
      }

      var cx = root * rx * py / ry,
          cy = -root * ry * px / rx,
          cx1 = cosTh * cx - sinTh * cy + toX * 0.5,
          cy1 = sinTh * cx + cosTh * cy + toY * 0.5,
          mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry),
          dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);

      if (sweep === 0 && dtheta > 0) {
        dtheta -= 2 * PI;
      }
      else if (sweep === 1 && dtheta < 0) {
        dtheta += 2 * PI;
      }

      // Convert into cubic bezier segments <= 90deg
      var segments = Math.ceil(Math.abs(dtheta / PI * 2)),
          result = [], mDelta = dtheta / segments,
          mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2),
          th3 = mTheta + mDelta;

      for (var i = 0; i < segments; i++) {
        result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);
        fromX = result[i][4];
        fromY = result[i][5];
        mTheta = th3;
        th3 += mDelta;
      }
      arcToSegmentsCache[argsString] = result;
      return result;
    }

    function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {
      var argsString2 = _join.call(arguments);
      if (segmentToBezierCache[argsString2]) {
        return segmentToBezierCache[argsString2];
      }

      var costh2 = fabric.util.cos(th2),
          sinth2 = fabric.util.sin(th2),
          costh3 = fabric.util.cos(th3),
          sinth3 = fabric.util.sin(th3),
          toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1,
          toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1,
          cp1X = fromX + mT * ( -cosTh * rx * sinth2 - sinTh * ry * costh2),
          cp1Y = fromY + mT * ( -sinTh * rx * sinth2 + cosTh * ry * costh2),
          cp2X = toX + mT * ( cosTh * rx * sinth3 + sinTh * ry * costh3),
          cp2Y = toY + mT * ( sinTh * rx * sinth3 - cosTh * ry * costh3);

      segmentToBezierCache[argsString2] = [
        cp1X, cp1Y,
        cp2X, cp2Y,
        toX, toY
      ];
      return segmentToBezierCache[argsString2];
    }

    /*
     * Private
     */
    function calcVectorAngle(ux, uy, vx, vy) {
      var ta = Math.atan2(uy, ux),
          tb = Math.atan2(vy, vx);
      if (tb >= ta) {
        return tb - ta;
      }
      else {
        return 2 * Math.PI - (ta - tb);
      }
    }

    /**
     * Draws arc
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} fx
     * @param {Number} fy
     * @param {Array} coords
     */
    fabric.util.drawArc = function(ctx, fx, fy, coords) {
      var rx = coords[0],
          ry = coords[1],
          rot = coords[2],
          large = coords[3],
          sweep = coords[4],
          tx = coords[5],
          ty = coords[6],
          segs = [[], [], [], []],
          segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);

      for (var i = 0, len = segsNorm.length; i < len; i++) {
        segs[i][0] = segsNorm[i][0] + fx;
        segs[i][1] = segsNorm[i][1] + fy;
        segs[i][2] = segsNorm[i][2] + fx;
        segs[i][3] = segsNorm[i][3] + fy;
        segs[i][4] = segsNorm[i][4] + fx;
        segs[i][5] = segsNorm[i][5] + fy;
        ctx.bezierCurveTo.apply(ctx, segs[i]);
      }
    };

    /**
     * Calculate bounding box of a elliptic-arc
     * @param {Number} fx start point of arc
     * @param {Number} fy
     * @param {Number} rx horizontal radius
     * @param {Number} ry vertical radius
     * @param {Number} rot angle of horizontal axe
     * @param {Number} large 1 or 0, whatever the arc is the big or the small on the 2 points
     * @param {Number} sweep 1 or 0, 1 clockwise or counterclockwise direction
     * @param {Number} tx end point of arc
     * @param {Number} ty
     */
    fabric.util.getBoundsOfArc = function(fx, fy, rx, ry, rot, large, sweep, tx, ty) {

      var fromX = 0, fromY = 0, bound, bounds = [],
          segs = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);

      for (var i = 0, len = segs.length; i < len; i++) {
        bound = getBoundsOfCurve(fromX, fromY, segs[i][0], segs[i][1], segs[i][2], segs[i][3], segs[i][4], segs[i][5]);
        bounds.push({ x: bound[0].x + fx, y: bound[0].y + fy });
        bounds.push({ x: bound[1].x + fx, y: bound[1].y + fy });
        fromX = segs[i][4];
        fromY = segs[i][5];
      }
      return bounds;
    };

    /**
     * Calculate bounding box of a beziercurve
     * @param {Number} x0 starting point
     * @param {Number} y0
     * @param {Number} x1 first control point
     * @param {Number} y1
     * @param {Number} x2 secondo control point
     * @param {Number} y2
     * @param {Number} x3 end of beizer
     * @param {Number} y3
     */
    // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.
    function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {
      var argsString = _join.call(arguments);
      if (boundsOfCurveCache[argsString]) {
        return boundsOfCurveCache[argsString];
      }

      var sqrt = Math.sqrt,
          min = Math.min, max = Math.max,
          abs = Math.abs, tvalues = [],
          bounds = [[], []],
          a, b, c, t, t1, t2, b2ac, sqrtb2ac;

      b = 6 * x0 - 12 * x1 + 6 * x2;
      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c = 3 * x1 - 3 * x0;

      for (var i = 0; i < 2; ++i) {
        if (i > 0) {
          b = 6 * y0 - 12 * y1 + 6 * y2;
          a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
          c = 3 * y1 - 3 * y0;
        }

        if (abs(a) < 1e-12) {
          if (abs(b) < 1e-12) {
            continue;
          }
          t = -c / b;
          if (0 < t && t < 1) {
            tvalues.push(t);
          }
          continue;
        }
        b2ac = b * b - 4 * c * a;
        if (b2ac < 0) {
          continue;
        }
        sqrtb2ac = sqrt(b2ac);
        t1 = (-b + sqrtb2ac) / (2 * a);
        if (0 < t1 && t1 < 1) {
          tvalues.push(t1);
        }
        t2 = (-b - sqrtb2ac) / (2 * a);
        if (0 < t2 && t2 < 1) {
          tvalues.push(t2);
        }
      }

      var x, y, j = tvalues.length, jlen = j, mt;
      while (j--) {
        t = tvalues[j];
        mt = 1 - t;
        x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
        bounds[0][j] = x;

        y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
        bounds[1][j] = y;
      }

      bounds[0][jlen] = x0;
      bounds[1][jlen] = y0;
      bounds[0][jlen + 1] = x3;
      bounds[1][jlen + 1] = y3;
      var result = [
        {
          x: min.apply(null, bounds[0]),
          y: min.apply(null, bounds[1])
        },
        {
          x: max.apply(null, bounds[0]),
          y: max.apply(null, bounds[1])
        }
      ];
      boundsOfCurveCache[argsString] = result;
      return result;
    }

    fabric.util.getBoundsOfCurve = getBoundsOfCurve;

  })();


  (function() {

    var slice = Array.prototype.slice;

    /**
     * Invokes method on all items in a given array
     * @memberOf fabric.util.array
     * @param {Array} array Array to iterate over
     * @param {String} method Name of a method to invoke
     * @return {Array}
     */
    function invoke(array, method) {
      var args = slice.call(arguments, 2), result = [];
      for (var i = 0, len = array.length; i < len; i++) {
        result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);
      }
      return result;
    }

    /**
     * Finds maximum value in array (not necessarily "first" one)
     * @memberOf fabric.util.array
     * @param {Array} array Array to iterate over
     * @param {String} byProperty
     * @return {*}
     */
    function max(array, byProperty) {
      return find(array, byProperty, function(value1, value2) {
        return value1 >= value2;
      });
    }

    /**
     * Finds minimum value in array (not necessarily "first" one)
     * @memberOf fabric.util.array
     * @param {Array} array Array to iterate over
     * @param {String} byProperty
     * @return {*}
     */
    function min(array, byProperty) {
      return find(array, byProperty, function(value1, value2) {
        return value1 < value2;
      });
    }

    /**
     * @private
     */
    function fill(array, value) {
      var k = array.length;
      while (k--) {
        array[k] = value;
      }
      return array;
    }

    /**
     * @private
     */
    function find(array, byProperty, condition) {
      if (!array || array.length === 0) {
        return;
      }

      var i = array.length - 1,
          result = byProperty ? array[i][byProperty] : array[i];
      if (byProperty) {
        while (i--) {
          if (condition(array[i][byProperty], result)) {
            result = array[i][byProperty];
          }
        }
      }
      else {
        while (i--) {
          if (condition(array[i], result)) {
            result = array[i];
          }
        }
      }
      return result;
    }

    /**
     * @namespace fabric.util.array
     */
    fabric.util.array = {
      fill: fill,
      invoke: invoke,
      min: min,
      max: max
    };

  })();


  (function() {
    /**
     * Copies all enumerable properties of one js object to another
     * Does not clone or extend fabric.Object subclasses.
     * @memberOf fabric.util.object
     * @param {Object} destination Where to copy to
     * @param {Object} source Where to copy from
     * @return {Object}
     */

    function extend(destination, source, deep) {
      // JScript DontEnum bug is not taken care of
      // the deep clone is for internal use, is not meant to avoid
      // javascript traps or cloning html element or self referenced objects.
      if (deep) {
        if (!fabric.isLikelyNode && source instanceof Element) {
          // avoid cloning deep images, canvases,
          destination = source;
        }
        else if (source instanceof Array) {
          destination = [];
          for (var i = 0, len = source.length; i < len; i++) {
            destination[i] = extend({ }, source[i], deep);
          }
        }
        else if (source && typeof source === 'object') {
          for (var property in source) {
            if (source.hasOwnProperty(property)) {
              destination[property] = extend({ }, source[property], deep);
            }
          }
        }
        else {
          // this sounds odd for an extend but is ok for recursive use
          destination = source;
        }
      }
      else {
        for (var property in source) {
          destination[property] = source[property];
        }
      }
      return destination;
    }

    /**
     * Creates an empty object and copies all enumerable properties of another object to it
     * @memberOf fabric.util.object
     * TODO: this function return an empty object if you try to clone null
     * @param {Object} object Object to clone
     * @return {Object}
     */
    function clone(object, deep) {
      return extend({ }, object, deep);
    }

    /** @namespace fabric.util.object */
    fabric.util.object = {
      extend: extend,
      clone: clone
    };
    fabric.util.object.extend(fabric.util, fabric.Observable);
  })();


  (function() {

    /**
     * Camelizes a string
     * @memberOf fabric.util.string
     * @param {String} string String to camelize
     * @return {String} Camelized version of a string
     */
    function camelize(string) {
      return string.replace(/-+(.)?/g, function(match, character) {
        return character ? character.toUpperCase() : '';
      });
    }

    /**
     * Capitalizes a string
     * @memberOf fabric.util.string
     * @param {String} string String to capitalize
     * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized
     * and other letters stay untouched, if false first letter is capitalized
     * and other letters are converted to lowercase.
     * @return {String} Capitalized version of a string
     */
    function capitalize(string, firstLetterOnly) {
      return string.charAt(0).toUpperCase() +
        (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());
    }

    /**
     * Escapes XML in a string
     * @memberOf fabric.util.string
     * @param {String} string String to escape
     * @return {String} Escaped version of a string
     */
    function escapeXml(string) {
      return string.replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }

    /**
     * Divide a string in the user perceived single units
     * @memberOf fabric.util.string
     * @param {String} textstring String to escape
     * @return {Array} array containing the graphemes
     */
    function graphemeSplit(textstring) {
      var i = 0, chr, graphemes = [];
      for (i = 0, chr; i < textstring.length; i++) {
        if ((chr = getWholeChar(textstring, i)) === false) {
          continue;
        }
        graphemes.push(chr);
      }
      return graphemes;
    }

    // taken from mdn in the charAt doc page.
    function getWholeChar(str, i) {
      var code = str.charCodeAt(i);

      if (isNaN(code)) {
        return ''; // Position not found
      }
      if (code < 0xD800 || code > 0xDFFF) {
        return str.charAt(i);
      }

      // High surrogate (could change last hex to 0xDB7F to treat high private
      // surrogates as single characters)
      if (0xD800 <= code && code <= 0xDBFF) {
        if (str.length <= (i + 1)) {
          throw 'High surrogate without following low surrogate';
        }
        var next = str.charCodeAt(i + 1);
        if (0xDC00 > next || next > 0xDFFF) {
          throw 'High surrogate without following low surrogate';
        }
        return str.charAt(i) + str.charAt(i + 1);
      }
      // Low surrogate (0xDC00 <= code && code <= 0xDFFF)
      if (i === 0) {
        throw 'Low surrogate without preceding high surrogate';
      }
      var prev = str.charCodeAt(i - 1);

      // (could change last hex to 0xDB7F to treat high private
      // surrogates as single characters)
      if (0xD800 > prev || prev > 0xDBFF) {
        throw 'Low surrogate without preceding high surrogate';
      }
      // We can pass over low surrogates now as the second component
      // in a pair which we have already processed
      return false;
    }


    /**
     * String utilities
     * @namespace fabric.util.string
     */
    fabric.util.string = {
      camelize: camelize,
      capitalize: capitalize,
      escapeXml: escapeXml,
      graphemeSplit: graphemeSplit
    };
  })();


  (function() {

    var slice = Array.prototype.slice, emptyFunction = function() { },

        IS_DONTENUM_BUGGY = (function() {
          return true;
        })(),

        /** @ignore */
        addMethods = function(klass, source, parent) {
          for (var property in source) {

            if (property in klass.prototype &&
                typeof klass.prototype[property] === 'function' &&
                (source[property] + '').indexOf('callSuper') > -1) {

              klass.prototype[property] = (function(property) {
                return function() {

                  var superclass = this.constructor.superclass;
                  this.constructor.superclass = parent;
                  var returnValue = source[property].apply(this, arguments);
                  this.constructor.superclass = superclass;

                  if (property !== 'initialize') {
                    return returnValue;
                  }
                };
              })(property);
            }
            else {
              klass.prototype[property] = source[property];
            }

            if (IS_DONTENUM_BUGGY) {
              if (source.toString !== Object.prototype.toString) {
                klass.prototype.toString = source.toString;
              }
              if (source.valueOf !== Object.prototype.valueOf) {
                klass.prototype.valueOf = source.valueOf;
              }
            }
          }
        };

    function Subclass() { }

    function callSuper(methodName) {
      var parentMethod = null,
          _this = this;

      // climb prototype chain to find method not equal to callee's method
      while (_this.constructor.superclass) {
        var superClassMethod = _this.constructor.superclass.prototype[methodName];
        if (_this[methodName] !== superClassMethod) {
          parentMethod = superClassMethod;
          break;
        }
        // eslint-disable-next-line
        _this = _this.constructor.superclass.prototype;
      }

      if (!parentMethod) {
        return console.log('tried to callSuper ' + methodName + ', method not found in prototype chain', this);
      }

      return (arguments.length > 1)
        ? parentMethod.apply(this, slice.call(arguments, 1))
        : parentMethod.call(this);
    }

    /**
     * Helper for creation of "classes".
     * @memberOf fabric.util
     * @param {Function} [parent] optional "Class" to inherit from
     * @param {Object} [properties] Properties shared by all instances of this class
     *                  (be careful modifying objects defined here as this would affect all instances)
     */
    function createClass() {
      var parent = null,
          properties = slice.call(arguments, 0);

      if (typeof properties[0] === 'function') {
        parent = properties.shift();
      }
      function klass() {
        this.initialize.apply(this, arguments);
      }

      klass.superclass = parent;
      klass.subclasses = [];

      if (parent) {
        Subclass.prototype = parent.prototype;
        klass.prototype = new Subclass();
        parent.subclasses.push(klass);
      }
      for (var i = 0, length = properties.length; i < length; i++) {
        addMethods(klass, properties[i], parent);
      }
      if (!klass.prototype.initialize) {
        klass.prototype.initialize = emptyFunction;
      }
      klass.prototype.constructor = klass;
      klass.prototype.callSuper = callSuper;
      return klass;
    }

    fabric.util.createClass = createClass;
  })();


  (function () {

    var unknown = 'unknown';

    /* EVENT HANDLING */

    function areHostMethods(object) {
      var methodNames = Array.prototype.slice.call(arguments, 1),
          t, i, len = methodNames.length;
      for (i = 0; i < len; i++) {
        t = typeof object[methodNames[i]];
        if (!(/^(?:function|object|unknown)$/).test(t)) {
          return false;
        }
      }
      return true;
    }

    /** @ignore */
    var getElement,
        setElement,
        getUniqueId = (function () {
          var uid = 0;
          return function (element) {
            return element.__uniqueID || (element.__uniqueID = 'uniqueID__' + uid++);
          };
        })();

    (function () {
      var elements = { };
      /** @ignore */
      getElement = function (uid) {
        return elements[uid];
      };
      /** @ignore */
      setElement = function (uid, element) {
        elements[uid] = element;
      };
    })();

    function createListener(uid, handler) {
      return {
        handler: handler,
        wrappedHandler: createWrappedHandler(uid, handler)
      };
    }

    function createWrappedHandler(uid, handler) {
      return function (e) {
        handler.call(getElement(uid), e || fabric.window.event);
      };
    }

    function createDispatcher(uid, eventName) {
      return function (e) {
        if (handlers[uid] && handlers[uid][eventName]) {
          var handlersForEvent = handlers[uid][eventName];
          for (var i = 0, len = handlersForEvent.length; i < len; i++) {
            handlersForEvent[i].call(this, e || fabric.window.event);
          }
        }
      };
    }

    var shouldUseAddListenerRemoveListener = (
          areHostMethods(fabric.document.documentElement, 'addEventListener', 'removeEventListener') &&
          areHostMethods(fabric.window, 'addEventListener', 'removeEventListener')),

        shouldUseAttachEventDetachEvent = (
          areHostMethods(fabric.document.documentElement, 'attachEvent', 'detachEvent') &&
          areHostMethods(fabric.window, 'attachEvent', 'detachEvent')),

        // IE branch
        listeners = { },

        // DOM L0 branch
        handlers = { },

        addListener, removeListener;

    if (shouldUseAddListenerRemoveListener) {
      /** @ignore */
      addListener = function (element, eventName, handler, options) {
        // since ie10 or ie9 can use addEventListener but they do not support options, i need to check
        element && element.addEventListener(eventName, handler, shouldUseAttachEventDetachEvent ? false : options);
      };
      /** @ignore */
      removeListener = function (element, eventName, handler, options) {
        element && element.removeEventListener(eventName, handler, shouldUseAttachEventDetachEvent ? false : options);
      };
    }

    else if (shouldUseAttachEventDetachEvent) {
      /** @ignore */
      addListener = function (element, eventName, handler) {
        if (!element) {
          return;
        }
        var uid = getUniqueId(element);
        setElement(uid, element);
        if (!listeners[uid]) {
          listeners[uid] = { };
        }
        if (!listeners[uid][eventName]) {
          listeners[uid][eventName] = [];

        }
        var listener = createListener(uid, handler);
        listeners[uid][eventName].push(listener);
        element.attachEvent('on' + eventName, listener.wrappedHandler);
      };
      /** @ignore */
      removeListener = function (element, eventName, handler) {
        if (!element) {
          return;
        }
        var uid = getUniqueId(element), listener;
        if (listeners[uid] && listeners[uid][eventName]) {
          for (var i = 0, len = listeners[uid][eventName].length; i < len; i++) {
            listener = listeners[uid][eventName][i];
            if (listener && listener.handler === handler) {
              element.detachEvent('on' + eventName, listener.wrappedHandler);
              listeners[uid][eventName][i] = null;
            }
          }
        }
      };
    }
    else {
      /** @ignore */
      addListener = function (element, eventName, handler) {
        if (!element) {
          return;
        }
        var uid = getUniqueId(element);
        if (!handlers[uid]) {
          handlers[uid] = { };
        }
        if (!handlers[uid][eventName]) {
          handlers[uid][eventName] = [];
          var existingHandler = element['on' + eventName];
          if (existingHandler) {
            handlers[uid][eventName].push(existingHandler);
          }
          element['on' + eventName] = createDispatcher(uid, eventName);
        }
        handlers[uid][eventName].push(handler);
      };
      /** @ignore */
      removeListener = function (element, eventName, handler) {
        if (!element) {
          return;
        }
        var uid = getUniqueId(element);
        if (handlers[uid] && handlers[uid][eventName]) {
          var handlersForEvent = handlers[uid][eventName];
          for (var i = 0, len = handlersForEvent.length; i < len; i++) {
            if (handlersForEvent[i] === handler) {
              handlersForEvent.splice(i, 1);
            }
          }
        }
      };
    }

    /**
     * Adds an event listener to an element
     * @function
     * @memberOf fabric.util
     * @param {HTMLElement} element
     * @param {String} eventName
     * @param {Function} handler
     */
    fabric.util.addListener = addListener;

    /**
     * Removes an event listener from an element
     * @function
     * @memberOf fabric.util
     * @param {HTMLElement} element
     * @param {String} eventName
     * @param {Function} handler
     */
    fabric.util.removeListener = removeListener;

    /**
     * Cross-browser wrapper for getting event's coordinates
     * @memberOf fabric.util
     * @param {Event} event Event object
     */
    function getPointer(event) {
      event || (event = fabric.window.event);

      var element = event.target ||
                    (typeof event.srcElement !== unknown ? event.srcElement : null),

          scroll = fabric.util.getScrollLeftTop(element);
      return {
        x: pointerX(event) + scroll.left,
        y: pointerY(event) + scroll.top
      };
    }

    var pointerX = function(event) {
          return event.clientX;
        },

        pointerY = function(event) {
          return event.clientY;
        };

    function _getPointer(event, pageProp, clientProp) {
      var touchProp = event.type === 'touchend' ? 'changedTouches' : 'touches';
      var pointer, eventTouchProp = event[touchProp];

      if (eventTouchProp && eventTouchProp[0]) {
        pointer = eventTouchProp[0][clientProp];
      }

      if (typeof pointer === 'undefined') {
        pointer = event[clientProp];
      }

      return pointer;
    }

    if (fabric.isTouchSupported) {
      pointerX = function(event) {
        return _getPointer(event, 'pageX', 'clientX');
      };
      pointerY = function(event) {
        return _getPointer(event, 'pageY', 'clientY');
      };
    }

    fabric.util.getPointer = getPointer;

  })();


  (function () {

    /**
     * Cross-browser wrapper for setting element's style
     * @memberOf fabric.util
     * @param {HTMLElement} element
     * @param {Object} styles
     * @return {HTMLElement} Element that was passed as a first argument
     */
    function setStyle(element, styles) {
      var elementStyle = element.style;
      if (!elementStyle) {
        return element;
      }
      if (typeof styles === 'string') {
        element.style.cssText += ';' + styles;
        return styles.indexOf('opacity') > -1
          ? setOpacity(element, styles.match(/opacity:\s*(\d?\.?\d*)/)[1])
          : element;
      }
      for (var property in styles) {
        if (property === 'opacity') {
          setOpacity(element, styles[property]);
        }
        else {
          var normalizedProperty = (property === 'float' || property === 'cssFloat')
            ? (typeof elementStyle.styleFloat === 'undefined' ? 'cssFloat' : 'styleFloat')
            : property;
          elementStyle[normalizedProperty] = styles[property];
        }
      }
      return element;
    }

    var parseEl = fabric.document.createElement('div'),
        supportsOpacity = typeof parseEl.style.opacity === 'string',
        supportsFilters = typeof parseEl.style.filter === 'string',
        reOpacity = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/,

        /** @ignore */
        setOpacity = function (element) { return element; };

    if (supportsOpacity) {
      /** @ignore */
      setOpacity = function(element, value) {
        element.style.opacity = value;
        return element;
      };
    }
    else if (supportsFilters) {
      /** @ignore */
      setOpacity = function(element, value) {
        var es = element.style;
        if (element.currentStyle && !element.currentStyle.hasLayout) {
          es.zoom = 1;
        }
        if (reOpacity.test(es.filter)) {
          value = value >= 0.9999 ? '' : ('alpha(opacity=' + (value * 100) + ')');
          es.filter = es.filter.replace(reOpacity, value);
        }
        else {
          es.filter += ' alpha(opacity=' + (value * 100) + ')';
        }
        return element;
      };
    }

    fabric.util.setStyle = setStyle;

  })();


  (function() {

    var _slice = Array.prototype.slice;

    /**
     * Takes id and returns an element with that id (if one exists in a document)
     * @memberOf fabric.util
     * @param {String|HTMLElement} id
     * @return {HTMLElement|null}
     */
    function getById(id) {
      return typeof id === 'string' ? fabric.document.getElementById(id) : id;
    }

    var sliceCanConvertNodelists,
        /**
         * Converts an array-like object (e.g. arguments or NodeList) to an array
         * @memberOf fabric.util
         * @param {Object} arrayLike
         * @return {Array}
         */
        toArray = function(arrayLike) {
          return _slice.call(arrayLike, 0);
        };

    try {
      sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;
    }
    catch (err) { }

    if (!sliceCanConvertNodelists) {
      toArray = function(arrayLike) {
        var arr = new Array(arrayLike.length), i = arrayLike.length;
        while (i--) {
          arr[i] = arrayLike[i];
        }
        return arr;
      };
    }

    /**
     * Creates specified element with specified attributes
     * @memberOf fabric.util
     * @param {String} tagName Type of an element to create
     * @param {Object} [attributes] Attributes to set on an element
     * @return {HTMLElement} Newly created element
     */
    function makeElement(tagName, attributes) {
      var el = fabric.document.createElement(tagName);
      for (var prop in attributes) {
        if (prop === 'class') {
          el.className = attributes[prop];
        }
        else if (prop === 'for') {
          el.htmlFor = attributes[prop];
        }
        else {
          el.setAttribute(prop, attributes[prop]);
        }
      }
      return el;
    }

    /**
     * Adds class to an element
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to add class to
     * @param {String} className Class to add to an element
     */
    function addClass(element, className) {
      if (element && (' ' + element.className + ' ').indexOf(' ' + className + ' ') === -1) {
        element.className += (element.className ? ' ' : '') + className;
      }
    }

    /**
     * Wraps element with another element
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to wrap
     * @param {HTMLElement|String} wrapper Element to wrap with
     * @param {Object} [attributes] Attributes to set on a wrapper
     * @return {HTMLElement} wrapper
     */
    function wrapElement(element, wrapper, attributes) {
      if (typeof wrapper === 'string') {
        wrapper = makeElement(wrapper, attributes);
      }
      if (element.parentNode) {
        element.parentNode.replaceChild(wrapper, element);
      }
      wrapper.appendChild(element);
      return wrapper;
    }

    /**
     * Returns element scroll offsets
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to operate on
     * @return {Object} Object with left/top values
     */
    function getScrollLeftTop(element) {

      var left = 0,
          top = 0,
          docElement = fabric.document.documentElement,
          body = fabric.document.body || {
            scrollLeft: 0, scrollTop: 0
          };

      // While loop checks (and then sets element to) .parentNode OR .host
      //  to account for ShadowDOM. We still want to traverse up out of ShadowDOM,
      //  but the .parentNode of a root ShadowDOM node will always be null, instead
      //  it should be accessed through .host. See http://stackoverflow.com/a/24765528/4383938
      while (element && (element.parentNode || element.host)) {

        // Set element to element parent, or 'host' in case of ShadowDOM
        element = element.parentNode || element.host;

        if (element === fabric.document) {
          left = body.scrollLeft || docElement.scrollLeft || 0;
          top = body.scrollTop ||  docElement.scrollTop || 0;
        }
        else {
          left += element.scrollLeft || 0;
          top += element.scrollTop || 0;
        }

        if (element.nodeType === 1 && element.style.position === 'fixed') {
          break;
        }
      }

      return { left: left, top: top };
    }

    /**
     * Returns offset for a given element
     * @function
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to get offset for
     * @return {Object} Object with "left" and "top" properties
     */
    function getElementOffset(element) {
      var docElem,
          doc = element && element.ownerDocument,
          box = { left: 0, top: 0 },
          offset = { left: 0, top: 0 },
          scrollLeftTop,
          offsetAttributes = {
            borderLeftWidth: 'left',
            borderTopWidth:  'top',
            paddingLeft:     'left',
            paddingTop:      'top'
          };

      if (!doc) {
        return offset;
      }

      for (var attr in offsetAttributes) {
        offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;
      }

      docElem = doc.documentElement;
      if ( typeof element.getBoundingClientRect !== 'undefined' ) {
        box = element.getBoundingClientRect();
      }

      scrollLeftTop = getScrollLeftTop(element);

      return {
        left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,
        top: box.top + scrollLeftTop.top - (docElem.clientTop || 0)  + offset.top
      };
    }

    /**
     * Returns style attribute value of a given element
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to get style attribute for
     * @param {String} attr Style attribute to get for element
     * @return {String} Style attribute value of the given element.
     */
    var getElementStyle;
    if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {
      getElementStyle = function(element, attr) {
        var style = fabric.document.defaultView.getComputedStyle(element, null);
        return style ? style[attr] : undefined;
      };
    }
    else {
      getElementStyle = function(element, attr) {
        var value = element.style[attr];
        if (!value && element.currentStyle) {
          value = element.currentStyle[attr];
        }
        return value;
      };
    }

    (function () {
      var style = fabric.document.documentElement.style,
          selectProp = 'userSelect' in style
            ? 'userSelect'
            : 'MozUserSelect' in style
              ? 'MozUserSelect'
              : 'WebkitUserSelect' in style
                ? 'WebkitUserSelect'
                : 'KhtmlUserSelect' in style
                  ? 'KhtmlUserSelect'
                  : '';

      /**
       * Makes element unselectable
       * @memberOf fabric.util
       * @param {HTMLElement} element Element to make unselectable
       * @return {HTMLElement} Element that was passed in
       */
      function makeElementUnselectable(element) {
        if (typeof element.onselectstart !== 'undefined') {
          element.onselectstart = fabric.util.falseFunction;
        }
        if (selectProp) {
          element.style[selectProp] = 'none';
        }
        else if (typeof element.unselectable === 'string') {
          element.unselectable = 'on';
        }
        return element;
      }

      /**
       * Makes element selectable
       * @memberOf fabric.util
       * @param {HTMLElement} element Element to make selectable
       * @return {HTMLElement} Element that was passed in
       */
      function makeElementSelectable(element) {
        if (typeof element.onselectstart !== 'undefined') {
          element.onselectstart = null;
        }
        if (selectProp) {
          element.style[selectProp] = '';
        }
        else if (typeof element.unselectable === 'string') {
          element.unselectable = '';
        }
        return element;
      }

      fabric.util.makeElementUnselectable = makeElementUnselectable;
      fabric.util.makeElementSelectable = makeElementSelectable;
    })();

    (function() {

      /**
       * Inserts a script element with a given url into a document; invokes callback, when that script is finished loading
       * @memberOf fabric.util
       * @param {String} url URL of a script to load
       * @param {Function} callback Callback to execute when script is finished loading
       */
      function getScript(url, callback) {
        var headEl = fabric.document.getElementsByTagName('head')[0],
            scriptEl = fabric.document.createElement('script'),
            loading = true;

        /** @ignore */
        scriptEl.onload = /** @ignore */ scriptEl.onreadystatechange = function(e) {
          if (loading) {
            if (typeof this.readyState === 'string' &&
                this.readyState !== 'loaded' &&
                this.readyState !== 'complete') {
              return;
            }
            loading = false;
            callback(e || fabric.window.event);
            scriptEl = scriptEl.onload = scriptEl.onreadystatechange = null;
          }
        };
        scriptEl.src = url;
        headEl.appendChild(scriptEl);
        // causes issue in Opera
        // headEl.removeChild(scriptEl);
      }

      fabric.util.getScript = getScript;
    })();

    function getNodeCanvas(element) {
      var impl = fabric.jsdomImplForWrapper(element);
      return impl._canvas || impl._image;
    }
    fabric.util.getById = getById;
    fabric.util.toArray = toArray;
    fabric.util.makeElement = makeElement;
    fabric.util.addClass = addClass;
    fabric.util.wrapElement = wrapElement;
    fabric.util.getScrollLeftTop = getScrollLeftTop;
    fabric.util.getElementOffset = getElementOffset;
    fabric.util.getElementStyle = getElementStyle;
    fabric.util.getNodeCanvas = getNodeCanvas;

  })();


  (function() {

    function addParamToUrl(url, param) {
      return url + (/\?/.test(url) ? '&' : '?') + param;
    }

    var makeXHR = (function() {
      var factories = [
        function() { return new ActiveXObject('Microsoft.XMLHTTP'); },
        function() { return new ActiveXObject('Msxml2.XMLHTTP'); },
        function() { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); },
        function() { return new XMLHttpRequest(); }
      ];
      for (var i = factories.length; i--; ) {
        try {
          var req = factories[i]();
          if (req) {
            return factories[i];
          }
        }
        catch (err) { }
      }
    })();

    function emptyFn() { }

    /**
     * Cross-browser abstraction for sending XMLHttpRequest
     * @memberOf fabric.util
     * @param {String} url URL to send XMLHttpRequest to
     * @param {Object} [options] Options object
     * @param {String} [options.method="GET"]
     * @param {String} [options.parameters] parameters to append to url in GET or in body
     * @param {String} [options.body] body to send with POST or PUT request
     * @param {Function} options.onComplete Callback to invoke when request is completed
     * @return {XMLHttpRequest} request
     */
    function request(url, options) {

      options || (options = { });

      var method = options.method ? options.method.toUpperCase() : 'GET',
          onComplete = options.onComplete || function() { },
          xhr = makeXHR(),
          body = options.body || options.parameters;

      /** @ignore */
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          onComplete(xhr);
          xhr.onreadystatechange = emptyFn;
        }
      };

      if (method === 'GET') {
        body = null;
        if (typeof options.parameters === 'string') {
          url = addParamToUrl(url, options.parameters);
        }
      }

      xhr.open(method, url, true);

      if (method === 'POST' || method === 'PUT') {
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
      }

      xhr.send(body);
      return xhr;
    }

    fabric.util.request = request;
  })();


  /**
   * Wrapper around `console.log` (when available)
   * @param {*} [values] Values to log
   */
  fabric.log = function() { };

  /**
   * Wrapper around `console.warn` (when available)
   * @param {*} [values] Values to log as a warning
   */
  fabric.warn = function() { };

  /* eslint-disable */
  if (typeof console !== 'undefined') {

    ['log', 'warn'].forEach(function(methodName) {

      if (typeof console[methodName] !== 'undefined' &&
          typeof console[methodName].apply === 'function') {

        fabric[methodName] = function() {
          return console[methodName].apply(console, arguments);
        };
      }
    });
  }
  /* eslint-enable */


  (function() {

    function noop() {
      return false;
    }

    /**
     * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.
     * @memberOf fabric.util
     * @param {Object} [options] Animation options
     * @param {Function} [options.onChange] Callback; invoked on every value change
     * @param {Function} [options.onComplete] Callback; invoked when value change is completed
     * @param {Number} [options.startValue=0] Starting value
     * @param {Number} [options.endValue=100] Ending value
     * @param {Number} [options.byValue=100] Value to modify the property by
     * @param {Function} [options.easing] Easing function
     * @param {Number} [options.duration=500] Duration of change (in ms)
     */
    function animate(options) {

      requestAnimFrame(function(timestamp) {
        options || (options = { });

        var start = timestamp || +new Date(),
            duration = options.duration || 500,
            finish = start + duration, time,
            onChange = options.onChange || noop,
            abort = options.abort || noop,
            onComplete = options.onComplete || noop,
            easing = options.easing || function(t, b, c, d) {return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;},
            startValue = 'startValue' in options ? options.startValue : 0,
            endValue = 'endValue' in options ? options.endValue : 100,
            byValue = options.byValue || endValue - startValue;

        options.onStart && options.onStart();

        (function tick(ticktime) {
          if (abort()) {
            onComplete(endValue, 1, 1);
            return;
          }
          time = ticktime || +new Date();
          var currentTime = time > finish ? duration : (time - start),
              timePerc = currentTime / duration,
              current = easing(currentTime, startValue, byValue, duration),
              valuePerc = Math.abs((current - startValue) / byValue);
          onChange(current, valuePerc, timePerc);
          if (time > finish) {
            options.onComplete && options.onComplete();
            return;
          }
          requestAnimFrame(tick);
        })(start);
      });

    }

    var _requestAnimFrame = fabric.window.requestAnimationFrame       ||
                            fabric.window.webkitRequestAnimationFrame ||
                            fabric.window.mozRequestAnimationFrame    ||
                            fabric.window.oRequestAnimationFrame      ||
                            fabric.window.msRequestAnimationFrame     ||
                            function(callback) {
                              return fabric.window.setTimeout(callback, 1000 / 60);
                            };

    var _cancelAnimFrame = fabric.window.cancelAnimationFrame || fabric.window.clearTimeout;

    /**
     * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/
     * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method
     * @memberOf fabric.util
     * @param {Function} callback Callback to invoke
     * @param {DOMElement} element optional Element to associate with animation
     */
    function requestAnimFrame() {
      return _requestAnimFrame.apply(fabric.window, arguments);
    }

    function cancelAnimFrame() {
      return _cancelAnimFrame.apply(fabric.window, arguments);
    }

    fabric.util.animate = animate;
    fabric.util.requestAnimFrame = requestAnimFrame;
    fabric.util.cancelAnimFrame = cancelAnimFrame;
  })();


  (function() {
    // Calculate an in-between color. Returns a "rgba()" string.
    // Credit: Edwin Martin <edwin@bitstorm.org>
    //         http://www.bitstorm.org/jquery/color-animation/jquery.animate-colors.js
    function calculateColor(begin, end, pos) {
      var color = 'rgba('
          + parseInt((begin[0] + pos * (end[0] - begin[0])), 10) + ','
          + parseInt((begin[1] + pos * (end[1] - begin[1])), 10) + ','
          + parseInt((begin[2] + pos * (end[2] - begin[2])), 10);

      color += ',' + (begin && end ? parseFloat(begin[3] + pos * (end[3] - begin[3])) : 1);
      color += ')';
      return color;
    }

    /**
     * Changes the color from one to another within certain period of time, invoking callbacks as value is being changed.
     * @memberOf fabric.util
     * @param {String} fromColor The starting color in hex or rgb(a) format.
     * @param {String} toColor The starting color in hex or rgb(a) format.
     * @param {Number} [duration] Duration of change (in ms).
     * @param {Object} [options] Animation options
     * @param {Function} [options.onChange] Callback; invoked on every value change
     * @param {Function} [options.onComplete] Callback; invoked when value change is completed
     * @param {Function} [options.colorEasing] Easing function. Note that this function only take two arguments (currentTime, duration). Thus the regular animation easing functions cannot be used.
     */
    function animateColor(fromColor, toColor, duration, options) {
      var startColor = new fabric.Color(fromColor).getSource(),
          endColor = new fabric.Color(toColor).getSource();

      options = options || {};

      fabric.util.animate(fabric.util.object.extend(options, {
        duration: duration || 500,
        startValue: startColor,
        endValue: endColor,
        byValue: endColor,
        easing: function (currentTime, startValue, byValue, duration) {
          var posValue = options.colorEasing
            ? options.colorEasing(currentTime, duration)
            : 1 - Math.cos(currentTime / duration * (Math.PI / 2));
          return calculateColor(startValue, byValue, posValue);
        }
      }));
    }

    fabric.util.animateColor = animateColor;

  })();


  (function() {

    function normalize(a, c, p, s) {
      if (a < Math.abs(c)) {
        a = c;
        s = p / 4;
      }
      else {
        //handle the 0/0 case:
        if (c === 0 && a === 0) {
          s = p / (2 * Math.PI) * Math.asin(1);
        }
        else {
          s = p / (2 * Math.PI) * Math.asin(c / a);
        }
      }
      return { a: a, c: c, p: p, s: s };
    }

    function elastic(opts, t, d) {
      return opts.a *
        Math.pow(2, 10 * (t -= 1)) *
        Math.sin( (t * d - opts.s) * (2 * Math.PI) / opts.p );
    }

    /**
     * Cubic easing out
     * @memberOf fabric.util.ease
     */
    function easeOutCubic(t, b, c, d) {
      return c * ((t = t / d - 1) * t * t + 1) + b;
    }

    /**
     * Cubic easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutCubic(t, b, c, d) {
      t /= d / 2;
      if (t < 1) {
        return c / 2 * t * t * t + b;
      }
      return c / 2 * ((t -= 2) * t * t + 2) + b;
    }

    /**
     * Quartic easing in
     * @memberOf fabric.util.ease
     */
    function easeInQuart(t, b, c, d) {
      return c * (t /= d) * t * t * t + b;
    }

    /**
     * Quartic easing out
     * @memberOf fabric.util.ease
     */
    function easeOutQuart(t, b, c, d) {
      return -c * ((t = t / d - 1) * t * t * t - 1) + b;
    }

    /**
     * Quartic easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutQuart(t, b, c, d) {
      t /= d / 2;
      if (t < 1) {
        return c / 2 * t * t * t * t + b;
      }
      return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
    }

    /**
     * Quintic easing in
     * @memberOf fabric.util.ease
     */
    function easeInQuint(t, b, c, d) {
      return c * (t /= d) * t * t * t * t + b;
    }

    /**
     * Quintic easing out
     * @memberOf fabric.util.ease
     */
    function easeOutQuint(t, b, c, d) {
      return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
    }

    /**
     * Quintic easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutQuint(t, b, c, d) {
      t /= d / 2;
      if (t < 1) {
        return c / 2 * t * t * t * t * t + b;
      }
      return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
    }

    /**
     * Sinusoidal easing in
     * @memberOf fabric.util.ease
     */
    function easeInSine(t, b, c, d) {
      return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
    }

    /**
     * Sinusoidal easing out
     * @memberOf fabric.util.ease
     */
    function easeOutSine(t, b, c, d) {
      return c * Math.sin(t / d * (Math.PI / 2)) + b;
    }

    /**
     * Sinusoidal easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutSine(t, b, c, d) {
      return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
    }

    /**
     * Exponential easing in
     * @memberOf fabric.util.ease
     */
    function easeInExpo(t, b, c, d) {
      return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
    }

    /**
     * Exponential easing out
     * @memberOf fabric.util.ease
     */
    function easeOutExpo(t, b, c, d) {
      return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
    }

    /**
     * Exponential easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutExpo(t, b, c, d) {
      if (t === 0) {
        return b;
      }
      if (t === d) {
        return b + c;
      }
      t /= d / 2;
      if (t < 1) {
        return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
      }
      return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
    }

    /**
     * Circular easing in
     * @memberOf fabric.util.ease
     */
    function easeInCirc(t, b, c, d) {
      return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
    }

    /**
     * Circular easing out
     * @memberOf fabric.util.ease
     */
    function easeOutCirc(t, b, c, d) {
      return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
    }

    /**
     * Circular easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutCirc(t, b, c, d) {
      t /= d / 2;
      if (t < 1) {
        return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
      }
      return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
    }

    /**
     * Elastic easing in
     * @memberOf fabric.util.ease
     */
    function easeInElastic(t, b, c, d) {
      var s = 1.70158, p = 0, a = c;
      if (t === 0) {
        return b;
      }
      t /= d;
      if (t === 1) {
        return b + c;
      }
      if (!p) {
        p = d * 0.3;
      }
      var opts = normalize(a, c, p, s);
      return -elastic(opts, t, d) + b;
    }

    /**
     * Elastic easing out
     * @memberOf fabric.util.ease
     */
    function easeOutElastic(t, b, c, d) {
      var s = 1.70158, p = 0, a = c;
      if (t === 0) {
        return b;
      }
      t /= d;
      if (t === 1) {
        return b + c;
      }
      if (!p) {
        p = d * 0.3;
      }
      var opts = normalize(a, c, p, s);
      return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) + opts.c + b;
    }

    /**
     * Elastic easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutElastic(t, b, c, d) {
      var s = 1.70158, p = 0, a = c;
      if (t === 0) {
        return b;
      }
      t /= d / 2;
      if (t === 2) {
        return b + c;
      }
      if (!p) {
        p = d * (0.3 * 1.5);
      }
      var opts = normalize(a, c, p, s);
      if (t < 1) {
        return -0.5 * elastic(opts, t, d) + b;
      }
      return opts.a * Math.pow(2, -10 * (t -= 1)) *
        Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) * 0.5 + opts.c + b;
    }

    /**
     * Backwards easing in
     * @memberOf fabric.util.ease
     */
    function easeInBack(t, b, c, d, s) {
      if (s === undefined) {
        s = 1.70158;
      }
      return c * (t /= d) * t * ((s + 1) * t - s) + b;
    }

    /**
     * Backwards easing out
     * @memberOf fabric.util.ease
     */
    function easeOutBack(t, b, c, d, s) {
      if (s === undefined) {
        s = 1.70158;
      }
      return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
    }

    /**
     * Backwards easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutBack(t, b, c, d, s) {
      if (s === undefined) {
        s = 1.70158;
      }
      t /= d / 2;
      if (t < 1) {
        return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
      }
      return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
    }

    /**
     * Bouncing easing in
     * @memberOf fabric.util.ease
     */
    function easeInBounce(t, b, c, d) {
      return c - easeOutBounce (d - t, 0, c, d) + b;
    }

    /**
     * Bouncing easing out
     * @memberOf fabric.util.ease
     */
    function easeOutBounce(t, b, c, d) {
      if ((t /= d) < (1 / 2.75)) {
        return c * (7.5625 * t * t) + b;
      }
      else if (t < (2 / 2.75)) {
        return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
      }
      else if (t < (2.5 / 2.75)) {
        return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
      }
      else {
        return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
      }
    }

    /**
     * Bouncing easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutBounce(t, b, c, d) {
      if (t < d / 2) {
        return easeInBounce (t * 2, 0, c, d) * 0.5 + b;
      }
      return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
    }

    /**
     * Easing functions
     * See <a href="http://gizma.com/easing/">Easing Equations by Robert Penner</a>
     * @namespace fabric.util.ease
     */
    fabric.util.ease = {

      /**
       * Quadratic easing in
       * @memberOf fabric.util.ease
       */
      easeInQuad: function(t, b, c, d) {
        return c * (t /= d) * t + b;
      },

      /**
       * Quadratic easing out
       * @memberOf fabric.util.ease
       */
      easeOutQuad: function(t, b, c, d) {
        return -c * (t /= d) * (t - 2) + b;
      },

      /**
       * Quadratic easing in and out
       * @memberOf fabric.util.ease
       */
      easeInOutQuad: function(t, b, c, d) {
        t /= (d / 2);
        if (t < 1) {
          return c / 2 * t * t + b;
        }
        return -c / 2 * ((--t) * (t - 2) - 1) + b;
      },

      /**
       * Cubic easing in
       * @memberOf fabric.util.ease
       */
      easeInCubic: function(t, b, c, d) {
        return c * (t /= d) * t * t + b;
      },

      easeOutCubic: easeOutCubic,
      easeInOutCubic: easeInOutCubic,
      easeInQuart: easeInQuart,
      easeOutQuart: easeOutQuart,
      easeInOutQuart: easeInOutQuart,
      easeInQuint: easeInQuint,
      easeOutQuint: easeOutQuint,
      easeInOutQuint: easeInOutQuint,
      easeInSine: easeInSine,
      easeOutSine: easeOutSine,
      easeInOutSine: easeInOutSine,
      easeInExpo: easeInExpo,
      easeOutExpo: easeOutExpo,
      easeInOutExpo: easeInOutExpo,
      easeInCirc: easeInCirc,
      easeOutCirc: easeOutCirc,
      easeInOutCirc: easeInOutCirc,
      easeInElastic: easeInElastic,
      easeOutElastic: easeOutElastic,
      easeInOutElastic: easeInOutElastic,
      easeInBack: easeInBack,
      easeOutBack: easeOutBack,
      easeInOutBack: easeInOutBack,
      easeInBounce: easeInBounce,
      easeOutBounce: easeOutBounce,
      easeInOutBounce: easeInOutBounce
    };

  })();


  (function(global) {

    /**
     * @name fabric
     * @namespace
     */

    var fabric = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        clone = fabric.util.object.clone,
        toFixed = fabric.util.toFixed,
        parseUnit = fabric.util.parseUnit,
        multiplyTransformMatrices = fabric.util.multiplyTransformMatrices,

        svgValidTagNames = ['path', 'circle', 'polygon', 'polyline', 'ellipse', 'rect', 'line',
          'image', 'text', 'linearGradient', 'radialGradient', 'stop'],
        svgViewBoxElements = ['symbol', 'image', 'marker', 'pattern', 'view', 'svg'],
        svgInvalidAncestors = ['pattern', 'defs', 'symbol', 'metadata', 'clipPath', 'mask', 'desc'],
        svgValidParents = ['symbol', 'g', 'a', 'svg'],

        attributesMap = {
          cx:                   'left',
          x:                    'left',
          r:                    'radius',
          cy:                   'top',
          y:                    'top',
          display:              'visible',
          visibility:           'visible',
          transform:            'transformMatrix',
          'fill-opacity':       'fillOpacity',
          'fill-rule':          'fillRule',
          'font-family':        'fontFamily',
          'font-size':          'fontSize',
          'font-style':         'fontStyle',
          'font-weight':        'fontWeight',
          'letter-spacing':     'charSpacing',
          'paint-order':        'paintFirst',
          'stroke-dasharray':   'strokeDashArray',
          'stroke-linecap':     'strokeLineCap',
          'stroke-linejoin':    'strokeLineJoin',
          'stroke-miterlimit':  'strokeMiterLimit',
          'stroke-opacity':     'strokeOpacity',
          'stroke-width':       'strokeWidth',
          'text-decoration':    'textDecoration',
          'text-anchor':        'textAnchor',
          opacity:              'opacity'
        },

        colorAttributes = {
          stroke: 'strokeOpacity',
          fill:   'fillOpacity'
        };

    fabric.svgValidTagNamesRegEx = getSvgRegex(svgValidTagNames);
    fabric.svgViewBoxElementsRegEx = getSvgRegex(svgViewBoxElements);
    fabric.svgInvalidAncestorsRegEx = getSvgRegex(svgInvalidAncestors);
    fabric.svgValidParentsRegEx = getSvgRegex(svgValidParents);

    fabric.cssRules = { };
    fabric.gradientDefs = { };

    function normalizeAttr(attr) {
      // transform attribute names
      if (attr in attributesMap) {
        return attributesMap[attr];
      }
      return attr;
    }

    function normalizeValue(attr, value, parentAttributes, fontSize) {
      var isArray = Object.prototype.toString.call(value) === '[object Array]',
          parsed;

      if ((attr === 'fill' || attr === 'stroke') && value === 'none') {
        value = '';
      }
      else if (attr === 'strokeDashArray') {
        if (value === 'none') {
          value = null;
        }
        else {
          value = value.replace(/,/g, ' ').split(/\s+/).map(function(n) {
            return parseFloat(n);
          });
        }
      }
      else if (attr === 'transformMatrix') {
        if (parentAttributes && parentAttributes.transformMatrix) {
          value = multiplyTransformMatrices(
            parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));
        }
        else {
          value = fabric.parseTransformAttribute(value);
        }
      }
      else if (attr === 'visible') {
        value = value !== 'none' && value !== 'hidden';
        // display=none on parent element always takes precedence over child element
        if (parentAttributes && parentAttributes.visible === false) {
          value = false;
        }
      }
      else if (attr === 'opacity') {
        value = parseFloat(value);
        if (parentAttributes && typeof parentAttributes.opacity !== 'undefined') {
          value *= parentAttributes.opacity;
        }
      }
      else if (attr === 'textAnchor' /* text-anchor */) {
        value = value === 'start' ? 'left' : value === 'end' ? 'right' : 'center';
      }
      else if (attr === 'charSpacing') {
        // parseUnit returns px and we convert it to em
        parsed = parseUnit(value, fontSize) / fontSize * 1000;
      }
      else if (attr === 'paintFirst') {
        var fillIndex = value.indexOf('fill');
        var strokeIndex = value.indexOf('stroke');
        var value = 'fill';
        if (fillIndex > -1 && strokeIndex > -1 && strokeIndex < fillIndex) {
          value = 'stroke';
        }
        else if (fillIndex === -1 && strokeIndex > -1) {
          value = 'stroke';
        }
      }
      else {
        parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);
      }

      return (!isArray && isNaN(parsed) ? value : parsed);
    }

    /**
      * @private
      */
    function getSvgRegex(arr) {
      return new RegExp('^(' + arr.join('|') + ')\\b', 'i');
    }

    /**
     * @private
     * @param {Object} attributes Array of attributes to parse
     */
    function _setStrokeFillOpacity(attributes) {
      for (var attr in colorAttributes) {

        if (typeof attributes[colorAttributes[attr]] === 'undefined' || attributes[attr] === '') {
          continue;
        }

        if (typeof attributes[attr] === 'undefined') {
          if (!fabric.Object.prototype[attr]) {
            continue;
          }
          attributes[attr] = fabric.Object.prototype[attr];
        }

        if (attributes[attr].indexOf('url(') === 0) {
          continue;
        }

        var color = new fabric.Color(attributes[attr]);
        attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();
      }
      return attributes;
    }

    /**
     * @private
     */
    function _getMultipleNodes(doc, nodeNames) {
      var nodeName, nodeArray = [], nodeList, i, len;
      for (i = 0, len = nodeNames.length; i < len; i++) {
        nodeName = nodeNames[i];
        nodeList = doc.getElementsByTagName(nodeName);
        nodeArray = nodeArray.concat(Array.prototype.slice.call(nodeList));
      }
      return nodeArray;
    }

    /**
     * Parses "transform" attribute, returning an array of values
     * @static
     * @function
     * @memberOf fabric
     * @param {String} attributeValue String containing attribute value
     * @return {Array} Array of 6 elements representing transformation matrix
     */
    fabric.parseTransformAttribute = (function() {
      function rotateMatrix(matrix, args) {
        var cos = fabric.util.cos(args[0]), sin = fabric.util.sin(args[0]),
            x = 0, y = 0;
        if (args.length === 3) {
          x = args[1];
          y = args[2];
        }

        matrix[0] = cos;
        matrix[1] = sin;
        matrix[2] = -sin;
        matrix[3] = cos;
        matrix[4] = x - (cos * x - sin * y);
        matrix[5] = y - (sin * x + cos * y);
      }

      function scaleMatrix(matrix, args) {
        var multiplierX = args[0],
            multiplierY = (args.length === 2) ? args[1] : args[0];

        matrix[0] = multiplierX;
        matrix[3] = multiplierY;
      }

      function skewMatrix(matrix, args, pos) {
        matrix[pos] = Math.tan(fabric.util.degreesToRadians(args[0]));
      }

      function translateMatrix(matrix, args) {
        matrix[4] = args[0];
        if (args.length === 2) {
          matrix[5] = args[1];
        }
      }

      // identity matrix
      var iMatrix = [
            1, // a
            0, // b
            0, // c
            1, // d
            0, // e
            0  // f
          ],

          // == begin transform regexp
          number = fabric.reNum,

          commaWsp = '(?:\\s+,?\\s*|,\\s*)',

          skewX = '(?:(skewX)\\s*\\(\\s*(' + number + ')\\s*\\))',

          skewY = '(?:(skewY)\\s*\\(\\s*(' + number + ')\\s*\\))',

          rotate = '(?:(rotate)\\s*\\(\\s*(' + number + ')(?:' +
                      commaWsp + '(' + number + ')' +
                      commaWsp + '(' + number + '))?\\s*\\))',

          scale = '(?:(scale)\\s*\\(\\s*(' + number + ')(?:' +
                      commaWsp + '(' + number + '))?\\s*\\))',

          translate = '(?:(translate)\\s*\\(\\s*(' + number + ')(?:' +
                      commaWsp + '(' + number + '))?\\s*\\))',

          matrix = '(?:(matrix)\\s*\\(\\s*' +
                    '(' + number + ')' + commaWsp +
                    '(' + number + ')' + commaWsp +
                    '(' + number + ')' + commaWsp +
                    '(' + number + ')' + commaWsp +
                    '(' + number + ')' + commaWsp +
                    '(' + number + ')' +
                    '\\s*\\))',

          transform = '(?:' +
                      matrix + '|' +
                      translate + '|' +
                      scale + '|' +
                      rotate + '|' +
                      skewX + '|' +
                      skewY +
                      ')',

          transforms = '(?:' + transform + '(?:' + commaWsp + '*' + transform + ')*' + ')',

          transformList = '^\\s*(?:' + transforms + '?)\\s*$',

          // http://www.w3.org/TR/SVG/coords.html#TransformAttribute
          reTransformList = new RegExp(transformList),
          // == end transform regexp

          reTransform = new RegExp(transform, 'g');

      return function(attributeValue) {

        // start with identity matrix
        var matrix = iMatrix.concat(),
            matrices = [];

        // return if no argument was given or
        // an argument does not match transform attribute regexp
        if (!attributeValue || (attributeValue && !reTransformList.test(attributeValue))) {
          return matrix;
        }

        attributeValue.replace(reTransform, function(match) {

          var m = new RegExp(transform).exec(match).filter(function (match) {
                // match !== '' && match != null
                return (!!match);
              }),
              operation = m[1],
              args = m.slice(2).map(parseFloat);

          switch (operation) {
            case 'translate':
              translateMatrix(matrix, args);
              break;
            case 'rotate':
              args[0] = fabric.util.degreesToRadians(args[0]);
              rotateMatrix(matrix, args);
              break;
            case 'scale':
              scaleMatrix(matrix, args);
              break;
            case 'skewX':
              skewMatrix(matrix, args, 2);
              break;
            case 'skewY':
              skewMatrix(matrix, args, 1);
              break;
            case 'matrix':
              matrix = args;
              break;
          }

          // snapshot current matrix into matrices array
          matrices.push(matrix.concat());
          // reset
          matrix = iMatrix.concat();
        });

        var combinedMatrix = matrices[0];
        while (matrices.length > 1) {
          matrices.shift();
          combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);
        }
        return combinedMatrix;
      };
    })();

    /**
     * @private
     */
    function parseStyleString(style, oStyle) {
      var attr, value;
      style.replace(/;\s*$/, '').split(';').forEach(function (chunk) {
        var pair = chunk.split(':');

        attr = pair[0].trim().toLowerCase();
        value =  pair[1].trim();

        oStyle[attr] = value;
      });
    }

    /**
     * @private
     */
    function parseStyleObject(style, oStyle) {
      var attr, value;
      for (var prop in style) {
        if (typeof style[prop] === 'undefined') {
          continue;
        }

        attr = prop.toLowerCase();
        value = style[prop];

        oStyle[attr] = value;
      }
    }

    /**
     * @private
     */
    function getGlobalStylesForElement(element, svgUid) {
      var styles = { };
      for (var rule in fabric.cssRules[svgUid]) {
        if (elementMatchesRule(element, rule.split(' '))) {
          for (var property in fabric.cssRules[svgUid][rule]) {
            styles[property] = fabric.cssRules[svgUid][rule][property];
          }
        }
      }
      return styles;
    }

    /**
     * @private
     */
    function elementMatchesRule(element, selectors) {
      var firstMatching, parentMatching = true;
      //start from rightmost selector.
      firstMatching = selectorMatches(element, selectors.pop());
      if (firstMatching && selectors.length) {
        parentMatching = doesSomeParentMatch(element, selectors);
      }
      return firstMatching && parentMatching && (selectors.length === 0);
    }

    function doesSomeParentMatch(element, selectors) {
      var selector, parentMatching = true;
      while (element.parentNode && element.parentNode.nodeType === 1 && selectors.length) {
        if (parentMatching) {
          selector = selectors.pop();
        }
        element = element.parentNode;
        parentMatching = selectorMatches(element, selector);
      }
      return selectors.length === 0;
    }

    /**
     * @private
     */
    function selectorMatches(element, selector) {
      var nodeName = element.nodeName,
          classNames = element.getAttribute('class'),
          id = element.getAttribute('id'), matcher, i;
      // i check if a selector matches slicing away part from it.
      // if i get empty string i should match
      matcher = new RegExp('^' + nodeName, 'i');
      selector = selector.replace(matcher, '');
      if (id && selector.length) {
        matcher = new RegExp('#' + id + '(?![a-zA-Z\\-]+)', 'i');
        selector = selector.replace(matcher, '');
      }
      if (classNames && selector.length) {
        classNames = classNames.split(' ');
        for (i = classNames.length; i--;) {
          matcher = new RegExp('\\.' + classNames[i] + '(?![a-zA-Z\\-]+)', 'i');
          selector = selector.replace(matcher, '');
        }
      }
      return selector.length === 0;
    }

    /**
     * @private
     * to support IE8 missing getElementById on SVGdocument
     */
    function elementById(doc, id) {
      var el;
      doc.getElementById && (el = doc.getElementById(id));
      if (el) {
        return el;
      }
      var node, i, len, nodelist = doc.getElementsByTagName('*');
      for (i = 0, len = nodelist.length; i < len; i++) {
        node = nodelist[i];
        if (id === node.getAttribute('id')) {
          return node;
        }
      }
    }

    /**
     * @private
     */
    function parseUseDirectives(doc) {
      var nodelist = _getMultipleNodes(doc, ['use', 'svg:use']), i = 0;

      while (nodelist.length && i < nodelist.length) {
        var el = nodelist[i],
            xlink = el.getAttribute('xlink:href').substr(1),
            x = el.getAttribute('x') || 0,
            y = el.getAttribute('y') || 0,
            el2 = elementById(doc, xlink).cloneNode(true),
            currentTrans = (el2.getAttribute('transform') || '') + ' translate(' + x + ', ' + y + ')',
            parentNode, oldLength = nodelist.length, attr, j, attrs, len;

        applyViewboxTransform(el2);
        if (/^svg$/i.test(el2.nodeName)) {
          var el3 = el2.ownerDocument.createElement('g');
          for (j = 0, attrs = el2.attributes, len = attrs.length; j < len; j++) {
            attr = attrs.item(j);
            el3.setAttribute(attr.nodeName, attr.nodeValue);
          }
          // el2.firstChild != null
          while (el2.firstChild) {
            el3.appendChild(el2.firstChild);
          }
          el2 = el3;
        }

        for (j = 0, attrs = el.attributes, len = attrs.length; j < len; j++) {
          attr = attrs.item(j);
          if (attr.nodeName === 'x' || attr.nodeName === 'y' || attr.nodeName === 'xlink:href') {
            continue;
          }

          if (attr.nodeName === 'transform') {
            currentTrans = attr.nodeValue + ' ' + currentTrans;
          }
          else {
            el2.setAttribute(attr.nodeName, attr.nodeValue);
          }
        }

        el2.setAttribute('transform', currentTrans);
        el2.setAttribute('instantiated_by_use', '1');
        el2.removeAttribute('id');
        parentNode = el.parentNode;
        parentNode.replaceChild(el2, el);
        // some browsers do not shorten nodelist after replaceChild (IE8)
        if (nodelist.length === oldLength) {
          i++;
        }
      }
    }

    // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute
    // matches, e.g.: +14.56e-12, etc.
    var reViewBoxAttrValue = new RegExp(
      '^' +
      '\\s*(' + fabric.reNum + '+)\\s*,?' +
      '\\s*(' + fabric.reNum + '+)\\s*,?' +
      '\\s*(' + fabric.reNum + '+)\\s*,?' +
      '\\s*(' + fabric.reNum + '+)\\s*' +
      '$'
    );

    /**
     * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements
     */
    function applyViewboxTransform(element) {

      var viewBoxAttr = element.getAttribute('viewBox'),
          scaleX = 1,
          scaleY = 1,
          minX = 0,
          minY = 0,
          viewBoxWidth, viewBoxHeight, matrix, el,
          widthAttr = element.getAttribute('width'),
          heightAttr = element.getAttribute('height'),
          x = element.getAttribute('x') || 0,
          y = element.getAttribute('y') || 0,
          preserveAspectRatio = element.getAttribute('preserveAspectRatio') || '',
          missingViewBox = (!viewBoxAttr || !fabric.svgViewBoxElementsRegEx.test(element.nodeName)
                             || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue))),
          missingDimAttr = (!widthAttr || !heightAttr || widthAttr === '100%' || heightAttr === '100%'),
          toBeParsed = missingViewBox && missingDimAttr,
          parsedDim = { }, translateMatrix = '', widthDiff = 0, heightDiff = 0;

      parsedDim.width = 0;
      parsedDim.height = 0;
      parsedDim.toBeParsed = toBeParsed;

      if (toBeParsed) {
        return parsedDim;
      }

      if (missingViewBox) {
        parsedDim.width = parseUnit(widthAttr);
        parsedDim.height = parseUnit(heightAttr);
        return parsedDim;
      }

      minX = -parseFloat(viewBoxAttr[1]);
      minY = -parseFloat(viewBoxAttr[2]);
      viewBoxWidth = parseFloat(viewBoxAttr[3]);
      viewBoxHeight = parseFloat(viewBoxAttr[4]);

      if (!missingDimAttr) {
        parsedDim.width = parseUnit(widthAttr);
        parsedDim.height = parseUnit(heightAttr);
        scaleX = parsedDim.width / viewBoxWidth;
        scaleY = parsedDim.height / viewBoxHeight;
      }
      else {
        parsedDim.width = viewBoxWidth;
        parsedDim.height = viewBoxHeight;
      }

      // default is to preserve aspect ratio
      preserveAspectRatio = fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);
      if (preserveAspectRatio.alignX !== 'none') {
        //translate all container for the effect of Mid, Min, Max
        if (preserveAspectRatio.meetOrSlice === 'meet') {
          scaleY = scaleX = (scaleX > scaleY ? scaleY : scaleX);
          // calculate additional translation to move the viewbox
        }
        if (preserveAspectRatio.meetOrSlice === 'slice') {
          scaleY = scaleX = (scaleX > scaleY ? scaleX : scaleY);
          // calculate additional translation to move the viewbox
        }
        widthDiff = parsedDim.width - viewBoxWidth * scaleX;
        heightDiff = parsedDim.height - viewBoxHeight * scaleX;
        if (preserveAspectRatio.alignX === 'Mid') {
          widthDiff /= 2;
        }
        if (preserveAspectRatio.alignY === 'Mid') {
          heightDiff /= 2;
        }
        if (preserveAspectRatio.alignX === 'Min') {
          widthDiff = 0;
        }
        if (preserveAspectRatio.alignY === 'Min') {
          heightDiff = 0;
        }
      }

      if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x === 0 && y === 0) {
        return parsedDim;
      }

      if (x || y) {
        translateMatrix = ' translate(' + parseUnit(x) + ' ' + parseUnit(y) + ') ';
      }

      matrix = translateMatrix + ' matrix(' + scaleX +
                    ' 0' +
                    ' 0 ' +
                    scaleY + ' ' +
                    (minX * scaleX + widthDiff) + ' ' +
                    (minY * scaleY + heightDiff) + ') ';

      if (element.nodeName === 'svg') {
        el = element.ownerDocument.createElement('g');
        // element.firstChild != null
        while (element.firstChild) {
          el.appendChild(element.firstChild);
        }
        element.appendChild(el);
      }
      else {
        el = element;
        matrix = el.getAttribute('transform') + matrix;
      }

      el.setAttribute('transform', matrix);
      return parsedDim;
    }

    function hasAncestorWithNodeName(element, nodeName) {
      while (element && (element = element.parentNode)) {
        if (element.nodeName && nodeName.test(element.nodeName.replace('svg:', ''))
          && !element.getAttribute('instantiated_by_use')) {
          return true;
        }
      }
      return false;
    }

    /**
     * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback
     * @static
     * @function
     * @memberOf fabric
     * @param {SVGDocument} doc SVG document to parse
     * @param {Function} callback Callback to call when parsing is finished;
     * It's being passed an array of elements (parsed from a document).
     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
     * @param {Object} [parsingOptions] options for parsing document
     * @param {String} [parsingOptions.crossOrigin] crossOrigin settings
     */
    fabric.parseSVGDocument = function(doc, callback, reviver, parsingOptions) {
      if (!doc) {
        return;
      }

      parseUseDirectives(doc);

      var svgUid =  fabric.Object.__uid++, i, len,
          options = applyViewboxTransform(doc),
          descendants = fabric.util.toArray(doc.getElementsByTagName('*'));
      options.crossOrigin = parsingOptions && parsingOptions.crossOrigin;
      options.svgUid = svgUid;

      if (descendants.length === 0 && fabric.isLikelyNode) {
        // we're likely in node, where "o3-xml" library fails to gEBTN("*")
        // https://github.com/ajaxorg/node-o3-xml/issues/21
        descendants = doc.selectNodes('//*[name(.)!="svg"]');
        var arr = [];
        for (i = 0, len = descendants.length; i < len; i++) {
          arr[i] = descendants[i];
        }
        descendants = arr;
      }

      var elements = descendants.filter(function(el) {
        applyViewboxTransform(el);
        return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace('svg:', '')) &&
              !hasAncestorWithNodeName(el, fabric.svgInvalidAncestorsRegEx); // http://www.w3.org/TR/SVG/struct.html#DefsElement
      });

      if (!elements || (elements && !elements.length)) {
        callback && callback([], {});
        return;
      }

      fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);
      fabric.cssRules[svgUid] = fabric.getCSSRules(doc);
      // Precedence of rules:   style > class > attribute
      fabric.parseElements(elements, function(instances, elements) {
        if (callback) {
          callback(instances, options, elements, descendants);
        }
      }, clone(options), reviver, parsingOptions);
    };

    var reFontDeclaration = new RegExp(
      '(normal|italic)?\\s*(normal|small-caps)?\\s*' +
      '(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(' +
        fabric.reNum +
      '(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|' + fabric.reNum + '))?\\s+(.*)');

    extend(fabric, {
      /**
       * Parses a short font declaration, building adding its properties to a style object
       * @static
       * @function
       * @memberOf fabric
       * @param {String} value font declaration
       * @param {Object} oStyle definition
       */
      parseFontDeclaration: function(value, oStyle) {
        var match = value.match(reFontDeclaration);

        if (!match) {
          return;
        }
        var fontStyle = match[1],
            // font variant is not used
            // fontVariant = match[2],
            fontWeight = match[3],
            fontSize = match[4],
            lineHeight = match[5],
            fontFamily = match[6];

        if (fontStyle) {
          oStyle.fontStyle = fontStyle;
        }
        if (fontWeight) {
          oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);
        }
        if (fontSize) {
          oStyle.fontSize = parseUnit(fontSize);
        }
        if (fontFamily) {
          oStyle.fontFamily = fontFamily;
        }
        if (lineHeight) {
          oStyle.lineHeight = lineHeight === 'normal' ? 1 : lineHeight;
        }
      },

      /**
       * Parses an SVG document, returning all of the gradient declarations found in it
       * @static
       * @function
       * @memberOf fabric
       * @param {SVGDocument} doc SVG document to parse
       * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element
       */
      getGradientDefs: function(doc) {
        var tagArray = [
              'linearGradient',
              'radialGradient',
              'svg:linearGradient',
              'svg:radialGradient'],
            elList = _getMultipleNodes(doc, tagArray),
            el, j = 0, id, xlink,
            gradientDefs = { }, idsToXlinkMap = { };
        j = elList.length;

        while (j--) {
          el = elList[j];
          xlink = el.getAttribute('xlink:href');
          id = el.getAttribute('id');
          if (xlink) {
            idsToXlinkMap[id] = xlink.substr(1);
          }
          gradientDefs[id] = el;
        }

        for (id in idsToXlinkMap) {
          var el2 = gradientDefs[idsToXlinkMap[id]].cloneNode(true);
          el = gradientDefs[id];
          while (el2.firstChild) {
            el.appendChild(el2.firstChild);
          }
        }
        return gradientDefs;
      },

      /**
       * Returns an object of attributes' name/value, given element and an array of attribute names;
       * Parses parent "g" nodes recursively upwards.
       * @static
       * @memberOf fabric
       * @param {DOMElement} element Element to parse
       * @param {Array} attributes Array of attributes to parse
       * @return {Object} object containing parsed attributes' names/values
       */
      parseAttributes: function(element, attributes, svgUid) {

        if (!element) {
          return;
        }

        var value,
            parentAttributes = { },
            fontSize;

        if (typeof svgUid === 'undefined') {
          svgUid = element.getAttribute('svgUid');
        }
        // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards
        if (element.parentNode && fabric.svgValidParentsRegEx.test(element.parentNode.nodeName)) {
          parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);
        }
        fontSize = (parentAttributes && parentAttributes.fontSize ) ||
                   element.getAttribute('font-size') || fabric.Text.DEFAULT_SVG_FONT_SIZE;

        var ownAttributes = attributes.reduce(function(memo, attr) {
          value = element.getAttribute(attr);
          if (value) { // eslint-disable-line
            memo[attr] = value;
          }
          return memo;
        }, { });
        // add values parsed from style, which take precedence over attributes
        // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)
        ownAttributes = extend(ownAttributes,
          extend(getGlobalStylesForElement(element, svgUid), fabric.parseStyleAttribute(element)));

        var normalizedAttr, normalizedValue, normalizedStyle = {};
        for (var attr in ownAttributes) {
          normalizedAttr = normalizeAttr(attr);
          normalizedValue = normalizeValue(normalizedAttr, ownAttributes[attr], parentAttributes, fontSize);
          normalizedStyle[normalizedAttr] = normalizedValue;
        }
        if (normalizedStyle && normalizedStyle.font) {
          fabric.parseFontDeclaration(normalizedStyle.font, normalizedStyle);
        }
        var mergedAttrs = extend(parentAttributes, normalizedStyle);
        return fabric.svgValidParentsRegEx.test(element.nodeName) ? mergedAttrs : _setStrokeFillOpacity(mergedAttrs);
      },

      /**
       * Transforms an array of svg elements to corresponding fabric.* instances
       * @static
       * @memberOf fabric
       * @param {Array} elements Array of elements to parse
       * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)
       * @param {Object} [options] Options object
       * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
       */
      parseElements: function(elements, callback, options, reviver, parsingOptions) {
        new fabric.ElementsParser(elements, callback, options, reviver, parsingOptions).parse();
      },

      /**
       * Parses "style" attribute, retuning an object with values
       * @static
       * @memberOf fabric
       * @param {SVGElement} element Element to parse
       * @return {Object} Objects with values parsed from style attribute of an element
       */
      parseStyleAttribute: function(element) {
        var oStyle = { },
            style = element.getAttribute('style');

        if (!style) {
          return oStyle;
        }

        if (typeof style === 'string') {
          parseStyleString(style, oStyle);
        }
        else {
          parseStyleObject(style, oStyle);
        }

        return oStyle;
      },

      /**
       * Parses "points" attribute, returning an array of values
       * @static
       * @memberOf fabric
       * @param {String} points points attribute string
       * @return {Array} array of points
       */
      parsePointsAttribute: function(points) {

        // points attribute is required and must not be empty
        if (!points) {
          return null;
        }

        // replace commas with whitespace and remove bookending whitespace
        points = points.replace(/,/g, ' ').trim();

        points = points.split(/\s+/);
        var parsedPoints = [], i, len;

        for (i = 0, len = points.length; i < len; i += 2) {
          parsedPoints.push({
            x: parseFloat(points[i]),
            y: parseFloat(points[i + 1])
          });
        }

        // odd number of points is an error
        // if (parsedPoints.length % 2 !== 0) {
        //   return null;
        // }

        return parsedPoints;
      },

      /**
       * Returns CSS rules for a given SVG document
       * @static
       * @function
       * @memberOf fabric
       * @param {SVGDocument} doc SVG document to parse
       * @return {Object} CSS rules of this document
       */
      getCSSRules: function(doc) {
        var styles = doc.getElementsByTagName('style'), i, len,
            allRules = { }, rules;

        // very crude parsing of style contents
        for (i = 0, len = styles.length; i < len; i++) {
          // IE9 doesn't support textContent, but provides text instead.
          var styleContents = styles[i].textContent || styles[i].text;

          // remove comments
          styleContents = styleContents.replace(/\/\*[\s\S]*?\*\//g, '');
          if (styleContents.trim() === '') {
            continue;
          }
          rules = styleContents.match(/[^{]*\{[\s\S]*?\}/g);
          rules = rules.map(function(rule) { return rule.trim(); });
          // eslint-disable-next-line no-loop-func
          rules.forEach(function(rule) {

            var match = rule.match(/([\s\S]*?)\s*\{([^}]*)\}/),
                ruleObj = { }, declaration = match[2].trim(),
                propertyValuePairs = declaration.replace(/;$/, '').split(/\s*;\s*/);

            for (i = 0, len = propertyValuePairs.length; i < len; i++) {
              var pair = propertyValuePairs[i].split(/\s*:\s*/),
                  property = pair[0],
                  value = pair[1];
              ruleObj[property] = value;
            }
            rule = match[1];
            rule.split(',').forEach(function(_rule) {
              _rule = _rule.replace(/^svg/i, '').trim();
              if (_rule === '') {
                return;
              }
              if (allRules[_rule]) {
                fabric.util.object.extend(allRules[_rule], ruleObj);
              }
              else {
                allRules[_rule] = fabric.util.object.clone(ruleObj);
              }
            });
          });
        }
        return allRules;
      },

      /**
       * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.
       * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)
       * @memberOf fabric
       * @param {String} url
       * @param {Function} callback
       * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
       * @param {Object} [options] Object containing options for parsing
       * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
       */
      loadSVGFromURL: function(url, callback, reviver, options) {

        url = url.replace(/^\n\s*/, '').trim();
        new fabric.util.request(url, {
          method: 'get',
          onComplete: onComplete
        });

        function onComplete(r) {

          var xml = r.responseXML;
          if (xml && !xml.documentElement && fabric.window.ActiveXObject && r.responseText) {
            xml = new ActiveXObject('Microsoft.XMLDOM');
            xml.async = 'false';
            //IE chokes on DOCTYPE
            xml.loadXML(r.responseText.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i, ''));
          }
          if (!xml || !xml.documentElement) {
            callback && callback(null);
          }

          fabric.parseSVGDocument(xml.documentElement, function (results, _options, elements, allElements) {
            callback && callback(results, _options, elements, allElements);
          }, reviver, options);
        }
      },

      /**
       * Takes string corresponding to an SVG document, and parses it into a set of fabric objects
       * @memberOf fabric
       * @param {String} string
       * @param {Function} callback
       * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
       * @param {Object} [options] Object containing options for parsing
       * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
       */
      loadSVGFromString: function(string, callback, reviver, options) {
        string = string.trim();
        var doc;
        if (typeof DOMParser !== 'undefined') {
          var parser = new DOMParser();
          if (parser && parser.parseFromString) {
            doc = parser.parseFromString(string, 'text/xml');
          }
        }
        else if (fabric.window.ActiveXObject) {
          doc = new ActiveXObject('Microsoft.XMLDOM');
          doc.async = 'false';
          // IE chokes on DOCTYPE
          doc.loadXML(string.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i, ''));
        }

        fabric.parseSVGDocument(doc.documentElement, function (results, _options, elements, allElements) {
          callback(results, _options, elements, allElements);
        }, reviver, options);
      }
    });

  })(exports);


  fabric.ElementsParser = function(elements, callback, options, reviver, parsingOptions) {
    this.elements = elements;
    this.callback = callback;
    this.options = options;
    this.reviver = reviver;
    this.svgUid = (options && options.svgUid) || 0;
    this.parsingOptions = parsingOptions;
    this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g;
  };

  fabric.ElementsParser.prototype.parse = function() {
    this.instances = new Array(this.elements.length);
    this.numElements = this.elements.length;

    this.createObjects();
  };

  fabric.ElementsParser.prototype.createObjects = function() {
    for (var i = 0, len = this.elements.length; i < len; i++) {
      this.elements[i].setAttribute('svgUid', this.svgUid);
      (function(_obj, i) {
        setTimeout(function() {
          _obj.createObject(_obj.elements[i], i);
        }, 0);
      })(this, i);
    }
  };

  fabric.ElementsParser.prototype.createObject = function(el, index) {
    var klass = fabric[fabric.util.string.capitalize(el.tagName.replace('svg:', ''))];
    if (klass && klass.fromElement) {
      try {
        this._createObject(klass, el, index);
      }
      catch (err) {
        fabric.log(err);
      }
    }
    else {
      this.checkIfDone();
    }
  };

  fabric.ElementsParser.prototype._createObject = function(klass, el, index) {
    klass.fromElement(el, this.createCallback(index, el), this.options);
  };

  fabric.ElementsParser.prototype.createCallback = function(index, el) {
    var _this = this;
    return function(obj) {
      var _options;
      _this.resolveGradient(obj, 'fill');
      _this.resolveGradient(obj, 'stroke');
      if (obj instanceof fabric.Image) {
        _options = obj.parsePreserveAspectRatioAttribute(el);
      }
      obj._removeTransformMatrix(_options);
      _this.reviver && _this.reviver(el, obj);
      _this.instances[index] = obj;
      _this.checkIfDone();
    };
  };

  fabric.ElementsParser.prototype.resolveGradient = function(obj, property) {

    var instanceFillValue = obj[property];
    if (!(/^url\(/).test(instanceFillValue)) {
      return;
    }
    var gradientId = this.regexUrl.exec(instanceFillValue)[1];
    this.regexUrl.lastIndex = 0;
    if (fabric.gradientDefs[this.svgUid][gradientId]) {
      obj.set(property,
        fabric.Gradient.fromElement(fabric.gradientDefs[this.svgUid][gradientId], obj));
    }
  };

  fabric.ElementsParser.prototype.checkIfDone = function() {
    if (--this.numElements === 0) {
      this.instances = this.instances.filter(function(el) {
        // eslint-disable-next-line no-eq-null, eqeqeq
        return el != null;
      });
      this.callback(this.instances, this.elements);
    }
  };


  (function(global) {

    /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */

    var fabric = global.fabric || (global.fabric = { });

    if (fabric.Point) {
      fabric.warn('fabric.Point is already defined');
      return;
    }

    fabric.Point = Point;

    /**
     * Point class
     * @class fabric.Point
     * @memberOf fabric
     * @constructor
     * @param {Number} x
     * @param {Number} y
     * @return {fabric.Point} thisArg
     */
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    Point.prototype = /** @lends fabric.Point.prototype */ {

      type: 'point',

      constructor: Point,

      /**
       * Adds another point to this one and returns another one
       * @param {fabric.Point} that
       * @return {fabric.Point} new Point instance with added values
       */
      add: function (that) {
        return new Point(this.x + that.x, this.y + that.y);
      },

      /**
       * Adds another point to this one
       * @param {fabric.Point} that
       * @return {fabric.Point} thisArg
       * @chainable
       */
      addEquals: function (that) {
        this.x += that.x;
        this.y += that.y;
        return this;
      },

      /**
       * Adds value to this point and returns a new one
       * @param {Number} scalar
       * @return {fabric.Point} new Point with added value
       */
      scalarAdd: function (scalar) {
        return new Point(this.x + scalar, this.y + scalar);
      },

      /**
       * Adds value to this point
       * @param {Number} scalar
       * @return {fabric.Point} thisArg
       * @chainable
       */
      scalarAddEquals: function (scalar) {
        this.x += scalar;
        this.y += scalar;
        return this;
      },

      /**
       * Subtracts another point from this point and returns a new one
       * @param {fabric.Point} that
       * @return {fabric.Point} new Point object with subtracted values
       */
      subtract: function (that) {
        return new Point(this.x - that.x, this.y - that.y);
      },

      /**
       * Subtracts another point from this point
       * @param {fabric.Point} that
       * @return {fabric.Point} thisArg
       * @chainable
       */
      subtractEquals: function (that) {
        this.x -= that.x;
        this.y -= that.y;
        return this;
      },

      /**
       * Subtracts value from this point and returns a new one
       * @param {Number} scalar
       * @return {fabric.Point}
       */
      scalarSubtract: function (scalar) {
        return new Point(this.x - scalar, this.y - scalar);
      },

      /**
       * Subtracts value from this point
       * @param {Number} scalar
       * @return {fabric.Point} thisArg
       * @chainable
       */
      scalarSubtractEquals: function (scalar) {
        this.x -= scalar;
        this.y -= scalar;
        return this;
      },

      /**
       * Multiplies this point by a value and returns a new one
       * TODO: rename in scalarMultiply in 2.0
       * @param {Number} scalar
       * @return {fabric.Point}
       */
      multiply: function (scalar) {
        return new Point(this.x * scalar, this.y * scalar);
      },

      /**
       * Multiplies this point by a value
       * TODO: rename in scalarMultiplyEquals in 2.0
       * @param {Number} scalar
       * @return {fabric.Point} thisArg
       * @chainable
       */
      multiplyEquals: function (scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
      },

      /**
       * Divides this point by a value and returns a new one
       * TODO: rename in scalarDivide in 2.0
       * @param {Number} scalar
       * @return {fabric.Point}
       */
      divide: function (scalar) {
        return new Point(this.x / scalar, this.y / scalar);
      },

      /**
       * Divides this point by a value
       * TODO: rename in scalarDivideEquals in 2.0
       * @param {Number} scalar
       * @return {fabric.Point} thisArg
       * @chainable
       */
      divideEquals: function (scalar) {
        this.x /= scalar;
        this.y /= scalar;
        return this;
      },

      /**
       * Returns true if this point is equal to another one
       * @param {fabric.Point} that
       * @return {Boolean}
       */
      eq: function (that) {
        return (this.x === that.x && this.y === that.y);
      },

      /**
       * Returns true if this point is less than another one
       * @param {fabric.Point} that
       * @return {Boolean}
       */
      lt: function (that) {
        return (this.x < that.x && this.y < that.y);
      },

      /**
       * Returns true if this point is less than or equal to another one
       * @param {fabric.Point} that
       * @return {Boolean}
       */
      lte: function (that) {
        return (this.x <= that.x && this.y <= that.y);
      },

      /**

       * Returns true if this point is greater another one
       * @param {fabric.Point} that
       * @return {Boolean}
       */
      gt: function (that) {
        return (this.x > that.x && this.y > that.y);
      },

      /**
       * Returns true if this point is greater than or equal to another one
       * @param {fabric.Point} that
       * @return {Boolean}
       */
      gte: function (that) {
        return (this.x >= that.x && this.y >= that.y);
      },

      /**
       * Returns new point which is the result of linear interpolation with this one and another one
       * @param {fabric.Point} that
       * @param {Number} t , position of interpolation, between 0 and 1 default 0.5
       * @return {fabric.Point}
       */
      lerp: function (that, t) {
        if (typeof t === 'undefined') {
          t = 0.5;
        }
        t = Math.max(Math.min(1, t), 0);
        return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);
      },

      /**
       * Returns distance from this point and another one
       * @param {fabric.Point} that
       * @return {Number}
       */
      distanceFrom: function (that) {
        var dx = this.x - that.x,
            dy = this.y - that.y;
        return Math.sqrt(dx * dx + dy * dy);
      },

      /**
       * Returns the point between this point and another one
       * @param {fabric.Point} that
       * @return {fabric.Point}
       */
      midPointFrom: function (that) {
        return this.lerp(that);
      },

      /**
       * Returns a new point which is the min of this and another one
       * @param {fabric.Point} that
       * @return {fabric.Point}
       */
      min: function (that) {
        return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));
      },

      /**
       * Returns a new point which is the max of this and another one
       * @param {fabric.Point} that
       * @return {fabric.Point}
       */
      max: function (that) {
        return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));
      },

      /**
       * Returns string representation of this point
       * @return {String}
       */
      toString: function () {
        return this.x + ',' + this.y;
      },

      /**
       * Sets x/y of this point
       * @param {Number} x
       * @param {Number} y
       * @chainable
       */
      setXY: function (x, y) {
        this.x = x;
        this.y = y;
        return this;
      },

      /**
       * Sets x of this point
       * @param {Number} x
       * @chainable
       */
      setX: function (x) {
        this.x = x;
        return this;
      },

      /**
       * Sets y of this point
       * @param {Number} y
       * @chainable
       */
      setY: function (y) {
        this.y = y;
        return this;
      },

      /**
       * Sets x/y of this point from another point
       * @param {fabric.Point} that
       * @chainable
       */
      setFromPoint: function (that) {
        this.x = that.x;
        this.y = that.y;
        return this;
      },

      /**
       * Swaps x/y of this point and another point
       * @param {fabric.Point} that
       */
      swap: function (that) {
        var x = this.x,
            y = this.y;
        this.x = that.x;
        this.y = that.y;
        that.x = x;
        that.y = y;
      },

      /**
       * return a cloned instance of the point
       * @return {fabric.Point}
       */
      clone: function () {
        return new Point(this.x, this.y);
      }
    };

  })(exports);


  (function(global) {

    /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */
    var fabric = global.fabric || (global.fabric = { });

    if (fabric.Intersection) {
      fabric.warn('fabric.Intersection is already defined');
      return;
    }

    /**
     * Intersection class
     * @class fabric.Intersection
     * @memberOf fabric
     * @constructor
     */
    function Intersection(status) {
      this.status = status;
      this.points = [];
    }

    fabric.Intersection = Intersection;

    fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {

      constructor: Intersection,

      /**
       * Appends a point to intersection
       * @param {fabric.Point} point
       * @return {fabric.Intersection} thisArg
       * @chainable
       */
      appendPoint: function (point) {
        this.points.push(point);
        return this;
      },

      /**
       * Appends points to intersection
       * @param {Array} points
       * @return {fabric.Intersection} thisArg
       * @chainable
       */
      appendPoints: function (points) {
        this.points = this.points.concat(points);
        return this;
      }
    };

    /**
     * Checks if one line intersects another
     * TODO: rename in intersectSegmentSegment
     * @static
     * @param {fabric.Point} a1
     * @param {fabric.Point} a2
     * @param {fabric.Point} b1
     * @param {fabric.Point} b2
     * @return {fabric.Intersection}
     */
    fabric.Intersection.intersectLineLine = function (a1, a2, b1, b2) {
      var result,
          uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
          ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),
          uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
      if (uB !== 0) {
        var ua = uaT / uB,
            ub = ubT / uB;
        if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
          result = new Intersection('Intersection');
          result.appendPoint(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));
        }
        else {
          result = new Intersection();
        }
      }
      else {
        if (uaT === 0 || ubT === 0) {
          result = new Intersection('Coincident');
        }
        else {
          result = new Intersection('Parallel');
        }
      }
      return result;
    };

    /**
     * Checks if line intersects polygon
     * TODO: rename in intersectSegmentPolygon
     * fix detection of coincident
     * @static
     * @param {fabric.Point} a1
     * @param {fabric.Point} a2
     * @param {Array} points
     * @return {fabric.Intersection}
     */
    fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {
      var result = new Intersection(),
          length = points.length,
          b1, b2, inter, i;

      for (i = 0; i < length; i++) {
        b1 = points[i];
        b2 = points[(i + 1) % length];
        inter = Intersection.intersectLineLine(a1, a2, b1, b2);

        result.appendPoints(inter.points);
      }
      if (result.points.length > 0) {
        result.status = 'Intersection';
      }
      return result;
    };

    /**
     * Checks if polygon intersects another polygon
     * @static
     * @param {Array} points1
     * @param {Array} points2
     * @return {fabric.Intersection}
     */
    fabric.Intersection.intersectPolygonPolygon = function (points1, points2) {
      var result = new Intersection(),
          length = points1.length, i;

      for (i = 0; i < length; i++) {
        var a1 = points1[i],
            a2 = points1[(i + 1) % length],
            inter = Intersection.intersectLinePolygon(a1, a2, points2);

        result.appendPoints(inter.points);
      }
      if (result.points.length > 0) {
        result.status = 'Intersection';
      }
      return result;
    };

    /**
     * Checks if polygon intersects rectangle
     * @static
     * @param {Array} points
     * @param {fabric.Point} r1
     * @param {fabric.Point} r2
     * @return {fabric.Intersection}
     */
    fabric.Intersection.intersectPolygonRectangle = function (points, r1, r2) {
      var min = r1.min(r2),
          max = r1.max(r2),
          topRight = new fabric.Point(max.x, min.y),
          bottomLeft = new fabric.Point(min.x, max.y),
          inter1 = Intersection.intersectLinePolygon(min, topRight, points),
          inter2 = Intersection.intersectLinePolygon(topRight, max, points),
          inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points),
          inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points),
          result = new Intersection();

      result.appendPoints(inter1.points);
      result.appendPoints(inter2.points);
      result.appendPoints(inter3.points);
      result.appendPoints(inter4.points);

      if (result.points.length > 0) {
        result.status = 'Intersection';
      }
      return result;
    };

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { });

    if (fabric.Color) {
      fabric.warn('fabric.Color is already defined.');
      return;
    }

    /**
     * Color class
     * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;
     * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.
     *
     * @class fabric.Color
     * @param {String} color optional in hex or rgb(a) or hsl format or from known color list
     * @return {fabric.Color} thisArg
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}
     */
    function Color(color) {
      if (!color) {
        this.setSource([0, 0, 0, 1]);
      }
      else {
        this._tryParsingColor(color);
      }
    }

    fabric.Color = Color;

    fabric.Color.prototype = /** @lends fabric.Color.prototype */ {

      /**
       * @private
       * @param {String|Array} color Color value to parse
       */
      _tryParsingColor: function(color) {
        var source;

        if (color in Color.colorNameMap) {
          color = Color.colorNameMap[color];
        }

        if (color === 'transparent') {
          source = [255, 255, 255, 0];
        }

        if (!source) {
          source = Color.sourceFromHex(color);
        }
        if (!source) {
          source = Color.sourceFromRgb(color);
        }
        if (!source) {
          source = Color.sourceFromHsl(color);
        }
        if (!source) {
          //if color is not recognize let's make black as canvas does
          source = [0, 0, 0, 1];
        }
        if (source) {
          this.setSource(source);
        }
      },

      /**
       * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
       * @private
       * @param {Number} r Red color value
       * @param {Number} g Green color value
       * @param {Number} b Blue color value
       * @return {Array} Hsl color
       */
      _rgbToHsl: function(r, g, b) {
        r /= 255; g /= 255; b /= 255;

        var h, s, l,
            max = fabric.util.array.max([r, g, b]),
            min = fabric.util.array.min([r, g, b]);

        l = (max + min) / 2;

        if (max === min) {
          h = s = 0; // achromatic
        }
        else {
          var d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }

        return [
          Math.round(h * 360),
          Math.round(s * 100),
          Math.round(l * 100)
        ];
      },

      /**
       * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])
       * @return {Array}
       */
      getSource: function() {
        return this._source;
      },

      /**
       * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])
       * @param {Array} source
       */
      setSource: function(source) {
        this._source = source;
      },

      /**
       * Returns color representation in RGB format
       * @return {String} ex: rgb(0-255,0-255,0-255)
       */
      toRgb: function() {
        var source = this.getSource();
        return 'rgb(' + source[0] + ',' + source[1] + ',' + source[2] + ')';
      },

      /**
       * Returns color representation in RGBA format
       * @return {String} ex: rgba(0-255,0-255,0-255,0-1)
       */
      toRgba: function() {
        var source = this.getSource();
        return 'rgba(' + source[0] + ',' + source[1] + ',' + source[2] + ',' + source[3] + ')';
      },

      /**
       * Returns color representation in HSL format
       * @return {String} ex: hsl(0-360,0%-100%,0%-100%)
       */
      toHsl: function() {
        var source = this.getSource(),
            hsl = this._rgbToHsl(source[0], source[1], source[2]);

        return 'hsl(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%)';
      },

      /**
       * Returns color representation in HSLA format
       * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)
       */
      toHsla: function() {
        var source = this.getSource(),
            hsl = this._rgbToHsl(source[0], source[1], source[2]);

        return 'hsla(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%,' + source[3] + ')';
      },

      /**
       * Returns color representation in HEX format
       * @return {String} ex: FF5555
       */
      toHex: function() {
        var source = this.getSource(), r, g, b;

        r = source[0].toString(16);
        r = (r.length === 1) ? ('0' + r) : r;

        g = source[1].toString(16);
        g = (g.length === 1) ? ('0' + g) : g;

        b = source[2].toString(16);
        b = (b.length === 1) ? ('0' + b) : b;

        return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();
      },

      /**
       * Returns color representation in HEXA format
       * @return {String} ex: FF5555CC
       */
      toHexa: function() {
        var source = this.getSource(), a;

        a = Math.round(source[3] * 255);
        a = a.toString(16);
        a = (a.length === 1) ? ('0' + a) : a;

        return this.toHex() + a.toUpperCase();
      },

      /**
       * Gets value of alpha channel for this color
       * @return {Number} 0-1
       */
      getAlpha: function() {
        return this.getSource()[3];
      },

      /**
       * Sets value of alpha channel for this color
       * @param {Number} alpha Alpha value 0-1
       * @return {fabric.Color} thisArg
       */
      setAlpha: function(alpha) {
        var source = this.getSource();
        source[3] = alpha;
        this.setSource(source);
        return this;
      },

      /**
       * Transforms color to its grayscale representation
       * @return {fabric.Color} thisArg
       */
      toGrayscale: function() {
        var source = this.getSource(),
            average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10),
            currentAlpha = source[3];
        this.setSource([average, average, average, currentAlpha]);
        return this;
      },

      /**
       * Transforms color to its black and white representation
       * @param {Number} threshold
       * @return {fabric.Color} thisArg
       */
      toBlackWhite: function(threshold) {
        var source = this.getSource(),
            average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0),
            currentAlpha = source[3];

        threshold = threshold || 127;

        average = (Number(average) < Number(threshold)) ? 0 : 255;
        this.setSource([average, average, average, currentAlpha]);
        return this;
      },

      /**
       * Overlays color with another color
       * @param {String|fabric.Color} otherColor
       * @return {fabric.Color} thisArg
       */
      overlayWith: function(otherColor) {
        if (!(otherColor instanceof Color)) {
          otherColor = new Color(otherColor);
        }

        var result = [],
            alpha = this.getAlpha(),
            otherAlpha = 0.5,
            source = this.getSource(),
            otherSource = otherColor.getSource(), i;

        for (i = 0; i < 3; i++) {
          result.push(Math.round((source[i] * (1 - otherAlpha)) + (otherSource[i] * otherAlpha)));
        }

        result[3] = alpha;
        this.setSource(result);
        return this;
      }
    };

    /**
     * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))
     * @static
     * @field
     * @memberOf fabric.Color
     */
    // eslint-disable-next-line max-len
    fabric.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i;

    /**
     * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))
     * @static
     * @field
     * @memberOf fabric.Color
     */
    fabric.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/i;

    /**
     * Regex matching color in HEX format (ex: #FF5544CC, #FF5555, 010155, aff)
     * @static
     * @field
     * @memberOf fabric.Color
     */
    fabric.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;

    /**
     * Map of the 148 color names with HEX code
     * @static
     * @field
     * @memberOf fabric.Color
     * @see: https://www.w3.org/TR/css3-color/#svg-color
     */
    fabric.Color.colorNameMap = {
      aliceblue:            '#F0F8FF',
      antiquewhite:         '#FAEBD7',
      aqua:                 '#00FFFF',
      aquamarine:           '#7FFFD4',
      azure:                '#F0FFFF',
      beige:                '#F5F5DC',
      bisque:               '#FFE4C4',
      black:                '#000000',
      blanchedalmond:       '#FFEBCD',
      blue:                 '#0000FF',
      blueviolet:           '#8A2BE2',
      brown:                '#A52A2A',
      burlywood:            '#DEB887',
      cadetblue:            '#5F9EA0',
      chartreuse:           '#7FFF00',
      chocolate:            '#D2691E',
      coral:                '#FF7F50',
      cornflowerblue:       '#6495ED',
      cornsilk:             '#FFF8DC',
      crimson:              '#DC143C',
      cyan:                 '#00FFFF',
      darkblue:             '#00008B',
      darkcyan:             '#008B8B',
      darkgoldenrod:        '#B8860B',
      darkgray:             '#A9A9A9',
      darkgrey:             '#A9A9A9',
      darkgreen:            '#006400',
      darkkhaki:            '#BDB76B',
      darkmagenta:          '#8B008B',
      darkolivegreen:       '#556B2F',
      darkorange:           '#FF8C00',
      darkorchid:           '#9932CC',
      darkred:              '#8B0000',
      darksalmon:           '#E9967A',
      darkseagreen:         '#8FBC8F',
      darkslateblue:        '#483D8B',
      darkslategray:        '#2F4F4F',
      darkslategrey:        '#2F4F4F',
      darkturquoise:        '#00CED1',
      darkviolet:           '#9400D3',
      deeppink:             '#FF1493',
      deepskyblue:          '#00BFFF',
      dimgray:              '#696969',
      dimgrey:              '#696969',
      dodgerblue:           '#1E90FF',
      firebrick:            '#B22222',
      floralwhite:          '#FFFAF0',
      forestgreen:          '#228B22',
      fuchsia:              '#FF00FF',
      gainsboro:            '#DCDCDC',
      ghostwhite:           '#F8F8FF',
      gold:                 '#FFD700',
      goldenrod:            '#DAA520',
      gray:                 '#808080',
      grey:                 '#808080',
      green:                '#008000',
      greenyellow:          '#ADFF2F',
      honeydew:             '#F0FFF0',
      hotpink:              '#FF69B4',
      indianred:            '#CD5C5C',
      indigo:               '#4B0082',
      ivory:                '#FFFFF0',
      khaki:                '#F0E68C',
      lavender:             '#E6E6FA',
      lavenderblush:        '#FFF0F5',
      lawngreen:            '#7CFC00',
      lemonchiffon:         '#FFFACD',
      lightblue:            '#ADD8E6',
      lightcoral:           '#F08080',
      lightcyan:            '#E0FFFF',
      lightgoldenrodyellow: '#FAFAD2',
      lightgray:            '#D3D3D3',
      lightgrey:            '#D3D3D3',
      lightgreen:           '#90EE90',
      lightpink:            '#FFB6C1',
      lightsalmon:          '#FFA07A',
      lightseagreen:        '#20B2AA',
      lightskyblue:         '#87CEFA',
      lightslategray:       '#778899',
      lightslategrey:       '#778899',
      lightsteelblue:       '#B0C4DE',
      lightyellow:          '#FFFFE0',
      lime:                 '#00FF00',
      limegreen:            '#32CD32',
      linen:                '#FAF0E6',
      magenta:              '#FF00FF',
      maroon:               '#800000',
      mediumaquamarine:     '#66CDAA',
      mediumblue:           '#0000CD',
      mediumorchid:         '#BA55D3',
      mediumpurple:         '#9370DB',
      mediumseagreen:       '#3CB371',
      mediumslateblue:      '#7B68EE',
      mediumspringgreen:    '#00FA9A',
      mediumturquoise:      '#48D1CC',
      mediumvioletred:      '#C71585',
      midnightblue:         '#191970',
      mintcream:            '#F5FFFA',
      mistyrose:            '#FFE4E1',
      moccasin:             '#FFE4B5',
      navajowhite:          '#FFDEAD',
      navy:                 '#000080',
      oldlace:              '#FDF5E6',
      olive:                '#808000',
      olivedrab:            '#6B8E23',
      orange:               '#FFA500',
      orangered:            '#FF4500',
      orchid:               '#DA70D6',
      palegoldenrod:        '#EEE8AA',
      palegreen:            '#98FB98',
      paleturquoise:        '#AFEEEE',
      palevioletred:        '#DB7093',
      papayawhip:           '#FFEFD5',
      peachpuff:            '#FFDAB9',
      peru:                 '#CD853F',
      pink:                 '#FFC0CB',
      plum:                 '#DDA0DD',
      powderblue:           '#B0E0E6',
      purple:               '#800080',
      rebeccapurple:        '#663399',
      red:                  '#FF0000',
      rosybrown:            '#BC8F8F',
      royalblue:            '#4169E1',
      saddlebrown:          '#8B4513',
      salmon:               '#FA8072',
      sandybrown:           '#F4A460',
      seagreen:             '#2E8B57',
      seashell:             '#FFF5EE',
      sienna:               '#A0522D',
      silver:               '#C0C0C0',
      skyblue:              '#87CEEB',
      slateblue:            '#6A5ACD',
      slategray:            '#708090',
      slategrey:            '#708090',
      snow:                 '#FFFAFA',
      springgreen:          '#00FF7F',
      steelblue:            '#4682B4',
      tan:                  '#D2B48C',
      teal:                 '#008080',
      thistle:              '#D8BFD8',
      tomato:               '#FF6347',
      turquoise:            '#40E0D0',
      violet:               '#EE82EE',
      wheat:                '#F5DEB3',
      white:                '#FFFFFF',
      whitesmoke:           '#F5F5F5',
      yellow:               '#FFFF00',
      yellowgreen:          '#9ACD32'
    };

    /**
     * @private
     * @param {Number} p
     * @param {Number} q
     * @param {Number} t
     * @return {Number}
     */
    function hue2rgb(p, q, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
      }
      if (t < 1 / 2) {
        return q;
      }
      if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
      }
      return p;
    }

    /**
     * Returns new color object, when given a color in RGB format
     * @memberOf fabric.Color
     * @param {String} color Color value ex: rgb(0-255,0-255,0-255)
     * @return {fabric.Color}
     */
    fabric.Color.fromRgb = function(color) {
      return Color.fromSource(Color.sourceFromRgb(color));
    };

    /**
     * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format
     * @memberOf fabric.Color
     * @param {String} color Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)
     * @return {Array} source
     */
    fabric.Color.sourceFromRgb = function(color) {
      var match = color.match(Color.reRGBa);
      if (match) {
        var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1),
            g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1),
            b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);

        return [
          parseInt(r, 10),
          parseInt(g, 10),
          parseInt(b, 10),
          match[4] ? parseFloat(match[4]) : 1
        ];
      }
    };

    /**
     * Returns new color object, when given a color in RGBA format
     * @static
     * @function
     * @memberOf fabric.Color
     * @param {String} color
     * @return {fabric.Color}
     */
    fabric.Color.fromRgba = Color.fromRgb;

    /**
     * Returns new color object, when given a color in HSL format
     * @param {String} color Color value ex: hsl(0-260,0%-100%,0%-100%)
     * @memberOf fabric.Color
     * @return {fabric.Color}
     */
    fabric.Color.fromHsl = function(color) {
      return Color.fromSource(Color.sourceFromHsl(color));
    };

    /**
     * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.
     * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
     * @memberOf fabric.Color
     * @param {String} color Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)
     * @return {Array} source
     * @see http://http://www.w3.org/TR/css3-color/#hsl-color
     */
    fabric.Color.sourceFromHsl = function(color) {
      var match = color.match(Color.reHSLa);
      if (!match) {
        return;
      }

      var h = (((parseFloat(match[1]) % 360) + 360) % 360) / 360,
          s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1),
          l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1),
          r, g, b;

      if (s === 0) {
        r = g = b = l;
      }
      else {
        var q = l <= 0.5 ? l * (s + 1) : l + s - l * s,
            p = l * 2 - q;

        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }

      return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255),
        match[4] ? parseFloat(match[4]) : 1
      ];
    };

    /**
     * Returns new color object, when given a color in HSLA format
     * @static
     * @function
     * @memberOf fabric.Color
     * @param {String} color
     * @return {fabric.Color}
     */
    fabric.Color.fromHsla = Color.fromHsl;

    /**
     * Returns new color object, when given a color in HEX format
     * @static
     * @memberOf fabric.Color
     * @param {String} color Color value ex: FF5555
     * @return {fabric.Color}
     */
    fabric.Color.fromHex = function(color) {
      return Color.fromSource(Color.sourceFromHex(color));
    };

    /**
     * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HEX format
     * @static
     * @memberOf fabric.Color
     * @param {String} color ex: FF5555 or FF5544CC (RGBa)
     * @return {Array} source
     */
    fabric.Color.sourceFromHex = function(color) {
      if (color.match(Color.reHex)) {
        var value = color.slice(color.indexOf('#') + 1),
            isShortNotation = (value.length === 3 || value.length === 4),
            isRGBa = (value.length === 8 || value.length === 4),
            r = isShortNotation ? (value.charAt(0) + value.charAt(0)) : value.substring(0, 2),
            g = isShortNotation ? (value.charAt(1) + value.charAt(1)) : value.substring(2, 4),
            b = isShortNotation ? (value.charAt(2) + value.charAt(2)) : value.substring(4, 6),
            a = isRGBa ? (isShortNotation ? (value.charAt(3) + value.charAt(3)) : value.substring(6, 8)) : 'FF';

        return [
          parseInt(r, 16),
          parseInt(g, 16),
          parseInt(b, 16),
          parseFloat((parseInt(a, 16) / 255).toFixed(2))
        ];
      }
    };

    /**
     * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])
     * @static
     * @memberOf fabric.Color
     * @param {Array} source
     * @return {fabric.Color}
     */
    fabric.Color.fromSource = function(source) {
      var oColor = new Color();
      oColor.setSource(source);
      return oColor;
    };

  })(exports);


  (function() {

    /* _FROM_SVG_START_ */
    function getColorStop(el) {
      var style = el.getAttribute('style'),
          offset = el.getAttribute('offset') || 0,
          color, colorAlpha, opacity, i;

      // convert percents to absolute values
      offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);
      offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;
      if (style) {
        var keyValuePairs = style.split(/\s*;\s*/);

        if (keyValuePairs[keyValuePairs.length - 1] === '') {
          keyValuePairs.pop();
        }

        for (i = keyValuePairs.length; i--; ) {

          var split = keyValuePairs[i].split(/\s*:\s*/),
              key = split[0].trim(),
              value = split[1].trim();

          if (key === 'stop-color') {
            color = value;
          }
          else if (key === 'stop-opacity') {
            opacity = value;
          }
        }
      }

      if (!color) {
        color = el.getAttribute('stop-color') || 'rgb(0,0,0)';
      }
      if (!opacity) {
        opacity = el.getAttribute('stop-opacity');
      }

      color = new fabric.Color(color);
      colorAlpha = color.getAlpha();
      opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);
      opacity *= colorAlpha;

      return {
        offset: offset,
        color: color.toRgb(),
        opacity: opacity
      };
    }

    function getLinearCoords(el) {
      return {
        x1: el.getAttribute('x1') || 0,
        y1: el.getAttribute('y1') || 0,
        x2: el.getAttribute('x2') || '100%',
        y2: el.getAttribute('y2') || 0
      };
    }

    function getRadialCoords(el) {
      return {
        x1: el.getAttribute('fx') || el.getAttribute('cx') || '50%',
        y1: el.getAttribute('fy') || el.getAttribute('cy') || '50%',
        r1: 0,
        x2: el.getAttribute('cx') || '50%',
        y2: el.getAttribute('cy') || '50%',
        r2: el.getAttribute('r') || '50%'
      };
    }
    /* _FROM_SVG_END_ */

    var clone = fabric.util.object.clone;

    /**
     * Gradient class
     * @class fabric.Gradient
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#gradients}
     * @see {@link fabric.Gradient#initialize} for constructor definition
     */
    fabric.Gradient = fabric.util.createClass(/** @lends fabric.Gradient.prototype */ {

      /**
       * Horizontal offset for aligning gradients coming from SVG when outside pathgroups
       * @type Number
       * @default 0
       */
      offsetX: 0,

      /**
       * Vertical offset for aligning gradients coming from SVG when outside pathgroups
       * @type Number
       * @default 0
       */
      offsetY: 0,

      /**
       * Constructor
       * @param {Object} [options] Options object with type, coords, gradientUnits and colorStops
       * @return {fabric.Gradient} thisArg
       */
      initialize: function(options) {
        options || (options = { });

        var coords = { };

        this.id = fabric.Object.__uid++;
        this.type = options.type || 'linear';

        coords = {
          x1: options.coords.x1 || 0,
          y1: options.coords.y1 || 0,
          x2: options.coords.x2 || 0,
          y2: options.coords.y2 || 0
        };

        if (this.type === 'radial') {
          coords.r1 = options.coords.r1 || 0;
          coords.r2 = options.coords.r2 || 0;
        }
        this.coords = coords;
        this.colorStops = options.colorStops.slice();
        if (options.gradientTransform) {
          this.gradientTransform = options.gradientTransform;
        }
        this.offsetX = options.offsetX || this.offsetX;
        this.offsetY = options.offsetY || this.offsetY;
      },

      /**
       * Adds another colorStop
       * @param {Object} colorStop Object with offset and color
       * @return {fabric.Gradient} thisArg
       */
      addColorStop: function(colorStops) {
        for (var position in colorStops) {
          var color = new fabric.Color(colorStops[position]);
          this.colorStops.push({
            offset: parseFloat(position),
            color: color.toRgb(),
            opacity: color.getAlpha()
          });
        }
        return this;
      },

      /**
       * Returns object representation of a gradient
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object}
       */
      toObject: function(propertiesToInclude) {
        var object = {
          type: this.type,
          coords: this.coords,
          colorStops: this.colorStops,
          offsetX: this.offsetX,
          offsetY: this.offsetY,
          gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform
        };
        fabric.util.populateWithProperties(this, object, propertiesToInclude);

        return object;
      },

      /* _TO_SVG_START_ */
      /**
       * Returns SVG representation of an gradient
       * @param {Object} object Object to create a gradient for
       * @return {String} SVG representation of an gradient (linear/radial)
       */
      toSVG: function(object) {
        var coords = clone(this.coords, true), i, len,
            markup, commonAttributes, colorStops = clone(this.colorStops, true),
            needsSwap = coords.r1 > coords.r2,
            offsetX = object.width / 2, offsetY = object.height / 2;
        // colorStops must be sorted ascending
        colorStops.sort(function(a, b) {
          return a.offset - b.offset;
        });
        if (object.type === 'path') {
          offsetX -= object.pathOffset.x;
          offsetY -= object.pathOffset.y;
        }

        commonAttributes = 'id="SVGID_' + this.id +
                       '" gradientUnits="userSpaceOnUse"';
        if (this.gradientTransform) {
          commonAttributes += ' gradientTransform="matrix(' + this.gradientTransform.join(' ') + ')" ';
        }
        if (this.type === 'linear') {
          markup = [
            '<linearGradient ',
            commonAttributes,
            ' x1="', coords.x1,
            '" y1="', coords.y1,
            '" x2="', coords.x2,
            '" y2="', coords.y2,
            '">\n'
          ];
        }
        else if (this.type === 'radial') {
          // svg radial gradient has just 1 radius. the biggest.
          markup = [
            '<radialGradient ',
            commonAttributes,
            ' cx="', needsSwap ? coords.x1 : coords.x2,
            '" cy="', needsSwap ? coords.y1 : coords.y2,
            '" r="', needsSwap ? coords.r1 : coords.r2,
            '" fx="', needsSwap ? coords.x2 : coords.x1,
            '" fy="', needsSwap ? coords.y2 : coords.y1,
            '">\n'
          ];
        }

        if (this.type === 'radial') {
          if (needsSwap) {
            // svg goes from internal to external radius. if radius are inverted, swap color stops.
            colorStops = colorStops.concat();
            colorStops.reverse();
            for (i = 0, len = colorStops.length; i < len; i++) {
              colorStops[i].offset = 1 - colorStops[i].offset;
            }
          }
          var minRadius = Math.min(coords.r1, coords.r2);
          if (minRadius > 0) {
            // i have to shift all colorStops and add new one in 0.
            var maxRadius = Math.max(coords.r1, coords.r2),
                percentageShift = minRadius / maxRadius;
            for (i = 0, len = colorStops.length; i < len; i++) {
              colorStops[i].offset += percentageShift * (1 - colorStops[i].offset);
            }
          }
        }

        for (i = 0, len = colorStops.length; i < len; i++) {
          var colorStop = colorStops[i];
          markup.push(
            '<stop ',
            'offset="', (colorStop.offset * 100) + '%',
            '" style="stop-color:', colorStop.color,
            (typeof colorStop.opacity !== 'undefined' ? ';stop-opacity: ' + colorStop.opacity : ';'),
            '"/>\n'
          );
        }

        markup.push((this.type === 'linear' ? '</linearGradient>\n' : '</radialGradient>\n'));

        return markup.join('');
      },
      /* _TO_SVG_END_ */

      /**
       * Returns an instance of CanvasGradient
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @return {CanvasGradient}
       */
      toLive: function(ctx) {
        var gradient, coords = fabric.util.object.clone(this.coords), i, len;

        if (!this.type) {
          return;
        }

        if (this.type === 'linear') {
          gradient = ctx.createLinearGradient(
            coords.x1, coords.y1, coords.x2, coords.y2);
        }
        else if (this.type === 'radial') {
          gradient = ctx.createRadialGradient(
            coords.x1, coords.y1, coords.r1, coords.x2, coords.y2, coords.r2);
        }

        for (i = 0, len = this.colorStops.length; i < len; i++) {
          var color = this.colorStops[i].color,
              opacity = this.colorStops[i].opacity,
              offset = this.colorStops[i].offset;

          if (typeof opacity !== 'undefined') {
            color = new fabric.Color(color).setAlpha(opacity).toRgba();
          }
          gradient.addColorStop(offset, color);
        }

        return gradient;
      }
    });

    fabric.util.object.extend(fabric.Gradient, {

      /* _FROM_SVG_START_ */
      /**
       * Returns {@link fabric.Gradient} instance from an SVG element
       * @static
       * @memberOf fabric.Gradient
       * @param {SVGGradientElement} el SVG gradient element
       * @param {fabric.Object} instance
       * @return {fabric.Gradient} Gradient instance
       * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement
       * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement
       */
      fromElement: function(el, instance) {
        /**
         *  @example:
         *
         *  <linearGradient id="linearGrad1">
         *    <stop offset="0%" stop-color="white"/>
         *    <stop offset="100%" stop-color="black"/>
         *  </linearGradient>
         *
         *  OR
         *
         *  <linearGradient id="linearGrad2">
         *    <stop offset="0" style="stop-color:rgb(255,255,255)"/>
         *    <stop offset="1" style="stop-color:rgb(0,0,0)"/>
         *  </linearGradient>
         *
         *  OR
         *
         *  <radialGradient id="radialGrad1">
         *    <stop offset="0%" stop-color="white" stop-opacity="1" />
         *    <stop offset="50%" stop-color="black" stop-opacity="0.5" />
         *    <stop offset="100%" stop-color="white" stop-opacity="1" />
         *  </radialGradient>
         *
         *  OR
         *
         *  <radialGradient id="radialGrad2">
         *    <stop offset="0" stop-color="rgb(255,255,255)" />
         *    <stop offset="0.5" stop-color="rgb(0,0,0)" />
         *    <stop offset="1" stop-color="rgb(255,255,255)" />
         *  </radialGradient>
         *
         */

        var colorStopEls = el.getElementsByTagName('stop'),
            type,
            gradientUnits = el.getAttribute('gradientUnits') || 'objectBoundingBox',
            gradientTransform = el.getAttribute('gradientTransform'),
            colorStops = [],
            coords, ellipseMatrix, i;

        if (el.nodeName === 'linearGradient' || el.nodeName === 'LINEARGRADIENT') {
          type = 'linear';
        }
        else {
          type = 'radial';
        }

        if (type === 'linear') {
          coords = getLinearCoords(el);
        }
        else if (type === 'radial') {
          coords = getRadialCoords(el);
        }

        for (i = colorStopEls.length; i--; ) {
          colorStops.push(getColorStop(colorStopEls[i]));
        }

        ellipseMatrix = _convertPercentUnitsToValues(instance, coords, gradientUnits);

        var gradient = new fabric.Gradient({
          type: type,
          coords: coords,
          colorStops: colorStops,
          offsetX: -instance.left,
          offsetY: -instance.top
        });

        if (gradientTransform || ellipseMatrix !== '') {
          gradient.gradientTransform = fabric.parseTransformAttribute((gradientTransform || '') + ellipseMatrix);
        }

        return gradient;
      },
      /* _FROM_SVG_END_ */

      /**
       * Returns {@link fabric.Gradient} instance from its object representation
       * @static
       * @memberOf fabric.Gradient
       * @param {Object} obj
       * @param {Object} [options] Options object
       */
      forObject: function(obj, options) {
        options || (options = { });
        _convertPercentUnitsToValues(obj, options.coords, 'userSpaceOnUse');
        return new fabric.Gradient(options);
      }
    });

    /**
     * @private
     */
    function _convertPercentUnitsToValues(object, options, gradientUnits) {
      var propValue, addFactor = 0, multFactor = 1, ellipseMatrix = '';
      for (var prop in options) {
        if (options[prop] === 'Infinity') {
          options[prop] = 1;
        }
        else if (options[prop] === '-Infinity') {
          options[prop] = 0;
        }
        propValue = parseFloat(options[prop], 10);
        if (typeof options[prop] === 'string' && /^(\d+\.\d+)%|(\d+)%$/.test(options[prop])) {
          multFactor = 0.01;
        }
        else {
          multFactor = 1;
        }
        if (prop === 'x1' || prop === 'x2' || prop === 'r2') {
          multFactor *= gradientUnits === 'objectBoundingBox' ? object.width : 1;
          addFactor = gradientUnits === 'objectBoundingBox' ? object.left || 0 : 0;
        }
        else if (prop === 'y1' || prop === 'y2') {
          multFactor *= gradientUnits === 'objectBoundingBox' ? object.height : 1;
          addFactor = gradientUnits === 'objectBoundingBox' ? object.top || 0 : 0;
        }
        options[prop] = propValue * multFactor + addFactor;
      }
      if (object.type === 'ellipse' &&
          options.r2 !== null &&
          gradientUnits === 'objectBoundingBox' &&
          object.rx !== object.ry) {

        var scaleFactor = object.ry / object.rx;
        ellipseMatrix = ' scale(1, ' + scaleFactor + ')';
        if (options.y1) {
          options.y1 /= scaleFactor;
        }
        if (options.y2) {
          options.y2 /= scaleFactor;
        }
      }
      return ellipseMatrix;
    }
  })();


  (function() {

    var toFixed = fabric.util.toFixed;

    /**
     * Pattern class
     * @class fabric.Pattern
     * @see {@link http://fabricjs.com/patterns|Pattern demo}
     * @see {@link http://fabricjs.com/dynamic-patterns|DynamicPattern demo}
     * @see {@link fabric.Pattern#initialize} for constructor definition
     */


    fabric.Pattern = fabric.util.createClass(/** @lends fabric.Pattern.prototype */ {

      /**
       * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
       * @type String
       * @default
       */
      repeat: 'repeat',

      /**
       * Pattern horizontal offset from object's left/top corner
       * @type Number
       * @default
       */
      offsetX: 0,

      /**
       * Pattern vertical offset from object's left/top corner
       * @type Number
       * @default
       */
      offsetY: 0,

      /**
       * crossOrigin value (one of "", "anonymous", "use-credentials")
       * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
       * @type String
       * @default
       */
      crossOrigin: '',

      /**
       * transform matrix to change the pattern, imported from svgs.
       * @type Array
       * @default
       */
      patternTransform: null,

      /**
       * Constructor
       * @param {Object} [options] Options object
       * @param {Function} [callback] function to invoke after callback init.
       * @return {fabric.Pattern} thisArg
       */
      initialize: function(options, callback) {
        options || (options = { });

        this.id = fabric.Object.__uid++;
        this.setOptions(options);
        if (!options.source || (options.source && typeof options.source !== 'string')) {
          callback && callback(this);
          return;
        }
        // function string
        if (typeof fabric.util.getFunctionBody(options.source) !== 'undefined') {
          this.source = new Function(fabric.util.getFunctionBody(options.source));
          callback && callback(this);
        }
        else {
          // img src string
          var _this = this;
          this.source = fabric.util.createImage();
          fabric.util.loadImage(options.source, function(img) {
            _this.source = img;
            callback && callback(_this);
          }, null, this.crossOrigin);
        }
      },

      /**
       * Returns object representation of a pattern
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} Object representation of a pattern instance
       */
      toObject: function(propertiesToInclude) {
        var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
            source, object;

        // callback
        if (typeof this.source === 'function') {
          source = String(this.source);
        }
        // <img> element
        else if (typeof this.source.src === 'string') {
          source = this.source.src;
        }
        // <canvas> element
        else if (typeof this.source === 'object' && this.source.toDataURL) {
          source = this.source.toDataURL();
        }

        object = {
          type: 'pattern',
          source: source,
          repeat: this.repeat,
          crossOrigin: this.crossOrigin,
          offsetX: toFixed(this.offsetX, NUM_FRACTION_DIGITS),
          offsetY: toFixed(this.offsetY, NUM_FRACTION_DIGITS),
          patternTransform: this.patternTransform ? this.patternTransform.concat() : null
        };
        fabric.util.populateWithProperties(this, object, propertiesToInclude);

        return object;
      },

      /* _TO_SVG_START_ */
      /**
       * Returns SVG representation of a pattern
       * @param {fabric.Object} object
       * @return {String} SVG representation of a pattern
       */
      toSVG: function(object) {
        var patternSource = typeof this.source === 'function' ? this.source() : this.source,
            patternWidth = patternSource.width / object.width,
            patternHeight = patternSource.height / object.height,
            patternOffsetX = this.offsetX / object.width,
            patternOffsetY = this.offsetY / object.height,
            patternImgSrc = '';
        if (this.repeat === 'repeat-x' || this.repeat === 'no-repeat') {
          patternHeight = 1;
        }
        if (this.repeat === 'repeat-y' || this.repeat === 'no-repeat') {
          patternWidth = 1;
        }
        if (patternSource.src) {
          patternImgSrc = patternSource.src;
        }
        else if (patternSource.toDataURL) {
          patternImgSrc = patternSource.toDataURL();
        }

        return '<pattern id="SVGID_' + this.id +
                      '" x="' + patternOffsetX +
                      '" y="' + patternOffsetY +
                      '" width="' + patternWidth +
                      '" height="' + patternHeight + '">\n' +
                 '<image x="0" y="0"' +
                        ' width="' + patternSource.width +
                        '" height="' + patternSource.height +
                        '" xlink:href="' + patternImgSrc +
                 '"></image>\n' +
               '</pattern>\n';
      },
      /* _TO_SVG_END_ */

      setOptions: function(options) {
        for (var prop in options) {
          this[prop] = options[prop];
        }
      },

      /**
       * Returns an instance of CanvasPattern
       * @param {CanvasRenderingContext2D} ctx Context to create pattern
       * @return {CanvasPattern}
       */
      toLive: function(ctx) {
        var source = typeof this.source === 'function' ? this.source() : this.source;

        // if the image failed to load, return, and allow rest to continue loading
        if (!source) {
          return '';
        }

        // if an image
        if (typeof source.src !== 'undefined') {
          if (!source.complete) {
            return '';
          }
          if (source.naturalWidth === 0 || source.naturalHeight === 0) {
            return '';
          }
        }
        return ctx.createPattern(source, this.repeat);
      }
    });
  })();


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        toFixed = fabric.util.toFixed;

    if (fabric.Shadow) {
      fabric.warn('fabric.Shadow is already defined.');
      return;
    }

    /**
     * Shadow class
     * @class fabric.Shadow
     * @see {@link http://fabricjs.com/shadows|Shadow demo}
     * @see {@link fabric.Shadow#initialize} for constructor definition
     */
    fabric.Shadow = fabric.util.createClass(/** @lends fabric.Shadow.prototype */ {

      /**
       * Shadow color
       * @type String
       * @default
       */
      color: 'rgb(0,0,0)',

      /**
       * Shadow blur
       * @type Number
       */
      blur: 0,

      /**
       * Shadow horizontal offset
       * @type Number
       * @default
       */
      offsetX: 0,

      /**
       * Shadow vertical offset
       * @type Number
       * @default
       */
      offsetY: 0,

      /**
       * Whether the shadow should affect stroke operations
       * @type Boolean
       * @default
       */
      affectStroke: false,

      /**
       * Indicates whether toObject should include default values
       * @type Boolean
       * @default
       */
      includeDefaultValues: true,

      /**
       * Constructor
       * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetY properties or string (e.g. "rgba(0,0,0,0.2) 2px 2px 10px")
       * @return {fabric.Shadow} thisArg
       */
      initialize: function(options) {

        if (typeof options === 'string') {
          options = this._parseShadow(options);
        }

        for (var prop in options) {
          this[prop] = options[prop];
        }

        this.id = fabric.Object.__uid++;
      },

      /**
       * @private
       * @param {String} shadow Shadow value to parse
       * @return {Object} Shadow object with color, offsetX, offsetY and blur
       */
      _parseShadow: function(shadow) {
        var shadowStr = shadow.trim(),
            offsetsAndBlur = fabric.Shadow.reOffsetsAndBlur.exec(shadowStr) || [],
            color = shadowStr.replace(fabric.Shadow.reOffsetsAndBlur, '') || 'rgb(0,0,0)';

        return {
          color: color.trim(),
          offsetX: parseInt(offsetsAndBlur[1], 10) || 0,
          offsetY: parseInt(offsetsAndBlur[2], 10) || 0,
          blur: parseInt(offsetsAndBlur[3], 10) || 0
        };
      },

      /**
       * Returns a string representation of an instance
       * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow
       * @return {String} Returns CSS3 text-shadow declaration
       */
      toString: function() {
        return [this.offsetX, this.offsetY, this.blur, this.color].join('px ');
      },

      /* _TO_SVG_START_ */
      /**
       * Returns SVG representation of a shadow
       * @param {fabric.Object} object
       * @return {String} SVG representation of a shadow
       */
      toSVG: function(object) {
        var fBoxX = 40, fBoxY = 40, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
            offset = fabric.util.rotateVector(
              { x: this.offsetX, y: this.offsetY },
              fabric.util.degreesToRadians(-object.angle)),
            BLUR_BOX = 20, color = new fabric.Color(this.color);

        if (object.width && object.height) {
          //http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion
          // we add some extra space to filter box to contain the blur ( 20 )
          fBoxX = toFixed((Math.abs(offset.x) + this.blur) / object.width, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
          fBoxY = toFixed((Math.abs(offset.y) + this.blur) / object.height, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
        }
        if (object.flipX) {
          offset.x *= -1;
        }
        if (object.flipY) {
          offset.y *= -1;
        }

        return (
          '<filter id="SVGID_' + this.id + '" y="-' + fBoxY + '%" height="' + (100 + 2 * fBoxY) + '%" ' +
            'x="-' + fBoxX + '%" width="' + (100 + 2 * fBoxX) + '%" ' + '>\n' +
            '\t<feGaussianBlur in="SourceAlpha" stdDeviation="' +
              toFixed(this.blur ? this.blur / 2 : 0, NUM_FRACTION_DIGITS) + '"></feGaussianBlur>\n' +
            '\t<feOffset dx="' + toFixed(offset.x, NUM_FRACTION_DIGITS) +
            '" dy="' + toFixed(offset.y, NUM_FRACTION_DIGITS) + '" result="oBlur" ></feOffset>\n' +
            '\t<feFlood flood-color="' + color.toRgb() + '" flood-opacity="' + color.getAlpha() + '"/>\n' +
            '\t<feComposite in2="oBlur" operator="in" />\n' +
            '\t<feMerge>\n' +
              '\t\t<feMergeNode></feMergeNode>\n' +
              '\t\t<feMergeNode in="SourceGraphic"></feMergeNode>\n' +
            '\t</feMerge>\n' +
          '</filter>\n');
      },
      /* _TO_SVG_END_ */

      /**
       * Returns object representation of a shadow
       * @return {Object} Object representation of a shadow instance
       */
      toObject: function() {
        if (this.includeDefaultValues) {
          return {
            color: this.color,
            blur: this.blur,
            offsetX: this.offsetX,
            offsetY: this.offsetY,
            affectStroke: this.affectStroke
          };
        }
        var obj = { }, proto = fabric.Shadow.prototype;

        ['color', 'blur', 'offsetX', 'offsetY', 'affectStroke'].forEach(function(prop) {
          if (this[prop] !== proto[prop]) {
            obj[prop] = this[prop];
          }
        }, this);

        return obj;
      }
    });

    /**
     * Regex matching shadow offsetX, offsetY and blur (ex: "2px 2px 10px rgba(0,0,0,0.2)", "rgb(0,255,0) 2px 2px")
     * @static
     * @field
     * @memberOf fabric.Shadow
     */
    // eslint-disable-next-line max-len
    fabric.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:px)?(?:\s?|$))?(-?\d+(?:px)?(?:\s?|$))?(\d+(?:px)?)?(?:\s?|$)(?:$|\s)/;

  })(exports);


  (function () {

    if (fabric.StaticCanvas) {
      fabric.warn('fabric.StaticCanvas is already defined.');
      return;
    }

    // aliases for faster resolution
    var extend = fabric.util.object.extend,
        getElementOffset = fabric.util.getElementOffset,
        removeFromArray = fabric.util.removeFromArray,
        toFixed = fabric.util.toFixed,
        transformPoint = fabric.util.transformPoint,
        invertTransform = fabric.util.invertTransform,

        CANVAS_INIT_ERROR = new Error('Could not initialize `canvas` element');

    /**
     * Static canvas class
     * @class fabric.StaticCanvas
     * @mixes fabric.Collection
     * @mixes fabric.Observable
     * @see {@link http://fabricjs.com/static_canvas|StaticCanvas demo}
     * @see {@link fabric.StaticCanvas#initialize} for constructor definition
     * @fires before:render
     * @fires after:render
     * @fires canvas:cleared
     * @fires object:added
     * @fires object:removed
     */
    fabric.StaticCanvas = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.StaticCanvas.prototype */ {

      /**
       * Constructor
       * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
       * @param {Object} [options] Options object
       * @return {Object} thisArg
       */
      initialize: function(el, options) {
        options || (options = { });
        this.renderAndResetBound = this.renderAndReset.bind(this);
        this.requestRenderAllBound = this.requestRenderAll.bind(this);
        this._initStatic(el, options);
      },

      /**
       * Background color of canvas instance.
       * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.
       * @type {(String|fabric.Pattern)}
       * @default
       */
      backgroundColor: '',

      /**
       * Background image of canvas instance.
       * Should be set via {@link fabric.StaticCanvas#setBackgroundImage}.
       * <b>Backwards incompatibility note:</b> The "backgroundImageOpacity"
       * and "backgroundImageStretch" properties are deprecated since 1.3.9.
       * Use {@link fabric.Image#opacity}, {@link fabric.Image#width} and {@link fabric.Image#height}.
       * @type fabric.Image
       * @default
       */
      backgroundImage: null,

      /**
       * Overlay color of canvas instance.
       * Should be set via {@link fabric.StaticCanvas#setOverlayColor}
       * @since 1.3.9
       * @type {(String|fabric.Pattern)}
       * @default
       */
      overlayColor: '',

      /**
       * Overlay image of canvas instance.
       * Should be set via {@link fabric.StaticCanvas#setOverlayImage}.
       * <b>Backwards incompatibility note:</b> The "overlayImageLeft"
       * and "overlayImageTop" properties are deprecated since 1.3.9.
       * Use {@link fabric.Image#left} and {@link fabric.Image#top}.
       * @type fabric.Image
       * @default
       */
      overlayImage: null,

      /**
       * Indicates whether toObject/toDatalessObject should include default values
       * @type Boolean
       * @default
       */
      includeDefaultValues: true,

      /**
       * Indicates whether objects' state should be saved
       * @type Boolean
       * @default
       */
      stateful: false,

      /**
       * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove},
       * {@link fabric.StaticCanvas.moveTo}, {@link fabric.StaticCanvas.clear} and many more, should also re-render canvas.
       * Disabling this option will not give a performance boost when adding/removing a lot of objects to/from canvas at once
       * since the renders are quequed and executed one per frame.
       * Disabling is suggested anyway and managing the renders of the app manually is not a big effort ( canvas.requestRenderAll() )
       * Left default to true to do not break documentation and old app, fiddles.
       * @type Boolean
       * @default
       */
      renderOnAddRemove: true,

      /**
       * Function that determines clipping of entire canvas area
       * Being passed context as first argument. See clipping canvas area in {@link https://github.com/kangax/fabric.js/wiki/FAQ}
       * @deprecated since 2.0.0
       * @type Function
       * @default
       */
      clipTo: null,

      /**
       * Indicates whether object controls (borders/controls) are rendered above overlay image
       * @type Boolean
       * @default
       */
      controlsAboveOverlay: false,

      /**
       * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas
       * @type Boolean
       * @default
       */
      allowTouchScrolling: false,

      /**
       * Indicates whether this canvas will use image smoothing, this is on by default in browsers
       * @type Boolean
       * @default
       */
      imageSmoothingEnabled: true,

      /**
       * The transformation (in the format of Canvas transform) which focuses the viewport
       * @type Array
       * @default
       */
      viewportTransform: fabric.iMatrix.concat(),

      /**
       * if set to false background image is not affected by viewport transform
       * @since 1.6.3
       * @type Boolean
       * @default
       */
      backgroundVpt: true,

      /**
       * if set to false overlya image is not affected by viewport transform
       * @since 1.6.3
       * @type Boolean
       * @default
       */
      overlayVpt: true,

      /**
       * Callback; invoked right before object is about to be scaled/rotated
       * @deprecated since 2.3.0
       * Use before:transform event
       */
      onBeforeScaleRotate: function () {
        /* NOOP */
      },

      /**
       * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens
       * @type Boolean
       * @default
       */
      enableRetinaScaling: true,

      /**
       * Describe canvas element extension over design
       * properties are tl,tr,bl,br.
       * if canvas is not zoomed/panned those points are the four corner of canvas
       * if canvas is viewportTransformed you those points indicate the extension
       * of canvas element in plain untrasformed coordinates
       * The coordinates get updated with @method calcViewportBoundaries.
       * @memberOf fabric.StaticCanvas.prototype
       */
      vptCoords: { },

      /**
       * Based on vptCoords and object.aCoords, skip rendering of objects that
       * are not included in current viewport.
       * May greatly help in applications with crowded canvas and use of zoom/pan
       * If One of the corner of the bounding box of the object is on the canvas
       * the objects get rendered.
       * @memberOf fabric.StaticCanvas.prototype
       * @type Boolean
       * @default
       */
      skipOffscreen: true,

      /**
       * @private
       * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
       * @param {Object} [options] Options object
       */
      _initStatic: function(el, options) {
        var cb = this.requestRenderAllBound;
        this._objects = [];
        this._createLowerCanvas(el);
        this._initOptions(options);
        this._setImageSmoothing();
        // only initialize retina scaling once
        if (!this.interactive) {
          this._initRetinaScaling();
        }

        if (options.overlayImage) {
          this.setOverlayImage(options.overlayImage, cb);
        }
        if (options.backgroundImage) {
          this.setBackgroundImage(options.backgroundImage, cb);
        }
        if (options.backgroundColor) {
          this.setBackgroundColor(options.backgroundColor, cb);
        }
        if (options.overlayColor) {
          this.setOverlayColor(options.overlayColor, cb);
        }
        this.calcOffset();
      },

      /**
       * @private
       */
      _isRetinaScaling: function() {
        return (fabric.devicePixelRatio !== 1 && this.enableRetinaScaling);
      },

      /**
       * @private
       * @return {Number} retinaScaling if applied, otherwise 1;
       */
      getRetinaScaling: function() {
        return this._isRetinaScaling() ? fabric.devicePixelRatio : 1;
      },

      /**
       * @private
       */
      _initRetinaScaling: function() {
        if (!this._isRetinaScaling()) {
          return;
        }
        this.lowerCanvasEl.setAttribute('width', this.width * fabric.devicePixelRatio);
        this.lowerCanvasEl.setAttribute('height', this.height * fabric.devicePixelRatio);

        this.contextContainer.scale(fabric.devicePixelRatio, fabric.devicePixelRatio);
      },

      /**
       * Calculates canvas element offset relative to the document
       * This method is also attached as "resize" event handler of window
       * @return {fabric.Canvas} instance
       * @chainable
       */
      calcOffset: function () {
        this._offset = getElementOffset(this.lowerCanvasEl);
        return this;
      },

      /**
       * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas
       * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to
       * @param {Function} callback callback to invoke when image is loaded and set as an overlay
       * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.
       * @return {fabric.Canvas} thisArg
       * @chainable
       * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}
       * @example <caption>Normal overlayImage with left/top = 0</caption>
       * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
       *   // Needed to position overlayImage at 0/0
       *   originX: 'left',
       *   originY: 'top'
       * });
       * @example <caption>overlayImage with different properties</caption>
       * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
       *   opacity: 0.5,
       *   angle: 45,
       *   left: 400,
       *   top: 400,
       *   originX: 'left',
       *   originY: 'top'
       * });
       * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>
       * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img) {
       *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
       *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));
       * });
       * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>
       * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
       *   width: canvas.width,
       *   height: canvas.height,
       *   // Needed to position overlayImage at 0/0
       *   originX: 'left',
       *   originY: 'top'
       * });
       * @example <caption>overlayImage loaded from cross-origin</caption>
       * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
       *   opacity: 0.5,
       *   angle: 45,
       *   left: 400,
       *   top: 400,
       *   originX: 'left',
       *   originY: 'top',
       *   crossOrigin: 'anonymous'
       * });
       */
      setOverlayImage: function (image, callback, options) {
        return this.__setBgOverlayImage('overlayImage', image, callback, options);
      },

      /**
       * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas
       * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to
       * @param {Function} callback Callback to invoke when image is loaded and set as background
       * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.
       * @return {fabric.Canvas} thisArg
       * @chainable
       * @see {@link http://jsfiddle.net/djnr8o7a/28/|jsFiddle demo}
       * @example <caption>Normal backgroundImage with left/top = 0</caption>
       * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
       *   // Needed to position backgroundImage at 0/0
       *   originX: 'left',
       *   originY: 'top'
       * });
       * @example <caption>backgroundImage with different properties</caption>
       * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
       *   opacity: 0.5,
       *   angle: 45,
       *   left: 400,
       *   top: 400,
       *   originX: 'left',
       *   originY: 'top'
       * });
       * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>
       * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img) {
       *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
       *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
       * });
       * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>
       * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
       *   width: canvas.width,
       *   height: canvas.height,
       *   // Needed to position backgroundImage at 0/0
       *   originX: 'left',
       *   originY: 'top'
       * });
       * @example <caption>backgroundImage loaded from cross-origin</caption>
       * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
       *   opacity: 0.5,
       *   angle: 45,
       *   left: 400,
       *   top: 400,
       *   originX: 'left',
       *   originY: 'top',
       *   crossOrigin: 'anonymous'
       * });
       */
      setBackgroundImage: function (image, callback, options) {
        return this.__setBgOverlayImage('backgroundImage', image, callback, options);
      },

      /**
       * Sets {@link fabric.StaticCanvas#overlayColor|foreground color} for this canvas
       * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set foreground color to
       * @param {Function} callback Callback to invoke when foreground color is set
       * @return {fabric.Canvas} thisArg
       * @chainable
       * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}
       * @example <caption>Normal overlayColor - color value</caption>
       * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
       * @example <caption>fabric.Pattern used as overlayColor</caption>
       * canvas.setOverlayColor({
       *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
       * }, canvas.renderAll.bind(canvas));
       * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>
       * canvas.setOverlayColor({
       *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
       *   repeat: 'repeat',
       *   offsetX: 200,
       *   offsetY: 100
       * }, canvas.renderAll.bind(canvas));
       */
      setOverlayColor: function(overlayColor, callback) {
        return this.__setBgOverlayColor('overlayColor', overlayColor, callback);
      },

      /**
       * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas
       * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to
       * @param {Function} callback Callback to invoke when background color is set
       * @return {fabric.Canvas} thisArg
       * @chainable
       * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}
       * @example <caption>Normal backgroundColor - color value</caption>
       * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
       * @example <caption>fabric.Pattern used as backgroundColor</caption>
       * canvas.setBackgroundColor({
       *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
       * }, canvas.renderAll.bind(canvas));
       * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>
       * canvas.setBackgroundColor({
       *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
       *   repeat: 'repeat',
       *   offsetX: 200,
       *   offsetY: 100
       * }, canvas.renderAll.bind(canvas));
       */
      setBackgroundColor: function(backgroundColor, callback) {
        return this.__setBgOverlayColor('backgroundColor', backgroundColor, callback);
      },

      /**
       * @private
       * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-imagesmoothingenabled|WhatWG Canvas Standard}
       */
      _setImageSmoothing: function() {
        var ctx = this.getContext();

        ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled || ctx.webkitImageSmoothingEnabled
          || ctx.mozImageSmoothingEnabled || ctx.msImageSmoothingEnabled || ctx.oImageSmoothingEnabled;
        ctx.imageSmoothingEnabled = this.imageSmoothingEnabled;
      },

      /**
       * @private
       * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}
       * or {@link fabric.StaticCanvas#overlayImage|overlayImage})
       * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to
       * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay
       * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.
       */
      __setBgOverlayImage: function(property, image, callback, options) {
        if (typeof image === 'string') {
          fabric.util.loadImage(image, function(img) {
            img && (this[property] = new fabric.Image(img, options));
            callback && callback(img);
          }, this, options && options.crossOrigin);
        }
        else {
          options && image.setOptions(options);
          this[property] = image;
          callback && callback(image);
        }

        return this;
      },

      /**
       * @private
       * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}
       * or {@link fabric.StaticCanvas#overlayColor|overlayColor})
       * @param {(Object|String|null)} color Object with pattern information, color value or null
       * @param {Function} [callback] Callback is invoked when color is set
       */
      __setBgOverlayColor: function(property, color, callback) {
        this[property] = color;
        this._initGradient(color, property);
        this._initPattern(color, property, callback);
        return this;
      },

      /**
       * @private
       */
      _createCanvasElement: function() {
        var element = fabric.util.createCanvasElement();
        if (!element) {
          throw CANVAS_INIT_ERROR;
        }
        if (!element.style) {
          element.style = { };
        }
        if (typeof element.getContext === 'undefined') {
          throw CANVAS_INIT_ERROR;
        }
        return element;
      },

      /**
       * @private
       * @param {Object} [options] Options object
       */
      _initOptions: function (options) {
        this._setOptions(options);

        this.width = this.width || parseInt(this.lowerCanvasEl.width, 10) || 0;
        this.height = this.height || parseInt(this.lowerCanvasEl.height, 10) || 0;

        if (!this.lowerCanvasEl.style) {
          return;
        }

        this.lowerCanvasEl.width = this.width;
        this.lowerCanvasEl.height = this.height;

        this.lowerCanvasEl.style.width = this.width + 'px';
        this.lowerCanvasEl.style.height = this.height + 'px';

        this.viewportTransform = this.viewportTransform.slice();
      },

      /**
       * Creates a bottom canvas
       * @private
       * @param {HTMLElement} [canvasEl]
       */
      _createLowerCanvas: function (canvasEl) {
        // canvasEl === 'HTMLCanvasElement' does not work on jsdom/node
        if (canvasEl && canvasEl.getContext) {
          this.lowerCanvasEl = canvasEl;
        }
        else {
          this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement();
        }

        fabric.util.addClass(this.lowerCanvasEl, 'lower-canvas');

        if (this.interactive) {
          this._applyCanvasStyle(this.lowerCanvasEl);
        }

        this.contextContainer = this.lowerCanvasEl.getContext('2d');
      },

      /**
       * Returns canvas width (in px)
       * @return {Number}
       */
      getWidth: function () {
        return this.width;
      },

      /**
       * Returns canvas height (in px)
       * @return {Number}
       */
      getHeight: function () {
        return this.height;
      },

      /**
       * Sets width of this canvas instance
       * @param {Number|String} value                         Value to set width to
       * @param {Object}        [options]                     Options object
       * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
       * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      setWidth: function (value, options) {
        return this.setDimensions({ width: value }, options);
      },

      /**
       * Sets height of this canvas instance
       * @param {Number|String} value                         Value to set height to
       * @param {Object}        [options]                     Options object
       * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
       * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      setHeight: function (value, options) {
        return this.setDimensions({ height: value }, options);
      },

      /**
       * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)
       * @param {Object}        dimensions                    Object with width/height properties
       * @param {Number|String} [dimensions.width]            Width of canvas element
       * @param {Number|String} [dimensions.height]           Height of canvas element
       * @param {Object}        [options]                     Options object
       * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
       * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      setDimensions: function (dimensions, options) {
        var cssValue;

        options = options || {};

        for (var prop in dimensions) {
          cssValue = dimensions[prop];

          if (!options.cssOnly) {
            this._setBackstoreDimension(prop, dimensions[prop]);
            cssValue += 'px';
            this.hasLostContext = true;
          }

          if (!options.backstoreOnly) {
            this._setCssDimension(prop, cssValue);
          }
        }
        if (this._isCurrentlyDrawing) {
          this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles();
        }
        this._initRetinaScaling();
        this._setImageSmoothing();
        this.calcOffset();

        if (!options.cssOnly) {
          this.requestRenderAll();
        }

        return this;
      },

      /**
       * Helper for setting width/height
       * @private
       * @param {String} prop property (width|height)
       * @param {Number} value value to set property to
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      _setBackstoreDimension: function (prop, value) {
        this.lowerCanvasEl[prop] = value;

        if (this.upperCanvasEl) {
          this.upperCanvasEl[prop] = value;
        }

        if (this.cacheCanvasEl) {
          this.cacheCanvasEl[prop] = value;
        }

        this[prop] = value;

        return this;
      },

      /**
       * Helper for setting css width/height
       * @private
       * @param {String} prop property (width|height)
       * @param {String} value value to set property to
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      _setCssDimension: function (prop, value) {
        this.lowerCanvasEl.style[prop] = value;

        if (this.upperCanvasEl) {
          this.upperCanvasEl.style[prop] = value;
        }

        if (this.wrapperEl) {
          this.wrapperEl.style[prop] = value;
        }

        return this;
      },

      /**
       * Returns canvas zoom level
       * @return {Number}
       */
      getZoom: function () {
        return this.viewportTransform[0];
      },

      /**
       * Sets viewport transform of this canvas instance
       * @param {Array} vpt the transform in the form of context.transform
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      setViewportTransform: function (vpt) {
        var activeObject = this._activeObject, object, ignoreVpt = false, skipAbsolute = true, i, len;
        this.viewportTransform = vpt;
        for (i = 0, len = this._objects.length; i < len; i++) {
          object = this._objects[i];
          object.group || object.setCoords(ignoreVpt, skipAbsolute);
        }
        if (activeObject && activeObject.type === 'activeSelection') {
          activeObject.setCoords(ignoreVpt, skipAbsolute);
        }
        this.calcViewportBoundaries();
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },

      /**
       * Sets zoom level of this canvas instance, zoom centered around point
       * @param {fabric.Point} point to zoom with respect to
       * @param {Number} value to set zoom to, less than 1 zooms out
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      zoomToPoint: function (point, value) {
        // TODO: just change the scale, preserve other transformations
        var before = point, vpt = this.viewportTransform.slice(0);
        point = transformPoint(point, invertTransform(this.viewportTransform));
        vpt[0] = value;
        vpt[3] = value;
        var after = transformPoint(point, vpt);
        vpt[4] += before.x - after.x;
        vpt[5] += before.y - after.y;
        return this.setViewportTransform(vpt);
      },

      /**
       * Sets zoom level of this canvas instance
       * @param {Number} value to set zoom to, less than 1 zooms out
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      setZoom: function (value) {
        this.zoomToPoint(new fabric.Point(0, 0), value);
        return this;
      },

      /**
       * Pan viewport so as to place point at top left corner of canvas
       * @param {fabric.Point} point to move to
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      absolutePan: function (point) {
        var vpt = this.viewportTransform.slice(0);
        vpt[4] = -point.x;
        vpt[5] = -point.y;
        return this.setViewportTransform(vpt);
      },

      /**
       * Pans viewpoint relatively
       * @param {fabric.Point} point (position vector) to move by
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      relativePan: function (point) {
        return this.absolutePan(new fabric.Point(
          -point.x - this.viewportTransform[4],
          -point.y - this.viewportTransform[5]
        ));
      },

      /**
       * Returns &lt;canvas> element corresponding to this instance
       * @return {HTMLCanvasElement}
       */
      getElement: function () {
        return this.lowerCanvasEl;
      },

      /**
       * @private
       * @param {fabric.Object} obj Object that was added
       */
      _onObjectAdded: function(obj) {
        this.stateful && obj.setupState();
        obj._set('canvas', this);
        obj.setCoords();
        this.fire('object:added', { target: obj });
        obj.fire('added');
      },

      /**
       * @private
       * @param {fabric.Object} obj Object that was removed
       */
      _onObjectRemoved: function(obj) {
        this.fire('object:removed', { target: obj });
        obj.fire('removed');
        delete obj.canvas;
      },

      /**
       * Clears specified context of canvas element
       * @param {CanvasRenderingContext2D} ctx Context to clear
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      clearContext: function(ctx) {
        ctx.clearRect(0, 0, this.width, this.height);
        return this;
      },

      /**
       * Returns context of canvas where objects are drawn
       * @return {CanvasRenderingContext2D}
       */
      getContext: function () {
        return this.contextContainer;
      },

      /**
       * Clears all contexts (background, main, top) of an instance
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      clear: function () {
        this._objects.length = 0;
        this.backgroundImage = null;
        this.overlayImage = null;
        this.backgroundColor = '';
        this.overlayColor = '';
        if (this._hasITextHandlers) {
          this.off('mouse:up', this._mouseUpITextHandler);
          this._iTextInstances = null;
          this._hasITextHandlers = false;
        }
        this.clearContext(this.contextContainer);
        this.fire('canvas:cleared');
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },

      /**
       * Renders the canvas
       * @return {fabric.Canvas} instance
       * @chainable
       */
      renderAll: function () {
        var canvasToDrawOn = this.contextContainer;
        this.renderCanvas(canvasToDrawOn, this._objects);
        return this;
      },

      /**
       * Function created to be instance bound at initialization
       * used in requestAnimationFrame rendering
       * @return {fabric.Canvas} instance
       * @chainable
       */
      renderAndReset: function() {
        this.isRendering = 0;
        this.renderAll();
      },

      /**
       * Append a renderAll request to next animation frame.
       * a boolean flag will avoid appending more.
       * @return {fabric.Canvas} instance
       * @chainable
       */
      requestRenderAll: function () {
        if (!this.isRendering) {
          this.isRendering = fabric.util.requestAnimFrame(this.renderAndResetBound);
        }
        return this;
      },

      /**
       * Calculate the position of the 4 corner of canvas with current viewportTransform.
       * helps to determinate when an object is in the current rendering viewport using
       * object absolute coordinates ( aCoords )
       * @return {Object} points.tl
       * @chainable
       */
      calcViewportBoundaries: function() {
        var points = { }, width = this.width, height = this.height,
            iVpt = invertTransform(this.viewportTransform);
        points.tl = transformPoint({ x: 0, y: 0 }, iVpt);
        points.br = transformPoint({ x: width, y: height }, iVpt);
        points.tr = new fabric.Point(points.br.x, points.tl.y);
        points.bl = new fabric.Point(points.tl.x, points.br.y);
        this.vptCoords = points;
        return points;
      },

      /**
       * Renders background, objects, overlay and controls.
       * @param {CanvasRenderingContext2D} ctx
       * @param {Array} objects to render
       * @return {fabric.Canvas} instance
       * @chainable
       */
      renderCanvas: function(ctx, objects) {
        var v = this.viewportTransform;
        if (this.isRendering) {
          fabric.util.cancelAnimFrame(this.isRendering);
          this.isRendering = 0;
        }
        this.calcViewportBoundaries();
        this.clearContext(ctx);
        this.fire('before:render');
        if (this.clipTo) {
          fabric.util.clipContext(this, ctx);
        }
        this._renderBackground(ctx);

        ctx.save();
        //apply viewport transform once for all rendering process
        ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
        this._renderObjects(ctx, objects);
        ctx.restore();
        if (!this.controlsAboveOverlay && this.interactive) {
          this.drawControls(ctx);
        }
        if (this.clipTo) {
          ctx.restore();
        }
        this._renderOverlay(ctx);
        if (this.controlsAboveOverlay && this.interactive) {
          this.drawControls(ctx);
        }
        this.fire('after:render');
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {Array} objects to render
       */
      _renderObjects: function(ctx, objects) {
        var i, len;
        for (i = 0, len = objects.length; i < len; ++i) {
          objects[i] && objects[i].render(ctx);
        }
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {string} property 'background' or 'overlay'
       */
      _renderBackgroundOrOverlay: function(ctx, property) {
        var object = this[property + 'Color'], v;
        if (object) {
          ctx.fillStyle = object.toLive
            ? object.toLive(ctx, this)
            : object;

          ctx.fillRect(
            object.offsetX || 0,
            object.offsetY || 0,
            this.width,
            this.height);
        }
        object = this[property + 'Image'];
        if (object) {
          if (this[property + 'Vpt']) {
            v = this.viewportTransform;
            ctx.save();
            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
          }
          object.render(ctx);
          this[property + 'Vpt'] && ctx.restore();
        }
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderBackground: function(ctx) {
        this._renderBackgroundOrOverlay(ctx, 'background');
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderOverlay: function(ctx) {
        this._renderBackgroundOrOverlay(ctx, 'overlay');
      },

      /**
       * Returns coordinates of a center of canvas.
       * Returned value is an object with top and left properties
       * @return {Object} object with "top" and "left" number values
       */
      getCenter: function () {
        return {
          top: this.height / 2,
          left: this.width / 2
        };
      },

      /**
       * Centers object horizontally in the canvas
       * @param {fabric.Object} object Object to center horizontally
       * @return {fabric.Canvas} thisArg
       */
      centerObjectH: function (object) {
        return this._centerObject(object, new fabric.Point(this.getCenter().left, object.getCenterPoint().y));
      },

      /**
       * Centers object vertically in the canvas
       * @param {fabric.Object} object Object to center vertically
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      centerObjectV: function (object) {
        return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenter().top));
      },

      /**
       * Centers object vertically and horizontally in the canvas
       * @param {fabric.Object} object Object to center vertically and horizontally
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      centerObject: function(object) {
        var center = this.getCenter();

        return this._centerObject(object, new fabric.Point(center.left, center.top));
      },

      /**
       * Centers object vertically and horizontally in the viewport
       * @param {fabric.Object} object Object to center vertically and horizontally
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      viewportCenterObject: function(object) {
        var vpCenter = this.getVpCenter();

        return this._centerObject(object, vpCenter);
      },

      /**
       * Centers object horizontally in the viewport, object.top is unchanged
       * @param {fabric.Object} object Object to center vertically and horizontally
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      viewportCenterObjectH: function(object) {
        var vpCenter = this.getVpCenter();
        this._centerObject(object, new fabric.Point(vpCenter.x, object.getCenterPoint().y));
        return this;
      },

      /**
       * Centers object Vertically in the viewport, object.top is unchanged
       * @param {fabric.Object} object Object to center vertically and horizontally
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      viewportCenterObjectV: function(object) {
        var vpCenter = this.getVpCenter();

        return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, vpCenter.y));
      },

      /**
       * Calculate the point in canvas that correspond to the center of actual viewport.
       * @return {fabric.Point} vpCenter, viewport center
       * @chainable
       */
      getVpCenter: function() {
        var center = this.getCenter(),
            iVpt = invertTransform(this.viewportTransform);
        return transformPoint({ x: center.left, y: center.top }, iVpt);
      },

      /**
       * @private
       * @param {fabric.Object} object Object to center
       * @param {fabric.Point} center Center point
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      _centerObject: function(object, center) {
        object.setPositionByOrigin(center, 'center', 'center');
        object.setCoords();
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },

      /**
       * Returs dataless JSON representation of canvas
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {String} json string
       */
      toDatalessJSON: function (propertiesToInclude) {
        return this.toDatalessObject(propertiesToInclude);
      },

      /**
       * Returns object representation of canvas
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function (propertiesToInclude) {
        return this._toObjectMethod('toObject', propertiesToInclude);
      },

      /**
       * Returns dataless object representation of canvas
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toDatalessObject: function (propertiesToInclude) {
        return this._toObjectMethod('toDatalessObject', propertiesToInclude);
      },

      /**
       * @private
       */
      _toObjectMethod: function (methodName, propertiesToInclude) {

        var data = {
          version: fabric.version,
          objects: this._toObjects(methodName, propertiesToInclude)
        };

        extend(data, this.__serializeBgOverlay(methodName, propertiesToInclude));

        fabric.util.populateWithProperties(this, data, propertiesToInclude);

        return data;
      },

      /**
       * @private
       */
      _toObjects: function(methodName, propertiesToInclude) {
        return this.getObjects().filter(function(object) {
          return !object.excludeFromExport;
        }).map(function(instance) {
          return this._toObject(instance, methodName, propertiesToInclude);
        }, this);
      },

      /**
       * @private
       */
      _toObject: function(instance, methodName, propertiesToInclude) {
        var originalValue;

        if (!this.includeDefaultValues) {
          originalValue = instance.includeDefaultValues;
          instance.includeDefaultValues = false;
        }

        var object = instance[methodName](propertiesToInclude);
        if (!this.includeDefaultValues) {
          instance.includeDefaultValues = originalValue;
        }
        return object;
      },

      /**
       * @private
       */
      __serializeBgOverlay: function(methodName, propertiesToInclude) {
        var data = { }, bgImage = this.backgroundImage, overlay = this.overlayImage;

        if (this.backgroundColor) {
          data.background = this.backgroundColor.toObject
            ? this.backgroundColor.toObject(propertiesToInclude)
            : this.backgroundColor;
        }

        if (this.overlayColor) {
          data.overlay = this.overlayColor.toObject
            ? this.overlayColor.toObject(propertiesToInclude)
            : this.overlayColor;
        }
        if (bgImage && !bgImage.excludeFromExport) {
          data.backgroundImage = this._toObject(bgImage, methodName, propertiesToInclude);
        }
        if (overlay && !overlay.excludeFromExport) {
          data.overlayImage = this._toObject(overlay, methodName, propertiesToInclude);
        }

        return data;
      },

      /* _TO_SVG_START_ */
      /**
       * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,
       * a zoomed canvas will then produce zoomed SVG output.
       * @type Boolean
       * @default
       */
      svgViewportTransformation: true,

      /**
       * Returns SVG representation of canvas
       * @function
       * @param {Object} [options] Options object for SVG output
       * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included
       * @param {Object} [options.viewBox] SVG viewbox object
       * @param {Number} [options.viewBox.x] x-cooridnate of viewbox
       * @param {Number} [options.viewBox.y] y-coordinate of viewbox
       * @param {Number} [options.viewBox.width] Width of viewbox
       * @param {Number} [options.viewBox.height] Height of viewbox
       * @param {String} [options.encoding=UTF-8] Encoding of SVG output
       * @param {String} [options.width] desired width of svg with or without units
       * @param {String} [options.height] desired height of svg with or without units
       * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.
       * @return {String} SVG string
       * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
       * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}
       * @example <caption>Normal SVG output</caption>
       * var svg = canvas.toSVG();
       * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>
       * var svg = canvas.toSVG({suppressPreamble: true});
       * @example <caption>SVG output with viewBox attribute</caption>
       * var svg = canvas.toSVG({
       *   viewBox: {
       *     x: 100,
       *     y: 100,
       *     width: 200,
       *     height: 300
       *   }
       * });
       * @example <caption>SVG output with different encoding (default: UTF-8)</caption>
       * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});
       * @example <caption>Modify SVG output with reviver function</caption>
       * var svg = canvas.toSVG(null, function(svg) {
       *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');
       * });
       */
      toSVG: function(options, reviver) {
        options || (options = { });

        var markup = [];

        this._setSVGPreamble(markup, options);
        this._setSVGHeader(markup, options);

        this._setSVGBgOverlayColor(markup, 'backgroundColor');
        this._setSVGBgOverlayImage(markup, 'backgroundImage', reviver);

        this._setSVGObjects(markup, reviver);

        this._setSVGBgOverlayColor(markup, 'overlayColor');
        this._setSVGBgOverlayImage(markup, 'overlayImage', reviver);

        markup.push('</svg>');

        return markup.join('');
      },

      /**
       * @private
       */
      _setSVGPreamble: function(markup, options) {
        if (options.suppressPreamble) {
          return;
        }
        markup.push(
          '<?xml version="1.0" encoding="', (options.encoding || 'UTF-8'), '" standalone="no" ?>\n',
          '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ',
          '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n'
        );
      },

      /**
       * @private
       */
      _setSVGHeader: function(markup, options) {
        var width = options.width || this.width,
            height = options.height || this.height,
            vpt, viewBox = 'viewBox="0 0 ' + this.width + ' ' + this.height + '" ',
            NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;

        if (options.viewBox) {
          viewBox = 'viewBox="' +
                  options.viewBox.x + ' ' +
                  options.viewBox.y + ' ' +
                  options.viewBox.width + ' ' +
                  options.viewBox.height + '" ';
        }
        else {
          if (this.svgViewportTransformation) {
            vpt = this.viewportTransform;
            viewBox = 'viewBox="' +
                    toFixed(-vpt[4] / vpt[0], NUM_FRACTION_DIGITS) + ' ' +
                    toFixed(-vpt[5] / vpt[3], NUM_FRACTION_DIGITS) + ' ' +
                    toFixed(this.width / vpt[0], NUM_FRACTION_DIGITS) + ' ' +
                    toFixed(this.height / vpt[3], NUM_FRACTION_DIGITS) + '" ';
          }
        }

        markup.push(
          '<svg ',
          'xmlns="http://www.w3.org/2000/svg" ',
          'xmlns:xlink="http://www.w3.org/1999/xlink" ',
          'version="1.1" ',
          'width="', width, '" ',
          'height="', height, '" ',
          viewBox,
          'xml:space="preserve">\n',
          '<desc>Created with Fabric.js ', fabric.version, '</desc>\n',
          '<defs>\n',
          this.createSVGFontFacesMarkup(),
          this.createSVGRefElementsMarkup(),
          '</defs>\n'
        );
      },

      /**
       * Creates markup containing SVG referenced elements like patterns, gradients etc.
       * @return {String}
       */
      createSVGRefElementsMarkup: function() {
        var _this = this,
            markup = ['backgroundColor', 'overlayColor'].map(function(prop) {
              var fill = _this[prop];
              if (fill && fill.toLive) {
                return fill.toSVG(_this, false);
              }
            });
        return markup.join('');
      },

      /**
       * Creates markup containing SVG font faces,
       * font URLs for font faces must be collected by developers
       * and are not extracted from the DOM by fabricjs
       * @param {Array} objects Array of fabric objects
       * @return {String}
       */
      createSVGFontFacesMarkup: function() {
        var markup = '', fontList = { }, obj, fontFamily,
            style, row, rowIndex, _char, charIndex, i, len,
            fontPaths = fabric.fontPaths, objects = this.getObjects();

        for (i = 0, len = objects.length; i < len; i++) {
          obj = objects[i];
          fontFamily = obj.fontFamily;
          if (obj.type.indexOf('text') === -1 || fontList[fontFamily] || !fontPaths[fontFamily]) {
            continue;
          }
          fontList[fontFamily] = true;
          if (!obj.styles) {
            continue;
          }
          style = obj.styles;
          for (rowIndex in style) {
            row = style[rowIndex];
            for (charIndex in row) {
              _char = row[charIndex];
              fontFamily = _char.fontFamily;
              if (!fontList[fontFamily] && fontPaths[fontFamily]) {
                fontList[fontFamily] = true;
              }
            }
          }
        }

        for (var j in fontList) {
          markup += [
            '\t\t@font-face {\n',
            '\t\t\tfont-family: \'', j, '\';\n',
            '\t\t\tsrc: url(\'', fontPaths[j], '\');\n',
            '\t\t}\n'
          ].join('');
        }

        if (markup) {
          markup = [
            '\t<style type="text/css">',
            '<![CDATA[\n',
            markup,
            ']]>',
            '</style>\n'
          ].join('');
        }

        return markup;
      },

      /**
       * @private
       */
      _setSVGObjects: function(markup, reviver) {
        var instance, i, len, objects = this.getObjects();
        for (i = 0, len = objects.length; i < len; i++) {
          instance = objects[i];
          if (instance.excludeFromExport) {
            continue;
          }
          this._setSVGObject(markup, instance, reviver);
        }
      },

      /**
       * @private
       */
      _setSVGObject: function(markup, instance, reviver) {
        markup.push(instance.toSVG(reviver));
      },

      /**
       * @private
       */
      _setSVGBgOverlayImage: function(markup, property, reviver) {
        if (this[property] && this[property].toSVG) {
          markup.push(this[property].toSVG(reviver));
        }
      },

      /**
       * @private
       */
      _setSVGBgOverlayColor: function(markup, property) {
        var filler = this[property], vpt = this.viewportTransform, finalWidth = this.width / vpt[0],
            finalHeight = this.height / vpt[3];
        if (!filler) {
          return;
        }
        if (filler.toLive) {
          var repeat = filler.repeat;
          markup.push(
            '<rect transform="translate(', finalWidth / 2, ',', finalHeight / 2, ')"',
            ' x="', filler.offsetX - finalWidth / 2, '" y="', filler.offsetY - finalHeight / 2, '" ',
            'width="',
            (repeat === 'repeat-y' || repeat === 'no-repeat'
              ? filler.source.width
              : finalWidth ),
            '" height="',
            (repeat === 'repeat-x' || repeat === 'no-repeat'
              ? filler.source.height
              : finalHeight),
            '" fill="url(#SVGID_' + filler.id + ')"',
            '></rect>\n'
          );
        }
        else {
          markup.push(
            '<rect x="0" y="0" width="100%" height="100%" ',
            'fill="', this[property], '"',
            '></rect>\n'
          );
        }
      },
      /* _TO_SVG_END_ */

      /**
       * Moves an object or the objects of a multiple selection
       * to the bottom of the stack of drawn objects
       * @param {fabric.Object} object Object to send to back
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      sendToBack: function (object) {
        if (!object) {
          return this;
        }
        var activeSelection = this._activeObject,
            i, obj, objs;
        if (object === activeSelection && object.type === 'activeSelection') {
          objs = activeSelection._objects;
          for (i = objs.length; i--;) {
            obj = objs[i];
            removeFromArray(this._objects, obj);
            this._objects.unshift(obj);
          }
        }
        else {
          removeFromArray(this._objects, object);
          this._objects.unshift(object);
        }
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },

      /**
       * Moves an object or the objects of a multiple selection
       * to the top of the stack of drawn objects
       * @param {fabric.Object} object Object to send
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      bringToFront: function (object) {
        if (!object) {
          return this;
        }
        var activeSelection = this._activeObject,
            i, obj, objs;
        if (object === activeSelection && object.type === 'activeSelection') {
          objs = activeSelection._objects;
          for (i = 0; i < objs.length; i++) {
            obj = objs[i];
            removeFromArray(this._objects, obj);
            this._objects.push(obj);
          }
        }
        else {
          removeFromArray(this._objects, object);
          this._objects.push(object);
        }
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },

      /**
       * Moves an object or a selection down in stack of drawn objects
       * An optional paramter, intersecting allowes to move the object in behind
       * the first intersecting object. Where intersection is calculated with
       * bounding box. If no intersection is found, there will not be change in the
       * stack.
       * @param {fabric.Object} object Object to send
       * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      sendBackwards: function (object, intersecting) {
        if (!object) {
          return this;
        }
        var activeSelection = this._activeObject,
            i, obj, idx, newIdx, objs, objsMoved = 0;

        if (object === activeSelection && object.type === 'activeSelection') {
          objs = activeSelection._objects;
          for (i = 0; i < objs.length; i++) {
            obj = objs[i];
            idx = this._objects.indexOf(obj);
            if (idx > 0 + objsMoved) {
              newIdx = idx - 1;
              removeFromArray(this._objects, obj);
              this._objects.splice(newIdx, 0, obj);
            }
            objsMoved++;
          }
        }
        else {
          idx = this._objects.indexOf(object);
          if (idx !== 0) {
            // if object is not on the bottom of stack
            newIdx = this._findNewLowerIndex(object, idx, intersecting);
            removeFromArray(this._objects, object);
            this._objects.splice(newIdx, 0, object);
          }
        }
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },

      /**
       * @private
       */
      _findNewLowerIndex: function(object, idx, intersecting) {
        var newIdx, i;

        if (intersecting) {
          newIdx = idx;

          // traverse down the stack looking for the nearest intersecting object
          for (i = idx - 1; i >= 0; --i) {

            var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
                                 object.isContainedWithinObject(this._objects[i]) ||
                                 this._objects[i].isContainedWithinObject(object);

            if (isIntersecting) {
              newIdx = i;
              break;
            }
          }
        }
        else {
          newIdx = idx - 1;
        }

        return newIdx;
      },

      /**
       * Moves an object or a selection up in stack of drawn objects
       * An optional paramter, intersecting allowes to move the object in front
       * of the first intersecting object. Where intersection is calculated with
       * bounding box. If no intersection is found, there will not be change in the
       * stack.
       * @param {fabric.Object} object Object to send
       * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      bringForward: function (object, intersecting) {
        if (!object) {
          return this;
        }
        var activeSelection = this._activeObject,
            i, obj, idx, newIdx, objs, objsMoved = 0;

        if (object === activeSelection && object.type === 'activeSelection') {
          objs = activeSelection._objects;
          for (i = objs.length; i--;) {
            obj = objs[i];
            idx = this._objects.indexOf(obj);
            if (idx < this._objects.length - 1 - objsMoved) {
              newIdx = idx + 1;
              removeFromArray(this._objects, obj);
              this._objects.splice(newIdx, 0, obj);
            }
            objsMoved++;
          }
        }
        else {
          idx = this._objects.indexOf(object);
          if (idx !== this._objects.length - 1) {
            // if object is not on top of stack (last item in an array)
            newIdx = this._findNewUpperIndex(object, idx, intersecting);
            removeFromArray(this._objects, object);
            this._objects.splice(newIdx, 0, object);
          }
        }
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },

      /**
       * @private
       */
      _findNewUpperIndex: function(object, idx, intersecting) {
        var newIdx, i, len;

        if (intersecting) {
          newIdx = idx;

          // traverse up the stack looking for the nearest intersecting object
          for (i = idx + 1, len = this._objects.length; i < len; ++i) {

            var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
                                 object.isContainedWithinObject(this._objects[i]) ||
                                 this._objects[i].isContainedWithinObject(object);

            if (isIntersecting) {
              newIdx = i;
              break;
            }
          }
        }
        else {
          newIdx = idx + 1;
        }

        return newIdx;
      },

      /**
       * Moves an object to specified level in stack of drawn objects
       * @param {fabric.Object} object Object to send
       * @param {Number} index Position to move to
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      moveTo: function (object, index) {
        removeFromArray(this._objects, object);
        this._objects.splice(index, 0, object);
        return this.renderOnAddRemove && this.requestRenderAll();
      },

      /**
       * Clears a canvas element and dispose objects
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      dispose: function () {
        // cancel eventually ongoing renders
        if (this.isRendering) {
          fabric.util.cancelAnimFrame(this.isRendering);
          this.isRendering = 0;
        }
        this.forEachObject(function(object) {
          object.dispose && object.dispose();
        });
        this._objects = [];
        this.backgroundImage = null;
        this.overlayImage = null;
        this._iTextInstances = null;
        this.lowerCanvasEl = null;
        this.contextContainer = null;
        return this;
      },

      /**
       * Returns a string representation of an instance
       * @return {String} string representation of an instance
       */
      toString: function () {
        return '#<fabric.Canvas (' + this.complexity() + '): ' +
                 '{ objects: ' + this.getObjects().length + ' }>';
      }
    });

    extend(fabric.StaticCanvas.prototype, fabric.Observable);
    extend(fabric.StaticCanvas.prototype, fabric.Collection);
    extend(fabric.StaticCanvas.prototype, fabric.DataURLExporter);

    extend(fabric.StaticCanvas, /** @lends fabric.StaticCanvas */ {

      /**
       * @static
       * @type String
       * @default
       */
      EMPTY_JSON: '{"objects": [], "background": "white"}',

      /**
       * Provides a way to check support of some of the canvas methods
       * (either those of HTMLCanvasElement itself, or rendering context)
       *
       * @param {String} methodName Method to check support for;
       *                            Could be one of "getImageData", "toDataURL", "toDataURLWithQuality" or "setLineDash"
       * @return {Boolean | null} `true` if method is supported (or at least exists),
       *                          `null` if canvas element or context can not be initialized
       */
      supports: function (methodName) {
        var el = fabric.util.createCanvasElement();

        if (!el || !el.getContext) {
          return null;
        }

        var ctx = el.getContext('2d');
        if (!ctx) {
          return null;
        }

        switch (methodName) {

          case 'getImageData':
            return typeof ctx.getImageData !== 'undefined';

          case 'setLineDash':
            return typeof ctx.setLineDash !== 'undefined';

          case 'toDataURL':
            return typeof el.toDataURL !== 'undefined';

          case 'toDataURLWithQuality':
            try {
              el.toDataURL('image/jpeg', 0);
              return true;
            }
            catch (e) { }
            return false;

          default:
            return null;
        }
      }
    });

    /**
     * Returns JSON representation of canvas
     * @function
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {String} JSON string
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
     * @see {@link http://jsfiddle.net/fabricjs/pec86/|jsFiddle demo}
     * @example <caption>JSON without additional properties</caption>
     * var json = canvas.toJSON();
     * @example <caption>JSON with additional properties included</caption>
     * var json = canvas.toJSON(['lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY', 'lockUniScaling']);
     * @example <caption>JSON without default values</caption>
     * canvas.includeDefaultValues = false;
     * var json = canvas.toJSON();
     */
    fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;

    if (fabric.isLikelyNode) {
      fabric.StaticCanvas.prototype.createPNGStream = function() {
        var impl = fabric.util.getNodeCanvas(this.lowerCanvasEl);
        return impl && impl.createPNGStream();
      };
      fabric.StaticCanvas.prototype.createJPEGStream = function(opts) {
        var impl = fabric.util.getNodeCanvas(this.lowerCanvasEl);
        return impl && impl.createJPEGStream(opts);
      };
    }
  })();


  /**
   * BaseBrush class
   * @class fabric.BaseBrush
   * @see {@link http://fabricjs.com/freedrawing|Freedrawing demo}
   */
  fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype */ {

    /**
     * Color of a brush
     * @type String
     * @default
     */
    color: 'rgb(0, 0, 0)',

    /**
     * Width of a brush, has to be a Number, no string literals
     * @type Number
     * @default
     */
    width: 1,

    /**
     * Shadow object representing shadow of this shape.
     * <b>Backwards incompatibility note:</b> This property replaces "shadowColor" (String), "shadowOffsetX" (Number),
     * "shadowOffsetY" (Number) and "shadowBlur" (Number) since v1.2.12
     * @type fabric.Shadow
     * @default
     */
    shadow: null,

    /**
     * Line endings style of a brush (one of "butt", "round", "square")
     * @type String
     * @default
     */
    strokeLineCap: 'round',

    /**
     * Corner style of a brush (one of "bevel", "round", "miter")
     * @type String
     * @default
     */
    strokeLineJoin: 'round',

    /**
     * Maximum miter length (used for strokeLineJoin = "miter") of a brush's
     * @type Number
     * @default
     */
    strokeMiterLimit:         10,

    /**
     * Stroke Dash Array.
     * @type Array
     * @default
     */
    strokeDashArray: null,

    /**
     * Sets shadow of an object
     * @param {Object|String} [options] Options object or string (e.g. "2px 2px 10px rgba(0,0,0,0.2)")
     * @return {fabric.Object} thisArg
     * @chainable
     */
    setShadow: function(options) {
      this.shadow = new fabric.Shadow(options);
      return this;
    },

    /**
     * Sets brush styles
     * @private
     */
    _setBrushStyles: function() {
      var ctx = this.canvas.contextTop;
      ctx.strokeStyle = this.color;
      ctx.lineWidth = this.width;
      ctx.lineCap = this.strokeLineCap;
      ctx.miterLimit = this.strokeMiterLimit;
      ctx.lineJoin = this.strokeLineJoin;
      if (fabric.StaticCanvas.supports('setLineDash')) {
        ctx.setLineDash(this.strokeDashArray || []);
      }
    },

    /**
     * Sets the transformation on given context
     * @param {RenderingContext2d} ctx context to render on
     * @private
     */
    _saveAndTransform: function(ctx) {
      var v = this.canvas.viewportTransform;
      ctx.save();
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
    },

    /**
     * Sets brush shadow styles
     * @private
     */
    _setShadow: function() {
      if (!this.shadow) {
        return;
      }

      var ctx = this.canvas.contextTop,
          zoom = this.canvas.getZoom();

      ctx.shadowColor = this.shadow.color;
      ctx.shadowBlur = this.shadow.blur * zoom;
      ctx.shadowOffsetX = this.shadow.offsetX * zoom;
      ctx.shadowOffsetY = this.shadow.offsetY * zoom;
    },

    /**
     * Removes brush shadow styles
     * @private
     */
    _resetShadow: function() {
      var ctx = this.canvas.contextTop;

      ctx.shadowColor = '';
      ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
    }
  });


  (function() {

    /**
     * PencilBrush class
     * @class fabric.PencilBrush
     * @extends fabric.BaseBrush
     */
    fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.PencilBrush.prototype */ {

      /**
       * Constructor
       * @param {fabric.Canvas} canvas
       * @return {fabric.PencilBrush} Instance of a pencil brush
       */
      initialize: function(canvas) {
        this.canvas = canvas;
        this._points = [];
      },

      /**
       * Invoked inside on mouse down and mouse move
       * @param {Object} pointer
       */
      _drawSegment: function (ctx, p1, p2) {
        var midPoint = p1.midPointFrom(p2);
        ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);
        return midPoint;
      },

      /**
       * Inovoked on mouse down
       * @param {Object} pointer
       */
      onMouseDown: function(pointer) {
        this._prepareForDrawing(pointer);
        // capture coordinates immediately
        // this allows to draw dots (when movement never occurs)
        this._captureDrawingPath(pointer);
        this._render();
      },

      /**
       * Inovoked on mouse move
       * @param {Object} pointer
       */
      onMouseMove: function(pointer) {
        if (this._captureDrawingPath(pointer) && this._points.length > 1) {
          if (this.needsFullRender) {
            // redraw curve
            // clear top canvas
            this.canvas.clearContext(this.canvas.contextTop);
            this._render();
          }
          else {
            var points = this._points, length = points.length, ctx = this.canvas.contextTop;
            // draw the curve update
            this._saveAndTransform(ctx);
            if (this.oldEnd) {
              ctx.beginPath();
              ctx.moveTo(this.oldEnd.x, this.oldEnd.y);
            }
            this.oldEnd = this._drawSegment(ctx, points[length - 2], points[length - 1], true);
            ctx.stroke();
            ctx.restore();
          }
        }
      },

      /**
       * Invoked on mouse up
       */
      onMouseUp: function() {
        this.oldEnd = undefined;
        this._finalizeAndAddPath();
      },

      /**
       * @private
       * @param {Object} pointer Actual mouse position related to the canvas.
       */
      _prepareForDrawing: function(pointer) {

        var p = new fabric.Point(pointer.x, pointer.y);

        this._reset();
        this._addPoint(p);
        this.canvas.contextTop.moveTo(p.x, p.y);
      },

      /**
       * @private
       * @param {fabric.Point} point Point to be added to points array
       */
      _addPoint: function(point) {
        if (this._points.length > 1 && point.eq(this._points[this._points.length - 1])) {
          return false;
        }
        this._points.push(point);
        return true;
      },

      /**
       * Clear points array and set contextTop canvas style.
       * @private
       */
      _reset: function() {
        this._points.length = 0;
        this._setBrushStyles();
        var color = new fabric.Color(this.color);
        this.needsFullRender = (color.getAlpha() < 1);
        this._setShadow();
      },

      /**
       * @private
       * @param {Object} pointer Actual mouse position related to the canvas.
       */
      _captureDrawingPath: function(pointer) {
        var pointerPoint = new fabric.Point(pointer.x, pointer.y);
        return this._addPoint(pointerPoint);
      },

      /**
       * Draw a smooth path on the topCanvas using quadraticCurveTo
       * @private
       */
      _render: function() {
        var ctx  = this.canvas.contextTop, i, len,
            p1 = this._points[0],
            p2 = this._points[1];

        this._saveAndTransform(ctx);
        ctx.beginPath();
        //if we only have 2 points in the path and they are the same
        //it means that the user only clicked the canvas without moving the mouse
        //then we should be drawing a dot. A path isn't drawn between two identical dots
        //that's why we set them apart a bit
        if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {
          var width = this.width / 1000;
          p1 = new fabric.Point(p1.x, p1.y);
          p2 = new fabric.Point(p2.x, p2.y);
          p1.x -= width;
          p2.x += width;
        }
        ctx.moveTo(p1.x, p1.y);

        for (i = 1, len = this._points.length; i < len; i++) {
          // we pick the point between pi + 1 & pi + 2 as the
          // end point and p1 as our control point.
          this._drawSegment(ctx, p1, p2);
          p1 = this._points[i];
          p2 = this._points[i + 1];
        }
        // Draw last line as a straight line while
        // we wait for the next point to be able to calculate
        // the bezier control point
        ctx.lineTo(p1.x, p1.y);
        ctx.stroke();
        ctx.restore();
      },

      /**
       * Converts points to SVG path
       * @param {Array} points Array of points
       * @return {String} SVG path
       */
      convertPointsToSVGPath: function(points) {
        var path = [], i, width = this.width / 1000,
            p1 = new fabric.Point(points[0].x, points[0].y),
            p2 = new fabric.Point(points[1].x, points[1].y),
            len = points.length, multSignX = 1, multSignY = 1, manyPoints = len > 2;

        if (manyPoints) {
          multSignX = points[2].x < p2.x ? -1 : points[2].x === p2.x ? 0 : 1;
          multSignY = points[2].y < p2.y ? -1 : points[2].y === p2.y ? 0 : 1;
        }
        path.push('M ', p1.x - multSignX * width, ' ', p1.y - multSignY * width, ' ');
        for (i = 1; i < len; i++) {
          if (!p1.eq(p2)) {
            var midPoint = p1.midPointFrom(p2);
            // p1 is our bezier control point
            // midpoint is our endpoint
            // start point is p(i-1) value.
            path.push('Q ', p1.x, ' ', p1.y, ' ', midPoint.x, ' ', midPoint.y, ' ');
          }
          p1 = points[i];
          if ((i + 1) < points.length) {
            p2 = points[i + 1];
          }
        }
        if (manyPoints) {
          multSignX = p1.x > points[i - 2].x ? 1 : p1.x === points[i - 2].x ? 0 : -1;
          multSignY = p1.y > points[i - 2].y ? 1 : p1.y === points[i - 2].y ? 0 : -1;
        }
        path.push('L ', p1.x + multSignX * width, ' ', p1.y + multSignY * width);
        return path;
      },

      /**
       * Creates fabric.Path object to add on canvas
       * @param {String} pathData Path data
       * @return {fabric.Path} Path to add on canvas
       */
      createPath: function(pathData) {
        var path = new fabric.Path(pathData, {
          fill: null,
          stroke: this.color,
          strokeWidth: this.width,
          strokeLineCap: this.strokeLineCap,
          strokeMiterLimit: this.strokeMiterLimit,
          strokeLineJoin: this.strokeLineJoin,
          strokeDashArray: this.strokeDashArray,
        });
        var position = new fabric.Point(path.left + path.width / 2, path.top + path.height / 2);
        position = path.translateToGivenOrigin(position, 'center', 'center', path.originX, path.originY);
        path.top = position.y;
        path.left = position.x;
        if (this.shadow) {
          this.shadow.affectStroke = true;
          path.setShadow(this.shadow);
        }

        return path;
      },

      /**
       * On mouseup after drawing the path on contextTop canvas
       * we use the points captured to create an new fabric path object
       * and add it to the fabric canvas.
       */
      _finalizeAndAddPath: function() {
        var ctx = this.canvas.contextTop;
        ctx.closePath();

        var pathData = this.convertPointsToSVGPath(this._points).join('');
        if (pathData === 'M 0 0 Q 0 0 0 0 L 0 0') {
          // do not create 0 width/height paths, as they are
          // rendered inconsistently across browsers
          // Firefox 4, for example, renders a dot,
          // whereas Chrome 10 renders nothing
          this.canvas.requestRenderAll();
          return;
        }

        var path = this.createPath(pathData);
        this.canvas.clearContext(this.canvas.contextTop);
        this.canvas.add(path);
        this.canvas.renderAll();
        path.setCoords();
        this._resetShadow();


        // fire event 'path' created
        this.canvas.fire('path:created', { path: path });
      }
    });
  })();


  /**
   * CircleBrush class
   * @class fabric.CircleBrush
   */
  fabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.CircleBrush.prototype */ {

    /**
     * Width of a brush
     * @type Number
     * @default
     */
    width: 10,

    /**
     * Constructor
     * @param {fabric.Canvas} canvas
     * @return {fabric.CircleBrush} Instance of a circle brush
     */
    initialize: function(canvas) {
      this.canvas = canvas;
      this.points = [];
    },

    /**
     * Invoked inside on mouse down and mouse move
     * @param {Object} pointer
     */
    drawDot: function(pointer) {
      var point = this.addPoint(pointer),
          ctx = this.canvas.contextTop;
      this._saveAndTransform(ctx);
      ctx.fillStyle = point.fill;
      ctx.beginPath();
      ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    },

    /**
     * Invoked on mouse down
     */
    onMouseDown: function(pointer) {
      this.points.length = 0;
      this.canvas.clearContext(this.canvas.contextTop);
      this._setShadow();
      this.drawDot(pointer);
    },

    /**
     * Render the full state of the brush
     * @private
     */
    _render: function() {
      var ctx  = this.canvas.contextTop, i, len,
          points = this.points, point;
      this._saveAndTransform(ctx);
      for (i = 0, len = points.length; i < len; i++) {
        point = points[i];
        ctx.fillStyle = point.fill;
        ctx.beginPath();
        ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();
    },

    /**
     * Invoked on mouse move
     * @param {Object} pointer
     */
    onMouseMove: function(pointer) {
      this.drawDot(pointer);
    },

    /**
     * Invoked on mouse up
     */
    onMouseUp: function() {
      var originalRenderOnAddRemove = this.canvas.renderOnAddRemove, i, len;
      this.canvas.renderOnAddRemove = false;

      var circles = [];

      for (i = 0, len = this.points.length; i < len; i++) {
        var point = this.points[i],
            circle = new fabric.Circle({
              radius: point.radius,
              left: point.x,
              top: point.y,
              originX: 'center',
              originY: 'center',
              fill: point.fill
            });

        this.shadow && circle.setShadow(this.shadow);

        circles.push(circle);
      }
      var group = new fabric.Group(circles, { originX: 'center', originY: 'center' });
      group.canvas = this.canvas;

      this.canvas.add(group);
      this.canvas.fire('path:created', { path: group });

      this.canvas.clearContext(this.canvas.contextTop);
      this._resetShadow();
      this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
      this.canvas.requestRenderAll();
    },

    /**
     * @param {Object} pointer
     * @return {fabric.Point} Just added pointer point
     */
    addPoint: function(pointer) {
      var pointerPoint = new fabric.Point(pointer.x, pointer.y),

          circleRadius = fabric.util.getRandomInt(
            Math.max(0, this.width - 20), this.width + 20) / 2,

          circleColor = new fabric.Color(this.color)
            .setAlpha(fabric.util.getRandomInt(0, 100) / 100)
            .toRgba();

      pointerPoint.radius = circleRadius;
      pointerPoint.fill = circleColor;

      this.points.push(pointerPoint);

      return pointerPoint;
    }
  });


  /**
   * SprayBrush class
   * @class fabric.SprayBrush
   */
  fabric.SprayBrush = fabric.util.createClass( fabric.BaseBrush, /** @lends fabric.SprayBrush.prototype */ {

    /**
     * Width of a spray
     * @type Number
     * @default
     */
    width:              10,

    /**
     * Density of a spray (number of dots per chunk)
     * @type Number
     * @default
     */
    density:            20,

    /**
     * Width of spray dots
     * @type Number
     * @default
     */
    dotWidth:           1,

    /**
     * Width variance of spray dots
     * @type Number
     * @default
     */
    dotWidthVariance:   1,

    /**
     * Whether opacity of a dot should be random
     * @type Boolean
     * @default
     */
    randomOpacity:        false,

    /**
     * Whether overlapping dots (rectangles) should be removed (for performance reasons)
     * @type Boolean
     * @default
     */
    optimizeOverlapping:  true,

    /**
     * Constructor
     * @param {fabric.Canvas} canvas
     * @return {fabric.SprayBrush} Instance of a spray brush
     */
    initialize: function(canvas) {
      this.canvas = canvas;
      this.sprayChunks = [];
    },

    /**
     * Invoked on mouse down
     * @param {Object} pointer
     */
    onMouseDown: function(pointer) {
      this.sprayChunks.length = 0;
      this.canvas.clearContext(this.canvas.contextTop);
      this._setShadow();

      this.addSprayChunk(pointer);
      this.render(this.sprayChunkPoints);
    },

    /**
     * Invoked on mouse move
     * @param {Object} pointer
     */
    onMouseMove: function(pointer) {
      this.addSprayChunk(pointer);
      this.render(this.sprayChunkPoints);
    },

    /**
     * Invoked on mouse up
     */
    onMouseUp: function() {
      var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;
      this.canvas.renderOnAddRemove = false;

      var rects = [];

      for (var i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {
        var sprayChunk = this.sprayChunks[i];

        for (var j = 0, jlen = sprayChunk.length; j < jlen; j++) {

          var rect = new fabric.Rect({
            width: sprayChunk[j].width,
            height: sprayChunk[j].width,
            left: sprayChunk[j].x + 1,
            top: sprayChunk[j].y + 1,
            originX: 'center',
            originY: 'center',
            fill: this.color
          });
          rects.push(rect);
        }
      }

      if (this.optimizeOverlapping) {
        rects = this._getOptimizedRects(rects);
      }

      var group = new fabric.Group(rects, { originX: 'center', originY: 'center' });
      this.shadow && group.setShadow(this.shadow);
      this.canvas.add(group);
      this.canvas.fire('path:created', { path: group });

      this.canvas.clearContext(this.canvas.contextTop);
      this._resetShadow();
      this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
      this.canvas.requestRenderAll();
    },

    /**
     * @private
     * @param {Array} rects
     */
    _getOptimizedRects: function(rects) {

      // avoid creating duplicate rects at the same coordinates
      var uniqueRects = { }, key, i, len;

      for (i = 0, len = rects.length; i < len; i++) {
        key = rects[i].left + '' + rects[i].top;
        if (!uniqueRects[key]) {
          uniqueRects[key] = rects[i];
        }
      }
      var uniqueRectsArray = [];
      for (key in uniqueRects) {
        uniqueRectsArray.push(uniqueRects[key]);
      }

      return uniqueRectsArray;
    },

    /**
     * Render new chunk of spray brush
     */
    render: function(sprayChunk) {
      var ctx = this.canvas.contextTop, i, len;
      ctx.fillStyle = this.color;

      this._saveAndTransform(ctx);

      for (i = 0, len = sprayChunk.length; i < len; i++) {
        var point = sprayChunk[i];
        if (typeof point.opacity !== 'undefined') {
          ctx.globalAlpha = point.opacity;
        }
        ctx.fillRect(point.x, point.y, point.width, point.width);
      }
      ctx.restore();
    },

    /**
     * Render all spray chunks
     */
    _render: function() {
      var ctx = this.canvas.contextTop, i, ilen;
      ctx.fillStyle = this.color;

      this._saveAndTransform(ctx);

      for (i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {
        this.render(this.sprayChunks[i]);
      }
      ctx.restore();
    },

    /**
     * @param {Object} pointer
     */
    addSprayChunk: function(pointer) {
      this.sprayChunkPoints = [];

      var x, y, width, radius = this.width / 2, i;

      for (i = 0; i < this.density; i++) {

        x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);
        y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);

        if (this.dotWidthVariance) {
          width = fabric.util.getRandomInt(
            // bottom clamp width to 1
            Math.max(1, this.dotWidth - this.dotWidthVariance),
            this.dotWidth + this.dotWidthVariance);
        }
        else {
          width = this.dotWidth;
        }

        var point = new fabric.Point(x, y);
        point.width = width;

        if (this.randomOpacity) {
          point.opacity = fabric.util.getRandomInt(0, 100) / 100;
        }

        this.sprayChunkPoints.push(point);
      }

      this.sprayChunks.push(this.sprayChunkPoints);
    }
  });


  /**
   * PatternBrush class
   * @class fabric.PatternBrush
   * @extends fabric.BaseBrush
   */
  fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fabric.PatternBrush.prototype */ {

    getPatternSrc: function() {

      var dotWidth = 20,
          dotDistance = 5,
          patternCanvas = fabric.document.createElement('canvas'),
          patternCtx = patternCanvas.getContext('2d');

      patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;

      patternCtx.fillStyle = this.color;
      patternCtx.beginPath();
      patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);
      patternCtx.closePath();
      patternCtx.fill();

      return patternCanvas;
    },

    getPatternSrcFunction: function() {
      return String(this.getPatternSrc).replace('this.color', '"' + this.color + '"');
    },

    /**
     * Creates "pattern" instance property
     */
    getPattern: function() {
      return this.canvas.contextTop.createPattern(this.source || this.getPatternSrc(), 'repeat');
    },

    /**
     * Sets brush styles
     */
    _setBrushStyles: function() {
      this.callSuper('_setBrushStyles');
      this.canvas.contextTop.strokeStyle = this.getPattern();
    },

    /**
     * Creates path
     */
    createPath: function(pathData) {
      var path = this.callSuper('createPath', pathData),
          topLeft = path._getLeftTopCoords().scalarAdd(path.strokeWidth / 2);

      path.stroke = new fabric.Pattern({
        source: this.source || this.getPatternSrcFunction(),
        offsetX: -topLeft.x,
        offsetY: -topLeft.y
      });
      return path;
    }
  });


  (function() {

    var getPointer = fabric.util.getPointer,
        degreesToRadians = fabric.util.degreesToRadians,
        radiansToDegrees = fabric.util.radiansToDegrees,
        atan2 = Math.atan2,
        abs = Math.abs,
        supportLineDash = fabric.StaticCanvas.supports('setLineDash'),

        STROKE_OFFSET = 0.5;

    /**
     * Canvas class
     * @class fabric.Canvas
     * @extends fabric.StaticCanvas
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#canvas}
     * @see {@link fabric.Canvas#initialize} for constructor definition
     *
     * @fires object:modified
     * @fires object:rotated
     * @fires object:scaled
     * @fires object:moved
     * @fires object:skewed
     * @fires object:rotating
     * @fires object:scaling
     * @fires object:moving
     * @fires object:skewing
     * @fires object:selected this event is deprecated. use selection:created
     *
     * @fires before:transform
     * @fires before:selection:cleared
     * @fires selection:cleared
     * @fires selection:updated
     * @fires selection:created
     *
     * @fires path:created
     * @fires mouse:down
     * @fires mouse:move
     * @fires mouse:up
     * @fires mouse:down:before
     * @fires mouse:move:before
     * @fires mouse:up:before
     * @fires mouse:over
     * @fires mouse:out
     * @fires mouse:dblclick
     *
     * @fires dragover
     * @fires dragenter
     * @fires dragleave
     * @fires drop
     *
     */
    fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, /** @lends fabric.Canvas.prototype */ {

      /**
       * Constructor
       * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
       * @param {Object} [options] Options object
       * @return {Object} thisArg
       */
      initialize: function(el, options) {
        options || (options = { });
        this.renderAndResetBound = this.renderAndReset.bind(this);
        this._initStatic(el, options);
        this._initInteractive();
        this._createCacheCanvas();
      },

      /**
       * When true, objects can be transformed by one side (unproportionally)
       * @type Boolean
       * @default
       */
      uniScaleTransform:      false,

      /**
       * Indicates which key enable unproportional scaling
       * values: 'altKey', 'shiftKey', 'ctrlKey'.
       * If `null` or 'none' or any other string that is not a modifier key
       * feature is disabled feature disabled.
       * @since 1.6.2
       * @type String
       * @default
       */
      uniScaleKey:           'shiftKey',

      /**
       * When true, objects use center point as the origin of scale transformation.
       * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
       * @since 1.3.4
       * @type Boolean
       * @default
       */
      centeredScaling:        false,

      /**
       * When true, objects use center point as the origin of rotate transformation.
       * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
       * @since 1.3.4
       * @type Boolean
       * @default
       */
      centeredRotation:       false,

      /**
       * Indicates which key enable centered Transform
       * values: 'altKey', 'shiftKey', 'ctrlKey'.
       * If `null` or 'none' or any other string that is not a modifier key
       * feature is disabled feature disabled.
       * @since 1.6.2
       * @type String
       * @default
       */
      centeredKey:           'altKey',

      /**
       * Indicates which key enable alternate action on corner
       * values: 'altKey', 'shiftKey', 'ctrlKey'.
       * If `null` or 'none' or any other string that is not a modifier key
       * feature is disabled feature disabled.
       * @since 1.6.2
       * @type String
       * @default
       */
      altActionKey:           'shiftKey',

      /**
       * Indicates that canvas is interactive. This property should not be changed.
       * @type Boolean
       * @default
       */
      interactive:            true,

      /**
       * Indicates whether group selection should be enabled
       * @type Boolean
       * @default
       */
      selection:              true,

      /**
       * Indicates which key or keys enable multiple click selection
       * Pass value as a string or array of strings
       * values: 'altKey', 'shiftKey', 'ctrlKey'.
       * If `null` or empty or containing any other string that is not a modifier key
       * feature is disabled.
       * @since 1.6.2
       * @type String|Array
       * @default
       */
      selectionKey:           'shiftKey',

      /**
       * Indicates which key enable alternative selection
       * in case of target overlapping with active object
       * values: 'altKey', 'shiftKey', 'ctrlKey'.
       * For a series of reason that come from the general expectations on how
       * things should work, this feature works only for preserveObjectStacking true.
       * If `null` or 'none' or any other string that is not a modifier key
       * feature is disabled.
       * @since 1.6.5
       * @type null|String
       * @default
       */
      altSelectionKey:           null,

      /**
       * Color of selection
       * @type String
       * @default
       */
      selectionColor:         'rgba(100, 100, 255, 0.3)', // blue

      /**
       * Default dash array pattern
       * If not empty the selection border is dashed
       * @type Array
       */
      selectionDashArray:     [],

      /**
       * Color of the border of selection (usually slightly darker than color of selection itself)
       * @type String
       * @default
       */
      selectionBorderColor:   'rgba(255, 255, 255, 0.3)',

      /**
       * Width of a line used in object/group selection
       * @type Number
       * @default
       */
      selectionLineWidth:     1,

      /**
       * Select only shapes that are fully contained in the dragged selection rectangle.
       * @type Boolean
       * @default
       */
      selectionFullyContained: false,

      /**
       * Default cursor value used when hovering over an object on canvas
       * @type String
       * @default
       */
      hoverCursor:            'move',

      /**
       * Default cursor value used when moving an object on canvas
       * @type String
       * @default
       */
      moveCursor:             'move',

      /**
       * Default cursor value used for the entire canvas
       * @type String
       * @default
       */
      defaultCursor:          'default',

      /**
       * Cursor value used during free drawing
       * @type String
       * @default
       */
      freeDrawingCursor:      'crosshair',

      /**
       * Cursor value used for rotation point
       * @type String
       * @default
       */
      rotationCursor:         'crosshair',

      /**
       * Cursor value used for disabled elements ( corners with disabled action )
       * @type String
       * @since 2.0.0
       * @default
       */
      notAllowedCursor:         'not-allowed',

      /**
       * Default element class that's given to wrapper (div) element of canvas
       * @type String
       * @default
       */
      containerClass:         'canvas-container',

      /**
       * When true, object detection happens on per-pixel basis rather than on per-bounding-box
       * @type Boolean
       * @default
       */
      perPixelTargetFind:     false,

      /**
       * Number of pixels around target pixel to tolerate (consider active) during object detection
       * @type Number
       * @default
       */
      targetFindTolerance:    0,

      /**
       * When true, target detection is skipped when hovering over canvas. This can be used to improve performance.
       * @type Boolean
       * @default
       */
      skipTargetFind:         false,

      /**
       * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.
       * After mousedown, mousemove creates a shape,
       * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.
       * @tutorial {@link http://fabricjs.com/fabric-intro-part-4#free_drawing}
       * @type Boolean
       * @default
       */
      isDrawingMode:          false,

      /**
       * Indicates whether objects should remain in current stack position when selected.
       * When false objects are brought to top and rendered as part of the selection group
       * @type Boolean
       * @default
       */
      preserveObjectStacking: false,

      /**
       * Indicates the angle that an object will lock to while rotating.
       * @type Number
       * @since 1.6.7
       * @default
       */
      snapAngle: 0,

      /**
       * Indicates the distance from the snapAngle the rotation will lock to the snapAngle.
       * When `null`, the snapThreshold will default to the snapAngle.
       * @type null|Number
       * @since 1.6.7
       * @default
       */
      snapThreshold: null,

      /**
       * Indicates if the right click on canvas can output the context menu or not
       * @type Boolean
       * @since 1.6.5
       * @default
       */
      stopContextMenu: false,

      /**
       * Indicates if the canvas can fire right click events
       * @type Boolean
       * @since 1.6.5
       * @default
       */
      fireRightClick: false,

      /**
       * Indicates if the canvas can fire middle click events
       * @type Boolean
       * @since 1.7.8
       * @default
       */
      fireMiddleClick: false,

      /**
       * @private
       */
      _initInteractive: function() {
        this._currentTransform = null;
        this._groupSelector = null;
        this._initWrapperElement();
        this._createUpperCanvas();
        this._initEventListeners();

        this._initRetinaScaling();

        this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this);

        this.calcOffset();
      },

      /**
       * Divides objects in two groups, one to render immediately
       * and one to render as activeGroup.
       * @return {Array} objects to render immediately and pushes the other in the activeGroup.
       */
      _chooseObjectsToRender: function() {
        var activeObjects = this.getActiveObjects(),
            object, objsToRender, activeGroupObjects;

        if (activeObjects.length > 0 && !this.preserveObjectStacking) {
          objsToRender = [];
          activeGroupObjects = [];
          for (var i = 0, length = this._objects.length; i < length; i++) {
            object = this._objects[i];
            if (activeObjects.indexOf(object) === -1 ) {
              objsToRender.push(object);
            }
            else {
              activeGroupObjects.push(object);
            }
          }
          if (activeObjects.length > 1) {
            this._activeObject._objects = activeGroupObjects;
          }
          objsToRender.push.apply(objsToRender, activeGroupObjects);
        }
        else {
          objsToRender = this._objects;
        }
        return objsToRender;
      },

      /**
       * Renders both the top canvas and the secondary container canvas.
       * @return {fabric.Canvas} instance
       * @chainable
       */
      renderAll: function () {
        if (this.contextTopDirty && !this._groupSelector && !this.isDrawingMode) {
          this.clearContext(this.contextTop);
          this.contextTopDirty = false;
        }
        if (this.hasLostContext) {
          this.renderTopLayer(this.contextTop);
        }
        var canvasToDrawOn = this.contextContainer;
        this.renderCanvas(canvasToDrawOn, this._chooseObjectsToRender());
        return this;
      },

      renderTopLayer: function(ctx) {
        if (this.isDrawingMode && this._isCurrentlyDrawing) {
          this.freeDrawingBrush && this.freeDrawingBrush._render();
        }
        // we render the top context - last object
        if (this.selection && this._groupSelector) {
          this._drawSelection(ctx);
        }
      },

      /**
       * Method to render only the top canvas.
       * Also used to render the group selection box.
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      renderTop: function () {
        var ctx = this.contextTop;
        this.clearContext(ctx);
        this.renderTopLayer(ctx);
        this.fire('after:render');
        this.contextTopDirty = true;
        return this;
      },

      /**
       * Resets the current transform to its original values and chooses the type of resizing based on the event
       * @private
       */
      _resetCurrentTransform: function() {
        var t = this._currentTransform;

        t.target.set({
          scaleX: t.original.scaleX,
          scaleY: t.original.scaleY,
          skewX: t.original.skewX,
          skewY: t.original.skewY,
          left: t.original.left,
          top: t.original.top
        });

        if (this._shouldCenterTransform(t.target)) {
          if (t.originX !== 'center') {
            if (t.originX === 'right') {
              t.mouseXSign = -1;
            }
            else {
              t.mouseXSign = 1;
            }
          }
          if (t.originY !== 'center') {
            if (t.originY === 'bottom') {
              t.mouseYSign = -1;
            }
            else {
              t.mouseYSign = 1;
            }
          }

          t.originX = 'center';
          t.originY = 'center';
        }
        else {
          t.originX = t.original.originX;
          t.originY = t.original.originY;
        }
      },

      /**
       * Checks if point is contained within an area of given object
       * @param {Event} e Event object
       * @param {fabric.Object} target Object to test against
       * @param {Object} [point] x,y object of point coordinates we want to check.
       * @return {Boolean} true if point is contained within an area of given object
       */
      containsPoint: function (e, target, point) {
        var ignoreZoom = true,
            pointer = point || this.getPointer(e, ignoreZoom),
            xy;

        if (target.group && target.group === this._activeObject && target.group.type === 'activeSelection') {
          xy = this._normalizePointer(target.group, pointer);
        }
        else {
          xy = { x: pointer.x, y: pointer.y };
        }
        // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html
        // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html
        return (target.containsPoint(xy) || target._findTargetCorner(pointer));
      },

      /**
       * @private
       */
      _normalizePointer: function (object, pointer) {
        var m = object.calcTransformMatrix(),
            invertedM = fabric.util.invertTransform(m),
            vptPointer = this.restorePointerVpt(pointer);
        return fabric.util.transformPoint(vptPointer, invertedM);
      },

      /**
       * Returns true if object is transparent at a certain location
       * @param {fabric.Object} target Object to check
       * @param {Number} x Left coordinate
       * @param {Number} y Top coordinate
       * @return {Boolean}
       */
      isTargetTransparent: function (target, x, y) {
        if (target.shouldCache() && target._cacheCanvas) {
          var normalizedPointer = this._normalizePointer(target, {x: x, y: y}),
              targetRelativeX = target.cacheTranslationX + (normalizedPointer.x * target.zoomX),
              targetRelativeY = target.cacheTranslationY + (normalizedPointer.y * target.zoomY);

          var isTransparent = fabric.util.isTransparent(
            target._cacheContext, targetRelativeX, targetRelativeY, this.targetFindTolerance);

          return isTransparent;
        }

        var ctx = this.contextCache,
            originalColor = target.selectionBackgroundColor, v = this.viewportTransform;

        target.selectionBackgroundColor = '';

        this.clearContext(ctx);

        ctx.save();
        ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
        target.render(ctx);
        ctx.restore();

        target === this._activeObject && target._renderControls(ctx, {
          hasBorders: false,
          transparentCorners: false
        }, {
          hasBorders: false,
        });

        target.selectionBackgroundColor = originalColor;

        var isTransparent = fabric.util.isTransparent(
          ctx, x, y, this.targetFindTolerance);

        return isTransparent;
      },

      /**
       * takes an event and determins if selection key has been pressed
       * @private
       * @param {Event} e Event object
       */
      _isSelectionKeyPressed: function(e) {
        var selectionKeyPressed = false;

        if (Object.prototype.toString.call(this.selectionKey) === '[object Array]') {
          selectionKeyPressed = !!this.selectionKey.find(function(key) { return e[key] === true; });
        }
        else {
          selectionKeyPressed = e[this.selectionKey];
        }

        return selectionKeyPressed;
      },

      /**
       * @private
       * @param {Event} e Event object
       * @param {fabric.Object} target
       */
      _shouldClearSelection: function (e, target) {
        var activeObjects = this.getActiveObjects(),
            activeObject = this._activeObject;

        return (
          !target
          ||
          (target &&
            activeObject &&
            activeObjects.length > 1 &&
            activeObjects.indexOf(target) === -1 &&
            activeObject !== target &&
            !this._isSelectionKeyPressed(e))
          ||
          (target && !target.evented)
          ||
          (target &&
            !target.selectable &&
            activeObject &&
            activeObject !== target)
        );
      },

      /**
       * centeredScaling from object can't override centeredScaling from canvas.
       * this should be fixed, since object setting should take precedence over canvas.
       * @private
       * @param {fabric.Object} target
       */
      _shouldCenterTransform: function (target) {
        if (!target) {
          return;
        }

        var t = this._currentTransform,
            centerTransform;

        if (t.action === 'scale' || t.action === 'scaleX' || t.action === 'scaleY') {
          centerTransform = this.centeredScaling || target.centeredScaling;
        }
        else if (t.action === 'rotate') {
          centerTransform = this.centeredRotation || target.centeredRotation;
        }

        return centerTransform ? !t.altKey : t.altKey;
      },

      /**
       * @private
       */
      _getOriginFromCorner: function(target, corner) {
        var origin = {
          x: target.originX,
          y: target.originY
        };

        if (corner === 'ml' || corner === 'tl' || corner === 'bl') {
          origin.x = 'right';
        }
        else if (corner === 'mr' || corner === 'tr' || corner === 'br') {
          origin.x = 'left';
        }

        if (corner === 'tl' || corner === 'mt' || corner === 'tr') {
          origin.y = 'bottom';
        }
        else if (corner === 'bl' || corner === 'mb' || corner === 'br') {
          origin.y = 'top';
        }

        return origin;
      },

      /**
       * @private
       */
      _getActionFromCorner: function(target, corner, e) {
        if (!corner) {
          return 'drag';
        }

        switch (corner) {
          case 'mtr':
            return 'rotate';
          case 'ml':
          case 'mr':
            return e[this.altActionKey] ? 'skewY' : 'scaleX';
          case 'mt':
          case 'mb':
            return e[this.altActionKey] ? 'skewX' : 'scaleY';
          default:
            return 'scale';
        }
      },

      /**
       * @private
       * @param {Event} e Event object
       * @param {fabric.Object} target
       */
      _setupCurrentTransform: function (e, target) {
        if (!target) {
          return;
        }

        var pointer = this.getPointer(e),
            corner = target._findTargetCorner(this.getPointer(e, true)),
            action = this._getActionFromCorner(target, corner, e),
            origin = this._getOriginFromCorner(target, corner);

        this._currentTransform = {
          target: target,
          action: action,
          corner: corner,
          scaleX: target.scaleX,
          scaleY: target.scaleY,
          skewX: target.skewX,
          skewY: target.skewY,
          // used by transation
          offsetX: pointer.x - target.left,
          offsetY: pointer.y - target.top,
          originX: origin.x,
          originY: origin.y,
          ex: pointer.x,
          ey: pointer.y,
          lastX: pointer.x,
          lastY: pointer.y,
          // unsure they are usefull anymore.
          // left: target.left,
          // top: target.top,
          theta: degreesToRadians(target.angle),
          // end of unsure
          width: target.width * target.scaleX,
          mouseXSign: 1,
          mouseYSign: 1,
          shiftKey: e.shiftKey,
          altKey: e[this.centeredKey]
        };

        this._currentTransform.original = {
          left: target.left,
          top: target.top,
          scaleX: target.scaleX,
          scaleY: target.scaleY,
          skewX: target.skewX,
          skewY: target.skewY,
          originX: origin.x,
          originY: origin.y
        };

        this._resetCurrentTransform();
        this._beforeTransform(e);
      },

      /**
       * Translates object by "setting" its left/top
       * @private
       * @param {Number} x pointer's x coordinate
       * @param {Number} y pointer's y coordinate
       * @return {Boolean} true if the translation occurred
       */
      _translateObject: function (x, y) {
        var transform = this._currentTransform,
            target = transform.target,
            newLeft = x - transform.offsetX,
            newTop = y - transform.offsetY,
            moveX = !target.get('lockMovementX') && target.left !== newLeft,
            moveY = !target.get('lockMovementY') && target.top !== newTop;

        moveX && target.set('left', newLeft);
        moveY && target.set('top', newTop);
        return moveX || moveY;
      },

      /**
       * Check if we are increasing a positive skew or lower it,
       * checking mouse direction and pressed corner.
       * @private
       */
      _changeSkewTransformOrigin: function(mouseMove, t, by) {
        var property = 'originX', origins = { 0: 'center' },
            skew = t.target.skewX, originA = 'left', originB = 'right',
            corner = t.corner === 'mt' || t.corner === 'ml' ? 1 : -1,
            flipSign = 1;

        mouseMove = mouseMove > 0 ? 1 : -1;
        if (by === 'y') {
          skew = t.target.skewY;
          originA = 'top';
          originB = 'bottom';
          property = 'originY';
        }
        origins[-1] = originA;
        origins[1] = originB;

        t.target.flipX && (flipSign *= -1);
        t.target.flipY && (flipSign *= -1);

        if (skew === 0) {
          t.skewSign = -corner * mouseMove * flipSign;
          t[property] = origins[-mouseMove];
        }
        else {
          skew = skew > 0 ? 1 : -1;
          t.skewSign = skew;
          t[property] = origins[skew * corner * flipSign];
        }
      },

      /**
       * Skew object by mouse events
       * @private
       * @param {Number} x pointer's x coordinate
       * @param {Number} y pointer's y coordinate
       * @param {String} by Either 'x' or 'y'
       * @return {Boolean} true if the skewing occurred
       */
      _skewObject: function (x, y, by) {
        var t = this._currentTransform,
            target = t.target, skewed = false,
            lockSkewingX = target.get('lockSkewingX'),
            lockSkewingY = target.get('lockSkewingY');

        if ((lockSkewingX && by === 'x') || (lockSkewingY && by === 'y')) {
          return false;
        }

        // Get the constraint point
        var center = target.getCenterPoint(),
            actualMouseByCenter = target.toLocalPoint(new fabric.Point(x, y), 'center', 'center')[by],
            lastMouseByCenter = target.toLocalPoint(new fabric.Point(t.lastX, t.lastY), 'center', 'center')[by],
            actualMouseByOrigin, constraintPosition, dim = target._getTransformedDimensions();

        this._changeSkewTransformOrigin(actualMouseByCenter - lastMouseByCenter, t, by);
        actualMouseByOrigin = target.toLocalPoint(new fabric.Point(x, y), t.originX, t.originY)[by];
        constraintPosition = target.translateToOriginPoint(center, t.originX, t.originY);
        // Actually skew the object
        skewed = this._setObjectSkew(actualMouseByOrigin, t, by, dim);
        t.lastX = x;
        t.lastY = y;
        // Make sure the constraints apply
        target.setPositionByOrigin(constraintPosition, t.originX, t.originY);
        return skewed;
      },

      /**
       * Set object skew
       * @private
       * @return {Boolean} true if the skewing occurred
       */
      _setObjectSkew: function(localMouse, transform, by, _dim) {
        var target = transform.target, newValue, skewed = false,
            skewSign = transform.skewSign, newDim, dimNoSkew,
            otherBy, _otherBy, _by, newDimMouse, skewX, skewY;

        if (by === 'x') {
          otherBy = 'y';
          _otherBy = 'Y';
          _by = 'X';
          skewX = 0;
          skewY = target.skewY;
        }
        else {
          otherBy = 'x';
          _otherBy = 'X';
          _by = 'Y';
          skewX = target.skewX;
          skewY = 0;
        }

        dimNoSkew = target._getTransformedDimensions(skewX, skewY);
        newDimMouse = 2 * Math.abs(localMouse) - dimNoSkew[by];
        if (newDimMouse <= 2) {
          newValue = 0;
        }
        else {
          newValue = skewSign * Math.atan((newDimMouse / target['scale' + _by]) /
                                          (dimNoSkew[otherBy] / target['scale' + _otherBy]));
          newValue = fabric.util.radiansToDegrees(newValue);
        }
        skewed = target['skew' + _by] !== newValue;
        target.set('skew' + _by, newValue);
        if (target['skew' + _otherBy] !== 0) {
          newDim = target._getTransformedDimensions();
          newValue = (_dim[otherBy] / newDim[otherBy]) * target['scale' + _otherBy];
          target.set('scale' + _otherBy, newValue);
        }
        return skewed;
      },

      /**
       * Scales object by invoking its scaleX/scaleY methods
       * @private
       * @param {Number} x pointer's x coordinate
       * @param {Number} y pointer's y coordinate
       * @param {String} by Either 'x' or 'y' - specifies dimension constraint by which to scale an object.
       *                    When not provided, an object is scaled by both dimensions equally
       * @return {Boolean} true if the scaling occurred
       */
      _scaleObject: function (x, y, by) {
        var t = this._currentTransform,
            target = t.target,
            lockScalingX = target.lockScalingX,
            lockScalingY = target.lockScalingY,
            lockScalingFlip = target.lockScalingFlip;

        if (lockScalingX && lockScalingY) {
          return false;
        }

        // Get the constraint point
        var constraintPosition = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY),
            localMouse = target.toLocalPoint(new fabric.Point(x, y), t.originX, t.originY),
            dim = target._getTransformedDimensions(), scaled = false;

        this._setLocalMouse(localMouse, t);

        // Actually scale the object
        scaled = this._setObjectScale(localMouse, t, lockScalingX, lockScalingY, by, lockScalingFlip, dim);

        // Make sure the constraints apply
        target.setPositionByOrigin(constraintPosition, t.originX, t.originY);
        return scaled;
      },

      /**
       * @private
       * @return {Boolean} true if the scaling occurred
       */
      _setObjectScale: function(localMouse, transform, lockScalingX, lockScalingY, by, lockScalingFlip, _dim) {
        var target = transform.target, forbidScalingX = false, forbidScalingY = false, scaled = false,
            changeX, changeY, scaleX, scaleY;

        scaleX = localMouse.x * target.scaleX / _dim.x;
        scaleY = localMouse.y * target.scaleY / _dim.y;
        changeX = target.scaleX !== scaleX;
        changeY = target.scaleY !== scaleY;

        if (lockScalingFlip && scaleX <= 0 && scaleX < target.scaleX) {
          forbidScalingX = true;
          localMouse.x = 0;
        }

        if (lockScalingFlip && scaleY <= 0 && scaleY < target.scaleY) {
          forbidScalingY = true;
          localMouse.y = 0;
        }

        if (by === 'equally' && !lockScalingX && !lockScalingY) {
          scaled = this._scaleObjectEqually(localMouse, target, transform, _dim);
        }
        else if (!by) {
          forbidScalingX || lockScalingX || (target.set('scaleX', scaleX) && (scaled = scaled || changeX));
          forbidScalingY || lockScalingY || (target.set('scaleY', scaleY) && (scaled = scaled || changeY));
        }
        else if (by === 'x' && !target.get('lockUniScaling')) {
          forbidScalingX || lockScalingX || (target.set('scaleX', scaleX) && (scaled = scaled || changeX));
        }
        else if (by === 'y' && !target.get('lockUniScaling')) {
          forbidScalingY || lockScalingY || (target.set('scaleY', scaleY) && (scaled = scaled || changeY));
        }
        transform.newScaleX = scaleX;
        transform.newScaleY = scaleY;
        forbidScalingX || forbidScalingY || this._flipObject(transform, by);
        return scaled;
      },

      /**
       * @private
       * @return {Boolean} true if the scaling occurred
       */
      _scaleObjectEqually: function(localMouse, target, transform, _dim) {

        var dist = localMouse.y + localMouse.x,
            lastDist = _dim.y * transform.original.scaleY / target.scaleY +
                       _dim.x * transform.original.scaleX / target.scaleX,
            scaled, signX = localMouse.x < 0 ? -1 : 1,
            signY = localMouse.y < 0 ? -1 : 1;

        // We use transform.scaleX/Y instead of target.scaleX/Y
        // because the object may have a min scale and we'll loose the proportions
        transform.newScaleX = signX * Math.abs(transform.original.scaleX * dist / lastDist);
        transform.newScaleY = signY * Math.abs(transform.original.scaleY * dist / lastDist);
        scaled = transform.newScaleX !== target.scaleX || transform.newScaleY !== target.scaleY;
        target.set('scaleX', transform.newScaleX);
        target.set('scaleY', transform.newScaleY);
        return scaled;
      },

      /**
       * @private
       */
      _flipObject: function(transform, by) {
        if (transform.newScaleX < 0 && by !== 'y') {
          if (transform.originX === 'left') {
            transform.originX = 'right';
          }
          else if (transform.originX === 'right') {
            transform.originX = 'left';
          }
        }

        if (transform.newScaleY < 0 && by !== 'x') {
          if (transform.originY === 'top') {
            transform.originY = 'bottom';
          }
          else if (transform.originY === 'bottom') {
            transform.originY = 'top';
          }
        }
      },

      /**
       * @private
       */
      _setLocalMouse: function(localMouse, t) {
        var target = t.target, zoom = this.getZoom(),
            padding = target.padding / zoom;

        if (t.originX === 'right') {
          localMouse.x *= -1;
        }
        else if (t.originX === 'center') {
          localMouse.x *= t.mouseXSign * 2;
          if (localMouse.x < 0) {
            t.mouseXSign = -t.mouseXSign;
          }
        }

        if (t.originY === 'bottom') {
          localMouse.y *= -1;
        }
        else if (t.originY === 'center') {
          localMouse.y *= t.mouseYSign * 2;
          if (localMouse.y < 0) {
            t.mouseYSign = -t.mouseYSign;
          }
        }

        // adjust the mouse coordinates when dealing with padding
        if (abs(localMouse.x) > padding) {
          if (localMouse.x < 0) {
            localMouse.x += padding;
          }
          else {
            localMouse.x -= padding;
          }
        }
        else { // mouse is within the padding, set to 0
          localMouse.x = 0;
        }

        if (abs(localMouse.y) > padding) {
          if (localMouse.y < 0) {
            localMouse.y += padding;
          }
          else {
            localMouse.y -= padding;
          }
        }
        else {
          localMouse.y = 0;
        }
      },

      /**
       * Rotates object by invoking its rotate method
       * @private
       * @param {Number} x pointer's x coordinate
       * @param {Number} y pointer's y coordinate
       * @return {Boolean} true if the rotation occurred
       */
      _rotateObject: function (x, y) {

        var t = this._currentTransform,
            target = t.target, constraintPosition,
            constraintPosition = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY);

        if (target.lockRotation) {
          return false;
        }

        var lastAngle = atan2(t.ey - constraintPosition.y, t.ex - constraintPosition.x),
            curAngle = atan2(y - constraintPosition.y, x - constraintPosition.x),
            angle = radiansToDegrees(curAngle - lastAngle + t.theta),
            hasRotated = true;

        if (target.snapAngle > 0) {
          var snapAngle  = target.snapAngle,
              snapThreshold  = target.snapThreshold || snapAngle,
              rightAngleLocked = Math.ceil(angle / snapAngle) * snapAngle,
              leftAngleLocked = Math.floor(angle / snapAngle) * snapAngle;

          if (Math.abs(angle - leftAngleLocked) < snapThreshold) {
            angle = leftAngleLocked;
          }
          else if (Math.abs(angle - rightAngleLocked) < snapThreshold) {
            angle = rightAngleLocked;
          }
        }

        // normalize angle to positive value
        if (angle < 0) {
          angle = 360 + angle;
        }
        angle %= 360;

        if (target.angle === angle) {
          hasRotated = false;
        }
        else {
          // rotation only happen here
          target.angle = angle;
          // Make sure the constraints apply
          target.setPositionByOrigin(constraintPosition, t.originX, t.originY);
        }

        return hasRotated;
      },

      /**
       * Set the cursor type of the canvas element
       * @param {String} value Cursor type of the canvas element.
       * @see http://www.w3.org/TR/css3-ui/#cursor
       */
      setCursor: function (value) {
        this.upperCanvasEl.style.cursor = value;
      },

      /**
       * @param {fabric.Object} target to reset transform
       * @private
       */
      _resetObjectTransform: function (target) {
        target.scaleX = 1;
        target.scaleY = 1;
        target.skewX = 0;
        target.skewY = 0;
        target.rotate(0);
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx to draw the selection on
       */
      _drawSelection: function (ctx) {
        var groupSelector = this._groupSelector,
            left = groupSelector.left,
            top = groupSelector.top,
            aleft = abs(left),
            atop = abs(top);

        if (this.selectionColor) {
          ctx.fillStyle = this.selectionColor;

          ctx.fillRect(
            groupSelector.ex - ((left > 0) ? 0 : -left),
            groupSelector.ey - ((top > 0) ? 0 : -top),
            aleft,
            atop
          );
        }

        if (!this.selectionLineWidth || !this.selectionBorderColor) {
          return;
        }
        ctx.lineWidth = this.selectionLineWidth;
        ctx.strokeStyle = this.selectionBorderColor;

        // selection border
        if (this.selectionDashArray.length > 1 && !supportLineDash) {

          var px = groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),
              py = groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop);

          ctx.beginPath();

          fabric.util.drawDashedLine(ctx, px, py, px + aleft, py, this.selectionDashArray);
          fabric.util.drawDashedLine(ctx, px, py + atop - 1, px + aleft, py + atop - 1, this.selectionDashArray);
          fabric.util.drawDashedLine(ctx, px, py, px, py + atop, this.selectionDashArray);
          fabric.util.drawDashedLine(ctx, px + aleft - 1, py, px + aleft - 1, py + atop, this.selectionDashArray);

          ctx.closePath();
          ctx.stroke();
        }
        else {
          fabric.Object.prototype._setLineDash.call(this, ctx, this.selectionDashArray);
          ctx.strokeRect(
            groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),
            groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop),
            aleft,
            atop
          );
        }
      },

      /**
       * Method that determines what object we are clicking on
       * the skipGroup parameter is for internal use, is needed for shift+click action
       * @param {Event} e mouse event
       * @param {Boolean} skipGroup when true, activeGroup is skipped and only objects are traversed through
       */
      findTarget: function (e, skipGroup) {
        if (this.skipTargetFind) {
          return;
        }

        var ignoreZoom = true,
            pointer = this.getPointer(e, ignoreZoom),
            activeObject = this._activeObject,
            aObjects = this.getActiveObjects(),
            activeTarget, activeTargetSubs;

        // first check current group (if one exists)
        // active group does not check sub targets like normal groups.
        // if active group just exits.
        this.targets = [];

        if (aObjects.length > 1 && !skipGroup && activeObject === this._searchPossibleTargets([activeObject], pointer)) {
          return activeObject;
        }
        // if we hit the corner of an activeObject, let's return that.
        if (aObjects.length === 1 && activeObject._findTargetCorner(pointer)) {
          return activeObject;
        }
        if (aObjects.length === 1 &&
          activeObject === this._searchPossibleTargets([activeObject], pointer)) {
          if (!this.preserveObjectStacking) {
            return activeObject;
          }
          else {
            activeTarget = activeObject;
            activeTargetSubs = this.targets;
            this.targets = [];
          }
        }
        var target = this._searchPossibleTargets(this._objects, pointer);
        if (e[this.altSelectionKey] && target && activeTarget && target !== activeTarget) {
          target = activeTarget;
          this.targets = activeTargetSubs;
        }
        return target;
      },

      /**
       * @private
       */
      _checkTarget: function(pointer, obj) {
        if (obj &&
            obj.visible &&
            obj.evented &&
            this.containsPoint(null, obj, pointer)){
          if ((this.perPixelTargetFind || obj.perPixelTargetFind) && !obj.isEditing) {
            var isTransparent = this.isTargetTransparent(obj, pointer.x, pointer.y);
            if (!isTransparent) {
              return true;
            }
          }
          else {
            return true;
          }
        }
      },

      /**
       * @private
       */
      _searchPossibleTargets: function(objects, pointer) {

        // Cache all targets where their bounding box contains point.
        var target, i = objects.length, normalizedPointer, subTarget;
        // Do not check for currently grouped objects, since we check the parent group itself.
        // until we call this function specifically to search inside the activeGroup
        while (i--) {
          if (this._checkTarget(pointer, objects[i])) {
            target = objects[i];
            if (target.subTargetCheck && target instanceof fabric.Group) {
              normalizedPointer = this._normalizePointer(target, pointer);
              subTarget = this._searchPossibleTargets(target._objects, normalizedPointer);
              subTarget && this.targets.push(subTarget);
            }
            break;
          }
        }
        return target;
      },

      /**
       * Returns pointer coordinates without the effect of the viewport
       * @param {Object} pointer with "x" and "y" number values
       * @return {Object} object with "x" and "y" number values
       */
      restorePointerVpt: function(pointer) {
        return fabric.util.transformPoint(
          pointer,
          fabric.util.invertTransform(this.viewportTransform)
        );
      },

      /**
       * Returns pointer coordinates relative to canvas.
       * Can return coordinates with or without viewportTransform.
       * ignoreZoom false gives back coordinates that represent
       * the point clicked on canvas element.
       * ignoreZoom true gives back coordinates after being processed
       * by the viewportTransform ( sort of coordinates of what is displayed
       * on the canvas where you are clicking.
       * ignoreZoom true = HTMLElement coordinates relative to top,left
       * ignoreZoom false, default = fabric space coordinates, the same used for shape position
       * To interact with your shapes top and left you want to use ignoreZoom true
       * most of the time, while ignoreZoom false will give you coordinates
       * compatible with the object.oCoords system.
       * of the time.
       * @param {Event} e
       * @param {Boolean} ignoreZoom
       * @return {Object} object with "x" and "y" number values
       */
      getPointer: function (e, ignoreZoom) {
        // return cached values if we are in the event processing chain
        if (this._absolutePointer && !ignoreZoom) {
          return this._absolutePointer;
        }
        if (this._pointer && ignoreZoom) {
          return this._pointer;
        }

        var pointer = getPointer(e),
            upperCanvasEl = this.upperCanvasEl,
            bounds = upperCanvasEl.getBoundingClientRect(),
            boundsWidth = bounds.width || 0,
            boundsHeight = bounds.height || 0,
            cssScale;

        if (!boundsWidth || !boundsHeight ) {
          if ('top' in bounds && 'bottom' in bounds) {
            boundsHeight = Math.abs( bounds.top - bounds.bottom );
          }
          if ('right' in bounds && 'left' in bounds) {
            boundsWidth = Math.abs( bounds.right - bounds.left );
          }
        }

        this.calcOffset();
        pointer.x = pointer.x - this._offset.left;
        pointer.y = pointer.y - this._offset.top;
        if (!ignoreZoom) {
          pointer = this.restorePointerVpt(pointer);
        }

        if (boundsWidth === 0 || boundsHeight === 0) {
          // If bounds are not available (i.e. not visible), do not apply scale.
          cssScale = { width: 1, height: 1 };
        }
        else {
          cssScale = {
            width: upperCanvasEl.width / boundsWidth,
            height: upperCanvasEl.height / boundsHeight
          };
        }

        return {
          x: pointer.x * cssScale.width,
          y: pointer.y * cssScale.height
        };
      },

      /**
       * @private
       * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized
       */
      _createUpperCanvas: function () {
        var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, '');

        // there is no need to create a new upperCanvas element if we have already one.
        if (this.upperCanvasEl) {
          this.upperCanvasEl.className = '';
        }
        else {
          this.upperCanvasEl = this._createCanvasElement();
        }
        fabric.util.addClass(this.upperCanvasEl, 'upper-canvas ' + lowerCanvasClass);

        this.wrapperEl.appendChild(this.upperCanvasEl);

        this._copyCanvasStyle(this.lowerCanvasEl, this.upperCanvasEl);
        this._applyCanvasStyle(this.upperCanvasEl);
        this.contextTop = this.upperCanvasEl.getContext('2d');
      },

      /**
       * @private
       */
      _createCacheCanvas: function () {
        this.cacheCanvasEl = this._createCanvasElement();
        this.cacheCanvasEl.setAttribute('width', this.width);
        this.cacheCanvasEl.setAttribute('height', this.height);
        this.contextCache = this.cacheCanvasEl.getContext('2d');
      },

      /**
       * @private
       */
      _initWrapperElement: function () {
        this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, 'div', {
          'class': this.containerClass
        });
        fabric.util.setStyle(this.wrapperEl, {
          width: this.width + 'px',
          height: this.height + 'px',
          position: 'relative'
        });
        fabric.util.makeElementUnselectable(this.wrapperEl);
      },

      /**
       * @private
       * @param {HTMLElement} element canvas element to apply styles on
       */
      _applyCanvasStyle: function (element) {
        var width = this.width || element.width,
            height = this.height || element.height;

        fabric.util.setStyle(element, {
          position: 'absolute',
          width: width + 'px',
          height: height + 'px',
          left: 0,
          top: 0,
          'touch-action': this.allowTouchScrolling ? 'manipulation' : 'none'
        });
        element.width = width;
        element.height = height;
        fabric.util.makeElementUnselectable(element);
      },

      /**
       * Copy the entire inline style from one element (fromEl) to another (toEl)
       * @private
       * @param {Element} fromEl Element style is copied from
       * @param {Element} toEl Element copied style is applied to
       */
      _copyCanvasStyle: function (fromEl, toEl) {
        toEl.style.cssText = fromEl.style.cssText;
      },

      /**
       * Returns context of canvas where object selection is drawn
       * @return {CanvasRenderingContext2D}
       */
      getSelectionContext: function() {
        return this.contextTop;
      },

      /**
       * Returns &lt;canvas> element on which object selection is drawn
       * @return {HTMLCanvasElement}
       */
      getSelectionElement: function () {
        return this.upperCanvasEl;
      },

      /**
       * Returns currently active object
       * @return {fabric.Object} active object
       */
      getActiveObject: function () {
        return this._activeObject;
      },

      /**
       * Returns an array with the current selected objects
       * @return {fabric.Object} active object
       */
      getActiveObjects: function () {
        var active = this._activeObject;
        if (active) {
          if (active.type === 'activeSelection' && active._objects) {
            return active._objects.slice(0);
          }
          else {
            return [active];
          }
        }
        return [];
      },

      /**
       * @private
       * @param {fabric.Object} obj Object that was removed
       */
      _onObjectRemoved: function(obj) {
        // removing active object should fire "selection:cleared" events
        if (obj === this._activeObject) {
          this.fire('before:selection:cleared', { target: obj });
          this._discardActiveObject();
          this.fire('selection:cleared', { target: obj });
          obj.fire('deselected');
        }
        if (this._hoveredTarget === obj) {
          this._hoveredTarget = null;
        }
        this.callSuper('_onObjectRemoved', obj);
      },

      /**
       * @private
       * Compares the old activeObject with the current one and fires correct events
       * @param {fabric.Object} obj old activeObject
       */
      _fireSelectionEvents: function(oldObjects, e) {
        var somethingChanged = false, objects = this.getActiveObjects(),
            added = [], removed = [], opt = { e: e };
        oldObjects.forEach(function(oldObject) {
          if (objects.indexOf(oldObject) === -1) {
            somethingChanged = true;
            oldObject.fire('deselected', opt);
            removed.push(oldObject);
          }
        });
        objects.forEach(function(object) {
          if (oldObjects.indexOf(object) === -1) {
            somethingChanged = true;
            object.fire('selected', opt);
            added.push(object);
          }
        });
        if (oldObjects.length > 0 && objects.length > 0) {
          opt.selected = added;
          opt.deselected = removed;
          // added for backward compatibility
          opt.updated = added[0] || removed[0];
          opt.target = this._activeObject;
          somethingChanged && this.fire('selection:updated', opt);
        }
        else if (objects.length > 0) {
          // deprecated event
          if (objects.length === 1) {
            opt.target = added[0];
            this.fire('object:selected', opt);
          }
          opt.selected = added;
          // added for backward compatibility
          opt.target = this._activeObject;
          this.fire('selection:created', opt);
        }
        else if (oldObjects.length > 0) {
          opt.deselected = removed;
          this.fire('selection:cleared', opt);
        }
      },

      /**
       * Sets given object as the only active object on canvas
       * @param {fabric.Object} object Object to set as an active one
       * @param {Event} [e] Event (passed along when firing "object:selected")
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      setActiveObject: function (object, e) {
        var currentActives = this.getActiveObjects();
        this._setActiveObject(object, e);
        this._fireSelectionEvents(currentActives, e);
        return this;
      },

      /**
       * @private
       * @param {Object} object to set as active
       * @param {Event} [e] Event (passed along when firing "object:selected")
       * @return {Boolean} true if the selection happened
       */
      _setActiveObject: function(object, e) {
        if (this._activeObject === object) {
          return false;
        }
        if (!this._discardActiveObject(e, object)) {
          return false;
        }
        if (object.onSelect({ e: e })) {
          return false;
        }
        this._activeObject = object;
        return true;
      },

      /**
       * @private
       */
      _discardActiveObject: function(e, object) {
        var obj = this._activeObject;
        if (obj) {
          // onDeselect return TRUE to cancel selection;
          if (obj.onDeselect({ e: e, object: object })) {
            return false;
          }
          this._activeObject = null;
        }
        return true;
      },

      /**
       * Discards currently active object and fire events. If the function is called by fabric
       * as a consequence of a mouse event, the event is passed as a parameter and
       * sent to the fire function for the custom events. When used as a method the
       * e param does not have any application.
       * @param {event} e
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      discardActiveObject: function (e) {
        var currentActives = this.getActiveObjects();
        if (currentActives.length) {
          this.fire('before:selection:cleared', { target: currentActives[0], e: e });
        }
        this._discardActiveObject(e);
        this._fireSelectionEvents(currentActives, e);
        return this;
      },

      /**
       * Clears a canvas element and removes all event listeners
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      dispose: function () {
        var wrapper = this.wrapperEl;
        this.removeListeners();
        wrapper.removeChild(this.upperCanvasEl);
        wrapper.removeChild(this.lowerCanvasEl);
        this.upperCanvasEl = null;
        this.cacheCanvasEl = null;
        this.contextCache = null;
        this.contextTop = null;
        if (wrapper.parentNode) {
          wrapper.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl);
        }
        delete this.wrapperEl;
        fabric.StaticCanvas.prototype.dispose.call(this);
        return this;
      },

      /**
       * Clears all contexts (background, main, top) of an instance
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      clear: function () {
        // this.discardActiveGroup();
        this.discardActiveObject();
        this.clearContext(this.contextTop);
        return this.callSuper('clear');
      },

      /**
       * Draws objects' controls (borders/controls)
       * @param {CanvasRenderingContext2D} ctx Context to render controls on
       */
      drawControls: function(ctx) {
        var activeObject = this._activeObject;

        if (activeObject) {
          activeObject._renderControls(ctx);
        }
      },

      /**
       * @private
       */
      _toObject: function(instance, methodName, propertiesToInclude) {
        //If the object is part of the current selection group, it should
        //be transformed appropriately
        //i.e. it should be serialised as it would appear if the selection group
        //were to be destroyed.
        var originalProperties = this._realizeGroupTransformOnObject(instance),
            object = this.callSuper('_toObject', instance, methodName, propertiesToInclude);
        //Undo the damage we did by changing all of its properties
        this._unwindGroupTransformOnObject(instance, originalProperties);
        return object;
      },

      /**
       * Realises an object's group transformation on it
       * @private
       * @param {fabric.Object} [instance] the object to transform (gets mutated)
       * @returns the original values of instance which were changed
       */
      _realizeGroupTransformOnObject: function(instance) {
        if (instance.group && instance.group.type === 'activeSelection' && this._activeObject === instance.group) {
          var layoutProps = ['angle', 'flipX', 'flipY', 'left', 'scaleX', 'scaleY', 'skewX', 'skewY', 'top'];
          //Copy all the positionally relevant properties across now
          var originalValues = {};
          layoutProps.forEach(function(prop) {
            originalValues[prop] = instance[prop];
          });
          this._activeObject.realizeTransform(instance);
          return originalValues;
        }
        else {
          return null;
        }
      },

      /**
       * Restores the changed properties of instance
       * @private
       * @param {fabric.Object} [instance] the object to un-transform (gets mutated)
       * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject
       */
      _unwindGroupTransformOnObject: function(instance, originalValues) {
        if (originalValues) {
          instance.set(originalValues);
        }
      },

      /**
       * @private
       */
      _setSVGObject: function(markup, instance, reviver) {
        //If the object is in a selection group, simulate what would happen to that
        //object when the group is deselected
        var originalProperties = this._realizeGroupTransformOnObject(instance);
        this.callSuper('_setSVGObject', markup, instance, reviver);
        this._unwindGroupTransformOnObject(instance, originalProperties);
      },

      setViewportTransform: function (vpt) {
        if (this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing) {
          this._activeObject.clearContextTop();
        }
        fabric.StaticCanvas.prototype.setViewportTransform.call(this, vpt);
      }
    });

    // copying static properties manually to work around Opera's bug,
    // where "prototype" property is enumerable and overrides existing prototype
    for (var prop in fabric.StaticCanvas) {
      if (prop !== 'prototype') {
        fabric.Canvas[prop] = fabric.StaticCanvas[prop];
      }
    }

    if (fabric.isTouchSupported) {
      /** @ignore */
      fabric.Canvas.prototype._setCursorFromEvent = function() { };
    }
  })();


  (function() {

    var cursorOffset = {
          mt: 0, // n
          tr: 1, // ne
          mr: 2, // e
          br: 3, // se
          mb: 4, // s
          bl: 5, // sw
          ml: 6, // w
          tl: 7 // nw
        },
        addListener = fabric.util.addListener,
        removeListener = fabric.util.removeListener,
        RIGHT_CLICK = 3, MIDDLE_CLICK = 2, LEFT_CLICK = 1,
        addEventOptions = { passive: false };

    function checkClick(e, value) {
      return 'which' in e ? e.which === value : e.button === value - 1;
    }

    fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {

      /**
       * Map of cursor style values for each of the object controls
       * @private
       */
      cursorMap: [
        'n-resize',
        'ne-resize',
        'e-resize',
        'se-resize',
        's-resize',
        'sw-resize',
        'w-resize',
        'nw-resize'
      ],

      /**
       * Adds mouse listeners to canvas
       * @private
       */
      _initEventListeners: function () {
        // in case we initialized the class twice. This should not happen normally
        // but in some kind of applications where the canvas element may be changed
        // this is a workaround to having double listeners.
        this.removeListeners();
        this._bindEvents();
        this.addOrRemove(addListener, 'add');
      },

      addOrRemove: function(functor, eventjsFunctor) {
        functor(fabric.window, 'resize', this._onResize);
        functor(this.upperCanvasEl, 'mousedown', this._onMouseDown);
        functor(this.upperCanvasEl, 'mousemove', this._onMouseMove, addEventOptions);
        functor(this.upperCanvasEl, 'mouseout', this._onMouseOut);
        functor(this.upperCanvasEl, 'mouseenter', this._onMouseEnter);
        functor(this.upperCanvasEl, 'wheel', this._onMouseWheel);
        functor(this.upperCanvasEl, 'contextmenu', this._onContextMenu);
        functor(this.upperCanvasEl, 'dblclick', this._onDoubleClick);
        functor(this.upperCanvasEl, 'touchstart', this._onMouseDown, addEventOptions);
        functor(this.upperCanvasEl, 'touchmove', this._onMouseMove, addEventOptions);
        functor(this.upperCanvasEl, 'dragover', this._onDragOver);
        functor(this.upperCanvasEl, 'dragenter', this._onDragEnter);
        functor(this.upperCanvasEl, 'dragleave', this._onDragLeave);
        functor(this.upperCanvasEl, 'drop', this._onDrop);
        if (typeof eventjs !== 'undefined' && eventjsFunctor in eventjs) {
          eventjs[eventjsFunctor](this.upperCanvasEl, 'gesture', this._onGesture);
          eventjs[eventjsFunctor](this.upperCanvasEl, 'drag', this._onDrag);
          eventjs[eventjsFunctor](this.upperCanvasEl, 'orientation', this._onOrientationChange);
          eventjs[eventjsFunctor](this.upperCanvasEl, 'shake', this._onShake);
          eventjs[eventjsFunctor](this.upperCanvasEl, 'longpress', this._onLongPress);
        }
      },

      /**
       * Removes all event listeners
       */
      removeListeners: function() {
        this.addOrRemove(removeListener, 'remove');
        // if you dispose on a mouseDown, before mouse up, you need to clean document to...
        removeListener(fabric.document, 'mouseup', this._onMouseUp);
        removeListener(fabric.document, 'touchend', this._onMouseUp, addEventOptions);
        removeListener(fabric.document, 'mousemove', this._onMouseMove, addEventOptions);
        removeListener(fabric.document, 'touchmove', this._onMouseMove, addEventOptions);
      },

      /**
       * @private
       */
      _bindEvents: function() {
        if (this.eventsBound) {
          // for any reason we pass here twice we do not want to bind events twice.
          return;
        }
        this._onMouseDown = this._onMouseDown.bind(this);
        this._onMouseMove = this._onMouseMove.bind(this);
        this._onMouseUp = this._onMouseUp.bind(this);
        this._onResize = this._onResize.bind(this);
        this._onGesture = this._onGesture.bind(this);
        this._onDrag = this._onDrag.bind(this);
        this._onShake = this._onShake.bind(this);
        this._onLongPress = this._onLongPress.bind(this);
        this._onOrientationChange = this._onOrientationChange.bind(this);
        this._onMouseWheel = this._onMouseWheel.bind(this);
        this._onMouseOut = this._onMouseOut.bind(this);
        this._onMouseEnter = this._onMouseEnter.bind(this);
        this._onContextMenu = this._onContextMenu.bind(this);
        this._onDoubleClick = this._onDoubleClick.bind(this);
        this._onDragOver = this._onDragOver.bind(this);
        this._onDragEnter = this._simpleEventHandler.bind(this, 'dragenter');
        this._onDragLeave = this._simpleEventHandler.bind(this, 'dragleave');
        this._onDrop = this._simpleEventHandler.bind(this, 'drop');
        this.eventsBound = true;
      },

      /**
       * @private
       * @param {Event} [e] Event object fired on Event.js gesture
       * @param {Event} [self] Inner Event object
       */
      _onGesture: function(e, self) {
        this.__onTransformGesture && this.__onTransformGesture(e, self);
      },

      /**
       * @private
       * @param {Event} [e] Event object fired on Event.js drag
       * @param {Event} [self] Inner Event object
       */
      _onDrag: function(e, self) {
        this.__onDrag && this.__onDrag(e, self);
      },

      /**
       * @private
       * @param {Event} [e] Event object fired on wheel event
       */
      _onMouseWheel: function(e) {
        this.__onMouseWheel(e);
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousedown
       */
      _onMouseOut: function(e) {
        var target = this._hoveredTarget;
        this.fire('mouse:out', { target: target, e: e });
        this._hoveredTarget = null;
        target && target.fire('mouseout', { e: e });
        if (this._iTextInstances) {
          this._iTextInstances.forEach(function(obj) {
            if (obj.isEditing) {
              obj.hiddenTextarea.focus();
            }
          });
        }
      },

      /**
       * @private
       * @param {Event} e Event object fired on mouseenter
       */
      _onMouseEnter: function(e) {
        if (!this.findTarget(e)) {
          this.fire('mouse:over', { target: null, e: e });
          this._hoveredTarget = null;
        }
      },

      /**
       * @private
       * @param {Event} [e] Event object fired on Event.js orientation change
       * @param {Event} [self] Inner Event object
       */
      _onOrientationChange: function(e, self) {
        this.__onOrientationChange && this.__onOrientationChange(e, self);
      },

      /**
       * @private
       * @param {Event} [e] Event object fired on Event.js shake
       * @param {Event} [self] Inner Event object
       */
      _onShake: function(e, self) {
        this.__onShake && this.__onShake(e, self);
      },

      /**
       * @private
       * @param {Event} [e] Event object fired on Event.js shake
       * @param {Event} [self] Inner Event object
       */
      _onLongPress: function(e, self) {
        this.__onLongPress && this.__onLongPress(e, self);
      },

      /**
       * prevent default to allow drop event to be fired
       * @private
       * @param {Event} [e] Event object fired on Event.js shake
       */
      _onDragOver: function(e) {
        e.preventDefault();
        var target = this._simpleEventHandler('dragover', e);
        this._fireEnterLeaveEvents(target, e);
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousedown
       */
      _onContextMenu: function (e) {
        if (this.stopContextMenu) {
          e.stopPropagation();
          e.preventDefault();
        }
        return false;
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousedown
       */
      _onDoubleClick: function (e) {
        this._cacheTransformEventData(e);
        this._handleEvent(e, 'dblclick');
        this._resetTransformEventData(e);
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousedown
       */
      _onMouseDown: function (e) {
        this.__onMouseDown(e);
        this._resetTransformEventData();
        addListener(fabric.document, 'touchend', this._onMouseUp, addEventOptions);
        addListener(fabric.document, 'touchmove', this._onMouseMove, addEventOptions);

        removeListener(this.upperCanvasEl, 'mousemove', this._onMouseMove, addEventOptions);
        removeListener(this.upperCanvasEl, 'touchmove', this._onMouseMove, addEventOptions);

        if (e.type === 'touchstart') {
          // Unbind mousedown to prevent double triggers from touch devices
          removeListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);
        }
        else {
          addListener(fabric.document, 'mouseup', this._onMouseUp);
          addListener(fabric.document, 'mousemove', this._onMouseMove, addEventOptions);
        }
      },

      /**
       * @private
       * @param {Event} e Event object fired on mouseup
       */
      _onMouseUp: function (e) {
        this.__onMouseUp(e);
        this._resetTransformEventData();
        removeListener(fabric.document, 'mouseup', this._onMouseUp);
        removeListener(fabric.document, 'touchend', this._onMouseUp, addEventOptions);

        removeListener(fabric.document, 'mousemove', this._onMouseMove, addEventOptions);
        removeListener(fabric.document, 'touchmove', this._onMouseMove, addEventOptions);

        addListener(this.upperCanvasEl, 'mousemove', this._onMouseMove, addEventOptions);
        addListener(this.upperCanvasEl, 'touchmove', this._onMouseMove, addEventOptions);

        if (e.type === 'touchend') {
          // Wait 400ms before rebinding mousedown to prevent double triggers
          // from touch devices
          var _this = this;
          setTimeout(function() {
            addListener(_this.upperCanvasEl, 'mousedown', _this._onMouseDown);
          }, 400);
        }
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousemove
       */
      _onMouseMove: function (e) {
        !this.allowTouchScrolling && e.preventDefault && e.preventDefault();
        this.__onMouseMove(e);
      },

      /**
       * @private
       */
      _onResize: function () {
        this.calcOffset();
      },

      /**
       * Decides whether the canvas should be redrawn in mouseup and mousedown events.
       * @private
       * @param {Object} target
       * @param {Object} pointer
       */
      _shouldRender: function(target, pointer) {
        var activeObject = this._activeObject;

        if (activeObject && activeObject.isEditing && target === activeObject) {
          // if we mouse up/down over a editing textbox a cursor change,
          // there is no need to re render
          return false;
        }
        return !!(
          (target && (
            target.isMoving ||
            target !== activeObject))
          ||
          (!target && !!activeObject)
          ||
          (!target && !activeObject && !this._groupSelector)
          ||
          (pointer &&
            this._previousPointer &&
            this.selection && (
              pointer.x !== this._previousPointer.x ||
            pointer.y !== this._previousPointer.y))
        );
      },

      /**
       * Method that defines the actions when mouse is released on canvas.
       * The method resets the currentTransform parameters, store the image corner
       * position in the image object and render the canvas on top.
       * @private
       * @param {Event} e Event object fired on mouseup
       */
      __onMouseUp: function (e) {
        var target, transform = this._currentTransform,
            groupSelector = this._groupSelector,
            isClick = (!groupSelector || (groupSelector.left === 0 && groupSelector.top === 0));
        this._cacheTransformEventData(e);
        target = this._target;
        this._handleEvent(e, 'up:before');
        // if right/middle click just fire events and return
        // target undefined will make the _handleEvent search the target
        if (checkClick(e, RIGHT_CLICK)) {
          if (this.fireRightClick) {
            this._handleEvent(e, 'up', RIGHT_CLICK, isClick);
          }
          return;
        }

        if (checkClick(e, MIDDLE_CLICK)) {
          if (this.fireMiddleClick) {
            this._handleEvent(e, 'up', MIDDLE_CLICK, isClick);
          }
          this._resetTransformEventData();
          return;
        }

        if (this.isDrawingMode && this._isCurrentlyDrawing) {
          this._onMouseUpInDrawingMode(e);
          return;
        }

        if (transform) {
          this._finalizeCurrentTransform(e);
        }

        var shouldRender = this._shouldRender(target, this._absolutePointer);

        if (target || !isClick) {
          this._maybeGroupObjects(e);
        }
        if (target) {
          target.isMoving = false;
        }
        this._setCursorFromEvent(e, target);
        this._handleEvent(e, 'up', LEFT_CLICK, isClick);
        this._groupSelector = null;
        this._currentTransform = null;
        target && (target.__corner = 0);
        shouldRender && this.requestRenderAll();
      },

      /**
       * @private
       * Handle event firing for target and subtargets
       * @param {Event} e event from mouse
       * @param {String} eventType event to fire (up, down or move)
       * @return {Fabric.Object} target return the the target found, for internal reasons.
       */
      _simpleEventHandler: function(eventType, e) {
        var target = this.findTarget(e),
            targets = this.targets,
            options = {
              e: e,
              target: target,
              subTargets: targets,
            };
        this.fire(eventType, options);
        target && target.fire(eventType, options);
        if (!targets) {
          return target;
        }
        for (var i = 0; i < targets.length; i++) {
          targets[i].fire(eventType, options);
        }
        return target;
      },

      /**
       * @private
       * Handle event firing for target and subtargets
       * @param {Event} e event from mouse
       * @param {String} eventType event to fire (up, down or move)
       * @param {fabric.Object} targetObj receiving event
       * @param {Number} [button] button used in the event 1 = left, 2 = middle, 3 = right
       * @param {Boolean} isClick for left button only, indicates that the mouse up happened without move.
       */
      _handleEvent: function(e, eventType, button, isClick) {
        var target = this._target,
            targets = this.targets || [],
            options = {
              e: e,
              target: target,
              subTargets: targets,
              button: button || LEFT_CLICK,
              isClick: isClick || false,
              pointer: this._pointer,
              absolutePointer: this._absolutePointer,
              transform: this._currentTransform
            };
        this.fire('mouse:' + eventType, options);
        target && target.fire('mouse' + eventType, options);
        for (var i = 0; i < targets.length; i++) {
          targets[i].fire('mouse' + eventType, options);
        }
      },

      /**
       * @private
       * @param {Event} e send the mouse event that generate the finalize down, so it can be used in the event
       */
      _finalizeCurrentTransform: function(e) {

        var transform = this._currentTransform,
            target = transform.target,
            eventName,
            options = {
              e: e,
              target: target,
              transform: transform,
            };

        if (target._scaling) {
          target._scaling = false;
        }

        target.setCoords();

        if (transform.actionPerformed || (this.stateful && target.hasStateChanged())) {
          if (transform.actionPerformed) {
            eventName = this._addEventOptions(options, transform);
            this._fire(eventName, options);
          }
          this._fire('modified', options);
        }
      },

      /**
       * Mutate option object in order to add by property and give back the event name.
       * @private
       * @param {Object} options to mutate
       * @param {Object} transform to inspect action from
       */
      _addEventOptions: function(options, transform) {
        // we can probably add more details at low cost
        // scale change, rotation changes, translation changes
        var eventName, by;
        switch (transform.action) {
          case 'scaleX':
            eventName = 'scaled';
            by = 'x';
            break;
          case 'scaleY':
            eventName = 'scaled';
            by = 'y';
            break;
          case 'skewX':
            eventName = 'skewed';
            by = 'x';
            break;
          case 'skewY':
            eventName = 'skewed';
            by = 'y';
            break;
          case 'scale':
            eventName = 'scaled';
            by = 'equally';
            break;
          case 'rotate':
            eventName = 'rotated';
            break;
          case 'drag':
            eventName = 'moved';
            break;
        }
        options.by = by;
        return eventName;
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousedown
       */
      _onMouseDownInDrawingMode: function(e) {
        this._isCurrentlyDrawing = true;
        if (this.getActiveObject()) {
          this.discardActiveObject(e).requestRenderAll();
        }
        if (this.clipTo) {
          fabric.util.clipContext(this, this.contextTop);
        }
        var pointer = this.getPointer(e);
        this.freeDrawingBrush.onMouseDown(pointer);
        this._handleEvent(e, 'down');
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousemove
       */
      _onMouseMoveInDrawingMode: function(e) {
        if (this._isCurrentlyDrawing) {
          var pointer = this.getPointer(e);
          this.freeDrawingBrush.onMouseMove(pointer);
        }
        this.setCursor(this.freeDrawingCursor);
        this._handleEvent(e, 'move');
      },

      /**
       * @private
       * @param {Event} e Event object fired on mouseup
       */
      _onMouseUpInDrawingMode: function(e) {
        this._isCurrentlyDrawing = false;
        if (this.clipTo) {
          this.contextTop.restore();
        }
        this.freeDrawingBrush.onMouseUp();
        this._handleEvent(e, 'up');
      },

      /**
       * Method that defines the actions when mouse is clicked on canvas.
       * The method inits the currentTransform parameters and renders all the
       * canvas so the current image can be placed on the top canvas and the rest
       * in on the container one.
       * @private
       * @param {Event} e Event object fired on mousedown
       */
      __onMouseDown: function (e) {
        this._cacheTransformEventData(e);
        this._handleEvent(e, 'down:before');
        var target = this._target;
        // if right click just fire events
        if (checkClick(e, RIGHT_CLICK)) {
          if (this.fireRightClick) {
            this._handleEvent(e, 'down', RIGHT_CLICK);
          }
          return;
        }

        if (checkClick(e, MIDDLE_CLICK)) {
          if (this.fireMiddleClick) {
            this._handleEvent(e, 'down', MIDDLE_CLICK);
          }
          return;
        }

        if (this.isDrawingMode) {
          this._onMouseDownInDrawingMode(e);
          return;
        }

        // ignore if some object is being transformed at this moment
        if (this._currentTransform) {
          return;
        }

        var pointer = this._pointer;
        // save pointer for check in __onMouseUp event
        this._previousPointer = pointer;
        var shouldRender = this._shouldRender(target, pointer),
            shouldGroup = this._shouldGroup(e, target);
        if (this._shouldClearSelection(e, target)) {
          this.discardActiveObject(e);
        }
        else if (shouldGroup) {
          this._handleGrouping(e, target);
          target = this._activeObject;
        }

        if (this.selection && (!target ||
          (!target.selectable && !target.isEditing && target !== this._activeObject))) {
          this._groupSelector = {
            ex: pointer.x,
            ey: pointer.y,
            top: 0,
            left: 0
          };
        }

        if (target) {
          if (target.selectable) {
            this.setActiveObject(target, e);
          }
          if (target === this._activeObject && (target.__corner || !shouldGroup)) {
            this._setupCurrentTransform(e, target);
          }
        }
        this._handleEvent(e, 'down');
        // we must renderAll so that we update the visuals
        shouldRender && this.requestRenderAll();
      },

      /**
       * reset cache form common information needed during event processing
       * @private
       */
      _resetTransformEventData: function() {
        this._target = null;
        this._pointer = null;
        this._absolutePointer = null;
      },

      /**
       * Cache common information needed during event processing
       * @private
       * @param {Event} e Event object fired on event
       */
      _cacheTransformEventData: function(e) {
        // reset in order to avoid stale caching
        this._resetTransformEventData();
        this._pointer = this.getPointer(e, true);
        this._absolutePointer = this.restorePointerVpt(this._pointer);
        this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(e) || null;
      },

      /**
       * @private
       */
      _beforeTransform: function(e) {
        var t = this._currentTransform;
        this.stateful && t.target.saveState();
        this.fire('before:transform', {
          e: e,
          transform: t,
        });
        // determine if it's a drag or rotate case
        if (t.corner) {
          this.onBeforeScaleRotate(t.target);
        }
      },

      /**
       * Method that defines the actions when mouse is hovering the canvas.
       * The currentTransform parameter will definde whether the user is rotating/scaling/translating
       * an image or neither of them (only hovering). A group selection is also possible and would cancel
       * all any other type of action.
       * In case of an image transformation only the top canvas will be rendered.
       * @private
       * @param {Event} e Event object fired on mousemove
       */
      __onMouseMove: function (e) {
        this._handleEvent(e, 'move:before');
        this._cacheTransformEventData(e);
        var target, pointer;

        if (this.isDrawingMode) {
          this._onMouseMoveInDrawingMode(e);
          return;
        }
        if (typeof e.touches !== 'undefined' && e.touches.length > 1) {
          return;
        }

        var groupSelector = this._groupSelector;

        // We initially clicked in an empty area, so we draw a box for multiple selection
        if (groupSelector) {
          pointer = this._pointer;

          groupSelector.left = pointer.x - groupSelector.ex;
          groupSelector.top = pointer.y - groupSelector.ey;

          this.renderTop();
        }
        else if (!this._currentTransform) {
          target = this.findTarget(e) || null;
          this._setCursorFromEvent(e, target);
          this._fireOverOutEvents(target, e);
        }
        else {
          this._transformObject(e);
        }
        this._handleEvent(e, 'move');
        this._resetTransformEventData();
      },

      /**
       * Manage the mouseout, mouseover events for the fabric object on the canvas
       * @param {Fabric.Object} target the target where the target from the mousemove event
       * @param {Event} e Event object fired on mousemove
       * @private
       */
      _fireOverOutEvents: function(target, e) {
        this.fireSynteticInOutEvents(target, e, {
          targetName: '_hoveredTarget',
          canvasEvtOut: 'mouse:out',
          evtOut: 'mouseout',
          canvasEvtIn: 'mouse:over',
          evtIn: 'mouseover',
        });
      },

      /**
       * Manage the dragEnter, dragLeave events for the fabric objects on the canvas
       * @param {Fabric.Object} target the target where the target from the onDrag event
       * @param {Event} e Event object fired on ondrag
       * @private
       */
      _fireEnterLeaveEvents: function(target, e) {
        this.fireSynteticInOutEvents(target, e, {
          targetName: '_draggedoverTarget',
          evtOut: 'dragleave',
          evtIn: 'dragenter',
        });
      },

      /**
       * Manage the syntetic in/out events for the fabric objects on the canvas
       * @param {Fabric.Object} target the target where the target from the supported events
       * @param {Event} e Event object fired
       * @param {Object} config configuration for the function to work
       * @param {String} config.targetName property on the canvas where the old target is stored
       * @param {String} [config.canvasEvtOut] name of the event to fire at canvas level for out
       * @param {String} config.evtOut name of the event to fire for out
       * @param {String} [config.canvasEvtIn] name of the event to fire at canvas level for in
       * @param {String} config.evtIn name of the event to fire for in
       * @private
       */
      fireSynteticInOutEvents: function(target, e, config) {
        var inOpt, outOpt, oldTarget = this[config.targetName], outFires, inFires,
            targetChanged = oldTarget !== target, canvasEvtIn = config.canvasEvtIn, canvasEvtOut = config.canvasEvtOut;
        if (targetChanged) {
          inOpt = { e: e, target: target, previousTarget: oldTarget };
          outOpt = { e: e, target: oldTarget, nextTarget: target };
          this[config.targetName] = target;
        }
        inFires = target && targetChanged;
        outFires = oldTarget && targetChanged;
        if (outFires) {
          canvasEvtOut && this.fire(canvasEvtOut, outOpt);
          oldTarget.fire(config.evtOut, outOpt);
        }
        if (inFires) {
          canvasEvtIn && this.fire(canvasEvtIn, inOpt);
          target.fire(config.evtIn, inOpt);
        }
      },

      /**
       * Method that defines actions when an Event Mouse Wheel
       * @param {Event} e Event object fired on mouseup
       */
      __onMouseWheel: function(e) {
        this._cacheTransformEventData(e);
        this._handleEvent(e, 'wheel');
        this._resetTransformEventData();
      },

      /**
       * @private
       * @param {Event} e Event fired on mousemove
       */
      _transformObject: function(e) {
        var pointer = this.getPointer(e),
            transform = this._currentTransform;

        transform.reset = false;
        transform.target.isMoving = true;
        transform.shiftKey = e.shiftKey;
        transform.altKey = e[this.centeredKey];

        this._beforeScaleTransform(e, transform);
        this._performTransformAction(e, transform, pointer);

        transform.actionPerformed && this.requestRenderAll();
      },

      /**
       * @private
       */
      _performTransformAction: function(e, transform, pointer) {
        var x = pointer.x,
            y = pointer.y,
            action = transform.action,
            actionPerformed = false,
            options = {
              target: transform.target,
              e: e,
              transform: transform,
              pointer: pointer
            };

        if (action === 'rotate') {
          (actionPerformed = this._rotateObject(x, y)) && this._fire('rotating', options);
        }
        else if (action === 'scale') {
          (actionPerformed = this._onScale(e, transform, x, y)) && this._fire('scaling', options);
        }
        else if (action === 'scaleX') {
          (actionPerformed = this._scaleObject(x, y, 'x')) && this._fire('scaling', options);
        }
        else if (action === 'scaleY') {
          (actionPerformed = this._scaleObject(x, y, 'y')) && this._fire('scaling', options);
        }
        else if (action === 'skewX') {
          (actionPerformed = this._skewObject(x, y, 'x')) && this._fire('skewing', options);
        }
        else if (action === 'skewY') {
          (actionPerformed = this._skewObject(x, y, 'y')) && this._fire('skewing', options);
        }
        else {
          actionPerformed = this._translateObject(x, y);
          if (actionPerformed) {
            this._fire('moving', options);
            this.setCursor(options.target.moveCursor || this.moveCursor);
          }
        }
        transform.actionPerformed = transform.actionPerformed || actionPerformed;
      },

      /**
       * @private
       */
      _fire: function(eventName, options) {
        this.fire('object:' + eventName, options);
        options.target.fire(eventName, options);
      },

      /**
       * @private
       */
      _beforeScaleTransform: function(e, transform) {
        if (transform.action === 'scale' || transform.action === 'scaleX' || transform.action === 'scaleY') {
          var centerTransform = this._shouldCenterTransform(transform.target);

          // Switch from a normal resize to center-based
          if ((centerTransform && (transform.originX !== 'center' || transform.originY !== 'center')) ||
             // Switch from center-based resize to normal one
             (!centerTransform && transform.originX === 'center' && transform.originY === 'center')
          ) {
            this._resetCurrentTransform();
            transform.reset = true;
          }
        }
      },

      /**
       * @private
       * @param {Event} e Event object
       * @param {Object} transform current tranform
       * @param {Number} x mouse position x from origin
       * @param {Number} y mouse poistion y from origin
       * @return {Boolean} true if the scaling occurred
       */
      _onScale: function(e, transform, x, y) {
        if (this._isUniscalePossible(e, transform.target)) {
          transform.currentAction = 'scale';
          return this._scaleObject(x, y);
        }
        else {
          // Switch from a normal resize to proportional
          if (!transform.reset && transform.currentAction === 'scale') {
            this._resetCurrentTransform();
          }

          transform.currentAction = 'scaleEqually';
          return this._scaleObject(x, y, 'equally');
        }
      },

      /**
       * @private
       * @param {Event} e Event object
       * @param {fabric.Object} target current target
       * @return {Boolean} true if unproportional scaling is possible
       */
      _isUniscalePossible: function(e, target) {
        return (e[this.uniScaleKey] || this.uniScaleTransform) && !target.get('lockUniScaling');
      },

      /**
       * Sets the cursor depending on where the canvas is being hovered.
       * Note: very buggy in Opera
       * @param {Event} e Event object
       * @param {Object} target Object that the mouse is hovering, if so.
       */
      _setCursorFromEvent: function (e, target) {
        if (!target) {
          this.setCursor(this.defaultCursor);
          return false;
        }

        var hoverCursor = target.hoverCursor || this.hoverCursor,
            activeSelection = this._activeObject && this._activeObject.type === 'activeSelection' ?
              this._activeObject : null,
            // only show proper corner when group selection is not active
            corner = (!activeSelection || !activeSelection.contains(target))
                      && target._findTargetCorner(this.getPointer(e, true));

        if (!corner) {
          this.setCursor(hoverCursor);
        }
        else {
          this.setCursor(this.getCornerCursor(corner, target, e));
        }
      },

      /**
       * @private
       */
      getCornerCursor: function(corner, target, e) {
        if (this.actionIsDisabled(corner, target, e)) {
          return this.notAllowedCursor;
        }
        else if (corner in cursorOffset) {
          return this._getRotatedCornerCursor(corner, target, e);
        }
        else if (corner === 'mtr' && target.hasRotatingPoint) {
          return this.rotationCursor;
        }
        else {
          return this.defaultCursor;
        }
      },

      actionIsDisabled: function(corner, target, e) {
        if (corner === 'mt' || corner === 'mb') {
          return e[this.altActionKey] ? target.lockSkewingX : target.lockScalingY;
        }
        else if (corner === 'ml' || corner === 'mr') {
          return e[this.altActionKey] ? target.lockSkewingY : target.lockScalingX;
        }
        else if (corner === 'mtr') {
          return target.lockRotation;
        }
        else {
          return this._isUniscalePossible(e, target) ?
            target.lockScalingX && target.lockScalingY : target.lockScalingX || target.lockScalingY;
        }
      },

      /**
       * @private
       */
      _getRotatedCornerCursor: function(corner, target, e) {
        var n = Math.round((target.angle % 360) / 45);

        if (n < 0) {
          n += 8; // full circle ahead
        }
        n += cursorOffset[corner];
        if (e[this.altActionKey] && cursorOffset[corner] % 2 === 0) {
          //if we are holding shift and we are on a mx corner...
          n += 2;
        }
        // normalize n to be from 0 to 7
        n %= 8;

        return this.cursorMap[n];
      }
    });
  })();


  (function() {

    var min = Math.min,
        max = Math.max;

    fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {

      /**
       * @private
       * @param {Event} e Event object
       * @param {fabric.Object} target
       * @return {Boolean}
       */
      _shouldGroup: function(e, target) {
        var activeObject = this._activeObject;

        return activeObject && this._isSelectionKeyPressed(e) && target && target.selectable && this.selection &&
              (activeObject !== target || activeObject.type === 'activeSelection');
      },

      /**
       * @private
       * @param {Event} e Event object
       * @param {fabric.Object} target
       */
      _handleGrouping: function (e, target) {
        var activeObject = this._activeObject;
        if (activeObject.__corner) {
          return;
        }
        if (target === activeObject) {
          // if it's a group, find target again, using activeGroup objects
          target = this.findTarget(e, true);
          // if even object is not found or we are on activeObjectCorner, bail out
          if (!target) {
            return;
          }
        }
        if (activeObject && activeObject.type === 'activeSelection') {
          this._updateActiveSelection(target, e);
        }
        else {
          this._createActiveSelection(target, e);
        }
      },

      /**
       * @private
       */
      _updateActiveSelection: function(target, e) {
        var activeSelection = this._activeObject,
            currentActiveObjects = activeSelection._objects.slice(0);
        if (activeSelection.contains(target)) {
          activeSelection.removeWithUpdate(target);
          this._hoveredTarget = target;
          if (activeSelection.size() === 1) {
            // activate last remaining object
            this._setActiveObject(activeSelection.item(0), e);
          }
        }
        else {
          activeSelection.addWithUpdate(target);
          this._hoveredTarget = activeSelection;
        }
        this._fireSelectionEvents(currentActiveObjects, e);
      },

      /**
       * @private
       */
      _createActiveSelection: function(target, e) {
        var currentActives = this.getActiveObjects(), group = this._createGroup(target);
        this._hoveredTarget = group;
        this._setActiveObject(group, e);
        this._fireSelectionEvents(currentActives, e);
      },

      /**
       * @private
       * @param {Object} target
       */
      _createGroup: function(target) {
        var objects = this.getObjects(),
            isActiveLower = objects.indexOf(this._activeObject) < objects.indexOf(target),
            groupObjects = isActiveLower
              ? [this._activeObject, target]
              : [target, this._activeObject];
        this._activeObject.isEditing && this._activeObject.exitEditing();
        return new fabric.ActiveSelection(groupObjects, {
          canvas: this
        });
      },

      /**
       * @private
       * @param {Event} e mouse event
       */
      _groupSelectedObjects: function (e) {

        var group = this._collectObjects(),
            aGroup;

        // do not create group for 1 element only
        if (group.length === 1) {
          this.setActiveObject(group[0], e);
        }
        else if (group.length > 1) {
          aGroup = new fabric.ActiveSelection(group.reverse(), {
            canvas: this
          });
          this.setActiveObject(aGroup, e);
        }
      },

      /**
       * @private
       */
      _collectObjects: function() {
        var group = [],
            currentObject,
            x1 = this._groupSelector.ex,
            y1 = this._groupSelector.ey,
            x2 = x1 + this._groupSelector.left,
            y2 = y1 + this._groupSelector.top,
            selectionX1Y1 = new fabric.Point(min(x1, x2), min(y1, y2)),
            selectionX2Y2 = new fabric.Point(max(x1, x2), max(y1, y2)),
            allowIntersect = !this.selectionFullyContained,
            isClick = x1 === x2 && y1 === y2;
        // we iterate reverse order to collect top first in case of click.
        for (var i = this._objects.length; i--; ) {
          currentObject = this._objects[i];

          if (!currentObject || !currentObject.selectable || !currentObject.visible) {
            continue;
          }

          if ((allowIntersect && currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2)) ||
              currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2) ||
              (allowIntersect && currentObject.containsPoint(selectionX1Y1)) ||
              (allowIntersect && currentObject.containsPoint(selectionX2Y2))
          ) {
            group.push(currentObject);

            // only add one object if it's a click
            if (isClick) {
              break;
            }
          }
        }

        return group;
      },

      /**
       * @private
       */
      _maybeGroupObjects: function(e) {
        if (this.selection && this._groupSelector) {
          this._groupSelectedObjects(e);
        }
        this.setCursor(this.defaultCursor);
        // clear selection and current transformation
        this._groupSelector = null;
      }
    });

  })();


  (function () {

    var supportQuality = fabric.StaticCanvas.supports('toDataURLWithQuality');

    fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

      /**
       * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately
       * @param {Object} [options] Options object
       * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
       * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
       * @param {Number} [options.multiplier=1] Multiplier to scale by, to have consistent
       * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
       * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
       * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
       * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
       * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 2.0.0
       * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
       * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}
       * @example <caption>Generate jpeg dataURL with lower quality</caption>
       * var dataURL = canvas.toDataURL({
       *   format: 'jpeg',
       *   quality: 0.8
       * });
       * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>
       * var dataURL = canvas.toDataURL({
       *   format: 'png',
       *   left: 100,
       *   top: 100,
       *   width: 200,
       *   height: 200
       * });
       * @example <caption>Generate double scaled png dataURL</caption>
       * var dataURL = canvas.toDataURL({
       *   format: 'png',
       *   multiplier: 2
       * });
       */
      toDataURL: function (options) {
        options || (options = { });

        var format = options.format || 'png',
            quality = options.quality || 1,
            multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? 1 : 1 / this.getRetinaScaling()),
            cropping = {
              left: options.left || 0,
              top: options.top || 0,
              width: options.width || 0,
              height: options.height || 0,
            };
        return this.__toDataURLWithMultiplier(format, quality, cropping, multiplier);
      },

      /**
       * @private
       */
      __toDataURLWithMultiplier: function(format, quality, cropping, multiplier) {

        var origWidth = this.width,
            origHeight = this.height,
            scaledWidth = (cropping.width || this.width) * multiplier,
            scaledHeight = (cropping.height || this.height) * multiplier,
            zoom = this.getZoom(),
            newZoom = zoom * multiplier,
            vp = this.viewportTransform,
            translateX = (vp[4] - cropping.left) * multiplier,
            translateY = (vp[5] - cropping.top) * multiplier,
            newVp = [newZoom, 0, 0, newZoom, translateX, translateY],
            originalInteractive = this.interactive,
            originalSkipOffScreen = this.skipOffscreen,
            needsResize = origWidth !== scaledWidth || origHeight !== scaledHeight;

        this.viewportTransform = newVp;
        this.skipOffscreen = false;
        // setting interactive to false avoid exporting controls
        this.interactive = false;
        if (needsResize) {
          this.setDimensions({ width: scaledWidth, height: scaledHeight }, { backstoreOnly: true });
        }
        // call a renderAll to force sync update. This will cancel the scheduled requestRenderAll
        // from setDimensions
        this.renderAll();
        var data = this.__toDataURL(format, quality, cropping);
        this.interactive = originalInteractive;
        this.skipOffscreen = originalSkipOffScreen;
        this.viewportTransform = vp;
        //setDimensions with no option object is taking care of:
        //this.width, this.height, this.requestRenderAll()
        if (needsResize) {
          this.setDimensions({ width: origWidth, height: origHeight }, { backstoreOnly: true });
        }
        this.renderAll();
        return data;
      },

      /**
       * @private
       */
      __toDataURL: function(format, quality) {

        var canvasEl = this.contextContainer.canvas;
        // to avoid common confusion https://github.com/kangax/fabric.js/issues/806
        if (format === 'jpg') {
          format = 'jpeg';
        }

        var data = supportQuality
          ? canvasEl.toDataURL('image/' + format, quality)
          : canvasEl.toDataURL('image/' + format);

        return data;
      },
    });

  })();


  fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

    /**
     * Populates canvas with data from the specified dataless JSON.
     * JSON format must conform to the one of {@link fabric.Canvas#toDatalessJSON}
     * @deprecated since 1.2.2
     * @param {String|Object} json JSON string or object
     * @param {Function} callback Callback, invoked when json is parsed
     *                            and corresponding objects (e.g: {@link fabric.Image})
     *                            are initialized
     * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.
     * @return {fabric.Canvas} instance
     * @chainable
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}
     */
    loadFromDatalessJSON: function (json, callback, reviver) {
      return this.loadFromJSON(json, callback, reviver);
    },

    /**
     * Populates canvas with data from the specified JSON.
     * JSON format must conform to the one of {@link fabric.Canvas#toJSON}
     * @param {String|Object} json JSON string or object
     * @param {Function} callback Callback, invoked when json is parsed
     *                            and corresponding objects (e.g: {@link fabric.Image})
     *                            are initialized
     * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.
     * @return {fabric.Canvas} instance
     * @chainable
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}
     * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}
     * @example <caption>loadFromJSON</caption>
     * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));
     * @example <caption>loadFromJSON with reviver</caption>
     * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {
     *   // `o` = json object
     *   // `object` = fabric.Object instance
     *   // ... do some stuff ...
     * });
     */
    loadFromJSON: function (json, callback, reviver) {
      if (!json) {
        return;
      }

      // serialize if it wasn't already
      var serialized = (typeof json === 'string')
        ? JSON.parse(json)
        : fabric.util.object.clone(json);

      var _this = this,
          renderOnAddRemove = this.renderOnAddRemove;
      this.renderOnAddRemove = false;

      this._enlivenObjects(serialized.objects, function (enlivenedObjects) {
        _this.clear();
        _this._setBgOverlay(serialized, function () {
          enlivenedObjects.forEach(function(obj, index) {
            // we splice the array just in case some custom classes restored from JSON
            // will add more object to canvas at canvas init.
            _this.insertAt(obj, index);
          });
          _this.renderOnAddRemove = renderOnAddRemove;
          // remove parts i cannot set as options
          delete serialized.objects;
          delete serialized.backgroundImage;
          delete serialized.overlayImage;
          delete serialized.background;
          delete serialized.overlay;
          // this._initOptions does too many things to just
          // call it. Normally loading an Object from JSON
          // create the Object instance. Here the Canvas is
          // already an instance and we are just loading things over it
          _this._setOptions(serialized);
          _this.renderAll();
          callback && callback();
        });
      }, reviver);
      return this;
    },

    /**
     * @private
     * @param {Object} serialized Object with background and overlay information
     * @param {Function} callback Invoked after all background and overlay images/patterns loaded
     */
    _setBgOverlay: function(serialized, callback) {
      var loaded = {
        backgroundColor: false,
        overlayColor: false,
        backgroundImage: false,
        overlayImage: false
      };

      if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {
        callback && callback();
        return;
      }

      var cbIfLoaded = function () {
        if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {
          callback && callback();
        }
      };

      this.__setBgOverlay('backgroundImage', serialized.backgroundImage, loaded, cbIfLoaded);
      this.__setBgOverlay('overlayImage', serialized.overlayImage, loaded, cbIfLoaded);
      this.__setBgOverlay('backgroundColor', serialized.background, loaded, cbIfLoaded);
      this.__setBgOverlay('overlayColor', serialized.overlay, loaded, cbIfLoaded);
    },

    /**
     * @private
     * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)
     * @param {(Object|String)} value Value to set
     * @param {Object} loaded Set loaded property to true if property is set
     * @param {Object} callback Callback function to invoke after property is set
     */
    __setBgOverlay: function(property, value, loaded, callback) {
      var _this = this;

      if (!value) {
        loaded[property] = true;
        callback && callback();
        return;
      }

      if (property === 'backgroundImage' || property === 'overlayImage') {
        fabric.util.enlivenObjects([value], function(enlivedObject){
          _this[property] = enlivedObject[0];
          loaded[property] = true;
          callback && callback();
        });
      }
      else {
        this['set' + fabric.util.string.capitalize(property, true)](value, function() {
          loaded[property] = true;
          callback && callback();
        });
      }
    },

    /**
     * @private
     * @param {Array} objects
     * @param {Function} callback
     * @param {Function} [reviver]
     */
    _enlivenObjects: function (objects, callback, reviver) {
      if (!objects || objects.length === 0) {
        callback && callback([]);
        return;
      }

      fabric.util.enlivenObjects(objects, function(enlivenedObjects) {
        callback && callback(enlivenedObjects);
      }, null, reviver);
    },

    /**
     * @private
     * @param {String} format
     * @param {Function} callback
     */
    _toDataURL: function (format, callback) {
      this.clone(function (clone) {
        callback(clone.toDataURL(format));
      });
    },

    /**
     * @private
     * @param {String} format
     * @param {Number} multiplier
     * @param {Function} callback
     */
    _toDataURLWithMultiplier: function (format, multiplier, callback) {
      this.clone(function (clone) {
        callback(clone.toDataURLWithMultiplier(format, multiplier));
      });
    },

    /**
     * Clones canvas instance
     * @param {Object} [callback] Receives cloned instance as a first argument
     * @param {Array} [properties] Array of properties to include in the cloned canvas and children
     */
    clone: function (callback, properties) {
      var data = JSON.stringify(this.toJSON(properties));
      this.cloneWithoutData(function(clone) {
        clone.loadFromJSON(data, function() {
          callback && callback(clone);
        });
      });
    },

    /**
     * Clones canvas instance without cloning existing data.
     * This essentially copies canvas dimensions, clipping properties, etc.
     * but leaves data empty (so that you can populate it with your own)
     * @param {Object} [callback] Receives cloned instance as a first argument
     */
    cloneWithoutData: function(callback) {
      var el = fabric.document.createElement('canvas');

      el.width = this.width;
      el.height = this.height;

      var clone = new fabric.Canvas(el);
      clone.clipTo = this.clipTo;
      if (this.backgroundImage) {
        clone.setBackgroundImage(this.backgroundImage.src, function() {
          clone.renderAll();
          callback && callback(clone);
        });
        clone.backgroundImageOpacity = this.backgroundImageOpacity;
        clone.backgroundImageStretch = this.backgroundImageStretch;
      }
      else {
        callback && callback(clone);
      }
    }
  });


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        clone = fabric.util.object.clone,
        toFixed = fabric.util.toFixed,
        capitalize = fabric.util.string.capitalize,
        degreesToRadians = fabric.util.degreesToRadians,
        supportsLineDash = fabric.StaticCanvas.supports('setLineDash'),
        objectCaching = !fabric.isLikelyNode,
        ALIASING_LIMIT = 2;

    if (fabric.Object) {
      return;
    }

    /**
     * Root object class from which all 2d shape classes inherit from
     * @class fabric.Object
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#objects}
     * @see {@link fabric.Object#initialize} for constructor definition
     *
     * @fires added
     * @fires removed
     *
     * @fires selected
     * @fires deselected
     * @fires modified
     * @fires modified
     * @fires moved
     * @fires scaled
     * @fires rotated
     * @fires skewed
     *
     * @fires rotating
     * @fires scaling
     * @fires moving
     * @fires skewing
     *
     * @fires mousedown
     * @fires mouseup
     * @fires mouseover
     * @fires mouseout
     * @fires mousewheel
     * @fires mousedblclick
     *
     * @fires dragover
     * @fires dragenter
     * @fires dragleave
     * @fires drop
     */
    fabric.Object = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.Object.prototype */ {

      /**
       * Type of an object (rect, circle, path, etc.).
       * Note that this property is meant to be read-only and not meant to be modified.
       * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.
       * @type String
       * @default
       */
      type:                     'object',

      /**
       * Horizontal origin of transformation of an object (one of "left", "right", "center")
       * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups
       * @type String
       * @default
       */
      originX:                  'left',

      /**
       * Vertical origin of transformation of an object (one of "top", "bottom", "center")
       * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups
       * @type String
       * @default
       */
      originY:                  'top',

      /**
       * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}
       * @type Number
       * @default
       */
      top:                      0,

      /**
       * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}
       * @type Number
       * @default
       */
      left:                     0,

      /**
       * Object width
       * @type Number
       * @default
       */
      width:                    0,

      /**
       * Object height
       * @type Number
       * @default
       */
      height:                   0,

      /**
       * Object scale factor (horizontal)
       * @type Number
       * @default
       */
      scaleX:                   1,

      /**
       * Object scale factor (vertical)
       * @type Number
       * @default
       */
      scaleY:                   1,

      /**
       * When true, an object is rendered as flipped horizontally
       * @type Boolean
       * @default
       */
      flipX:                    false,

      /**
       * When true, an object is rendered as flipped vertically
       * @type Boolean
       * @default
       */
      flipY:                    false,

      /**
       * Opacity of an object
       * @type Number
       * @default
       */
      opacity:                  1,

      /**
       * Angle of rotation of an object (in degrees)
       * @type Number
       * @default
       */
      angle:                    0,

      /**
       * Angle of skew on x axes of an object (in degrees)
       * @type Number
       * @default
       */
      skewX:                    0,

      /**
       * Angle of skew on y axes of an object (in degrees)
       * @type Number
       * @default
       */
      skewY:                    0,

      /**
       * Size of object's controlling corners (in pixels)
       * @type Number
       * @default
       */
      cornerSize:               13,

      /**
       * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)
       * @type Boolean
       * @default
       */
      transparentCorners:       true,

      /**
       * Default cursor value used when hovering over this object on canvas
       * @type String
       * @default
       */
      hoverCursor:              null,

      /**
       * Default cursor value used when moving this object on canvas
       * @type String
       * @default
       */
      moveCursor:               null,

      /**
       * Padding between object and its controlling borders (in pixels)
       * @type Number
       * @default
       */
      padding:                  0,

      /**
       * Color of controlling borders of an object (when it's active)
       * @type String
       * @default
       */
      borderColor:              'rgba(102,153,255,0.75)',

      /**
       * Array specifying dash pattern of an object's borders (hasBorder must be true)
       * @since 1.6.2
       * @type Array
       */
      borderDashArray:          null,

      /**
       * Color of controlling corners of an object (when it's active)
       * @type String
       * @default
       */
      cornerColor:              'rgba(102,153,255,0.5)',

      /**
       * Color of controlling corners of an object (when it's active and transparentCorners false)
       * @since 1.6.2
       * @type String
       * @default
       */
      cornerStrokeColor:        null,

      /**
       * Specify style of control, 'rect' or 'circle'
       * @since 1.6.2
       * @type String
       */
      cornerStyle:          'rect',

      /**
       * Array specifying dash pattern of an object's control (hasBorder must be true)
       * @since 1.6.2
       * @type Array
       */
      cornerDashArray:          null,

      /**
       * When true, this object will use center point as the origin of transformation
       * when being scaled via the controls.
       * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
       * @since 1.3.4
       * @type Boolean
       * @default
       */
      centeredScaling:          false,

      /**
       * When true, this object will use center point as the origin of transformation
       * when being rotated via the controls.
       * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
       * @since 1.3.4
       * @type Boolean
       * @default
       */
      centeredRotation:         true,

      /**
       * Color of object's fill
       * takes css colors https://www.w3.org/TR/css-color-3/
       * @type String
       * @default
       */
      fill:                     'rgb(0,0,0)',

      /**
       * Fill rule used to fill an object
       * accepted values are nonzero, evenodd
       * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)
       * @type String
       * @default
       */
      fillRule:                 'nonzero',

      /**
       * Composite rule used for canvas globalCompositeOperation
       * @type String
       * @default
       */
      globalCompositeOperation: 'source-over',

      /**
       * Background color of an object.
       * takes css colors https://www.w3.org/TR/css-color-3/
       * @type String
       * @default
       */
      backgroundColor:          '',

      /**
       * Selection Background color of an object. colored layer behind the object when it is active.
       * does not mix good with globalCompositeOperation methods.
       * @type String
       * @default
       */
      selectionBackgroundColor:          '',

      /**
       * When defined, an object is rendered via stroke and this property specifies its color
       * takes css colors https://www.w3.org/TR/css-color-3/
       * @type String
       * @default
       */
      stroke:                   null,

      /**
       * Width of a stroke used to render this object
       * @type Number
       * @default
       */
      strokeWidth:              1,

      /**
       * Array specifying dash pattern of an object's stroke (stroke must be defined)
       * @type Array
       */
      strokeDashArray:          null,

      /**
       * Line endings style of an object's stroke (one of "butt", "round", "square")
       * @type String
       * @default
       */
      strokeLineCap:            'butt',

      /**
       * Corner style of an object's stroke (one of "bevil", "round", "miter")
       * @type String
       * @default
       */
      strokeLineJoin:           'miter',

      /**
       * Maximum miter length (used for strokeLineJoin = "miter") of an object's stroke
       * @type Number
       * @default
       */
      strokeMiterLimit:         4,

      /**
       * Shadow object representing shadow of this shape
       * @type fabric.Shadow
       * @default
       */
      shadow:                   null,

      /**
       * Opacity of object's controlling borders when object is active and moving
       * @type Number
       * @default
       */
      borderOpacityWhenMoving:  0.4,

      /**
       * Scale factor of object's controlling borders
       * @type Number
       * @default
       */
      borderScaleFactor:        1,

      /**
       * Transform matrix (similar to SVG's transform matrix)
       * @type Array
       */
      transformMatrix:          null,

      /**
       * Minimum allowed scale value of an object
       * @type Number
       * @default
       */
      minScaleLimit:            0,

      /**
       * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).
       * But events still fire on it.
       * @type Boolean
       * @default
       */
      selectable:               true,

      /**
       * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4
       * @type Boolean
       * @default
       */
      evented:                  true,

      /**
       * When set to `false`, an object is not rendered on canvas
       * @type Boolean
       * @default
       */
      visible:                  true,

      /**
       * When set to `false`, object's controls are not displayed and can not be used to manipulate object
       * @type Boolean
       * @default
       */
      hasControls:              true,

      /**
       * When set to `false`, object's controlling borders are not rendered
       * @type Boolean
       * @default
       */
      hasBorders:               true,

      /**
       * When set to `false`, object's controlling rotating point will not be visible or selectable
       * @type Boolean
       * @default
       */
      hasRotatingPoint:         true,

      /**
       * Offset for object's controlling rotating point (when enabled via `hasRotatingPoint`)
       * @type Number
       * @default
       */
      rotatingPointOffset:      40,

      /**
       * When set to `true`, objects are "found" on canvas on per-pixel basis rather than according to bounding box
       * @type Boolean
       * @default
       */
      perPixelTargetFind:       false,

      /**
       * When `false`, default object's values are not included in its serialization
       * @type Boolean
       * @default
       */
      includeDefaultValues:     true,

      /**
       * Function that determines clipping of an object (context is passed as a first argument)
       * Note that context origin is at the object's center point (not left/top corner)
       * @deprecated since 2.0.0
       * @type Function
       */
      clipTo:                   null,

      /**
       * When `true`, object horizontal movement is locked
       * @type Boolean
       * @default
       */
      lockMovementX:            false,

      /**
       * When `true`, object vertical movement is locked
       * @type Boolean
       * @default
       */
      lockMovementY:            false,

      /**
       * When `true`, object rotation is locked
       * @type Boolean
       * @default
       */
      lockRotation:             false,

      /**
       * When `true`, object horizontal scaling is locked
       * @type Boolean
       * @default
       */
      lockScalingX:             false,

      /**
       * When `true`, object vertical scaling is locked
       * @type Boolean
       * @default
       */
      lockScalingY:             false,

      /**
       * When `true`, object non-uniform scaling is locked
       * @type Boolean
       * @default
       */
      lockUniScaling:           false,

      /**
       * When `true`, object horizontal skewing is locked
       * @type Boolean
       * @default
       */
      lockSkewingX:             false,

      /**
       * When `true`, object vertical skewing is locked
       * @type Boolean
       * @default
       */
      lockSkewingY:             false,

      /**
       * When `true`, object cannot be flipped by scaling into negative values
       * @type Boolean
       * @default
       */
      lockScalingFlip:          false,

      /**
       * When `true`, object is not exported in OBJECT/JSON
       * since 1.6.3
       * @type Boolean
       * @default
       */
      excludeFromExport:        false,

      /**
       * When `true`, object is cached on an additional canvas.
       * default to true
       * since 1.7.0
       * @type Boolean
       * @default true
       */
      objectCaching:            objectCaching,

      /**
       * When `true`, object properties are checked for cache invalidation. In some particular
       * situation you may want this to be disabled ( spray brush, very big, groups)
       * or if your application does not allow you to modify properties for groups child you want
       * to disable it for groups.
       * default to false
       * since 1.7.0
       * @type Boolean
       * @default false
       */
      statefullCache:            false,

      /**
       * When `true`, cache does not get updated during scaling. The picture will get blocky if scaled
       * too much and will be redrawn with correct details at the end of scaling.
       * this setting is performance and application dependant.
       * default to true
       * since 1.7.0
       * @type Boolean
       * @default true
       */
      noScaleCache:              true,

      /**
       * When set to `true`, object's cache will be rerendered next render call.
       * since 1.7.0
       * @type Boolean
       * @default true
       */
      dirty:                true,

      /**
       * keeps the value of the last hovered coner during mouse move.
       * 0 is no corner, or 'mt', 'ml', 'mtr' etc..
       * It should be private, but there is no harm in using it as
       * a read-only property.
       * @type number|string|any
       * @default 0
       */
      __corner: 0,

      /**
       * Determins if the fill or the stroke is drawn first (one of "fill" or "stroke")
       * @type String
       * @default
       */
      paintFirst:           'fill',

      /**
       * List of properties to consider when checking if state
       * of an object is changed (fabric.Object#hasStateChanged)
       * as well as for history (undo/redo) purposes
       * @type Array
       */
      stateProperties: (
        'top left width height scaleX scaleY flipX flipY originX originY transformMatrix ' +
        'stroke strokeWidth strokeDashArray strokeLineCap strokeLineJoin strokeMiterLimit ' +
        'angle opacity fill globalCompositeOperation shadow clipTo visible backgroundColor ' +
        'skewX skewY fillRule paintFirst'
      ).split(' '),

      /**
       * List of properties to consider when checking if cache needs refresh
       * @type Array
       */
      cacheProperties: (
        'fill stroke strokeWidth strokeDashArray width height paintFirst' +
        ' strokeLineCap strokeLineJoin strokeMiterLimit backgroundColor'
      ).split(' '),

      /**
       * Constructor
       * @param {Object} [options] Options object
       */
      initialize: function(options) {
        if (options) {
          this.setOptions(options);
        }
      },

      /**
       * Create a the canvas used to keep the cached copy of the object
       * @private
       */
      _createCacheCanvas: function() {
        this._cacheProperties = {};
        this._cacheCanvas = fabric.document.createElement('canvas');
        this._cacheContext = this._cacheCanvas.getContext('2d');
        this._updateCacheCanvas();
        // if canvas gets created, is empty, so dirty.
        this.dirty = true;
      },

      /**
       * Limit the cache dimensions so that X * Y do not cross fabric.perfLimitSizeTotal
       * and each side do not cross fabric.cacheSideLimit
       * those numbers are configurable so that you can get as much detail as you want
       * making bargain with performances.
       * @param {Object} dims
       * @param {Object} dims.width width of canvas
       * @param {Object} dims.height height of canvas
       * @param {Object} dims.zoomX zoomX zoom value to unscale the canvas before drawing cache
       * @param {Object} dims.zoomY zoomY zoom value to unscale the canvas before drawing cache
       * @return {Object}.width width of canvas
       * @return {Object}.height height of canvas
       * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
       * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
       */
      _limitCacheSize: function(dims) {
        var perfLimitSizeTotal = fabric.perfLimitSizeTotal,
            width = dims.width, height = dims.height,
            max = fabric.maxCacheSideLimit, min = fabric.minCacheSideLimit;
        if (width <= max && height <= max && width * height <= perfLimitSizeTotal) {
          if (width < min) {
            dims.width = min;
          }
          if (height < min) {
            dims.height = min;
          }
          return dims;
        }
        var ar = width / height, limitedDims = fabric.util.limitDimsByArea(ar, perfLimitSizeTotal),
            capValue = fabric.util.capValue,
            x = capValue(min, limitedDims.x, max),
            y = capValue(min, limitedDims.y, max);
        if (width > x) {
          dims.zoomX /= width / x;
          dims.width = x;
          dims.capped = true;
        }
        if (height > y) {
          dims.zoomY /= height / y;
          dims.height = y;
          dims.capped = true;
        }
        return dims;
      },

      /**
       * Return the dimension and the zoom level needed to create a cache canvas
       * big enough to host the object to be cached.
       * @private
       * @param {Object} dim.x width of object to be cached
       * @param {Object} dim.y height of object to be cached
       * @return {Object}.width width of canvas
       * @return {Object}.height height of canvas
       * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
       * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
       */
      _getCacheCanvasDimensions: function() {
        var zoom = this.canvas && this.canvas.getZoom() || 1,
            objectScale = this.getObjectScaling(),
            retina = this.canvas && this.canvas._isRetinaScaling() ? fabric.devicePixelRatio : 1,
            dim = this._getNonTransformedDimensions(),
            zoomX = objectScale.scaleX * zoom * retina,
            zoomY = objectScale.scaleY * zoom * retina,
            width = dim.x * zoomX,
            height = dim.y * zoomY;
        return {
          // for sure this ALIASING_LIMIT is slightly crating problem
          // in situation in wich the cache canvas gets an upper limit
          width: width + ALIASING_LIMIT,
          height: height + ALIASING_LIMIT,
          zoomX: zoomX,
          zoomY: zoomY,
          x: dim.x,
          y: dim.y
        };
      },

      /**
       * Update width and height of the canvas for cache
       * returns true or false if canvas needed resize.
       * @private
       * @return {Boolean} true if the canvas has been resized
       */
      _updateCacheCanvas: function() {
        if (this.noScaleCache && this.canvas && this.canvas._currentTransform) {
          var target = this.canvas._currentTransform.target,
              action = this.canvas._currentTransform.action;
          if (this === target && action.slice && action.slice(0, 5) === 'scale') {
            return false;
          }
        }
        var canvas = this._cacheCanvas,
            dims = this._limitCacheSize(this._getCacheCanvasDimensions()),
            minCacheSize = fabric.minCacheSideLimit,
            width = dims.width, height = dims.height, drawingWidth, drawingHeight,
            zoomX = dims.zoomX, zoomY = dims.zoomY,
            dimensionsChanged = width !== this.cacheWidth || height !== this.cacheHeight,
            zoomChanged = this.zoomX !== zoomX || this.zoomY !== zoomY,
            shouldRedraw = dimensionsChanged || zoomChanged,
            additionalWidth = 0, additionalHeight = 0, shouldResizeCanvas = false;
        if (dimensionsChanged) {
          var canvasWidth = this._cacheCanvas.width,
              canvasHeight = this._cacheCanvas.height,
              sizeGrowing = width > canvasWidth || height > canvasHeight,
              sizeShrinking = (width < canvasWidth * 0.9 || height < canvasHeight * 0.9) &&
                canvasWidth > minCacheSize && canvasHeight > minCacheSize;
          shouldResizeCanvas = sizeGrowing || sizeShrinking;
          if (sizeGrowing && !dims.capped && (width > minCacheSize || height > minCacheSize)) {
            additionalWidth = width * 0.1;
            additionalHeight = height * 0.1;
          }
        }
        if (shouldRedraw) {
          if (shouldResizeCanvas) {
            canvas.width = Math.ceil(width + additionalWidth);
            canvas.height = Math.ceil(height + additionalHeight);
          }
          else {
            this._cacheContext.setTransform(1, 0, 0, 1, 0, 0);
            this._cacheContext.clearRect(0, 0, canvas.width, canvas.height);
          }
          drawingWidth = dims.x * zoomX / 2;
          drawingHeight = dims.y * zoomY / 2;
          this.cacheTranslationX = Math.round(canvas.width / 2 - drawingWidth) + drawingWidth;
          this.cacheTranslationY = Math.round(canvas.height / 2 - drawingHeight) + drawingHeight;
          this.cacheWidth = width;
          this.cacheHeight = height;
          this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY);
          this._cacheContext.scale(zoomX, zoomY);
          this.zoomX = zoomX;
          this.zoomY = zoomY;
          return true;
        }
        return false;
      },

      /**
       * Sets object's properties from options
       * @param {Object} [options] Options object
       */
      setOptions: function(options) {
        this._setOptions(options);
        this._initGradient(options.fill, 'fill');
        this._initGradient(options.stroke, 'stroke');
        this._initClipping(options);
        this._initPattern(options.fill, 'fill');
        this._initPattern(options.stroke, 'stroke');
      },

      /**
       * Transforms context when rendering an object
       * @param {CanvasRenderingContext2D} ctx Context
       */
      transform: function(ctx) {
        var m;
        if (this.group && !this.group._transformDone) {
          m = this.calcTransformMatrix();
        }
        else {
          m = this.calcOwnMatrix();
        }
        ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      },

      /**
       * Returns an object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} Object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,

            object = {
              type:                     this.type,
              version:                  fabric.version,
              originX:                  this.originX,
              originY:                  this.originY,
              left:                     toFixed(this.left, NUM_FRACTION_DIGITS),
              top:                      toFixed(this.top, NUM_FRACTION_DIGITS),
              width:                    toFixed(this.width, NUM_FRACTION_DIGITS),
              height:                   toFixed(this.height, NUM_FRACTION_DIGITS),
              fill:                     (this.fill && this.fill.toObject) ? this.fill.toObject() : this.fill,
              stroke:                   (this.stroke && this.stroke.toObject) ? this.stroke.toObject() : this.stroke,
              strokeWidth:              toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),
              strokeDashArray:          this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,
              strokeLineCap:            this.strokeLineCap,
              strokeLineJoin:           this.strokeLineJoin,
              strokeMiterLimit:         toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),
              scaleX:                   toFixed(this.scaleX, NUM_FRACTION_DIGITS),
              scaleY:                   toFixed(this.scaleY, NUM_FRACTION_DIGITS),
              angle:                    toFixed(this.angle, NUM_FRACTION_DIGITS),
              flipX:                    this.flipX,
              flipY:                    this.flipY,
              opacity:                  toFixed(this.opacity, NUM_FRACTION_DIGITS),
              shadow:                   (this.shadow && this.shadow.toObject) ? this.shadow.toObject() : this.shadow,
              visible:                  this.visible,
              clipTo:                   this.clipTo && String(this.clipTo),
              backgroundColor:          this.backgroundColor,
              fillRule:                 this.fillRule,
              paintFirst:               this.paintFirst,
              globalCompositeOperation: this.globalCompositeOperation,
              transformMatrix:          this.transformMatrix ? this.transformMatrix.concat() : null,
              skewX:                    toFixed(this.skewX, NUM_FRACTION_DIGITS),
              skewY:                    toFixed(this.skewY, NUM_FRACTION_DIGITS)
            };

        fabric.util.populateWithProperties(this, object, propertiesToInclude);
        if (!this.includeDefaultValues) {
          object = this._removeDefaultValues(object);
        }

        return object;
      },

      /**
       * Returns (dataless) object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} Object representation of an instance
       */
      toDatalessObject: function(propertiesToInclude) {
        // will be overwritten by subclasses
        return this.toObject(propertiesToInclude);
      },

      /**
       * @private
       * @param {Object} object
       */
      _removeDefaultValues: function(object) {
        var prototype = fabric.util.getKlass(object.type).prototype,
            stateProperties = prototype.stateProperties;
        stateProperties.forEach(function(prop) {
          if (object[prop] === prototype[prop]) {
            delete object[prop];
          }
          var isArray = Object.prototype.toString.call(object[prop]) === '[object Array]' &&
                        Object.prototype.toString.call(prototype[prop]) === '[object Array]';

          // basically a check for [] === []
          if (isArray && object[prop].length === 0 && prototype[prop].length === 0) {
            delete object[prop];
          }
        });

        return object;
      },

      /**
       * Returns a string representation of an instance
       * @return {String}
       */
      toString: function() {
        return '#<fabric.' + capitalize(this.type) + '>';
      },

      /**
       * Return the object scale factor counting also the group scaling
       * @return {Object} object with scaleX and scaleY properties
       */
      getObjectScaling: function() {
        var scaleX = this.scaleX, scaleY = this.scaleY;
        if (this.group) {
          var scaling = this.group.getObjectScaling();
          scaleX *= scaling.scaleX;
          scaleY *= scaling.scaleY;
        }
        return { scaleX: scaleX, scaleY: scaleY };
      },

      /**
       * Return the object opacity counting also the group property
       * @return {Number}
       */
      getObjectOpacity: function() {
        var opacity = this.opacity;
        if (this.group) {
          opacity *= this.group.getObjectOpacity();
        }
        return opacity;
      },

      /**
       * @private
       * @param {String} key
       * @param {*} value
       * @return {fabric.Object} thisArg
       */
      _set: function(key, value) {
        var shouldConstrainValue = (key === 'scaleX' || key === 'scaleY'),
            isChanged = this[key] !== value, groupNeedsUpdate = false;

        if (shouldConstrainValue) {
          value = this._constrainScale(value);
        }
        if (key === 'scaleX' && value < 0) {
          this.flipX = !this.flipX;
          value *= -1;
        }
        else if (key === 'scaleY' && value < 0) {
          this.flipY = !this.flipY;
          value *= -1;
        }
        else if (key === 'shadow' && value && !(value instanceof fabric.Shadow)) {
          value = new fabric.Shadow(value);
        }
        else if (key === 'dirty' && this.group) {
          this.group.set('dirty', value);
        }

        this[key] = value;

        if (isChanged) {
          groupNeedsUpdate = this.group && this.group.isOnACache();
          if (this.cacheProperties.indexOf(key) > -1) {
            this.dirty = true;
            groupNeedsUpdate && this.group.set('dirty', true);
          }
          else if (groupNeedsUpdate && this.stateProperties.indexOf(key) > -1) {
            this.group.set('dirty', true);
          }
        }

        return this;
      },

      /**
       * This callback function is called by the parent group of an object every
       * time a non-delegated property changes on the group. It is passed the key
       * and value as parameters. Not adding in this function's signature to avoid
       * Travis build error about unused variables.
       */
      setOnGroup: function() {
        // implemented by sub-classes, as needed.
      },

      /**
       * Retrieves viewportTransform from Object's canvas if possible
       * @method getViewportTransform
       * @memberOf fabric.Object.prototype
       * @return {Boolean}
       */
      getViewportTransform: function() {
        if (this.canvas && this.canvas.viewportTransform) {
          return this.canvas.viewportTransform;
        }
        return fabric.iMatrix.concat();
      },

      /*
       * @private
       * return if the object would be visible in rendering
       * @memberOf fabric.Object.prototype
       * @return {Boolean}
       */
      isNotVisible: function() {
        return this.opacity === 0 || (this.width === 0 && this.height === 0) || !this.visible;
      },

      /**
       * Renders an object on a specified context
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      render: function(ctx) {
        // do not render if width/height are zeros or object is not visible
        if (this.isNotVisible()) {
          return;
        }
        if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
          return;
        }
        ctx.save();
        this._setupCompositeOperation(ctx);
        this.drawSelectionBackground(ctx);
        this.transform(ctx);
        this._setOpacity(ctx);
        this._setShadow(ctx, this);
        if (this.transformMatrix) {
          ctx.transform.apply(ctx, this.transformMatrix);
        }
        this.clipTo && fabric.util.clipContext(this, ctx);
        if (this.shouldCache()) {
          if (!this._cacheCanvas) {
            this._createCacheCanvas();

          }
          if (this.isCacheDirty()) {
            this.statefullCache && this.saveState({ propertySet: 'cacheProperties' });
            this.drawObject(this._cacheContext);
            this.dirty = false;
          }
          this.drawCacheOnCanvas(ctx);
        }
        else {
          this._removeCacheCanvas();
          this.dirty = false;
          this.drawObject(ctx);
          if (this.objectCaching && this.statefullCache) {
            this.saveState({ propertySet: 'cacheProperties' });
          }
        }
        this.clipTo && ctx.restore();
        ctx.restore();
      },

      /**
       * Remove cacheCanvas and its dimensions from the objects
       */
      _removeCacheCanvas: function() {
        this._cacheCanvas = null;
        this.cacheWidth = 0;
        this.cacheHeight = 0;
      },

      /**
       * When set to `true`, force the object to have its own cache, even if it is inside a group
       * it may be needed when your object behave in a particular way on the cache and always needs
       * its own isolated canvas to render correctly.
       * Created to be overridden
       * since 1.7.12
       * @returns false
       */
      needsItsOwnCache: function() {
        if (this.paintFirst === 'stroke' && typeof this.shadow === 'object') {
          return true;
        }
        return false;
      },

      /**
       * Decide if the object should cache or not. Create its own cache level
       * objectCaching is a global flag, wins over everything
       * needsItsOwnCache should be used when the object drawing method requires
       * a cache step. None of the fabric classes requires it.
       * Generally you do not cache objects in groups because the group outside is cached.
       * @return {Boolean}
       */
      shouldCache: function() {
        this.ownCaching = this.objectCaching &&
        (!this.group || this.needsItsOwnCache() || !this.group.isOnACache());
        return this.ownCaching;
      },

      /**
       * Check if this object or a child object will cast a shadow
       * used by Group.shouldCache to know if child has a shadow recursively
       * @return {Boolean}
       */
      willDrawShadow: function() {
        return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
      },

      /**
       * Execute the drawing operation for an object on a specified context
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      drawObject: function(ctx) {
        this._renderBackground(ctx);
        this._setStrokeStyles(ctx, this);
        this._setFillStyles(ctx, this);
        this._render(ctx);
      },

      /**
       * Paint the cached copy of the object on the target context.
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      drawCacheOnCanvas: function(ctx) {
        ctx.scale(1 / this.zoomX, 1 / this.zoomY);
        ctx.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
      },

      /**
       * Check if cache is dirty
       * @param {Boolean} skipCanvas skip canvas checks because this object is painted
       * on parent canvas.
       */
      isCacheDirty: function(skipCanvas) {
        if (this.isNotVisible()) {
          return false;
        }
        if (this._cacheCanvas && !skipCanvas && this._updateCacheCanvas()) {
          // in this case the context is already cleared.
          return true;
        }
        else {
          if (this.dirty || (this.statefullCache && this.hasStateChanged('cacheProperties'))) {
            if (this._cacheCanvas && !skipCanvas) {
              var width = this.cacheWidth / this.zoomX;
              var height = this.cacheHeight / this.zoomY;
              this._cacheContext.clearRect(-width / 2, -height / 2, width, height);
            }
            return true;
          }
        }
        return false;
      },

      /**
       * Draws a background for the object big as its untrasformed dimensions
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderBackground: function(ctx) {
        if (!this.backgroundColor) {
          return;
        }
        var dim = this._getNonTransformedDimensions();
        ctx.fillStyle = this.backgroundColor;

        ctx.fillRect(
          -dim.x / 2,
          -dim.y / 2,
          dim.x,
          dim.y
        );
        // if there is background color no other shadows
        // should be casted
        this._removeShadow(ctx);
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _setOpacity: function(ctx) {
        if (this.group && !this.group._transformDone) {
          ctx.globalAlpha = this.getObjectOpacity();
        }
        else {
          ctx.globalAlpha *= this.opacity;
        }
      },

      _setStrokeStyles: function(ctx, decl) {
        if (decl.stroke) {
          ctx.lineWidth = decl.strokeWidth;
          ctx.lineCap = decl.strokeLineCap;
          ctx.lineJoin = decl.strokeLineJoin;
          ctx.miterLimit = decl.strokeMiterLimit;
          ctx.strokeStyle = decl.stroke.toLive
            ? decl.stroke.toLive(ctx, this)
            : decl.stroke;
        }
      },

      _setFillStyles: function(ctx, decl) {
        if (decl.fill) {
          ctx.fillStyle = decl.fill.toLive
            ? decl.fill.toLive(ctx, this)
            : decl.fill;
        }
      },

      /**
       * @private
       * Sets line dash
       * @param {CanvasRenderingContext2D} ctx Context to set the dash line on
       * @param {Array} dashArray array representing dashes
       * @param {Function} alternative function to call if browaser does not support lineDash
       */
      _setLineDash: function(ctx, dashArray, alternative) {
        if (!dashArray) {
          return;
        }
        // Spec requires the concatenation of two copies the dash list when the number of elements is odd
        if (1 & dashArray.length) {
          dashArray.push.apply(dashArray, dashArray);
        }
        if (supportsLineDash) {
          ctx.setLineDash(dashArray);
        }
        else {
          alternative && alternative(ctx);
        }
      },

      /**
       * Renders controls and borders for the object
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {Object} [styleOverride] properties to override the object style
       */
      _renderControls: function(ctx, styleOverride) {
        var vpt = this.getViewportTransform(),
            matrix = this.calcTransformMatrix(),
            options, drawBorders, drawControls;
        styleOverride = styleOverride || { };
        drawBorders = typeof styleOverride.hasBorders !== 'undefined' ? styleOverride.hasBorders : this.hasBorders;
        drawControls = typeof styleOverride.hasControls !== 'undefined' ? styleOverride.hasControls : this.hasControls;
        matrix = fabric.util.multiplyTransformMatrices(vpt, matrix);
        options = fabric.util.qrDecompose(matrix);
        ctx.save();
        ctx.translate(options.translateX, options.translateY);
        ctx.lineWidth = 1 * this.borderScaleFactor;
        if (!this.group) {
          ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
        }
        if (styleOverride.forActiveSelection) {
          ctx.rotate(degreesToRadians(options.angle));
          drawBorders && this.drawBordersInGroup(ctx, options, styleOverride);
        }
        else {
          ctx.rotate(degreesToRadians(this.angle));
          drawBorders && this.drawBorders(ctx, styleOverride);
        }
        drawControls && this.drawControls(ctx, styleOverride);
        ctx.restore();
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _setShadow: function(ctx) {
        if (!this.shadow) {
          return;
        }

        var multX = (this.canvas && this.canvas.viewportTransform[0]) || 1,
            multY = (this.canvas && this.canvas.viewportTransform[3]) || 1,
            scaling = this.getObjectScaling();
        if (this.canvas && this.canvas._isRetinaScaling()) {
          multX *= fabric.devicePixelRatio;
          multY *= fabric.devicePixelRatio;
        }
        ctx.shadowColor = this.shadow.color;
        ctx.shadowBlur = this.shadow.blur * fabric.browserShadowBlurConstant *
          (multX + multY) * (scaling.scaleX + scaling.scaleY) / 4;
        ctx.shadowOffsetX = this.shadow.offsetX * multX * scaling.scaleX;
        ctx.shadowOffsetY = this.shadow.offsetY * multY * scaling.scaleY;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _removeShadow: function(ctx) {
        if (!this.shadow) {
          return;
        }

        ctx.shadowColor = '';
        ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {Object} filler fabric.Pattern or fabric.Gradient
       */
      _applyPatternGradientTransform: function(ctx, filler) {
        if (!filler || !filler.toLive) {
          return { offsetX: 0, offsetY: 0 };
        }
        var t = filler.gradientTransform || filler.patternTransform;
        var offsetX = -this.width / 2 + filler.offsetX || 0,
            offsetY = -this.height / 2 + filler.offsetY || 0;
        ctx.translate(offsetX, offsetY);
        if (t) {
          ctx.transform(t[0], t[1], t[2], t[3], t[4], t[5]);
        }
        return { offsetX: offsetX, offsetY: offsetY };
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderPaintInOrder: function(ctx) {
        if (this.paintFirst === 'stroke') {
          this._renderStroke(ctx);
          this._renderFill(ctx);
        }
        else {
          this._renderFill(ctx);
          this._renderStroke(ctx);
        }
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderFill: function(ctx) {
        if (!this.fill) {
          return;
        }

        ctx.save();
        this._applyPatternGradientTransform(ctx, this.fill);
        if (this.fillRule === 'evenodd') {
          ctx.fill('evenodd');
        }
        else {
          ctx.fill();
        }
        ctx.restore();
      },

      _renderStroke: function(ctx) {
        if (!this.stroke || this.strokeWidth === 0) {
          return;
        }

        if (this.shadow && !this.shadow.affectStroke) {
          this._removeShadow(ctx);
        }

        ctx.save();
        this._setLineDash(ctx, this.strokeDashArray, this._renderDashedStroke);
        this._applyPatternGradientTransform(ctx, this.stroke);
        ctx.stroke();
        ctx.restore();
      },

      /**
       * This function is an helper for svg import. it returns the center of the object in the svg
       * untransformed coordinates
       * @private
       * @return {Object} center point from element coordinates
       */
      _findCenterFromElement: function() {
        return { x: this.left + this.width / 2, y: this.top + this.height / 2 };
      },

      /**
       * This function is an helper for svg import. it decoompose the transformMatrix
       * and assign properties to object.
       * untransformed coordinates
       * @private
       * @chainable
       */
      _assignTransformMatrixProps: function() {
        if (this.transformMatrix) {
          var options = fabric.util.qrDecompose(this.transformMatrix);
          this.flipX = false;
          this.flipY = false;
          this.set('scaleX', options.scaleX);
          this.set('scaleY', options.scaleY);
          this.angle = options.angle;
          this.skewX = options.skewX;
          this.skewY = 0;
        }
      },

      /**
       * This function is an helper for svg import. it removes the transform matrix
       * and set to object properties that fabricjs can handle
       * @private
       * @param {Object} preserveAspectRatioOptions
       * @return {thisArg}
       */
      _removeTransformMatrix: function(preserveAspectRatioOptions) {
        var center = this._findCenterFromElement();
        if (this.transformMatrix) {
          this._assignTransformMatrixProps();
          center = fabric.util.transformPoint(center, this.transformMatrix);
        }
        this.transformMatrix = null;
        if (preserveAspectRatioOptions) {
          this.scaleX *= preserveAspectRatioOptions.scaleX;
          this.scaleY *= preserveAspectRatioOptions.scaleY;
          this.cropX = preserveAspectRatioOptions.cropX;
          this.cropY = preserveAspectRatioOptions.cropY;
          center.x += preserveAspectRatioOptions.offsetLeft;
          center.y += preserveAspectRatioOptions.offsetTop;
          this.width = preserveAspectRatioOptions.width;
          this.height = preserveAspectRatioOptions.height;
        }
        this.setPositionByOrigin(center, 'center', 'center');
      },

      /**
       * Clones an instance, using a callback method will work for every object.
       * @param {Function} callback Callback is invoked with a clone as a first argument
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       */
      clone: function(callback, propertiesToInclude) {
        var objectForm = this.toObject(propertiesToInclude);
        if (this.constructor.fromObject) {
          this.constructor.fromObject(objectForm, callback);
        }
        else {
          fabric.Object._fromObject('Object', objectForm, callback);
        }
      },

      /**
       * Creates an instance of fabric.Image out of an object
       * @param {Function} callback callback, invoked with an instance as a first argument
       * @param {Object} [options] for clone as image, passed to toDataURL
       * @param {Boolean} [options.enableRetinaScaling] enable retina scaling for the cloned image
       * @return {fabric.Object} thisArg
       */
      cloneAsImage: function(callback, options) {
        var dataUrl = this.toDataURL(options);
        fabric.util.loadImage(dataUrl, function(img) {
          if (callback) {
            callback(new fabric.Image(img));
          }
        });
        return this;
      },

      /**
       * Converts an object into a data-url-like string
       * @param {Object} options Options object
       * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
       * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
       * @param {Number} [options.multiplier=1] Multiplier to scale by
       * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
       * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
       * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
       * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
       * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
       * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
       */
      toDataURL: function(options) {
        options || (options = { });

        var el = fabric.util.createCanvasElement(),
            boundingRect = this.getBoundingRect();

        el.width = boundingRect.width;
        el.height = boundingRect.height;
        fabric.util.wrapElement(el, 'div');
        var canvas = new fabric.StaticCanvas(el, {
          enableRetinaScaling: options.enableRetinaScaling,
          renderOnAddRemove: false,
          skipOffscreen: false,
        });
        // to avoid common confusion https://github.com/kangax/fabric.js/issues/806
        if (options.format === 'jpg') {
          options.format = 'jpeg';
        }

        if (options.format === 'jpeg') {
          canvas.backgroundColor = '#fff';
        }

        var origParams = {
          left: this.left,
          top: this.top
        };

        this.setPositionByOrigin(new fabric.Point(canvas.width / 2, canvas.height / 2), 'center', 'center');

        var originalCanvas = this.canvas;
        canvas.add(this);
        var data = canvas.toDataURL(options);
        this.set(origParams).setCoords();
        this.canvas = originalCanvas;
        // canvas.dispose will call image.dispose that will nullify the elements
        // since this canvas is a simple element for the process, we remove references
        // to objects in this way in order to avoid object trashing.
        canvas._objects = [];
        canvas.dispose();
        canvas = null;

        return data;
      },

      /**
       * Returns true if specified type is identical to the type of an instance
       * @param {String} type Type to check against
       * @return {Boolean}
       */
      isType: function(type) {
        return this.type === type;
      },

      /**
       * Returns complexity of an instance
       * @return {Number} complexity of this instance (is 1 unless subclassed)
       */
      complexity: function() {
        return 1;
      },

      /**
       * Returns a JSON representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} JSON
       */
      toJSON: function(propertiesToInclude) {
        // delegate, not alias
        return this.toObject(propertiesToInclude);
      },

      /**
       * Sets gradient (fill or stroke) of an object
       * <b>Backwards incompatibility note:</b> This method was named "setGradientFill" until v1.1.0
       * @param {String} property Property name 'stroke' or 'fill'
       * @param {Object} [options] Options object
       * @param {String} [options.type] Type of gradient 'radial' or 'linear'
       * @param {Number} [options.x1=0] x-coordinate of start point
       * @param {Number} [options.y1=0] y-coordinate of start point
       * @param {Number} [options.x2=0] x-coordinate of end point
       * @param {Number} [options.y2=0] y-coordinate of end point
       * @param {Number} [options.r1=0] Radius of start point (only for radial gradients)
       * @param {Number} [options.r2=0] Radius of end point (only for radial gradients)
       * @param {Object} [options.colorStops] Color stops object eg. {0: 'ff0000', 1: '000000'}
       * @param {Object} [options.gradientTransform] transforMatrix for gradient
       * @return {fabric.Object} thisArg
       * @chainable
       * @see {@link http://jsfiddle.net/fabricjs/58y8b/|jsFiddle demo}
       * @example <caption>Set linear gradient</caption>
       * object.setGradient('fill', {
       *   type: 'linear',
       *   x1: -object.width / 2,
       *   y1: 0,
       *   x2: object.width / 2,
       *   y2: 0,
       *   colorStops: {
       *     0: 'red',
       *     0.5: '#005555',
       *     1: 'rgba(0,0,255,0.5)'
       *   }
       * });
       * canvas.renderAll();
       * @example <caption>Set radial gradient</caption>
       * object.setGradient('fill', {
       *   type: 'radial',
       *   x1: 0,
       *   y1: 0,
       *   x2: 0,
       *   y2: 0,
       *   r1: object.width / 2,
       *   r2: 10,
       *   colorStops: {
       *     0: 'red',
       *     0.5: '#005555',
       *     1: 'rgba(0,0,255,0.5)'
       *   }
       * });
       * canvas.renderAll();
       */
      setGradient: function(property, options) {
        options || (options = { });

        var gradient = { colorStops: [] };

        gradient.type = options.type || (options.r1 || options.r2 ? 'radial' : 'linear');
        gradient.coords = {
          x1: options.x1,
          y1: options.y1,
          x2: options.x2,
          y2: options.y2
        };

        if (options.r1 || options.r2) {
          gradient.coords.r1 = options.r1;
          gradient.coords.r2 = options.r2;
        }

        gradient.gradientTransform = options.gradientTransform;
        fabric.Gradient.prototype.addColorStop.call(gradient, options.colorStops);

        return this.set(property, fabric.Gradient.forObject(this, gradient));
      },

      /**
       * Sets pattern fill of an object
       * @param {Object} options Options object
       * @param {(String|HTMLImageElement)} options.source Pattern source
       * @param {String} [options.repeat=repeat] Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
       * @param {Number} [options.offsetX=0] Pattern horizontal offset from object's left/top corner
       * @param {Number} [options.offsetY=0] Pattern vertical offset from object's left/top corner
       * @return {fabric.Object} thisArg
       * @chainable
       * @see {@link http://jsfiddle.net/fabricjs/QT3pa/|jsFiddle demo}
       * @example <caption>Set pattern</caption>
       * fabric.util.loadImage('http://fabricjs.com/assets/escheresque_ste.png', function(img) {
       *   object.setPatternFill({
       *     source: img,
       *     repeat: 'repeat'
       *   });
       *   canvas.renderAll();
       * });
       */
      setPatternFill: function(options) {
        return this.set('fill', new fabric.Pattern(options));
      },

      /**
       * Sets {@link fabric.Object#shadow|shadow} of an object
       * @param {Object|String} [options] Options object or string (e.g. "2px 2px 10px rgba(0,0,0,0.2)")
       * @param {String} [options.color=rgb(0,0,0)] Shadow color
       * @param {Number} [options.blur=0] Shadow blur
       * @param {Number} [options.offsetX=0] Shadow horizontal offset
       * @param {Number} [options.offsetY=0] Shadow vertical offset
       * @return {fabric.Object} thisArg
       * @chainable
       * @see {@link http://jsfiddle.net/fabricjs/7gvJG/|jsFiddle demo}
       * @example <caption>Set shadow with string notation</caption>
       * object.setShadow('2px 2px 10px rgba(0,0,0,0.2)');
       * canvas.renderAll();
       * @example <caption>Set shadow with object notation</caption>
       * object.setShadow({
       *   color: 'red',
       *   blur: 10,
       *   offsetX: 20,
       *   offsetY: 20
       * });
       * canvas.renderAll();
       */
      setShadow: function(options) {
        return this.set('shadow', options ? new fabric.Shadow(options) : null);
      },

      /**
       * Sets "color" of an instance (alias of `set('fill', &hellip;)`)
       * @param {String} color Color value
       * @return {fabric.Object} thisArg
       * @chainable
       */
      setColor: function(color) {
        this.set('fill', color);
        return this;
      },

      /**
       * Sets "angle" of an instance with centered rotation
       * @param {Number} angle Angle value (in degrees)
       * @return {fabric.Object} thisArg
       * @chainable
       */
      rotate: function(angle) {
        var shouldCenterOrigin = (this.originX !== 'center' || this.originY !== 'center') && this.centeredRotation;

        if (shouldCenterOrigin) {
          this._setOriginToCenter();
        }

        this.set('angle', angle);

        if (shouldCenterOrigin) {
          this._resetOrigin();
        }

        return this;
      },

      /**
       * Centers object horizontally on canvas to which it was added last.
       * You might need to call `setCoords` on an object after centering, to update controls area.
       * @return {fabric.Object} thisArg
       * @chainable
       */
      centerH: function () {
        this.canvas && this.canvas.centerObjectH(this);
        return this;
      },

      /**
       * Centers object horizontally on current viewport of canvas to which it was added last.
       * You might need to call `setCoords` on an object after centering, to update controls area.
       * @return {fabric.Object} thisArg
       * @chainable
       */
      viewportCenterH: function () {
        this.canvas && this.canvas.viewportCenterObjectH(this);
        return this;
      },

      /**
       * Centers object vertically on canvas to which it was added last.
       * You might need to call `setCoords` on an object after centering, to update controls area.
       * @return {fabric.Object} thisArg
       * @chainable
       */
      centerV: function () {
        this.canvas && this.canvas.centerObjectV(this);
        return this;
      },

      /**
       * Centers object vertically on current viewport of canvas to which it was added last.
       * You might need to call `setCoords` on an object after centering, to update controls area.
       * @return {fabric.Object} thisArg
       * @chainable
       */
      viewportCenterV: function () {
        this.canvas && this.canvas.viewportCenterObjectV(this);
        return this;
      },

      /**
       * Centers object vertically and horizontally on canvas to which is was added last
       * You might need to call `setCoords` on an object after centering, to update controls area.
       * @return {fabric.Object} thisArg
       * @chainable
       */
      center: function () {
        this.canvas && this.canvas.centerObject(this);
        return this;
      },

      /**
       * Centers object on current viewport of canvas to which it was added last.
       * You might need to call `setCoords` on an object after centering, to update controls area.
       * @return {fabric.Object} thisArg
       * @chainable
       */
      viewportCenter: function () {
        this.canvas && this.canvas.viewportCenterObject(this);
        return this;
      },

      /**
       * Returns coordinates of a pointer relative to an object
       * @param {Event} e Event to operate upon
       * @param {Object} [pointer] Pointer to operate upon (instead of event)
       * @return {Object} Coordinates of a pointer (x, y)
       */
      getLocalPointer: function(e, pointer) {
        pointer = pointer || this.canvas.getPointer(e);
        var pClicked = new fabric.Point(pointer.x, pointer.y),
            objectLeftTop = this._getLeftTopCoords();
        if (this.angle) {
          pClicked = fabric.util.rotatePoint(
            pClicked, objectLeftTop, degreesToRadians(-this.angle));
        }
        return {
          x: pClicked.x - objectLeftTop.x,
          y: pClicked.y - objectLeftTop.y
        };
      },

      /**
       * Sets canvas globalCompositeOperation for specific object
       * custom composition operation for the particular object can be specifed using globalCompositeOperation property
       * @param {CanvasRenderingContext2D} ctx Rendering canvas context
       */
      _setupCompositeOperation: function (ctx) {
        if (this.globalCompositeOperation) {
          ctx.globalCompositeOperation = this.globalCompositeOperation;
        }
      }
    });

    fabric.util.createAccessors && fabric.util.createAccessors(fabric.Object);

    extend(fabric.Object.prototype, fabric.Observable);

    /**
     * Defines the number of fraction digits to use when serializing object values.
     * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.
     * @static
     * @memberOf fabric.Object
     * @constant
     * @type Number
     */
    fabric.Object.NUM_FRACTION_DIGITS = 2;

    fabric.Object._fromObject = function(className, object, callback, extraParam) {
      var klass = fabric[className];
      object = clone(object, true);
      fabric.util.enlivenPatterns([object.fill, object.stroke], function(patterns) {
        if (typeof patterns[0] !== 'undefined') {
          object.fill = patterns[0];
        }
        if (typeof patterns[1] !== 'undefined') {
          object.stroke = patterns[1];
        }
        var instance = extraParam ? new klass(object[extraParam], object) : new klass(object);
        callback && callback(instance);
      });
    };

    /**
     * Unique id used internally when creating SVG elements
     * @static
     * @memberOf fabric.Object
     * @type Number
     */
    fabric.Object.__uid = 0;

  })(exports);


  (function() {

    var degreesToRadians = fabric.util.degreesToRadians,
        originXOffset = {
          left: -0.5,
          center: 0,
          right: 0.5
        },
        originYOffset = {
          top: -0.5,
          center: 0,
          bottom: 0.5
        };

    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

      /**
       * Translates the coordinates from a set of origin to another (based on the object's dimensions)
       * @param {fabric.Point} point The point which corresponds to the originX and originY params
       * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'
       * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'
       * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'
       * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'
       * @return {fabric.Point}
       */
      translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {
        var x = point.x,
            y = point.y,
            offsetX, offsetY, dim;

        if (typeof fromOriginX === 'string') {
          fromOriginX = originXOffset[fromOriginX];
        }
        else {
          fromOriginX -= 0.5;
        }

        if (typeof toOriginX === 'string') {
          toOriginX = originXOffset[toOriginX];
        }
        else {
          toOriginX -= 0.5;
        }

        offsetX = toOriginX - fromOriginX;

        if (typeof fromOriginY === 'string') {
          fromOriginY = originYOffset[fromOriginY];
        }
        else {
          fromOriginY -= 0.5;
        }

        if (typeof toOriginY === 'string') {
          toOriginY = originYOffset[toOriginY];
        }
        else {
          toOriginY -= 0.5;
        }

        offsetY = toOriginY - fromOriginY;

        if (offsetX || offsetY) {
          dim = this._getTransformedDimensions();
          x = point.x + offsetX * dim.x;
          y = point.y + offsetY * dim.y;
        }

        return new fabric.Point(x, y);
      },

      /**
       * Translates the coordinates from origin to center coordinates (based on the object's dimensions)
       * @param {fabric.Point} point The point which corresponds to the originX and originY params
       * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
       * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
       * @return {fabric.Point}
       */
      translateToCenterPoint: function(point, originX, originY) {
        var p = this.translateToGivenOrigin(point, originX, originY, 'center', 'center');
        if (this.angle) {
          return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));
        }
        return p;
      },

      /**
       * Translates the coordinates from center to origin coordinates (based on the object's dimensions)
       * @param {fabric.Point} center The point which corresponds to center of the object
       * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
       * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
       * @return {fabric.Point}
       */
      translateToOriginPoint: function(center, originX, originY) {
        var p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
        if (this.angle) {
          return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));
        }
        return p;
      },

      /**
       * Returns the real center coordinates of the object
       * @return {fabric.Point}
       */
      getCenterPoint: function() {
        var leftTop = new fabric.Point(this.left, this.top);
        return this.translateToCenterPoint(leftTop, this.originX, this.originY);
      },

      /**
       * Returns the coordinates of the object based on center coordinates
       * @param {fabric.Point} point The point which corresponds to the originX and originY params
       * @return {fabric.Point}
       */
      // getOriginPoint: function(center) {
      //   return this.translateToOriginPoint(center, this.originX, this.originY);
      // },

      /**
       * Returns the coordinates of the object as if it has a different origin
       * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
       * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
       * @return {fabric.Point}
       */
      getPointByOrigin: function(originX, originY) {
        var center = this.getCenterPoint();
        return this.translateToOriginPoint(center, originX, originY);
      },

      /**
       * Returns the point in local coordinates
       * @param {fabric.Point} point The point relative to the global coordinate system
       * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
       * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
       * @return {fabric.Point}
       */
      toLocalPoint: function(point, originX, originY) {
        var center = this.getCenterPoint(),
            p, p2;

        if (typeof originX !== 'undefined' && typeof originY !== 'undefined' ) {
          p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
        }
        else {
          p = new fabric.Point(this.left, this.top);
        }

        p2 = new fabric.Point(point.x, point.y);
        if (this.angle) {
          p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));
        }
        return p2.subtractEquals(p);
      },

      /**
       * Returns the point in global coordinates
       * @param {fabric.Point} The point relative to the local coordinate system
       * @return {fabric.Point}
       */
      // toGlobalPoint: function(point) {
      //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));
      // },

      /**
       * Sets the position of the object taking into consideration the object's origin
       * @param {fabric.Point} pos The new position of the object
       * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
       * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
       * @return {void}
       */
      setPositionByOrigin: function(pos, originX, originY) {
        var center = this.translateToCenterPoint(pos, originX, originY),
            position = this.translateToOriginPoint(center, this.originX, this.originY);
        this.set('left', position.x);
        this.set('top', position.y);
      },

      /**
       * @param {String} to One of 'left', 'center', 'right'
       */
      adjustPosition: function(to) {
        var angle = degreesToRadians(this.angle),
            hypotFull = this.getScaledWidth(),
            xFull = fabric.util.cos(angle) * hypotFull,
            yFull = fabric.util.sin(angle) * hypotFull,
            offsetFrom, offsetTo;

        //TODO: this function does not consider mixed situation like top, center.
        if (typeof this.originX === 'string') {
          offsetFrom = originXOffset[this.originX];
        }
        else {
          offsetFrom = this.originX - 0.5;
        }
        if (typeof to === 'string') {
          offsetTo = originXOffset[to];
        }
        else {
          offsetTo = to - 0.5;
        }
        this.left += xFull * (offsetTo - offsetFrom);
        this.top += yFull * (offsetTo - offsetFrom);
        this.setCoords();
        this.originX = to;
      },

      /**
       * Sets the origin/position of the object to it's center point
       * @private
       * @return {void}
       */
      _setOriginToCenter: function() {
        this._originalOriginX = this.originX;
        this._originalOriginY = this.originY;

        var center = this.getCenterPoint();

        this.originX = 'center';
        this.originY = 'center';

        this.left = center.x;
        this.top = center.y;
      },

      /**
       * Resets the origin/position of the object to it's original origin
       * @private
       * @return {void}
       */
      _resetOrigin: function() {
        var originPoint = this.translateToOriginPoint(
          this.getCenterPoint(),
          this._originalOriginX,
          this._originalOriginY);

        this.originX = this._originalOriginX;
        this.originY = this._originalOriginY;

        this.left = originPoint.x;
        this.top = originPoint.y;

        this._originalOriginX = null;
        this._originalOriginY = null;
      },

      /**
       * @private
       */
      _getLeftTopCoords: function() {
        return this.translateToOriginPoint(this.getCenterPoint(), 'left', 'top');
      },
    });

  })();


  (function() {

    function getCoords(coords) {
      return [
        new fabric.Point(coords.tl.x, coords.tl.y),
        new fabric.Point(coords.tr.x, coords.tr.y),
        new fabric.Point(coords.br.x, coords.br.y),
        new fabric.Point(coords.bl.x, coords.bl.y)
      ];
    }

    var degreesToRadians = fabric.util.degreesToRadians,
        multiplyMatrices = fabric.util.multiplyTransformMatrices,
        transformPoint = fabric.util.transformPoint;

    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

      /**
       * Describe object's corner position in canvas element coordinates.
       * properties are tl,mt,tr,ml,mr,bl,mb,br,mtr for the main controls.
       * each property is an object with x, y and corner.
       * The `corner` property contains in a similar manner the 4 points of the
       * interactive area of the corner.
       * The coordinates depends from this properties: width, height, scaleX, scaleY
       * skewX, skewY, angle, strokeWidth, viewportTransform, top, left, padding.
       * The coordinates get updated with @method setCoords.
       * You can calculate them without updating with @method calcCoords;
       * @memberOf fabric.Object.prototype
       */
      oCoords: null,

      /**
       * Describe object's corner position in canvas object absolute coordinates
       * properties are tl,tr,bl,br and describe the four main corner.
       * each property is an object with x, y, instance of Fabric.Point.
       * The coordinates depends from this properties: width, height, scaleX, scaleY
       * skewX, skewY, angle, strokeWidth, top, left.
       * Those coordinates are usefull to understand where an object is. They get updated
       * with oCoords but they do not need to be updated when zoom or panning change.
       * The coordinates get updated with @method setCoords.
       * You can calculate them without updating with @method calcCoords(true);
       * @memberOf fabric.Object.prototype
       */
      aCoords: null,

      /**
       * storage for object transform matrix
       */
      ownMatrixCache: null,

      /**
       * storage for object full transform matrix
       */
      matrixCache: null,

      /**
       * return correct set of coordinates for intersection
       */
      getCoords: function(absolute, calculate) {
        if (!this.oCoords) {
          this.setCoords();
        }
        var coords = absolute ? this.aCoords : this.oCoords;
        return getCoords(calculate ? this.calcCoords(absolute) : coords);
      },

      /**
       * Checks if object intersects with an area formed by 2 points
       * @param {Object} pointTL top-left point of area
       * @param {Object} pointBR bottom-right point of area
       * @param {Boolean} [absolute] use coordinates without viewportTransform
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
       * @return {Boolean} true if object intersects with an area formed by 2 points
       */
      intersectsWithRect: function(pointTL, pointBR, absolute, calculate) {
        var coords = this.getCoords(absolute, calculate),
            intersection = fabric.Intersection.intersectPolygonRectangle(
              coords,
              pointTL,
              pointBR
            );
        return intersection.status === 'Intersection';
      },

      /**
       * Checks if object intersects with another object
       * @param {Object} other Object to test
       * @param {Boolean} [absolute] use coordinates without viewportTransform
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
       * @return {Boolean} true if object intersects with another object
       */
      intersectsWithObject: function(other, absolute, calculate) {
        var intersection = fabric.Intersection.intersectPolygonPolygon(
          this.getCoords(absolute, calculate),
          other.getCoords(absolute, calculate)
        );

        return intersection.status === 'Intersection'
          || other.isContainedWithinObject(this, absolute, calculate)
          || this.isContainedWithinObject(other, absolute, calculate);
      },

      /**
       * Checks if object is fully contained within area of another object
       * @param {Object} other Object to test
       * @param {Boolean} [absolute] use coordinates without viewportTransform
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
       * @return {Boolean} true if object is fully contained within area of another object
       */
      isContainedWithinObject: function(other, absolute, calculate) {
        var points = this.getCoords(absolute, calculate),
            i = 0, lines = other._getImageLines(
              calculate ? other.calcCoords(absolute) : absolute ? other.aCoords : other.oCoords
            );
        for (; i < 4; i++) {
          if (!other.containsPoint(points[i], lines)) {
            return false;
          }
        }
        return true;
      },

      /**
       * Checks if object is fully contained within area formed by 2 points
       * @param {Object} pointTL top-left point of area
       * @param {Object} pointBR bottom-right point of area
       * @param {Boolean} [absolute] use coordinates without viewportTransform
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
       * @return {Boolean} true if object is fully contained within area formed by 2 points
       */
      isContainedWithinRect: function(pointTL, pointBR, absolute, calculate) {
        var boundingRect = this.getBoundingRect(absolute, calculate);

        return (
          boundingRect.left >= pointTL.x &&
          boundingRect.left + boundingRect.width <= pointBR.x &&
          boundingRect.top >= pointTL.y &&
          boundingRect.top + boundingRect.height <= pointBR.y
        );
      },

      /**
       * Checks if point is inside the object
       * @param {fabric.Point} point Point to check against
       * @param {Object} [lines] object returned from @method _getImageLines
       * @param {Boolean} [absolute] use coordinates without viewportTransform
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
       * @return {Boolean} true if point is inside the object
       */
      containsPoint: function(point, lines, absolute, calculate) {
        var lines = lines || this._getImageLines(
              calculate ? this.calcCoords(absolute) : absolute ? this.aCoords : this.oCoords
            ),
            xPoints = this._findCrossPoints(point, lines);

        // if xPoints is odd then point is inside the object
        return (xPoints !== 0 && xPoints % 2 === 1);
      },

      /**
       * Checks if object is contained within the canvas with current viewportTransform
       * the check is done stopping at first point that appears on screen
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
       * @return {Boolean} true if object is fully or partially contained within canvas
       */
      isOnScreen: function(calculate) {
        if (!this.canvas) {
          return false;
        }
        var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
        var points = this.getCoords(true, calculate), point;
        for (var i = 0; i < 4; i++) {
          point = points[i];
          if (point.x <= pointBR.x && point.x >= pointTL.x && point.y <= pointBR.y && point.y >= pointTL.y) {
            return true;
          }
        }
        // no points on screen, check intersection with absolute coordinates
        if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {
          return true;
        }
        return this._containsCenterOfCanvas(pointTL, pointBR, calculate);
      },

      /**
       * Checks if the object contains the midpoint between canvas extremities
       * Does not make sense outside the context of isOnScreen and isPartiallyOnScreen
       * @private
       * @param {Fabric.Point} pointTL Top Left point
       * @param {Fabric.Point} pointBR Top Right point
       * @param {Boolean} calculate use coordinates of current position instead of .oCoords
       * @return {Boolean} true if the objects containe the point
       */
      _containsCenterOfCanvas: function(pointTL, pointBR, calculate) {
        // worst case scenario the object is so big that contains the screen
        var centerPoint = { x: (pointTL.x + pointBR.x) / 2, y: (pointTL.y + pointBR.y) / 2 };
        if (this.containsPoint(centerPoint, null, true, calculate)) {
          return true;
        }
        return false;
      },

      /**
       * Checks if object is partially contained within the canvas with current viewportTransform
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
       * @return {Boolean} true if object is partially contained within canvas
       */
      isPartiallyOnScreen: function(calculate) {
        if (!this.canvas) {
          return false;
        }
        var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
        if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {
          return true;
        }
        return this._containsCenterOfCanvas(pointTL, pointBR, calculate);
      },

      /**
       * Method that returns an object with the object edges in it, given the coordinates of the corners
       * @private
       * @param {Object} oCoords Coordinates of the object corners
       */
      _getImageLines: function(oCoords) {
        return {
          topline: {
            o: oCoords.tl,
            d: oCoords.tr
          },
          rightline: {
            o: oCoords.tr,
            d: oCoords.br
          },
          bottomline: {
            o: oCoords.br,
            d: oCoords.bl
          },
          leftline: {
            o: oCoords.bl,
            d: oCoords.tl
          }
        };
      },

      /**
       * Helper method to determine how many cross points are between the 4 object edges
       * and the horizontal line determined by a point on canvas
       * @private
       * @param {fabric.Point} point Point to check
       * @param {Object} lines Coordinates of the object being evaluated
       */
      // remove yi, not used but left code here just in case.
      _findCrossPoints: function(point, lines) {
        var b1, b2, a1, a2, xi, // yi,
            xcount = 0,
            iLine;

        for (var lineKey in lines) {
          iLine = lines[lineKey];
          // optimisation 1: line below point. no cross
          if ((iLine.o.y < point.y) && (iLine.d.y < point.y)) {
            continue;
          }
          // optimisation 2: line above point. no cross
          if ((iLine.o.y >= point.y) && (iLine.d.y >= point.y)) {
            continue;
          }
          // optimisation 3: vertical line case
          if ((iLine.o.x === iLine.d.x) && (iLine.o.x >= point.x)) {
            xi = iLine.o.x;
            // yi = point.y;
          }
          // calculate the intersection point
          else {
            b1 = 0;
            b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);
            a1 = point.y - b1 * point.x;
            a2 = iLine.o.y - b2 * iLine.o.x;

            xi = -(a1 - a2) / (b1 - b2);
            // yi = a1 + b1 * xi;
          }
          // dont count xi < point.x cases
          if (xi >= point.x) {
            xcount += 1;
          }
          // optimisation 4: specific for square images
          if (xcount === 2) {
            break;
          }
        }
        return xcount;
      },

      /**
       * Returns coordinates of object's bounding rectangle (left, top, width, height)
       * the box is intented as aligned to axis of canvas.
       * @param {Boolean} [absolute] use coordinates without viewportTransform
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords / .aCoords
       * @return {Object} Object with left, top, width, height properties
       */
      getBoundingRect: function(absolute, calculate) {
        var coords = this.getCoords(absolute, calculate);
        return fabric.util.makeBoundingBoxFromPoints(coords);
      },

      /**
       * Returns width of an object bounding box counting transformations
       * before 2.0 it was named getWidth();
       * @return {Number} width value
       */
      getScaledWidth: function() {
        return this._getTransformedDimensions().x;
      },

      /**
       * Returns height of an object bounding box counting transformations
       * before 2.0 it was named getHeight();
       * @return {Number} height value
       */
      getScaledHeight: function() {
        return this._getTransformedDimensions().y;
      },

      /**
       * Makes sure the scale is valid and modifies it if necessary
       * @private
       * @param {Number} value
       * @return {Number}
       */
      _constrainScale: function(value) {
        if (Math.abs(value) < this.minScaleLimit) {
          if (value < 0) {
            return -this.minScaleLimit;
          }
          else {
            return this.minScaleLimit;
          }
        }
        else if (value === 0) {
          return 0.0001;
        }
        return value;
      },

      /**
       * Scales an object (equally by x and y)
       * @param {Number} value Scale factor
       * @return {fabric.Object} thisArg
       * @chainable
       */
      scale: function(value) {
        this._set('scaleX', value);
        this._set('scaleY', value);
        return this.setCoords();
      },

      /**
       * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)
       * @param {Number} value New width value
       * @param {Boolean} absolute ignore viewport
       * @return {fabric.Object} thisArg
       * @chainable
       */
      scaleToWidth: function(value, absolute) {
        // adjust to bounding rect factor so that rotated shapes would fit as well
        var boundingRectFactor = this.getBoundingRect(absolute).width / this.getScaledWidth();
        return this.scale(value / this.width / boundingRectFactor);
      },

      /**
       * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)
       * @param {Number} value New height value
       * @param {Boolean} absolute ignore viewport
       * @return {fabric.Object} thisArg
       * @chainable
       */
      scaleToHeight: function(value, absolute) {
        // adjust to bounding rect factor so that rotated shapes would fit as well
        var boundingRectFactor = this.getBoundingRect(absolute).height / this.getScaledHeight();
        return this.scale(value / this.height / boundingRectFactor);
      },

      /**
       * Calculate and returns the .coords of an object.
       * @return {Object} Object with tl, tr, br, bl ....
       * @chainable
       */
      calcCoords: function(absolute) {
        var rotateMatrix = this._calcRotateMatrix(),
            translateMatrix = this._calcTranslateMatrix(),
            startMatrix = multiplyMatrices(translateMatrix, rotateMatrix),
            vpt = this.getViewportTransform(),
            finalMatrix = absolute ? startMatrix : multiplyMatrices(vpt, startMatrix),
            dim = this._getTransformedDimensions(),
            w = dim.x / 2, h = dim.y / 2,
            tl = transformPoint({ x: -w, y: -h }, finalMatrix),
            tr = transformPoint({ x: w, y: -h }, finalMatrix),
            bl = transformPoint({ x: -w, y: h }, finalMatrix),
            br = transformPoint({ x: w, y: h }, finalMatrix);
        if (!absolute) {
          var padding = this.padding, angle = degreesToRadians(this.angle),
              cos = fabric.util.cos(angle), sin = fabric.util.sin(angle),
              cosP = cos * padding, sinP = sin * padding, cosPSinP = cosP + sinP,
              cosPMinusSinP = cosP - sinP;
          if (padding) {
            tl.x -= cosPMinusSinP;
            tl.y -= cosPSinP;
            tr.x += cosPSinP;
            tr.y -= cosPMinusSinP;
            bl.x -= cosPSinP;
            bl.y += cosPMinusSinP;
            br.x += cosPMinusSinP;
            br.y += cosPSinP;
          }
          var ml  = new fabric.Point((tl.x + bl.x) / 2, (tl.y + bl.y) / 2),
              mt  = new fabric.Point((tr.x + tl.x) / 2, (tr.y + tl.y) / 2),
              mr  = new fabric.Point((br.x + tr.x) / 2, (br.y + tr.y) / 2),
              mb  = new fabric.Point((br.x + bl.x) / 2, (br.y + bl.y) / 2),
              mtr = new fabric.Point(mt.x + sin * this.rotatingPointOffset, mt.y - cos * this.rotatingPointOffset);
        }

        // if (!absolute) {
        //   var canvas = this.canvas;
        //   setTimeout(function() {
        //     canvas.contextTop.clearRect(0, 0, 700, 700);
        //     canvas.contextTop.fillStyle = 'green';
        //     canvas.contextTop.fillRect(mb.x, mb.y, 3, 3);
        //     canvas.contextTop.fillRect(bl.x, bl.y, 3, 3);
        //     canvas.contextTop.fillRect(br.x, br.y, 3, 3);
        //     canvas.contextTop.fillRect(tl.x, tl.y, 3, 3);
        //     canvas.contextTop.fillRect(tr.x, tr.y, 3, 3);
        //     canvas.contextTop.fillRect(ml.x, ml.y, 3, 3);
        //     canvas.contextTop.fillRect(mr.x, mr.y, 3, 3);
        //     canvas.contextTop.fillRect(mt.x, mt.y, 3, 3);
        //     canvas.contextTop.fillRect(mtr.x, mtr.y, 3, 3);
        //   }, 50);
        // }

        var coords = {
          // corners
          tl: tl, tr: tr, br: br, bl: bl,
        };
        if (!absolute) {
          // middle
          coords.ml = ml;
          coords.mt = mt;
          coords.mr = mr;
          coords.mb = mb;
          // rotating point
          coords.mtr = mtr;
        }
        return coords;
      },

      /**
       * Sets corner position coordinates based on current angle, width and height
       * See https://github.com/kangax/fabric.js/wiki/When-to-call-setCoords
       * @param {Boolean} [ignoreZoom] set oCoords with or without the viewport transform.
       * @param {Boolean} [skipAbsolute] skip calculation of aCoords, usefull in setViewportTransform
       * @return {fabric.Object} thisArg
       * @chainable
       */
      setCoords: function(ignoreZoom, skipAbsolute) {
        this.oCoords = this.calcCoords(ignoreZoom);
        if (!skipAbsolute) {
          this.aCoords = this.calcCoords(true);
        }

        // set coordinates of the draggable boxes in the corners used to scale/rotate the image
        ignoreZoom || (this._setCornerCoords && this._setCornerCoords());

        return this;
      },

      /**
       * calculate rotation matrix of an object
       * @return {Array} rotation matrix for the object
       */
      _calcRotateMatrix: function() {
        if (this.angle) {
          var theta = degreesToRadians(this.angle), cos = fabric.util.cos(theta), sin = fabric.util.sin(theta);
          return [cos, sin, -sin, cos, 0, 0];
        }
        return fabric.iMatrix.concat();
      },

      /**
       * calculate the translation matrix for an object transform
       * @return {Array} rotation matrix for the object
       */
      _calcTranslateMatrix: function() {
        var center = this.getCenterPoint();
        return [1, 0, 0, 1, center.x, center.y];
      },

      transformMatrixKey: function(skipGroup) {
        var sep = '_', prefix = '';
        if (!skipGroup && this.group) {
          prefix = this.group.transformMatrixKey(skipGroup) + sep;
        }      return prefix + this.top + sep + this.left + sep + this.scaleX + sep + this.scaleY +
          sep + this.skewX + sep + this.skewY + sep + this.angle + sep + this.originX + sep + this.originY +
          sep + this.width + sep + this.height + sep + this.strokeWidth + this.flipX + this.flipY;
      },

      /**
       * calculate trasform Matrix that represent current transformation from
       * object properties.
       * @param {Boolean} [skipGroup] return transformMatrix for object and not go upward with parents
       * @return {Array} matrix Transform Matrix for the object
       */
      calcTransformMatrix: function(skipGroup) {
        if (skipGroup) {
          return this.calcOwnMatrix();
        }
        var key = this.transformMatrixKey(), cache = this.matrixCache || (this.matrixCache = {});
        if (cache.key === key) {
          return cache.value;
        }
        var matrix = this.calcOwnMatrix();
        if (this.group) {
          matrix = multiplyMatrices(this.group.calcTransformMatrix(), matrix);
        }
        cache.key = key;
        cache.value = matrix;
        return matrix;
      },

      calcOwnMatrix: function() {
        var key = this.transformMatrixKey(true), cache = this.ownMatrixCache || (this.ownMatrixCache = {});
        if (cache.key === key) {
          return cache.value;
        }
        var matrix = this._calcTranslateMatrix(),
            rotateMatrix,
            dimensionMatrix = this._calcDimensionsTransformMatrix(this.skewX, this.skewY, true);
        if (this.angle) {
          rotateMatrix = this._calcRotateMatrix();
          matrix = multiplyMatrices(matrix, rotateMatrix);
        }
        matrix = multiplyMatrices(matrix, dimensionMatrix);
        cache.key = key;
        cache.value = matrix;
        return matrix;
      },

      _calcDimensionsTransformMatrix: function(skewX, skewY, flipping) {
        var skewMatrix,
            scaleX = this.scaleX * (flipping && this.flipX ? -1 : 1),
            scaleY = this.scaleY * (flipping && this.flipY ? -1 : 1),
            scaleMatrix = [scaleX, 0, 0, scaleY, 0, 0];
        if (skewX) {
          skewMatrix = [1, 0, Math.tan(degreesToRadians(skewX)), 1];
          scaleMatrix = multiplyMatrices(scaleMatrix, skewMatrix, true);
        }
        if (skewY) {
          skewMatrix = [1, Math.tan(degreesToRadians(skewY)), 0, 1];
          scaleMatrix = multiplyMatrices(scaleMatrix, skewMatrix, true);
        }
        return scaleMatrix;
      },


      /*
       * Calculate object dimensions from its properties
       * @private
       * @return {Object} .x width dimension
       * @return {Object} .y height dimension
       */
      _getNonTransformedDimensions: function() {
        var strokeWidth = this.strokeWidth,
            w = this.width + strokeWidth,
            h = this.height + strokeWidth;
        return { x: w, y: h };
      },

      /*
       * Calculate object bounding boxdimensions from its properties scale, skew.
       * @private
       * @return {Object} .x width dimension
       * @return {Object} .y height dimension
       */
      _getTransformedDimensions: function(skewX, skewY) {
        if (typeof skewX === 'undefined') {
          skewX = this.skewX;
        }
        if (typeof skewY === 'undefined') {
          skewY = this.skewY;
        }
        var dimensions = this._getNonTransformedDimensions();
        if (skewX === 0 && skewY === 0) {
          return { x: dimensions.x * this.scaleX, y: dimensions.y * this.scaleY };
        }
        var dimX = dimensions.x / 2, dimY = dimensions.y / 2,
            points = [
              {
                x: -dimX,
                y: -dimY
              },
              {
                x: dimX,
                y: -dimY
              },
              {
                x: -dimX,
                y: dimY
              },
              {
                x: dimX,
                y: dimY
              }],
            i, transformMatrix = this._calcDimensionsTransformMatrix(skewX, skewY, false),
            bbox;
        for (i = 0; i < points.length; i++) {
          points[i] = fabric.util.transformPoint(points[i], transformMatrix);
        }
        bbox = fabric.util.makeBoundingBoxFromPoints(points);
        return { x: bbox.width, y: bbox.height };
      },

      /*
       * Calculate object dimensions for controls. include padding and canvas zoom
       * private
       */
      _calculateCurrentDimensions: function()  {
        var vpt = this.getViewportTransform(),
            dim = this._getTransformedDimensions(),
            p = fabric.util.transformPoint(dim, vpt, true);

        return p.scalarAdd(2 * this.padding);
      },
    });
  })();


  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * Moves an object to the bottom of the stack of drawn objects
     * @return {fabric.Object} thisArg
     * @chainable
     */
    sendToBack: function() {
      if (this.group) {
        fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);
      }
      else {
        this.canvas.sendToBack(this);
      }
      return this;
    },

    /**
     * Moves an object to the top of the stack of drawn objects
     * @return {fabric.Object} thisArg
     * @chainable
     */
    bringToFront: function() {
      if (this.group) {
        fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);
      }
      else {
        this.canvas.bringToFront(this);
      }
      return this;
    },

    /**
     * Moves an object down in stack of drawn objects
     * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
     * @return {fabric.Object} thisArg
     * @chainable
     */
    sendBackwards: function(intersecting) {
      if (this.group) {
        fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);
      }
      else {
        this.canvas.sendBackwards(this, intersecting);
      }
      return this;
    },

    /**
     * Moves an object up in stack of drawn objects
     * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
     * @return {fabric.Object} thisArg
     * @chainable
     */
    bringForward: function(intersecting) {
      if (this.group) {
        fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);
      }
      else {
        this.canvas.bringForward(this, intersecting);
      }
      return this;
    },

    /**
     * Moves an object to specified level in stack of drawn objects
     * @param {Number} index New position of object
     * @return {fabric.Object} thisArg
     * @chainable
     */
    moveTo: function(index) {
      if (this.group && this.group.type !== 'activeSelection') {
        fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);
      }
      else {
        this.canvas.moveTo(this, index);
      }
      return this;
    }
  });


  /* _TO_SVG_START_ */
  (function() {
    function getSvgColorString(prop, value) {
      if (!value) {
        return prop + ': none; ';
      }
      else if (value.toLive) {
        return prop + ': url(#SVGID_' + value.id + '); ';
      }
      else {
        var color = new fabric.Color(value),
            str = prop + ': ' + color.toRgb() + '; ',
            opacity = color.getAlpha();
        if (opacity !== 1) {
          //change the color in rgb + opacity
          str += prop + '-opacity: ' + opacity.toString() + '; ';
        }
        return str;
      }
    }

    var toFixed = fabric.util.toFixed;

    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
      /**
       * Returns styles-string for svg-export
       * @param {Boolean} skipShadow a boolean to skip shadow filter output
       * @return {String}
       */
      getSvgStyles: function(skipShadow) {

        var fillRule = this.fillRule,
            strokeWidth = this.strokeWidth ? this.strokeWidth : '0',
            strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(' ') : 'none',
            strokeLineCap = this.strokeLineCap ? this.strokeLineCap : 'butt',
            strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : 'miter',
            strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : '4',
            opacity = typeof this.opacity !== 'undefined' ? this.opacity : '1',
            visibility = this.visible ? '' : ' visibility: hidden;',
            filter = skipShadow ? '' : this.getSvgFilter(),
            fill = getSvgColorString('fill', this.fill),
            stroke = getSvgColorString('stroke', this.stroke);

        return [
          stroke,
          'stroke-width: ', strokeWidth, '; ',
          'stroke-dasharray: ', strokeDashArray, '; ',
          'stroke-linecap: ', strokeLineCap, '; ',
          'stroke-linejoin: ', strokeLineJoin, '; ',
          'stroke-miterlimit: ', strokeMiterLimit, '; ',
          fill,
          'fill-rule: ', fillRule, '; ',
          'opacity: ', opacity, ';',
          filter,
          visibility
        ].join('');
      },

      /**
       * Returns styles-string for svg-export
       * @param {Object} style the object from which to retrieve style properties
       * @param {Boolean} useWhiteSpace a boolean to include an additional attribute in the style.
       * @return {String}
       */
      getSvgSpanStyles: function(style, useWhiteSpace) {
        var term = '; ';
        var fontFamily = style.fontFamily ?
          'font-family: ' + (((style.fontFamily.indexOf('\'') === -1 && style.fontFamily.indexOf('"') === -1) ?
            '\'' + style.fontFamily  + '\'' : style.fontFamily)) + term : '';
        var strokeWidth = style.strokeWidth ? 'stroke-width: ' + style.strokeWidth + term : '',
            fontFamily = fontFamily,
            fontSize = style.fontSize ? 'font-size: ' + style.fontSize + 'px' + term : '',
            fontStyle = style.fontStyle ? 'font-style: ' + style.fontStyle + term : '',
            fontWeight = style.fontWeight ? 'font-weight: ' + style.fontWeight + term : '',
            fill = style.fill ? getSvgColorString('fill', style.fill) : '',
            stroke = style.stroke ? getSvgColorString('stroke', style.stroke) : '',
            textDecoration = this.getSvgTextDecoration(style),
            deltaY = style.deltaY ? 'baseline-shift: ' + (-style.deltaY) + '; ' : '';
        if (textDecoration) {
          textDecoration = 'text-decoration: ' + textDecoration + term;
        }

        return [
          stroke,
          strokeWidth,
          fontFamily,
          fontSize,
          fontStyle,
          fontWeight,
          textDecoration,
          fill,
          deltaY,
          useWhiteSpace ? 'white-space: pre; ' : ''
        ].join('');
      },

      /**
       * Returns text-decoration property for svg-export
       * @param {Object} style the object from which to retrieve style properties
       * @return {String}
       */
      getSvgTextDecoration: function(style) {
        if ('overline' in style || 'underline' in style || 'linethrough' in style) {
          return (style.overline ? 'overline ' : '') +
            (style.underline ? 'underline ' : '') + (style.linethrough ? 'line-through ' : '');
        }
        return '';
      },

      /**
       * Returns filter for svg shadow
       * @return {String}
       */
      getSvgFilter: function() {
        return this.shadow ? 'filter: url(#SVGID_' + this.shadow.id + ');' : '';
      },

      /**
       * Returns id attribute for svg output
       * @return {String}
       */
      getSvgId: function() {
        return this.id ? 'id="' + this.id + '" ' : '';
      },

      /**
       * Returns transform-string for svg-export
       * @return {String}
       */
      getSvgTransform: function() {
        var angle = this.angle,
            skewX = (this.skewX % 360),
            skewY = (this.skewY % 360),
            center = this.getCenterPoint(),

            NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,

            translatePart = 'translate(' +
                              toFixed(center.x, NUM_FRACTION_DIGITS) +
                              ' ' +
                              toFixed(center.y, NUM_FRACTION_DIGITS) +
                            ')',

            anglePart = angle !== 0
              ? (' rotate(' + toFixed(angle, NUM_FRACTION_DIGITS) + ')')
              : '',

            scalePart = (this.scaleX === 1 && this.scaleY === 1)
              ? '' :
              (' scale(' +
                toFixed(this.scaleX, NUM_FRACTION_DIGITS) +
                ' ' +
                toFixed(this.scaleY, NUM_FRACTION_DIGITS) +
              ')'),

            skewXPart = skewX !== 0 ? ' skewX(' + toFixed(skewX, NUM_FRACTION_DIGITS) + ')' : '',

            skewYPart = skewY !== 0 ? ' skewY(' + toFixed(skewY, NUM_FRACTION_DIGITS) + ')' : '',

            flipXPart = this.flipX ? ' matrix(-1 0 0 1 0 0) ' : '',

            flipYPart = this.flipY ? ' matrix(1 0 0 -1 0 0)' : '';

        return [
          translatePart, anglePart, scalePart, flipXPart, flipYPart, skewXPart, skewYPart
        ].join('');
      },

      /**
       * Returns transform-string for svg-export from the transform matrix of single elements
       * @return {String}
       */
      getSvgTransformMatrix: function() {
        return this.transformMatrix ? ' matrix(' + this.transformMatrix.join(' ') + ') ' : '';
      },

      _setSVGBg: function(textBgRects) {
        if (this.backgroundColor) {
          var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
          textBgRects.push(
            '\t\t<rect ',
            this._getFillAttributes(this.backgroundColor),
            ' x="',
            toFixed(-this.width / 2, NUM_FRACTION_DIGITS),
            '" y="',
            toFixed(-this.height / 2, NUM_FRACTION_DIGITS),
            '" width="',
            toFixed(this.width, NUM_FRACTION_DIGITS),
            '" height="',
            toFixed(this.height, NUM_FRACTION_DIGITS),
            '"></rect>\n');
        }
      },

      /**
       * @private
       */
      _createBaseSVGMarkup: function() {
        var markup = [];

        if (this.fill && this.fill.toLive) {
          markup.push(this.fill.toSVG(this, false));
        }
        if (this.stroke && this.stroke.toLive) {
          markup.push(this.stroke.toSVG(this, false));
        }
        if (this.shadow) {
          markup.push(this.shadow.toSVG(this));
        }
        return markup;
      },

      addPaintOrder: function() {
        return this.paintFirst !== 'fill' ? ' paint-order="' + this.paintFirst + '" ' : '';
      }
    });
  })();
  /* _TO_SVG_END_ */


  (function() {

    var extend = fabric.util.object.extend,
        originalSet = 'stateProperties';

    /*
      Depends on `stateProperties`
    */
    function saveProps(origin, destination, props) {
      var tmpObj = { }, deep = true;
      props.forEach(function(prop) {
        tmpObj[prop] = origin[prop];
      });
      extend(origin[destination], tmpObj, deep);
    }

    function _isEqual(origValue, currentValue, firstPass) {
      if (origValue === currentValue) {
        // if the objects are identical, return
        return true;
      }
      else if (Array.isArray(origValue)) {
        if (!Array.isArray(currentValue) || origValue.length !== currentValue.length) {
          return false;
        }
        for (var i = 0, len = origValue.length; i < len; i++) {
          if (!_isEqual(origValue[i], currentValue[i])) {
            return false;
          }
        }
        return true;
      }
      else if (origValue && typeof origValue === 'object') {
        var keys = Object.keys(origValue), key;
        if (!currentValue ||
            typeof currentValue !== 'object' ||
            (!firstPass && keys.length !== Object.keys(currentValue).length)
        ) {
          return false;
        }
        for (var i = 0, len = keys.length; i < len; i++) {
          key = keys[i];
          if (!_isEqual(origValue[key], currentValue[key])) {
            return false;
          }
        }
        return true;
      }
    }


    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

      /**
       * Returns true if object state (one of its state properties) was changed
       * @param {String} [propertySet] optional name for the set of property we want to save
       * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called
       */
      hasStateChanged: function(propertySet) {
        propertySet = propertySet || originalSet;
        var dashedPropertySet = '_' + propertySet;
        if (Object.keys(this[dashedPropertySet]).length < this[propertySet].length) {
          return true;
        }
        return !_isEqual(this[dashedPropertySet], this, true);
      },

      /**
       * Saves state of an object
       * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
       * @return {fabric.Object} thisArg
       */
      saveState: function(options) {
        var propertySet = options && options.propertySet || originalSet,
            destination = '_' + propertySet;
        if (!this[destination]) {
          return this.setupState(options);
        }
        saveProps(this, destination, this[propertySet]);
        if (options && options.stateProperties) {
          saveProps(this, destination, options.stateProperties);
        }
        return this;
      },

      /**
       * Setups state of an object
       * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
       * @return {fabric.Object} thisArg
       */
      setupState: function(options) {
        options = options || { };
        var propertySet = options.propertySet || originalSet;
        options.propertySet = propertySet;
        this['_' + propertySet] = { };
        this.saveState(options);
        return this;
      }
    });
  })();


  (function() {

    var degreesToRadians = fabric.util.degreesToRadians;

    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

      /**
       * The object interactivity controls.
       * @private
       */
      _controlsVisibility: null,

      /**
       * Determines which corner has been clicked
       * @private
       * @param {Object} pointer The pointer indicating the mouse position
       * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found
       */
      _findTargetCorner: function(pointer) {
        // objects in group, anykind, are not self modificable,
        // must not return an hovered corner.
        if (!this.hasControls || this.group || (!this.canvas || this.canvas._activeObject !== this)) {
          return false;
        }

        var ex = pointer.x,
            ey = pointer.y,
            xPoints,
            lines;
        this.__corner = 0;
        for (var i in this.oCoords) {

          if (!this.isControlVisible(i)) {
            continue;
          }

          if (i === 'mtr' && !this.hasRotatingPoint) {
            continue;
          }

          if (this.get('lockUniScaling') &&
             (i === 'mt' || i === 'mr' || i === 'mb' || i === 'ml')) {
            continue;
          }

          lines = this._getImageLines(this.oCoords[i].corner);

          // debugging

          // canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);
          // canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);

          // canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);
          // canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);

          // canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);
          // canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);

          // canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);
          // canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);

          xPoints = this._findCrossPoints({ x: ex, y: ey }, lines);
          if (xPoints !== 0 && xPoints % 2 === 1) {
            this.__corner = i;
            return i;
          }
        }
        return false;
      },

      /**
       * Sets the coordinates of the draggable boxes in the corners of
       * the image used to scale/rotate it.
       * @private
       */
      _setCornerCoords: function() {
        var coords = this.oCoords,
            newTheta = degreesToRadians(45 - this.angle),
            /* Math.sqrt(2 * Math.pow(this.cornerSize, 2)) / 2, */
            /* 0.707106 stands for sqrt(2)/2 */
            cornerHypotenuse = this.cornerSize * 0.707106,
            cosHalfOffset = cornerHypotenuse * fabric.util.cos(newTheta),
            sinHalfOffset = cornerHypotenuse * fabric.util.sin(newTheta),
            x, y;

        for (var point in coords) {
          x = coords[point].x;
          y = coords[point].y;
          coords[point].corner = {
            tl: {
              x: x - sinHalfOffset,
              y: y - cosHalfOffset
            },
            tr: {
              x: x + cosHalfOffset,
              y: y - sinHalfOffset
            },
            bl: {
              x: x - cosHalfOffset,
              y: y + sinHalfOffset
            },
            br: {
              x: x + sinHalfOffset,
              y: y + cosHalfOffset
            }
          };
        }
      },

      /**
       * Draws a colored layer behind the object, inside its selection borders.
       * Requires public options: padding, selectionBackgroundColor
       * this function is called when the context is transformed
       * has checks to be skipped when the object is on a staticCanvas
       * @param {CanvasRenderingContext2D} ctx Context to draw on
       * @return {fabric.Object} thisArg
       * @chainable
       */
      drawSelectionBackground: function(ctx) {
        if (!this.selectionBackgroundColor ||
          (this.canvas && !this.canvas.interactive) ||
          (this.canvas && this.canvas._activeObject !== this)
        ) {
          return this;
        }
        ctx.save();
        var center = this.getCenterPoint(), wh = this._calculateCurrentDimensions(),
            vpt = this.canvas.viewportTransform;
        ctx.translate(center.x, center.y);
        ctx.scale(1 / vpt[0], 1 / vpt[3]);
        ctx.rotate(degreesToRadians(this.angle));
        ctx.fillStyle = this.selectionBackgroundColor;
        ctx.fillRect(-wh.x / 2, -wh.y / 2, wh.x, wh.y);
        ctx.restore();
        return this;
      },

      /**
       * Draws borders of an object's bounding box.
       * Requires public properties: width, height
       * Requires public options: padding, borderColor
       * @param {CanvasRenderingContext2D} ctx Context to draw on
       * @param {Object} styleOverride object to override the object style
       * @return {fabric.Object} thisArg
       * @chainable
       */
      drawBorders: function(ctx, styleOverride) {
        styleOverride = styleOverride || {};
        var wh = this._calculateCurrentDimensions(),
            strokeWidth = 1 / this.borderScaleFactor,
            width = wh.x + strokeWidth,
            height = wh.y + strokeWidth,
            drawRotatingPoint = typeof styleOverride.hasRotatingPoint !== 'undefined' ?
              styleOverride.hasRotatingPoint : this.hasRotatingPoint,
            hasControls = typeof styleOverride.hasControls !== 'undefined' ?
              styleOverride.hasControls : this.hasControls,
            rotatingPointOffset = typeof styleOverride.rotatingPointOffset !== 'undefined' ?
              styleOverride.rotatingPointOffset : this.rotatingPointOffset;

        ctx.save();
        ctx.strokeStyle = styleOverride.borderColor || this.borderColor;
        this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray, null);

        ctx.strokeRect(
          -width / 2,
          -height / 2,
          width,
          height
        );

        if (drawRotatingPoint && this.isControlVisible('mtr') && hasControls) {

          var rotateHeight = -height / 2;

          ctx.beginPath();
          ctx.moveTo(0, rotateHeight);
          ctx.lineTo(0, rotateHeight - rotatingPointOffset);
          ctx.stroke();
        }

        ctx.restore();
        return this;
      },

      /**
       * Draws borders of an object's bounding box when it is inside a group.
       * Requires public properties: width, height
       * Requires public options: padding, borderColor
       * @param {CanvasRenderingContext2D} ctx Context to draw on
       * @param {object} options object representing current object parameters
       * @param {Object} styleOverride object to override the object style
       * @return {fabric.Object} thisArg
       * @chainable
       */
      drawBordersInGroup: function(ctx, options, styleOverride) {
        styleOverride = styleOverride || {};
        var p = this._getNonTransformedDimensions(),
            matrix = fabric.util.customTransformMatrix(options.scaleX, options.scaleY, options.skewX),
            wh = fabric.util.transformPoint(p, matrix),
            strokeWidth = 1 / this.borderScaleFactor,
            width = wh.x + strokeWidth,
            height = wh.y + strokeWidth;

        ctx.save();
        this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray, null);
        ctx.strokeStyle = styleOverride.borderColor || this.borderColor;

        ctx.strokeRect(
          -width / 2,
          -height / 2,
          width,
          height
        );

        ctx.restore();
        return this;
      },

      /**
       * Draws corners of an object's bounding box.
       * Requires public properties: width, height
       * Requires public options: cornerSize, padding
       * @param {CanvasRenderingContext2D} ctx Context to draw on
       * @param {Object} styleOverride object to override the object style
       * @return {fabric.Object} thisArg
       * @chainable
       */
      drawControls: function(ctx, styleOverride) {
        styleOverride = styleOverride || {};
        var wh = this._calculateCurrentDimensions(),
            width = wh.x,
            height = wh.y,
            scaleOffset = styleOverride.cornerSize || this.cornerSize,
            left = -(width + scaleOffset) / 2,
            top = -(height + scaleOffset) / 2,
            transparentCorners = typeof styleOverride.transparentCorners !== 'undefined' ?
              styleOverride.transparentCorners : this.transparentCorners,
            hasRotatingPoint = typeof styleOverride.hasRotatingPoint !== 'undefined' ?
              styleOverride.hasRotatingPoint : this.hasRotatingPoint,
            methodName = transparentCorners ? 'stroke' : 'fill';

        ctx.save();
        ctx.strokeStyle = ctx.fillStyle = styleOverride.cornerColor || this.cornerColor;
        if (!this.transparentCorners) {
          ctx.strokeStyle = styleOverride.cornerStrokeColor || this.cornerStrokeColor;
        }
        this._setLineDash(ctx, styleOverride.cornerDashArray || this.cornerDashArray, null);

        // top-left
        this._drawControl('tl', ctx, methodName,
          left,
          top, styleOverride);

        // top-right
        this._drawControl('tr', ctx, methodName,
          left + width,
          top, styleOverride);

        // bottom-left
        this._drawControl('bl', ctx, methodName,
          left,
          top + height, styleOverride);

        // bottom-right
        this._drawControl('br', ctx, methodName,
          left + width,
          top + height, styleOverride);

        if (!this.get('lockUniScaling')) {

          // middle-top
          this._drawControl('mt', ctx, methodName,
            left + width / 2,
            top, styleOverride);

          // middle-bottom
          this._drawControl('mb', ctx, methodName,
            left + width / 2,
            top + height, styleOverride);

          // middle-right
          this._drawControl('mr', ctx, methodName,
            left + width,
            top + height / 2, styleOverride);

          // middle-left
          this._drawControl('ml', ctx, methodName,
            left,
            top + height / 2, styleOverride);
        }

        // middle-top-rotate
        if (hasRotatingPoint) {
          this._drawControl('mtr', ctx, methodName,
            left + width / 2,
            top - this.rotatingPointOffset, styleOverride);
        }

        ctx.restore();

        return this;
      },

      /**
       * @private
       */
      _drawControl: function(control, ctx, methodName, left, top, styleOverride) {
        styleOverride = styleOverride || {};
        if (!this.isControlVisible(control)) {
          return;
        }
        var size = this.cornerSize, stroke = !this.transparentCorners && this.cornerStrokeColor;
        switch (styleOverride.cornerStyle || this.cornerStyle) {
          case 'circle':
            ctx.beginPath();
            ctx.arc(left + size / 2, top + size / 2, size / 2, 0, 2 * Math.PI, false);
            ctx[methodName]();
            if (stroke) {
              ctx.stroke();
            }
            break;
          default:
            this.transparentCorners || ctx.clearRect(left, top, size, size);
            ctx[methodName + 'Rect'](left, top, size, size);
            if (stroke) {
              ctx.strokeRect(left, top, size, size);
            }
        }
      },

      /**
       * Returns true if the specified control is visible, false otherwise.
       * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
       * @returns {Boolean} true if the specified control is visible, false otherwise
       */
      isControlVisible: function(controlName) {
        return this._getControlsVisibility()[controlName];
      },

      /**
       * Sets the visibility of the specified control.
       * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
       * @param {Boolean} visible true to set the specified control visible, false otherwise
       * @return {fabric.Object} thisArg
       * @chainable
       */
      setControlVisible: function(controlName, visible) {
        this._getControlsVisibility()[controlName] = visible;
        return this;
      },

      /**
       * Sets the visibility state of object controls.
       * @param {Object} [options] Options object
       * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it
       * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it
       * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it
       * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it
       * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it
       * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it
       * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it
       * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it
       * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it
       * @return {fabric.Object} thisArg
       * @chainable
       */
      setControlsVisibility: function(options) {
        options || (options = { });

        for (var p in options) {
          this.setControlVisible(p, options[p]);
        }
        return this;
      },

      /**
       * Returns the instance of the control visibility set for this object.
       * @private
       * @returns {Object}
       */
      _getControlsVisibility: function() {
        if (!this._controlsVisibility) {
          this._controlsVisibility = {
            tl: true,
            tr: true,
            br: true,
            bl: true,
            ml: true,
            mt: true,
            mr: true,
            mb: true,
            mtr: true
          };
        }
        return this._controlsVisibility;
      },

      /**
       * This callback function is called every time _discardActiveObject or _setActiveObject
       * try to to deselect this object. If the function returns true, the process is cancelled
       * @param {Object} [options] options sent from the upper functions
       * @param {Event} [options.e] event if the process is generated by an event
       */
      onDeselect: function() {
        // implemented by sub-classes, as needed.
      },


      /**
       * This callback function is called every time _discardActiveObject or _setActiveObject
       * try to to select this object. If the function returns true, the process is cancelled
       * @param {Object} [options] options sent from the upper functions
       * @param {Event} [options.e] event if the process is generated by an event
       */
      onSelect: function() {
        // implemented by sub-classes, as needed.
      }
    });
  })();


  fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

    /**
     * Animation duration (in ms) for fx* methods
     * @type Number
     * @default
     */
    FX_DURATION: 500,

    /**
     * Centers object horizontally with animation.
     * @param {fabric.Object} object Object to center
     * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
     * @param {Function} [callbacks.onComplete] Invoked on completion
     * @param {Function} [callbacks.onChange] Invoked on every step of animation
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    fxCenterObjectH: function (object, callbacks) {
      callbacks = callbacks || { };

      var empty = function() { },
          onComplete = callbacks.onComplete || empty,
          onChange = callbacks.onChange || empty,
          _this = this;

      fabric.util.animate({
        startValue: object.left,
        endValue: this.getCenter().left,
        duration: this.FX_DURATION,
        onChange: function(value) {
          object.set('left', value);
          _this.requestRenderAll();
          onChange();
        },
        onComplete: function() {
          object.setCoords();
          onComplete();
        }
      });

      return this;
    },

    /**
     * Centers object vertically with animation.
     * @param {fabric.Object} object Object to center
     * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
     * @param {Function} [callbacks.onComplete] Invoked on completion
     * @param {Function} [callbacks.onChange] Invoked on every step of animation
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    fxCenterObjectV: function (object, callbacks) {
      callbacks = callbacks || { };

      var empty = function() { },
          onComplete = callbacks.onComplete || empty,
          onChange = callbacks.onChange || empty,
          _this = this;

      fabric.util.animate({
        startValue: object.top,
        endValue: this.getCenter().top,
        duration: this.FX_DURATION,
        onChange: function(value) {
          object.set('top', value);
          _this.requestRenderAll();
          onChange();
        },
        onComplete: function() {
          object.setCoords();
          onComplete();
        }
      });

      return this;
    },

    /**
     * Same as `fabric.Canvas#remove` but animated
     * @param {fabric.Object} object Object to remove
     * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
     * @param {Function} [callbacks.onComplete] Invoked on completion
     * @param {Function} [callbacks.onChange] Invoked on every step of animation
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    fxRemove: function (object, callbacks) {
      callbacks = callbacks || { };

      var empty = function() { },
          onComplete = callbacks.onComplete || empty,
          onChange = callbacks.onChange || empty,
          _this = this;

      fabric.util.animate({
        startValue: object.opacity,
        endValue: 0,
        duration: this.FX_DURATION,
        onChange: function(value) {
          object.set('opacity', value);
          _this.requestRenderAll();
          onChange();
        },
        onComplete: function () {
          _this.remove(object);
          onComplete();
        }
      });

      return this;
    }
  });

  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
    /**
     * Animates object's properties
     * @param {String|Object} property Property to animate (if string) or properties to animate (if object)
     * @param {Number|Object} value Value to animate property to (if string was given first) or options object
     * @return {fabric.Object} thisArg
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}
     * @chainable
     *
     * As object — multiple properties
     *
     * object.animate({ left: ..., top: ... });
     * object.animate({ left: ..., top: ... }, { duration: ... });
     *
     * As string — one property
     *
     * object.animate('left', ...);
     * object.animate('left', { duration: ... });
     *
     */
    animate: function() {
      if (arguments[0] && typeof arguments[0] === 'object') {
        var propsToAnimate = [], prop, skipCallbacks;
        for (prop in arguments[0]) {
          propsToAnimate.push(prop);
        }
        for (var i = 0, len = propsToAnimate.length; i < len; i++) {
          prop = propsToAnimate[i];
          skipCallbacks = i !== len - 1;
          this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks);
        }
      }
      else {
        this._animate.apply(this, arguments);
      }
      return this;
    },

    /**
     * @private
     * @param {String} property Property to animate
     * @param {String} to Value to animate to
     * @param {Object} [options] Options object
     * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked
     */
    _animate: function(property, to, options, skipCallbacks) {
      var _this = this, propPair;

      to = to.toString();

      if (!options) {
        options = { };
      }
      else {
        options = fabric.util.object.clone(options);
      }

      if (~property.indexOf('.')) {
        propPair = property.split('.');
      }

      var currentValue = propPair
        ? this.get(propPair[0])[propPair[1]]
        : this.get(property);

      if (!('from' in options)) {
        options.from = currentValue;
      }

      if (~to.indexOf('=')) {
        to = currentValue + parseFloat(to.replace('=', ''));
      }
      else {
        to = parseFloat(to);
      }

      fabric.util.animate({
        startValue: options.from,
        endValue: to,
        byValue: options.by,
        easing: options.easing,
        duration: options.duration,
        abort: options.abort && function() {
          return options.abort.call(_this);
        },
        onChange: function(value, valueProgress, timeProgress) {
          if (propPair) {
            _this[propPair[0]][propPair[1]] = value;
          }
          else {
            _this.set(property, value);
          }
          if (skipCallbacks) {
            return;
          }
          options.onChange && options.onChange(value, valueProgress, timeProgress);
        },
        onComplete: function(value, valueProgress, timeProgress) {
          if (skipCallbacks) {
            return;
          }

          _this.setCoords();
          options.onComplete && options.onComplete(value, valueProgress, timeProgress);
        }
      });
    }
  });


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        clone = fabric.util.object.clone,
        coordProps = { x1: 1, x2: 1, y1: 1, y2: 1 },
        supportsLineDash = fabric.StaticCanvas.supports('setLineDash');

    if (fabric.Line) {
      fabric.warn('fabric.Line is already defined');
      return;
    }

    /**
     * Line class
     * @class fabric.Line
     * @extends fabric.Object
     * @see {@link fabric.Line#initialize} for constructor definition
     */
    fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'line',

      /**
       * x value or first line edge
       * @type Number
       * @default
       */
      x1: 0,

      /**
       * y value or first line edge
       * @type Number
       * @default
       */
      y1: 0,

      /**
       * x value or second line edge
       * @type Number
       * @default
       */
      x2: 0,

      /**
       * y value or second line edge
       * @type Number
       * @default
       */
      y2: 0,

      cacheProperties: fabric.Object.prototype.cacheProperties.concat('x1', 'x2', 'y1', 'y2'),

      /**
       * Constructor
       * @param {Array} [points] Array of points
       * @param {Object} [options] Options object
       * @return {fabric.Line} thisArg
       */
      initialize: function(points, options) {
        if (!points) {
          points = [0, 0, 0, 0];
        }

        this.callSuper('initialize', options);

        this.set('x1', points[0]);
        this.set('y1', points[1]);
        this.set('x2', points[2]);
        this.set('y2', points[3]);

        this._setWidthHeight(options);
      },

      /**
       * @private
       * @param {Object} [options] Options
       */
      _setWidthHeight: function(options) {
        options || (options = { });

        this.width = Math.abs(this.x2 - this.x1);
        this.height = Math.abs(this.y2 - this.y1);

        this.left = 'left' in options
          ? options.left
          : this._getLeftToOriginX();

        this.top = 'top' in options
          ? options.top
          : this._getTopToOriginY();
      },

      /**
       * @private
       * @param {String} key
       * @param {*} value
       */
      _set: function(key, value) {
        this.callSuper('_set', key, value);
        if (typeof coordProps[key] !== 'undefined') {
          this._setWidthHeight();
        }
        return this;
      },

      /**
       * @private
       * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.
       */
      _getLeftToOriginX: makeEdgeToOriginGetter(
        { // property names
          origin: 'originX',
          axis1: 'x1',
          axis2: 'x2',
          dimension: 'width'
        },
        { // possible values of origin
          nearest: 'left',
          center: 'center',
          farthest: 'right'
        }
      ),

      /**
       * @private
       * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.
       */
      _getTopToOriginY: makeEdgeToOriginGetter(
        { // property names
          origin: 'originY',
          axis1: 'y1',
          axis2: 'y2',
          dimension: 'height'
        },
        { // possible values of origin
          nearest: 'top',
          center: 'center',
          farthest: 'bottom'
        }
      ),

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {
        ctx.beginPath();

        if (!this.strokeDashArray || this.strokeDashArray && supportsLineDash) {
          // move from center (of virtual box) to its left/top corner
          // we can't assume x1, y1 is top left and x2, y2 is bottom right
          var p = this.calcLinePoints();
          ctx.moveTo(p.x1, p.y1);
          ctx.lineTo(p.x2, p.y2);
        }

        ctx.lineWidth = this.strokeWidth;

        // TODO: test this
        // make sure setting "fill" changes color of a line
        // (by copying fillStyle to strokeStyle, since line is stroked, not filled)
        var origStrokeStyle = ctx.strokeStyle;
        ctx.strokeStyle = this.stroke || ctx.fillStyle;
        this.stroke && this._renderStroke(ctx);
        ctx.strokeStyle = origStrokeStyle;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderDashedStroke: function(ctx) {
        var p = this.calcLinePoints();

        ctx.beginPath();
        fabric.util.drawDashedLine(ctx, p.x1, p.y1, p.x2, p.y2, this.strokeDashArray);
        ctx.closePath();
      },

      /**
       * This function is an helper for svg import. it returns the center of the object in the svg
       * untransformed coordinates
       * @private
       * @return {Object} center point from element coordinates
       */
      _findCenterFromElement: function() {
        return {
          x: (this.x1 + this.x2) / 2,
          y: (this.y1 + this.y2) / 2,
        };
      },

      /**
       * Returns object representation of an instance
       * @methd toObject
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        return extend(this.callSuper('toObject', propertiesToInclude), this.calcLinePoints());
      },

      /*
       * Calculate object dimensions from its properties
       * @private
       */
      _getNonTransformedDimensions: function() {
        var dim = this.callSuper('_getNonTransformedDimensions');
        if (this.strokeLineCap === 'butt') {
          if (this.width === 0) {
            dim.y -= this.strokeWidth;
          }
          if (this.height === 0) {
            dim.x -= this.strokeWidth;
          }
        }
        return dim;
      },

      /**
       * Recalculates line points given width and height
       * @private
       */
      calcLinePoints: function() {
        var xMult = this.x1 <= this.x2 ? -1 : 1,
            yMult = this.y1 <= this.y2 ? -1 : 1,
            x1 = (xMult * this.width * 0.5),
            y1 = (yMult * this.height * 0.5),
            x2 = (xMult * this.width * -0.5),
            y2 = (yMult * this.height * -0.5);

        return {
          x1: x1,
          x2: x2,
          y1: y1,
          y2: y2
        };
      },

      /* _TO_SVG_START_ */
      /**
       * Returns SVG representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        var markup = this._createBaseSVGMarkup(),
            p = this.calcLinePoints();
        markup.push(
          '<line ', this.getSvgId(),
          'x1="', p.x1,
          '" y1="', p.y1,
          '" x2="', p.x2,
          '" y2="', p.y2,
          '" style="', this.getSvgStyles(),
          '" transform="', this.getSvgTransform(),
          this.getSvgTransformMatrix(),
          '"/>\n'
        );

        return reviver ? reviver(markup.join('')) : markup.join('');
      },
      /* _TO_SVG_END_ */
    });

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})
     * @static
     * @memberOf fabric.Line
     * @see http://www.w3.org/TR/SVG/shapes.html#LineElement
     */
    fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x1 y1 x2 y2'.split(' '));

    /**
     * Returns fabric.Line instance from an SVG element
     * @static
     * @memberOf fabric.Line
     * @param {SVGElement} element Element to parse
     * @param {Object} [options] Options object
     * @param {Function} [callback] callback function invoked after parsing
     */
    fabric.Line.fromElement = function(element, callback, options) {
      options = options || { };
      var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES),
          points = [
            parsedAttributes.x1 || 0,
            parsedAttributes.y1 || 0,
            parsedAttributes.x2 || 0,
            parsedAttributes.y2 || 0
          ];
      callback(new fabric.Line(points, extend(parsedAttributes, options)));
    };
    /* _FROM_SVG_END_ */

    /**
     * Returns fabric.Line instance from an object representation
     * @static
     * @memberOf fabric.Line
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] invoked with new instance as first argument
     */
    fabric.Line.fromObject = function(object, callback) {
      function _callback(instance) {
        delete instance.points;
        callback && callback(instance);
      }    var options = clone(object, true);
      options.points = [object.x1, object.y1, object.x2, object.y2];
      fabric.Object._fromObject('Line', options, _callback, 'points');
    };

    /**
     * Produces a function that calculates distance from canvas edge to Line origin.
     */
    function makeEdgeToOriginGetter(propertyNames, originValues) {
      var origin = propertyNames.origin,
          axis1 = propertyNames.axis1,
          axis2 = propertyNames.axis2,
          dimension = propertyNames.dimension,
          nearest = originValues.nearest,
          center = originValues.center,
          farthest = originValues.farthest;

      return function() {
        switch (this.get(origin)) {
          case nearest:
            return Math.min(this.get(axis1), this.get(axis2));
          case center:
            return Math.min(this.get(axis1), this.get(axis2)) + (0.5 * this.get(dimension));
          case farthest:
            return Math.max(this.get(axis1), this.get(axis2));
        }
      };

    }

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        pi = Math.PI;

    if (fabric.Circle) {
      fabric.warn('fabric.Circle is already defined.');
      return;
    }

    /**
     * Circle class
     * @class fabric.Circle
     * @extends fabric.Object
     * @see {@link fabric.Circle#initialize} for constructor definition
     */
    fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'circle',

      /**
       * Radius of this circle
       * @type Number
       * @default
       */
      radius: 0,

      /**
       * Start angle of the circle, moving clockwise
       * deprectated type, this should be in degree, this was an oversight.
       * probably will change to degrees in next major version
       * @type Number
       * @default 0
       */
      startAngle: 0,

      /**
       * End angle of the circle
       * deprectated type, this should be in degree, this was an oversight.
       * probably will change to degrees in next major version
       * @type Number
       * @default 2Pi
       */
      endAngle: pi * 2,

      cacheProperties: fabric.Object.prototype.cacheProperties.concat('radius', 'startAngle', 'endAngle'),

      /**
       * @private
       * @param {String} key
       * @param {*} value
       * @return {fabric.Circle} thisArg
       */
      _set: function(key, value) {
        this.callSuper('_set', key, value);

        if (key === 'radius') {
          this.setRadius(value);
        }

        return this;
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        return this.callSuper('toObject', ['radius', 'startAngle', 'endAngle'].concat(propertiesToInclude));
      },

      /* _TO_SVG_START_ */
      /**
       * Returns svg representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        var markup = this._createBaseSVGMarkup(), x = 0, y = 0,
            angle = (this.endAngle - this.startAngle) % ( 2 * pi);

        if (angle === 0) {
          markup.push(
            '<circle ', this.getSvgId(),
            'cx="' + x + '" cy="' + y + '" ',
            'r="', this.radius,
            '" style="', this.getSvgStyles(),
            '" transform="', this.getSvgTransform(),
            ' ', this.getSvgTransformMatrix(), '"',
            this.addPaintOrder(),
            '/>\n'
          );
        }
        else {
          var startX = fabric.util.cos(this.startAngle) * this.radius,
              startY = fabric.util.sin(this.startAngle) * this.radius,
              endX = fabric.util.cos(this.endAngle) * this.radius,
              endY = fabric.util.sin(this.endAngle) * this.radius,
              largeFlag = angle > pi ? '1' : '0';

          markup.push(
            '<path d="M ' + startX + ' ' + startY,
            ' A ' + this.radius + ' ' + this.radius,
            ' 0 ', +largeFlag + ' 1', ' ' + endX + ' ' + endY,
            '" style="', this.getSvgStyles(),
            '" transform="', this.getSvgTransform(),
            ' ', this.getSvgTransformMatrix(), '"',
            this.addPaintOrder(),
            '"/>\n'
          );
        }

        return reviver ? reviver(markup.join('')) : markup.join('');
      },
      /* _TO_SVG_END_ */

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx context to render on
       */
      _render: function(ctx) {
        ctx.beginPath();
        ctx.arc(
          0,
          0,
          this.radius,
          this.startAngle,
          this.endAngle, false);
        this._renderPaintInOrder(ctx);
      },

      /**
       * Returns horizontal radius of an object (according to how an object is scaled)
       * @return {Number}
       */
      getRadiusX: function() {
        return this.get('radius') * this.get('scaleX');
      },

      /**
       * Returns vertical radius of an object (according to how an object is scaled)
       * @return {Number}
       */
      getRadiusY: function() {
        return this.get('radius') * this.get('scaleY');
      },

      /**
       * Sets radius of an object (and updates width accordingly)
       * @return {fabric.Circle} thisArg
       */
      setRadius: function(value) {
        this.radius = value;
        return this.set('width', value * 2).set('height', value * 2);
      },
    });

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})
     * @static
     * @memberOf fabric.Circle
     * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement
     */
    fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy r'.split(' '));

    /**
     * Returns {@link fabric.Circle} instance from an SVG element
     * @static
     * @memberOf fabric.Circle
     * @param {SVGElement} element Element to parse
     * @param {Function} [callback] Options callback invoked after parsing is finished
     * @param {Object} [options] Options object
     * @throws {Error} If value of `r` attribute is missing or invalid
     */
    fabric.Circle.fromElement = function(element, callback) {
      var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);

      if (!isValidRadius(parsedAttributes)) {
        throw new Error('value of `r` attribute is required and can not be negative');
      }

      parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.radius;
      parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.radius;
      callback(new fabric.Circle(parsedAttributes));
    };

    /**
     * @private
     */
    function isValidRadius(attributes) {
      return (('radius' in attributes) && (attributes.radius >= 0));
    }
    /* _FROM_SVG_END_ */

    /**
     * Returns {@link fabric.Circle} instance from an object representation
     * @static
     * @memberOf fabric.Circle
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] invoked with new instance as first argument
     * @return {Object} Instance of fabric.Circle
     */
    fabric.Circle.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Circle', object, callback);
    };

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { });

    if (fabric.Triangle) {
      fabric.warn('fabric.Triangle is already defined');
      return;
    }

    /**
     * Triangle class
     * @class fabric.Triangle
     * @extends fabric.Object
     * @return {fabric.Triangle} thisArg
     * @see {@link fabric.Triangle#initialize} for constructor definition
     */
    fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'triangle',

      /**
       * Width is set to 100 to compensate the old initialize code that was setting it to 100
       * @type Number
       * @default
       */
      width: 100,

      /**
       * Height is set to 100 to compensate the old initialize code that was setting it to 100
       * @type Number
       * @default
       */
      height: 100,

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {
        var widthBy2 = this.width / 2,
            heightBy2 = this.height / 2;

        ctx.beginPath();
        ctx.moveTo(-widthBy2, heightBy2);
        ctx.lineTo(0, -heightBy2);
        ctx.lineTo(widthBy2, heightBy2);
        ctx.closePath();

        this._renderPaintInOrder(ctx);
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderDashedStroke: function(ctx) {
        var widthBy2 = this.width / 2,
            heightBy2 = this.height / 2;

        ctx.beginPath();
        fabric.util.drawDashedLine(ctx, -widthBy2, heightBy2, 0, -heightBy2, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, 0, -heightBy2, widthBy2, heightBy2, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, widthBy2, heightBy2, -widthBy2, heightBy2, this.strokeDashArray);
        ctx.closePath();
      },

      /* _TO_SVG_START_ */
      /**
       * Returns SVG representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        var markup = this._createBaseSVGMarkup(),
            widthBy2 = this.width / 2,
            heightBy2 = this.height / 2,
            points = [
              -widthBy2 + ' ' + heightBy2,
              '0 ' + -heightBy2,
              widthBy2 + ' ' + heightBy2
            ]
              .join(',');

        markup.push(
          '<polygon ', this.getSvgId(),
          'points="', points,
          '" style="', this.getSvgStyles(),
          '" transform="', this.getSvgTransform(), '"',
          this.addPaintOrder(),
          '/>'
        );

        return reviver ? reviver(markup.join('')) : markup.join('');
      },
      /* _TO_SVG_END_ */
    });

    /**
     * Returns {@link fabric.Triangle} instance from an object representation
     * @static
     * @memberOf fabric.Triangle
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] invoked with new instance as first argument
     */
    fabric.Triangle.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Triangle', object, callback);
    };

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        piBy2   = Math.PI * 2;

    if (fabric.Ellipse) {
      fabric.warn('fabric.Ellipse is already defined.');
      return;
    }

    /**
     * Ellipse class
     * @class fabric.Ellipse
     * @extends fabric.Object
     * @return {fabric.Ellipse} thisArg
     * @see {@link fabric.Ellipse#initialize} for constructor definition
     */
    fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'ellipse',

      /**
       * Horizontal radius
       * @type Number
       * @default
       */
      rx:   0,

      /**
       * Vertical radius
       * @type Number
       * @default
       */
      ry:   0,

      cacheProperties: fabric.Object.prototype.cacheProperties.concat('rx', 'ry'),

      /**
       * Constructor
       * @param {Object} [options] Options object
       * @return {fabric.Ellipse} thisArg
       */
      initialize: function(options) {
        this.callSuper('initialize', options);
        this.set('rx', options && options.rx || 0);
        this.set('ry', options && options.ry || 0);
      },

      /**
       * @private
       * @param {String} key
       * @param {*} value
       * @return {fabric.Ellipse} thisArg
       */
      _set: function(key, value) {
        this.callSuper('_set', key, value);
        switch (key) {

          case 'rx':
            this.rx = value;
            this.set('width', value * 2);
            break;

          case 'ry':
            this.ry = value;
            this.set('height', value * 2);
            break;

        }
        return this;
      },

      /**
       * Returns horizontal radius of an object (according to how an object is scaled)
       * @return {Number}
       */
      getRx: function() {
        return this.get('rx') * this.get('scaleX');
      },

      /**
       * Returns Vertical radius of an object (according to how an object is scaled)
       * @return {Number}
       */
      getRy: function() {
        return this.get('ry') * this.get('scaleY');
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
      },

      /* _TO_SVG_START_ */
      /**
       * Returns svg representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        var markup = this._createBaseSVGMarkup();
        markup.push(
          '<ellipse ', this.getSvgId(),
          'cx="0" cy="0" ',
          'rx="', this.rx,
          '" ry="', this.ry,
          '" style="', this.getSvgStyles(),
          '" transform="', this.getSvgTransform(),
          this.getSvgTransformMatrix(), '"',
          this.addPaintOrder(),
          '/>\n'
        );

        return reviver ? reviver(markup.join('')) : markup.join('');
      },
      /* _TO_SVG_END_ */

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx context to render on
       */
      _render: function(ctx) {
        ctx.beginPath();
        ctx.save();
        ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);
        ctx.arc(
          0,
          0,
          this.rx,
          0,
          piBy2,
          false);
        ctx.restore();
        this._renderPaintInOrder(ctx);
      },
    });

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})
     * @static
     * @memberOf fabric.Ellipse
     * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement
     */
    fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy rx ry'.split(' '));

    /**
     * Returns {@link fabric.Ellipse} instance from an SVG element
     * @static
     * @memberOf fabric.Ellipse
     * @param {SVGElement} element Element to parse
     * @param {Function} [callback] Options callback invoked after parsing is finished
     * @return {fabric.Ellipse}
     */
    fabric.Ellipse.fromElement = function(element, callback) {

      var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);

      parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.rx;
      parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.ry;
      callback(new fabric.Ellipse(parsedAttributes));
    };
    /* _FROM_SVG_END_ */

    /**
     * Returns {@link fabric.Ellipse} instance from an object representation
     * @static
     * @memberOf fabric.Ellipse
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] invoked with new instance as first argument
     * @return {fabric.Ellipse}
     */
    fabric.Ellipse.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Ellipse', object, callback);
    };

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend;

    if (fabric.Rect) {
      fabric.warn('fabric.Rect is already defined');
      return;
    }

    /**
     * Rectangle class
     * @class fabric.Rect
     * @extends fabric.Object
     * @return {fabric.Rect} thisArg
     * @see {@link fabric.Rect#initialize} for constructor definition
     */
    fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {

      /**
       * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})
       * as well as for history (undo/redo) purposes
       * @type Array
       */
      stateProperties: fabric.Object.prototype.stateProperties.concat('rx', 'ry'),

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'rect',

      /**
       * Horizontal border radius
       * @type Number
       * @default
       */
      rx:   0,

      /**
       * Vertical border radius
       * @type Number
       * @default
       */
      ry:   0,

      cacheProperties: fabric.Object.prototype.cacheProperties.concat('rx', 'ry'),

      /**
       * Constructor
       * @param {Object} [options] Options object
       * @return {Object} thisArg
       */
      initialize: function(options) {
        this.callSuper('initialize', options);
        this._initRxRy();
      },

      /**
       * Initializes rx/ry attributes
       * @private
       */
      _initRxRy: function() {
        if (this.rx && !this.ry) {
          this.ry = this.rx;
        }
        else if (this.ry && !this.rx) {
          this.rx = this.ry;
        }
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {

        // optimize 1x1 case (used in spray brush)
        if (this.width === 1 && this.height === 1) {
          ctx.fillRect(-0.5, -0.5, 1, 1);
          return;
        }

        var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0,
            ry = this.ry ? Math.min(this.ry, this.height / 2) : 0,
            w = this.width,
            h = this.height,
            x = -this.width / 2,
            y = -this.height / 2,
            isRounded = rx !== 0 || ry !== 0,
            /* "magic number" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */
            k = 1 - 0.5522847498;
        ctx.beginPath();

        ctx.moveTo(x + rx, y);

        ctx.lineTo(x + w - rx, y);
        isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);

        ctx.lineTo(x + w, y + h - ry);
        isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);

        ctx.lineTo(x + rx, y + h);
        isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);

        ctx.lineTo(x, y + ry);
        isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);

        ctx.closePath();

        this._renderPaintInOrder(ctx);
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderDashedStroke: function(ctx) {
        var x = -this.width / 2,
            y = -this.height / 2,
            w = this.width,
            h = this.height;

        ctx.beginPath();
        fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
        ctx.closePath();
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
      },

      /* _TO_SVG_START_ */
      /**
       * Returns svg representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        var markup = this._createBaseSVGMarkup(), x = -this.width / 2, y = -this.height / 2;
        markup.push(
          '<rect ', this.getSvgId(),
          'x="', x, '" y="', y,
          '" rx="', this.get('rx'), '" ry="', this.get('ry'),
          '" width="', this.width, '" height="', this.height,
          '" style="', this.getSvgStyles(),
          '" transform="', this.getSvgTransform(),
          this.getSvgTransformMatrix(), '"',
          this.addPaintOrder(),
          '/>\n');

        return reviver ? reviver(markup.join('')) : markup.join('');
      },
      /* _TO_SVG_END_ */
    });

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)
     * @static
     * @memberOf fabric.Rect
     * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement
     */
    fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x y rx ry width height'.split(' '));

    /**
     * Returns {@link fabric.Rect} instance from an SVG element
     * @static
     * @memberOf fabric.Rect
     * @param {SVGElement} element Element to parse
     * @param {Function} callback callback function invoked after parsing
     * @param {Object} [options] Options object
     */
    fabric.Rect.fromElement = function(element, callback, options) {
      if (!element) {
        return callback(null);
      }
      options = options || { };

      var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);

      parsedAttributes.left = parsedAttributes.left || 0;
      parsedAttributes.top  = parsedAttributes.top  || 0;
      var rect = new fabric.Rect(extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
      rect.visible = rect.visible && rect.width > 0 && rect.height > 0;
      callback(rect);
    };
    /* _FROM_SVG_END_ */

    /**
     * Returns {@link fabric.Rect} instance from an object representation
     * @static
     * @memberOf fabric.Rect
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] Callback to invoke when an fabric.Rect instance is created
     */
    fabric.Rect.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Rect', object, callback);
    };

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        min = fabric.util.array.min,
        max = fabric.util.array.max,
        toFixed = fabric.util.toFixed;

    if (fabric.Polyline) {
      fabric.warn('fabric.Polyline is already defined');
      return;
    }

    /**
     * Polyline class
     * @class fabric.Polyline
     * @extends fabric.Object
     * @see {@link fabric.Polyline#initialize} for constructor definition
     */
    fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'polyline',

      /**
       * Points array
       * @type Array
       * @default
       */
      points: null,

      cacheProperties: fabric.Object.prototype.cacheProperties.concat('points'),

      /**
       * Constructor
       * @param {Array} points Array of points (where each point is an object with x and y)
       * @param {Object} [options] Options object
       * @return {fabric.Polyline} thisArg
       * @example
       * var poly = new fabric.Polyline([
       *     { x: 10, y: 10 },
       *     { x: 50, y: 30 },
       *     { x: 40, y: 70 },
       *     { x: 60, y: 50 },
       *     { x: 100, y: 150 },
       *     { x: 40, y: 100 }
       *   ], {
       *   stroke: 'red',
       *   left: 100,
       *   top: 100
       * });
       */
      initialize: function(points, options) {
        options = options || {};
        this.points = points || [];
        this.callSuper('initialize', options);
        var calcDim = this._calcDimensions();
        if (typeof options.left === 'undefined') {
          this.left = calcDim.left;
        }
        if (typeof options.top === 'undefined') {
          this.top = calcDim.top;
        }
        this.width = calcDim.width;
        this.height = calcDim.height;
        this.pathOffset = {
          x: calcDim.left + this.width / 2,
          y: calcDim.top + this.height / 2
        };
      },

      /**
       * Calculate the polygon min and max point from points array,
       * returning an object with left, top, widht, height to measure the
       * polygon size
       * @return {Object} object.left X coordinate of the polygon leftmost point
       * @return {Object} object.top Y coordinate of the polygon topmost point
       * @return {Object} object.width distance between X coordinates of the polygon leftmost and rightmost point
       * @return {Object} object.height distance between Y coordinates of the polygon topmost and bottommost point
       * @private
       */
      _calcDimensions: function() {

        var points = this.points,
            minX = min(points, 'x') || 0,
            minY = min(points, 'y') || 0,
            maxX = max(points, 'x') || 0,
            maxY = max(points, 'y') || 0,
            width = (maxX - minX),
            height = (maxY - minY);

        return {
          left: minX,
          top: minY,
          width: width,
          height: height
        };
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} Object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        return extend(this.callSuper('toObject', propertiesToInclude), {
          points: this.points.concat()
        });
      },

      /* _TO_SVG_START_ */
      /**
       * Returns svg representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        var points = [], diffX = this.pathOffset.x, diffY = this.pathOffset.y,
            markup = this._createBaseSVGMarkup(),
            NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;

        for (var i = 0, len = this.points.length; i < len; i++) {
          points.push(
            toFixed(this.points[i].x - diffX, NUM_FRACTION_DIGITS), ',',
            toFixed(this.points[i].y - diffY, NUM_FRACTION_DIGITS), ' '
          );
        }
        markup.push(
          '<', this.type, ' ', this.getSvgId(),
          'points="', points.join(''),
          '" style="', this.getSvgStyles(),
          '" transform="', this.getSvgTransform(),
          ' ', this.getSvgTransformMatrix(), '"',
          this.addPaintOrder(),
          '/>\n'
        );

        return reviver ? reviver(markup.join('')) : markup.join('');
      },
      /* _TO_SVG_END_ */


      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      commonRender: function(ctx) {
        var point, len = this.points.length,
            x = this.pathOffset.x,
            y = this.pathOffset.y;

        if (!len || isNaN(this.points[len - 1].y)) {
          // do not draw if no points or odd points
          // NaN comes from parseFloat of a empty string in parser
          return false;
        }
        ctx.beginPath();
        ctx.moveTo(this.points[0].x - x, this.points[0].y - y);
        for (var i = 0; i < len; i++) {
          point = this.points[i];
          ctx.lineTo(point.x - x, point.y - y);
        }
        return true;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {
        if (!this.commonRender(ctx)) {
          return;
        }
        this._renderPaintInOrder(ctx);
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderDashedStroke: function(ctx) {
        var p1, p2;

        ctx.beginPath();
        for (var i = 0, len = this.points.length; i < len; i++) {
          p1 = this.points[i];
          p2 = this.points[i + 1] || p1;
          fabric.util.drawDashedLine(ctx, p1.x, p1.y, p2.x, p2.y, this.strokeDashArray);
        }
      },

      /**
       * Returns complexity of an instance
       * @return {Number} complexity of this instance
       */
      complexity: function() {
        return this.get('points').length;
      }
    });

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})
     * @static
     * @memberOf fabric.Polyline
     * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement
     */
    fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();

    /**
     * Returns fabric.Polyline instance from an SVG element
     * @static
     * @memberOf fabric.Polyline
     * @param {SVGElement} element Element to parser
     * @param {Function} callback callback function invoked after parsing
     * @param {Object} [options] Options object
     */
    fabric.Polyline.fromElement = function(element, callback, options) {
      if (!element) {
        return callback(null);
      }
      options || (options = { });

      var points = fabric.parsePointsAttribute(element.getAttribute('points')),
          parsedAttributes = fabric.parseAttributes(element, fabric.Polyline.ATTRIBUTE_NAMES);

      callback(new fabric.Polyline(points, fabric.util.object.extend(parsedAttributes, options)));
    };
    /* _FROM_SVG_END_ */

    /**
     * Returns fabric.Polyline instance from an object representation
     * @static
     * @memberOf fabric.Polyline
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
     */
    fabric.Polyline.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Polyline', object, callback, 'points');
    };

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend;

    if (fabric.Polygon) {
      fabric.warn('fabric.Polygon is already defined');
      return;
    }

    /**
     * Polygon class
     * @class fabric.Polygon
     * @extends fabric.Polyline
     * @see {@link fabric.Polygon#initialize} for constructor definition
     */
    fabric.Polygon = fabric.util.createClass(fabric.Polyline, /** @lends fabric.Polygon.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'polygon',

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {
        if (!this.commonRender(ctx)) {
          return;
        }
        ctx.closePath();
        this._renderPaintInOrder(ctx);
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderDashedStroke: function(ctx) {
        this.callSuper('_renderDashedStroke', ctx);
        ctx.closePath();
      },
    });

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)
     * @static
     * @memberOf fabric.Polygon
     * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement
     */
    fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();

    /**
     * Returns {@link fabric.Polygon} instance from an SVG element
     * @static
     * @memberOf fabric.Polygon
     * @param {SVGElement} element Element to parse
     * @param {Function} callback callback function invoked after parsing
     * @param {Object} [options] Options object
     */
    fabric.Polygon.fromElement = function(element, callback, options) {
      if (!element) {
        return callback(null);
      }

      options || (options = { });

      var points = fabric.parsePointsAttribute(element.getAttribute('points')),
          parsedAttributes = fabric.parseAttributes(element, fabric.Polygon.ATTRIBUTE_NAMES);

      callback(new fabric.Polygon(points, extend(parsedAttributes, options)));
    };
    /* _FROM_SVG_END_ */

    /**
     * Returns fabric.Polygon instance from an object representation
     * @static
     * @memberOf fabric.Polygon
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
     */
    fabric.Polygon.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Polygon', object, callback, 'points');
    };

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        min = fabric.util.array.min,
        max = fabric.util.array.max,
        extend = fabric.util.object.extend,
        _toString = Object.prototype.toString,
        drawArc = fabric.util.drawArc,
        commandLengths = {
          m: 2,
          l: 2,
          h: 1,
          v: 1,
          c: 6,
          s: 4,
          q: 4,
          t: 2,
          a: 7
        },
        repeatedCommands = {
          m: 'l',
          M: 'L'
        };

    if (fabric.Path) {
      fabric.warn('fabric.Path is already defined');
      return;
    }

    /**
     * Path class
     * @class fabric.Path
     * @extends fabric.Object
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}
     * @see {@link fabric.Path#initialize} for constructor definition
     */
    fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'path',

      /**
       * Array of path points
       * @type Array
       * @default
       */
      path: null,

      cacheProperties: fabric.Object.prototype.cacheProperties.concat('path', 'fillRule'),

      stateProperties: fabric.Object.prototype.stateProperties.concat('path'),

      /**
       * Constructor
       * @param {Array|String} path Path data (sequence of coordinates and corresponding "command" tokens)
       * @param {Object} [options] Options object
       * @return {fabric.Path} thisArg
       */
      initialize: function(path, options) {
        options = options || { };
        this.callSuper('initialize', options);

        if (!path) {
          path = [];
        }

        var fromArray = _toString.call(path) === '[object Array]';

        this.path = fromArray
          ? path
          // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)
          : path.match && path.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);

        if (!this.path) {
          return;
        }

        if (!fromArray) {
          this.path = this._parsePath();
        }

        this._setPositionDimensions(options);
      },

      /**
       * @private
       * @param {Object} options Options object
       */
      _setPositionDimensions: function(options) {
        var calcDim = this._parseDimensions();

        this.width = calcDim.width;
        this.height = calcDim.height;

        if (typeof options.left === 'undefined') {
          this.left = calcDim.left;
        }

        if (typeof options.top === 'undefined') {
          this.top = calcDim.top;
        }

        this.pathOffset = this.pathOffset || {
          x: calcDim.left + this.width / 2,
          y: calcDim.top + this.height / 2
        };
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx context to render path on
       */
      _renderPathCommands: function(ctx) {
        var current, // current instruction
            previous = null,
            subpathStartX = 0,
            subpathStartY = 0,
            x = 0, // current x
            y = 0, // current y
            controlX = 0, // current control point x
            controlY = 0, // current control point y
            tempX,
            tempY,
            l = -this.pathOffset.x,
            t = -this.pathOffset.y;

        ctx.beginPath();

        for (var i = 0, len = this.path.length; i < len; ++i) {

          current = this.path[i];

          switch (current[0]) { // first letter

            case 'l': // lineto, relative
              x += current[1];
              y += current[2];
              ctx.lineTo(x + l, y + t);
              break;

            case 'L': // lineto, absolute
              x = current[1];
              y = current[2];
              ctx.lineTo(x + l, y + t);
              break;

            case 'h': // horizontal lineto, relative
              x += current[1];
              ctx.lineTo(x + l, y + t);
              break;

            case 'H': // horizontal lineto, absolute
              x = current[1];
              ctx.lineTo(x + l, y + t);
              break;

            case 'v': // vertical lineto, relative
              y += current[1];
              ctx.lineTo(x + l, y + t);
              break;

            case 'V': // verical lineto, absolute
              y = current[1];
              ctx.lineTo(x + l, y + t);
              break;

            case 'm': // moveTo, relative
              x += current[1];
              y += current[2];
              subpathStartX = x;
              subpathStartY = y;
              ctx.moveTo(x + l, y + t);
              break;

            case 'M': // moveTo, absolute
              x = current[1];
              y = current[2];
              subpathStartX = x;
              subpathStartY = y;
              ctx.moveTo(x + l, y + t);
              break;

            case 'c': // bezierCurveTo, relative
              tempX = x + current[5];
              tempY = y + current[6];
              controlX = x + current[3];
              controlY = y + current[4];
              ctx.bezierCurveTo(
                x + current[1] + l, // x1
                y + current[2] + t, // y1
                controlX + l, // x2
                controlY + t, // y2
                tempX + l,
                tempY + t
              );
              x = tempX;
              y = tempY;
              break;

            case 'C': // bezierCurveTo, absolute
              x = current[5];
              y = current[6];
              controlX = current[3];
              controlY = current[4];
              ctx.bezierCurveTo(
                current[1] + l,
                current[2] + t,
                controlX + l,
                controlY + t,
                x + l,
                y + t
              );
              break;

            case 's': // shorthand cubic bezierCurveTo, relative

              // transform to absolute x,y
              tempX = x + current[3];
              tempY = y + current[4];

              if (previous[0].match(/[CcSs]/) === null) {
                // If there is no previous command or if the previous command was not a C, c, S, or s,
                // the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control points
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }

              ctx.bezierCurveTo(
                controlX + l,
                controlY + t,
                x + current[1] + l,
                y + current[2] + t,
                tempX + l,
                tempY + t
              );
              // set control point to 2nd one of this command
              // "... the first control point is assumed to be
              // the reflection of the second control point on
              // the previous command relative to the current point."
              controlX = x + current[1];
              controlY = y + current[2];

              x = tempX;
              y = tempY;
              break;

            case 'S': // shorthand cubic bezierCurveTo, absolute
              tempX = current[3];
              tempY = current[4];
              if (previous[0].match(/[CcSs]/) === null) {
                // If there is no previous command or if the previous command was not a C, c, S, or s,
                // the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control points
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }
              ctx.bezierCurveTo(
                controlX + l,
                controlY + t,
                current[1] + l,
                current[2] + t,
                tempX + l,
                tempY + t
              );
              x = tempX;
              y = tempY;

              // set control point to 2nd one of this command
              // "... the first control point is assumed to be
              // the reflection of the second control point on
              // the previous command relative to the current point."
              controlX = current[1];
              controlY = current[2];

              break;

            case 'q': // quadraticCurveTo, relative
              // transform to absolute x,y
              tempX = x + current[3];
              tempY = y + current[4];

              controlX = x + current[1];
              controlY = y + current[2];

              ctx.quadraticCurveTo(
                controlX + l,
                controlY + t,
                tempX + l,
                tempY + t
              );
              x = tempX;
              y = tempY;
              break;

            case 'Q': // quadraticCurveTo, absolute
              tempX = current[3];
              tempY = current[4];

              ctx.quadraticCurveTo(
                current[1] + l,
                current[2] + t,
                tempX + l,
                tempY + t
              );
              x = tempX;
              y = tempY;
              controlX = current[1];
              controlY = current[2];
              break;

            case 't': // shorthand quadraticCurveTo, relative

              // transform to absolute x,y
              tempX = x + current[1];
              tempY = y + current[2];

              if (previous[0].match(/[QqTt]/) === null) {
                // If there is no previous command or if the previous command was not a Q, q, T or t,
                // assume the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control point
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }

              ctx.quadraticCurveTo(
                controlX + l,
                controlY + t,
                tempX + l,
                tempY + t
              );
              x = tempX;
              y = tempY;

              break;

            case 'T':
              tempX = current[1];
              tempY = current[2];

              if (previous[0].match(/[QqTt]/) === null) {
                // If there is no previous command or if the previous command was not a Q, q, T or t,
                // assume the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control point
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }
              ctx.quadraticCurveTo(
                controlX + l,
                controlY + t,
                tempX + l,
                tempY + t
              );
              x = tempX;
              y = tempY;
              break;

            case 'a':
              // TODO: optimize this
              drawArc(ctx, x + l, y + t, [
                current[1],
                current[2],
                current[3],
                current[4],
                current[5],
                current[6] + x + l,
                current[7] + y + t
              ]);
              x += current[6];
              y += current[7];
              break;

            case 'A':
              // TODO: optimize this
              drawArc(ctx, x + l, y + t, [
                current[1],
                current[2],
                current[3],
                current[4],
                current[5],
                current[6] + l,
                current[7] + t
              ]);
              x = current[6];
              y = current[7];
              break;

            case 'z':
            case 'Z':
              x = subpathStartX;
              y = subpathStartY;
              ctx.closePath();
              break;
          }
          previous = current;
        }
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx context to render path on
       */
      _render: function(ctx) {
        this._renderPathCommands(ctx);
        this._renderPaintInOrder(ctx);
      },

      /**
       * Returns string representation of an instance
       * @return {String} string representation of an instance
       */
      toString: function() {
        return '#<fabric.Path (' + this.complexity() +
          '): { "top": ' + this.top + ', "left": ' + this.left + ' }>';
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        var o = extend(this.callSuper('toObject', propertiesToInclude), {
          path: this.path.map(function(item) { return item.slice(); }),
          top: this.top,
          left: this.left,
        });
        return o;
      },

      /**
       * Returns dataless object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toDatalessObject: function(propertiesToInclude) {
        var o = this.toObject(['sourcePath'].concat(propertiesToInclude));
        if (o.sourcePath) {
          delete o.path;
        }
        return o;
      },

      /* _TO_SVG_START_ */
      /**
       * Returns svg representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        var chunks = [],
            markup = this._createBaseSVGMarkup(), addTransform = '';

        for (var i = 0, len = this.path.length; i < len; i++) {
          chunks.push(this.path[i].join(' '));
        }
        var path = chunks.join(' ');
        addTransform = ' translate(' + (-this.pathOffset.x) + ', ' + (-this.pathOffset.y) + ') ';
        markup.push(
          '<path ', this.getSvgId(),
          'd="', path,
          '" style="', this.getSvgStyles(),
          '" transform="', this.getSvgTransform(), addTransform,
          this.getSvgTransformMatrix(), '" stroke-linecap="round" ',
          this.addPaintOrder(),
          '/>\n'
        );

        return reviver ? reviver(markup.join('')) : markup.join('');
      },
      /* _TO_SVG_END_ */

      /**
       * Returns number representation of an instance complexity
       * @return {Number} complexity of this instance
       */
      complexity: function() {
        return this.path.length;
      },

      /**
       * @private
       */
      _parsePath: function() {
        var result = [],
            coords = [],
            currentPath,
            parsed,
            re = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/ig,
            match,
            coordsStr;

        for (var i = 0, coordsParsed, len = this.path.length; i < len; i++) {
          currentPath = this.path[i];

          coordsStr = currentPath.slice(1).trim();
          coords.length = 0;

          while ((match = re.exec(coordsStr))) {
            coords.push(match[0]);
          }

          coordsParsed = [currentPath.charAt(0)];

          for (var j = 0, jlen = coords.length; j < jlen; j++) {
            parsed = parseFloat(coords[j]);
            if (!isNaN(parsed)) {
              coordsParsed.push(parsed);
            }
          }

          var command = coordsParsed[0],
              commandLength = commandLengths[command.toLowerCase()],
              repeatedCommand = repeatedCommands[command] || command;

          if (coordsParsed.length - 1 > commandLength) {
            for (var k = 1, klen = coordsParsed.length; k < klen; k += commandLength) {
              result.push([command].concat(coordsParsed.slice(k, k + commandLength)));
              command = repeatedCommand;
            }
          }
          else {
            result.push(coordsParsed);
          }
        }

        return result;
      },

      /**
       * @private
       */
      _parseDimensions: function() {

        var aX = [],
            aY = [],
            current, // current instruction
            previous = null,
            subpathStartX = 0,
            subpathStartY = 0,
            x = 0, // current x
            y = 0, // current y
            controlX = 0, // current control point x
            controlY = 0, // current control point y
            tempX,
            tempY,
            bounds;

        for (var i = 0, len = this.path.length; i < len; ++i) {

          current = this.path[i];

          switch (current[0]) { // first letter

            case 'l': // lineto, relative
              x += current[1];
              y += current[2];
              bounds = [];
              break;

            case 'L': // lineto, absolute
              x = current[1];
              y = current[2];
              bounds = [];
              break;

            case 'h': // horizontal lineto, relative
              x += current[1];
              bounds = [];
              break;

            case 'H': // horizontal lineto, absolute
              x = current[1];
              bounds = [];
              break;

            case 'v': // vertical lineto, relative
              y += current[1];
              bounds = [];
              break;

            case 'V': // verical lineto, absolute
              y = current[1];
              bounds = [];
              break;

            case 'm': // moveTo, relative
              x += current[1];
              y += current[2];
              subpathStartX = x;
              subpathStartY = y;
              bounds = [];
              break;

            case 'M': // moveTo, absolute
              x = current[1];
              y = current[2];
              subpathStartX = x;
              subpathStartY = y;
              bounds = [];
              break;

            case 'c': // bezierCurveTo, relative
              tempX = x + current[5];
              tempY = y + current[6];
              controlX = x + current[3];
              controlY = y + current[4];
              bounds = fabric.util.getBoundsOfCurve(x, y,
                x + current[1], // x1
                y + current[2], // y1
                controlX, // x2
                controlY, // y2
                tempX,
                tempY
              );
              x = tempX;
              y = tempY;
              break;

            case 'C': // bezierCurveTo, absolute
              controlX = current[3];
              controlY = current[4];
              bounds = fabric.util.getBoundsOfCurve(x, y,
                current[1],
                current[2],
                controlX,
                controlY,
                current[5],
                current[6]
              );
              x = current[5];
              y = current[6];
              break;

            case 's': // shorthand cubic bezierCurveTo, relative

              // transform to absolute x,y
              tempX = x + current[3];
              tempY = y + current[4];

              if (previous[0].match(/[CcSs]/) === null) {
                // If there is no previous command or if the previous command was not a C, c, S, or s,
                // the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control points
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }

              bounds = fabric.util.getBoundsOfCurve(x, y,
                controlX,
                controlY,
                x + current[1],
                y + current[2],
                tempX,
                tempY
              );
              // set control point to 2nd one of this command
              // "... the first control point is assumed to be
              // the reflection of the second control point on
              // the previous command relative to the current point."
              controlX = x + current[1];
              controlY = y + current[2];
              x = tempX;
              y = tempY;
              break;

            case 'S': // shorthand cubic bezierCurveTo, absolute
              tempX = current[3];
              tempY = current[4];
              if (previous[0].match(/[CcSs]/) === null) {
                // If there is no previous command or if the previous command was not a C, c, S, or s,
                // the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control points
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }
              bounds = fabric.util.getBoundsOfCurve(x, y,
                controlX,
                controlY,
                current[1],
                current[2],
                tempX,
                tempY
              );
              x = tempX;
              y = tempY;
              // set control point to 2nd one of this command
              // "... the first control point is assumed to be
              // the reflection of the second control point on
              // the previous command relative to the current point."
              controlX = current[1];
              controlY = current[2];
              break;

            case 'q': // quadraticCurveTo, relative
              // transform to absolute x,y
              tempX = x + current[3];
              tempY = y + current[4];
              controlX = x + current[1];
              controlY = y + current[2];
              bounds = fabric.util.getBoundsOfCurve(x, y,
                controlX,
                controlY,
                controlX,
                controlY,
                tempX,
                tempY
              );
              x = tempX;
              y = tempY;
              break;

            case 'Q': // quadraticCurveTo, absolute
              controlX = current[1];
              controlY = current[2];
              bounds = fabric.util.getBoundsOfCurve(x, y,
                controlX,
                controlY,
                controlX,
                controlY,
                current[3],
                current[4]
              );
              x = current[3];
              y = current[4];
              break;

            case 't': // shorthand quadraticCurveTo, relative
              // transform to absolute x,y
              tempX = x + current[1];
              tempY = y + current[2];
              if (previous[0].match(/[QqTt]/) === null) {
                // If there is no previous command or if the previous command was not a Q, q, T or t,
                // assume the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control point
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }

              bounds = fabric.util.getBoundsOfCurve(x, y,
                controlX,
                controlY,
                controlX,
                controlY,
                tempX,
                tempY
              );
              x = tempX;
              y = tempY;

              break;

            case 'T':
              tempX = current[1];
              tempY = current[2];

              if (previous[0].match(/[QqTt]/) === null) {
                // If there is no previous command or if the previous command was not a Q, q, T or t,
                // assume the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control point
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }
              bounds = fabric.util.getBoundsOfCurve(x, y,
                controlX,
                controlY,
                controlX,
                controlY,
                tempX,
                tempY
              );
              x = tempX;
              y = tempY;
              break;

            case 'a':
              // TODO: optimize this
              bounds = fabric.util.getBoundsOfArc(x, y,
                current[1],
                current[2],
                current[3],
                current[4],
                current[5],
                current[6] + x,
                current[7] + y
              );
              x += current[6];
              y += current[7];
              break;

            case 'A':
              // TODO: optimize this
              bounds = fabric.util.getBoundsOfArc(x, y,
                current[1],
                current[2],
                current[3],
                current[4],
                current[5],
                current[6],
                current[7]
              );
              x = current[6];
              y = current[7];
              break;

            case 'z':
            case 'Z':
              x = subpathStartX;
              y = subpathStartY;
              break;
          }
          previous = current;
          bounds.forEach(function (point) {
            aX.push(point.x);
            aY.push(point.y);
          });
          aX.push(x);
          aY.push(y);
        }

        var minX = min(aX) || 0,
            minY = min(aY) || 0,
            maxX = max(aX) || 0,
            maxY = max(aY) || 0,
            deltaX = maxX - minX,
            deltaY = maxY - minY,

            o = {
              left: minX,
              top: minY,
              width: deltaX,
              height: deltaY
            };

        return o;
      }
    });

    /**
     * Creates an instance of fabric.Path from an object
     * @static
     * @memberOf fabric.Path
     * @param {Object} object
     * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
     */
    fabric.Path.fromObject = function(object, callback) {
      if (typeof object.sourcePath === 'string') {
        var pathUrl = object.sourcePath;
        fabric.loadSVGFromURL(pathUrl, function (elements) {
          var path = elements[0];
          path.setOptions(object);
          callback && callback(path);
        });
      }
      else {
        fabric.Object._fromObject('Path', object, callback, 'path');
      }
    };

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)
     * @static
     * @memberOf fabric.Path
     * @see http://www.w3.org/TR/SVG/paths.html#PathElement
     */
    fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(['d']);

    /**
     * Creates an instance of fabric.Path from an SVG <path> element
     * @static
     * @memberOf fabric.Path
     * @param {SVGElement} element to parse
     * @param {Function} callback Callback to invoke when an fabric.Path instance is created
     * @param {Object} [options] Options object
     * @param {Function} [callback] Options callback invoked after parsing is finished
     */
    fabric.Path.fromElement = function(element, callback, options) {
      var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);
      callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));
    };
    /* _FROM_SVG_END_ */

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        min = fabric.util.array.min,
        max = fabric.util.array.max;

    if (fabric.Group) {
      return;
    }

    /**
     * Group class
     * @class fabric.Group
     * @extends fabric.Object
     * @mixes fabric.Collection
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
     * @see {@link fabric.Group#initialize} for constructor definition
     */
    fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'group',

      /**
       * Width of stroke
       * @type Number
       * @default
       */
      strokeWidth: 0,

      /**
       * Indicates if click events should also check for subtargets
       * @type Boolean
       * @default
       */
      subTargetCheck: false,

      /**
       * Groups are container, do not render anything on theyr own, ence no cache properties
       * @type Array
       * @default
       */
      cacheProperties: [],

      /**
       * setOnGroup is a method used for TextBox that is no more used since 2.0.0 The behavior is still
       * available setting this boolean to true.
       * @type Boolean
       * @since 2.0.0
       * @default
       */
      useSetOnGroup: false,

      /**
       * Constructor
       * @param {Object} objects Group objects
       * @param {Object} [options] Options object
       * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.
       * @return {Object} thisArg
       */
      initialize: function(objects, options, isAlreadyGrouped) {
        options = options || {};
        this._objects = [];
        // if objects enclosed in a group have been grouped already,
        // we cannot change properties of objects.
        // Thus we need to set options to group without objects,
        isAlreadyGrouped && this.callSuper('initialize', options);
        this._objects = objects || [];
        for (var i = this._objects.length; i--; ) {
          this._objects[i].group = this;
        }

        if (options.originX) {
          this.originX = options.originX;
        }
        if (options.originY) {
          this.originY = options.originY;
        }

        if (!isAlreadyGrouped) {
          var center = options && options.centerPoint;
          // if coming from svg i do not want to calc bounds.
          // i assume width and height are passed along options
          center || this._calcBounds();
          this._updateObjectsCoords(center);
          delete options.centerPoint;
          this.callSuper('initialize', options);
        }
        else {
          this._updateObjectsACoords();
        }

        this.setCoords();
      },

      /**
       * @private
       * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change
       */
      _updateObjectsACoords: function() {
        var ignoreZoom = true, skipAbsolute = true;
        for (var i = this._objects.length; i--; ){
          this._objects[i].setCoords(ignoreZoom, skipAbsolute);
        }
      },

      /**
       * @private
       * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change
       */
      _updateObjectsCoords: function(center) {
        var center = center || this.getCenterPoint();
        for (var i = this._objects.length; i--; ){
          this._updateObjectCoords(this._objects[i], center);
        }
      },

      /**
       * @private
       * @param {Object} object
       * @param {fabric.Point} center, current center of group.
       */
      _updateObjectCoords: function(object, center) {
        var objectLeft = object.left,
            objectTop = object.top,
            ignoreZoom = true, skipAbsolute = true;

        object.set({
          left: objectLeft - center.x,
          top: objectTop - center.y
        });
        object.group = this;
        object.setCoords(ignoreZoom, skipAbsolute);
      },

      /**
       * Returns string represenation of a group
       * @return {String}
       */
      toString: function() {
        return '#<fabric.Group: (' + this.complexity() + ')>';
      },

      /**
       * Adds an object to a group; Then recalculates group's dimension, position.
       * @param {Object} object
       * @return {fabric.Group} thisArg
       * @chainable
       */
      addWithUpdate: function(object) {
        this._restoreObjectsState();
        fabric.util.resetObjectTransform(this);
        if (object) {
          this._objects.push(object);
          object.group = this;
          object._set('canvas', this.canvas);
        }
        this._calcBounds();
        this._updateObjectsCoords();
        this.setCoords();
        this.dirty = true;
        return this;
      },

      /**
       * Removes an object from a group; Then recalculates group's dimension, position.
       * @param {Object} object
       * @return {fabric.Group} thisArg
       * @chainable
       */
      removeWithUpdate: function(object) {
        this._restoreObjectsState();
        fabric.util.resetObjectTransform(this);

        this.remove(object);
        this._calcBounds();
        this._updateObjectsCoords();
        this.setCoords();
        this.dirty = true;
        return this;
      },

      /**
       * @private
       */
      _onObjectAdded: function(object) {
        this.dirty = true;
        object.group = this;
        object._set('canvas', this.canvas);
      },

      /**
       * @private
       */
      _onObjectRemoved: function(object) {
        this.dirty = true;
        delete object.group;
      },

      /**
       * @private
       */
      _set: function(key, value) {
        var i = this._objects.length;
        if (this.useSetOnGroup) {
          while (i--) {
            this._objects[i].setOnGroup(key, value);
          }
        }
        if (key === 'canvas') {
          i = this._objects.length;
          while (i--) {
            this._objects[i]._set(key, value);
          }
        }
        this.callSuper('_set', key, value);
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        var objsToObject = this.getObjects().map(function(obj) {
          var originalDefaults = obj.includeDefaultValues;
          obj.includeDefaultValues = obj.group.includeDefaultValues;
          var _obj = obj.toObject(propertiesToInclude);
          obj.includeDefaultValues = originalDefaults;
          return _obj;
        });
        return extend(this.callSuper('toObject', propertiesToInclude), {
          objects: objsToObject
        });
      },

      /**
       * Returns object representation of an instance, in dataless mode.
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toDatalessObject: function(propertiesToInclude) {
        var objsToObject, sourcePath = this.sourcePath;
        if (sourcePath) {
          objsToObject = sourcePath;
        }
        else {
          objsToObject = this.getObjects().map(function(obj) {
            var originalDefaults = obj.includeDefaultValues;
            obj.includeDefaultValues = obj.group.includeDefaultValues;
            var _obj = obj.toDatalessObject(propertiesToInclude);
            obj.includeDefaultValues = originalDefaults;
            return _obj;
          });
        }
        return extend(this.callSuper('toDatalessObject', propertiesToInclude), {
          objects: objsToObject
        });
      },

      /**
       * Renders instance on a given context
       * @param {CanvasRenderingContext2D} ctx context to render instance on
       */
      render: function(ctx) {
        this._transformDone = true;
        this.callSuper('render', ctx);
        this._transformDone = false;
      },

      /**
       * Decide if the object should cache or not. Create its own cache level
       * objectCaching is a global flag, wins over everything
       * needsItsOwnCache should be used when the object drawing method requires
       * a cache step. None of the fabric classes requires it.
       * Generally you do not cache objects in groups because the group outside is cached.
       * @return {Boolean}
       */
      shouldCache: function() {
        var ownCache = this.objectCaching && (!this.group || this.needsItsOwnCache() || !this.group.isOnACache());
        this.ownCaching = ownCache;
        if (ownCache) {
          for (var i = 0, len = this._objects.length; i < len; i++) {
            if (this._objects[i].willDrawShadow()) {
              this.ownCaching = false;
              return false;
            }
          }
        }
        return ownCache;
      },

      /**
       * Check if this object or a child object will cast a shadow
       * @return {Boolean}
       */
      willDrawShadow: function() {
        if (this.shadow) {
          return this.callSuper('willDrawShadow');
        }
        for (var i = 0, len = this._objects.length; i < len; i++) {
          if (this._objects[i].willDrawShadow()) {
            return true;
          }
        }
        return false;
      },

      /**
       * Check if this group or its parent group are caching, recursively up
       * @return {Boolean}
       */
      isOnACache: function() {
        return this.ownCaching || (this.group && this.group.isOnACache());
      },

      /**
       * Execute the drawing operation for an object on a specified context
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      drawObject: function(ctx) {
        for (var i = 0, len = this._objects.length; i < len; i++) {
          this._objects[i].render(ctx);
        }
      },

      /**
       * Check if cache is dirty
       */
      isCacheDirty: function() {
        if (this.callSuper('isCacheDirty')) {
          return true;
        }
        if (!this.statefullCache) {
          return false;
        }
        for (var i = 0, len = this._objects.length; i < len; i++) {
          if (this._objects[i].isCacheDirty(true)) {
            if (this._cacheCanvas) {
              // if this group has not a cache canvas there is nothing to clean
              var x = this.cacheWidth / this.zoomX, y = this.cacheHeight / this.zoomY;
              this._cacheContext.clearRect(-x / 2, -y / 2, x, y);
            }
            return true;
          }
        }
        return false;
      },

      /**
       * Retores original state of each of group objects (original state is that which was before group was created).
       * @private
       * @return {fabric.Group} thisArg
       * @chainable
       */
      _restoreObjectsState: function() {
        this._objects.forEach(this._restoreObjectState, this);
        return this;
      },

      /**
       * Realises the transform from this group onto the supplied object
       * i.e. it tells you what would happen if the supplied object was in
       * the group, and then the group was destroyed. It mutates the supplied
       * object.
       * @param {fabric.Object} object
       * @return {fabric.Object} transformedObject
       */
      realizeTransform: function(object) {
        var matrix = object.calcTransformMatrix(),
            options = fabric.util.qrDecompose(matrix),
            center = new fabric.Point(options.translateX, options.translateY);
        object.flipX = false;
        object.flipY = false;
        object.set('scaleX', options.scaleX);
        object.set('scaleY', options.scaleY);
        object.skewX = options.skewX;
        object.skewY = options.skewY;
        object.angle = options.angle;
        object.setPositionByOrigin(center, 'center', 'center');
        return object;
      },

      /**
       * Restores original state of a specified object in group
       * @private
       * @param {fabric.Object} object
       * @return {fabric.Group} thisArg
       */
      _restoreObjectState: function(object) {
        this.realizeTransform(object);
        object.setCoords();
        delete object.group;
        return this;
      },

      /**
       * Destroys a group (restoring state of its objects)
       * @return {fabric.Group} thisArg
       * @chainable
       */
      destroy: function() {
        // when group is destroyed objects needs to get a repaint to be eventually
        // displayed on canvas.
        this._objects.forEach(function(object) {
          object.set('dirty', true);
        });
        return this._restoreObjectsState();
      },

      /**
       * make a group an active selection, remove the group from canvas
       * the group has to be on canvas for this to work.
       * @return {fabric.ActiveSelection} thisArg
       * @chainable
       */
      toActiveSelection: function() {
        if (!this.canvas) {
          return;
        }
        var objects = this._objects, canvas = this.canvas;
        this._objects = [];
        var options = this.toObject();
        delete options.objects;
        var activeSelection = new fabric.ActiveSelection([]);
        activeSelection.set(options);
        activeSelection.type = 'activeSelection';
        canvas.remove(this);
        objects.forEach(function(object) {
          object.group = activeSelection;
          object.dirty = true;
          canvas.add(object);
        });
        activeSelection.canvas = canvas;
        activeSelection._objects = objects;
        canvas._activeObject = activeSelection;
        activeSelection.setCoords();
        return activeSelection;
      },

      /**
       * Destroys a group (restoring state of its objects)
       * @return {fabric.Group} thisArg
       * @chainable
       */
      ungroupOnCanvas: function() {
        return this._restoreObjectsState();
      },

      /**
       * Sets coordinates of all objects inside group
       * @return {fabric.Group} thisArg
       * @chainable
       */
      setObjectsCoords: function() {
        var ignoreZoom = true, skipAbsolute = true;
        this.forEachObject(function(object) {
          object.setCoords(ignoreZoom, skipAbsolute);
        });
        return this;
      },

      /**
       * @private
       */
      _calcBounds: function(onlyWidthHeight) {
        var aX = [],
            aY = [],
            o, prop,
            props = ['tr', 'br', 'bl', 'tl'],
            i = 0, iLen = this._objects.length,
            j, jLen = props.length,
            ignoreZoom = true;

        for ( ; i < iLen; ++i) {
          o = this._objects[i];
          o.setCoords(ignoreZoom);
          for (j = 0; j < jLen; j++) {
            prop = props[j];
            aX.push(o.oCoords[prop].x);
            aY.push(o.oCoords[prop].y);
          }
        }

        this.set(this._getBounds(aX, aY, onlyWidthHeight));
      },

      /**
       * @private
       */
      _getBounds: function(aX, aY, onlyWidthHeight) {
        var minXY = new fabric.Point(min(aX), min(aY)),
            maxXY = new fabric.Point(max(aX), max(aY)),
            obj = {
              width: (maxXY.x - minXY.x) || 0,
              height: (maxXY.y - minXY.y) || 0
            };

        if (!onlyWidthHeight) {
          obj.left = minXY.x || 0;
          obj.top = minXY.y || 0;
          if (this.originX === 'center') {
            obj.left += obj.width / 2;
          }
          if (this.originX === 'right') {
            obj.left += obj.width;
          }
          if (this.originY === 'center') {
            obj.top += obj.height / 2;
          }
          if (this.originY === 'bottom') {
            obj.top += obj.height;
          }
        }
        return obj;
      },

      /* _TO_SVG_START_ */
      /**
       * Returns svg representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        var markup = this._createBaseSVGMarkup();
        markup.push(
          '<g ', this.getSvgId(), 'transform="',
          /* avoiding styles intentionally */
          this.getSvgTransform(),
          this.getSvgTransformMatrix(),
          '" style="',
          this.getSvgFilter(),
          '">\n'
        );

        for (var i = 0, len = this._objects.length; i < len; i++) {
          markup.push('\t', this._objects[i].toSVG(reviver));
        }

        markup.push('</g>\n');

        return reviver ? reviver(markup.join('')) : markup.join('');
      },
      /* _TO_SVG_END_ */
    });

    /**
     * Returns {@link fabric.Group} instance from an object representation
     * @static
     * @memberOf fabric.Group
     * @param {Object} object Object to create a group from
     * @param {Function} [callback] Callback to invoke when an group instance is created
     */
    fabric.Group.fromObject = function(object, callback) {
      fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {
        var options = fabric.util.object.clone(object, true);
        delete options.objects;
        callback && callback(new fabric.Group(enlivenedObjects, options, true));
      });
    };

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { });

    if (fabric.ActiveSelection) {
      return;
    }

    /**
     * Group class
     * @class fabric.ActiveSelection
     * @extends fabric.Group
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
     * @see {@link fabric.ActiveSelection#initialize} for constructor definition
     */
    fabric.ActiveSelection = fabric.util.createClass(fabric.Group, /** @lends fabric.ActiveSelection.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'activeSelection',

      /**
       * Constructor
       * @param {Object} objects ActiveSelection objects
       * @param {Object} [options] Options object
       * @return {Object} thisArg
       */
      initialize: function(objects, options) {
        options = options || {};
        this._objects = objects || [];
        for (var i = this._objects.length; i--; ) {
          this._objects[i].group = this;
        }

        if (options.originX) {
          this.originX = options.originX;
        }
        if (options.originY) {
          this.originY = options.originY;
        }
        this._calcBounds();
        this._updateObjectsCoords();
        fabric.Object.prototype.initialize.call(this, options);
        this.setCoords();
      },

      /**
       * Change te activeSelection to a normal group,
       * High level function that automatically adds it to canvas as
       * active object. no events fired.
       * @since 2.0.0
       * @return {fabric.Group}
       */
      toGroup: function() {
        var objects = this._objects;
        this._objects = [];
        var options = this.toObject();
        var newGroup = new fabric.Group([]);
        delete options.objects;
        newGroup.set(options);
        newGroup.type = 'group';
        objects.forEach(function(object) {
          object.group = newGroup;
          object.canvas.remove(object);
        });
        newGroup._objects = objects;
        if (!this.canvas) {
          return newGroup;
        }
        var canvas = this.canvas;
        canvas.add(newGroup);
        canvas._activeObject = newGroup;
        newGroup.setCoords();
        return newGroup;
      },

      /**
       * If returns true, deselection is cancelled.
       * @since 2.0.0
       * @return {Boolean} [cancel]
       */
      onDeselect: function() {
        this.destroy();
        return false;
      },

      /**
       * Returns string representation of a group
       * @return {String}
       */
      toString: function() {
        return '#<fabric.ActiveSelection: (' + this.complexity() + ')>';
      },

      /**
       * @private
       */
      _set: function(key, value) {
        var i = this._objects.length;
        if (key === 'canvas') {
          while (i--) {
            this._objects[i].set(key, value);
          }
        }
        if (this.useSetOnGroup) {
          while (i--) {
            this._objects[i].setOnGroup(key, value);
          }
        }
        fabric.Object.prototype._set.call(this, key, value);
      },

      /**
       * Decide if the object should cache or not. Create its own cache level
       * objectCaching is a global flag, wins over everything
       * needsItsOwnCache should be used when the object drawing method requires
       * a cache step. None of the fabric classes requires it.
       * Generally you do not cache objects in groups because the group outside is cached.
       * @return {Boolean}
       */
      shouldCache: function() {
        return false;
      },

      /**
       * Check if this object or a child object will cast a shadow
       * @return {Boolean}
       */
      willDrawShadow: function() {
        if (this.shadow) {
          return this.callSuper('willDrawShadow');
        }
        for (var i = 0, len = this._objects.length; i < len; i++) {
          if (this._objects[i].willDrawShadow()) {
            return true;
          }
        }
        return false;
      },

      /**
       * Check if this group or its parent group are caching, recursively up
       * @return {Boolean}
       */
      isOnACache: function() {
        return false;
      },

      /**
       * Renders controls and borders for the object
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {Object} [styleOverride] properties to override the object style
       * @param {Object} [childrenOverride] properties to override the children overrides
       */
      _renderControls: function(ctx, styleOverride, childrenOverride) {
        ctx.save();
        ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
        this.callSuper('_renderControls', ctx, styleOverride);
        childrenOverride = childrenOverride || { };
        if (typeof childrenOverride.hasControls === 'undefined') {
          childrenOverride.hasControls = false;
        }
        if (typeof childrenOverride.hasRotatingPoint === 'undefined') {
          childrenOverride.hasRotatingPoint = false;
        }
        childrenOverride.forActiveSelection = true;
        for (var i = 0, len = this._objects.length; i < len; i++) {
          this._objects[i]._renderControls(ctx, childrenOverride);
        }
        ctx.restore();
      },
    });

    /**
     * Returns {@link fabric.ActiveSelection} instance from an object representation
     * @static
     * @memberOf fabric.ActiveSelection
     * @param {Object} object Object to create a group from
     * @param {Function} [callback] Callback to invoke when an ActiveSelection instance is created
     */
    fabric.ActiveSelection.fromObject = function(object, callback) {
      fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {
        delete object.objects;
        callback && callback(new fabric.ActiveSelection(enlivenedObjects, object, true));
      });
    };

  })(exports);


  (function(global) {

    var extend = fabric.util.object.extend;

    if (!global.fabric) {
      global.fabric = { };
    }

    if (global.fabric.Image) {
      fabric.warn('fabric.Image is already defined.');
      return;
    }

    /**
     * Image class
     * @class fabric.Image
     * @extends fabric.Object
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#images}
     * @see {@link fabric.Image#initialize} for constructor definition
     */
    fabric.Image = fabric.util.createClass(fabric.Object, /** @lends fabric.Image.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'image',

      /**
       * crossOrigin value (one of "", "anonymous", "use-credentials")
       * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
       * @type String
       * @default
       */
      crossOrigin: '',

      /**
       * Width of a stroke.
       * For image quality a stroke multiple of 2 gives better results.
       * @type Number
       * @default
       */
      strokeWidth: 0,

      /**
       * private
       * contains last value of scaleX to detect
       * if the Image got resized after the last Render
       * @type Number
       */
      _lastScaleX: 1,

      /**
       * private
       * contains last value of scaleY to detect
       * if the Image got resized after the last Render
       * @type Number
       */
      _lastScaleY: 1,

      /**
       * private
       * contains last value of scaling applied by the apply filter chain
       * @type Number
       */
      _filterScalingX: 1,

      /**
       * private
       * contains last value of scaling applied by the apply filter chain
       * @type Number
       */
      _filterScalingY: 1,

      /**
       * minimum scale factor under which any resizeFilter is triggered to resize the image
       * 0 will disable the automatic resize. 1 will trigger automatically always.
       * number bigger than 1 are not implemented yet.
       * @type Number
       */
      minimumScaleTrigger: 0.5,

      /**
       * List of properties to consider when checking if
       * state of an object is changed ({@link fabric.Object#hasStateChanged})
       * as well as for history (undo/redo) purposes
       * @type Array
       */
      stateProperties: fabric.Object.prototype.stateProperties.concat('cropX', 'cropY'),

      /**
       * When `true`, object is cached on an additional canvas.
       * default to false for images
       * since 1.7.0
       * @type Boolean
       * @default
       */
      objectCaching: false,

      /**
       * key used to retrieve the texture representing this image
       * since 2.0.0
       * @type String
       * @default
       */
      cacheKey: '',

      /**
       * Image crop in pixels from original image size.
       * since 2.0.0
       * @type Number
       * @default
       */
      cropX: 0,

      /**
       * Image crop in pixels from original image size.
       * since 2.0.0
       * @type Number
       * @default
       */
      cropY: 0,

      /**
       * Constructor
       * @param {HTMLImageElement | String} element Image element
       * @param {Object} [options] Options object
       * @param {function} [callback] callback function to call after eventual filters applied.
       * @return {fabric.Image} thisArg
       */
      initialize: function(element, options) {
        options || (options = { });
        this.filters = [];
        this.cacheKey = 'texture' + fabric.Object.__uid++;
        this.callSuper('initialize', options);
        this._initElement(element, options);
      },

      /**
       * Returns image element which this instance if based on
       * @return {HTMLImageElement} Image element
       */
      getElement: function() {
        return this._element;
      },

      /**
       * Sets image element for this instance to a specified one.
       * If filters defined they are applied to new image.
       * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.
       * @param {HTMLImageElement} element
       * @param {Object} [options] Options object
       * @return {fabric.Image} thisArg
       * @chainable
       */
      setElement: function(element, options) {
        var backend = fabric.filterBackend;
        if (backend && backend.evictCachesForKey) {
          backend.evictCachesForKey(this.cacheKey);
          backend.evictCachesForKey(this.cacheKey + '_filtered');
        }
        this._element = element;
        this._originalElement = element;
        this._initConfig(options);
        if (this.resizeFilter) {
          this.applyResizeFilters();
        }
        if (this.filters.length !== 0) {
          this.applyFilters();
        }
        return this;
      },

      /**
       * Delete cacheKey if we have a webGlBackend
       * delete reference to image elements
       */
      dispose: function() {
        var backend = fabric.filterBackend;
        if (backend && backend.evictCachesForKey) {
          backend.evictCachesForKey(this.cacheKey);
          backend.evictCachesForKey(this.cacheKey + '_filtered');
        }
        this._originalElement = undefined;
        this._element = undefined;
        this._filteredEl = undefined;
      },

      /**
       * Sets crossOrigin value (on an instance and corresponding image element)
       * @return {fabric.Image} thisArg
       * @chainable
       */
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
        this._element.crossOrigin = value;

        return this;
      },

      /**
       * Returns original size of an image
       * @return {Object} Object with "width" and "height" properties
       */
      getOriginalSize: function() {
        var element = this.getElement();
        return {
          width: element.width,
          height: element.height
        };
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _stroke: function(ctx) {
        if (!this.stroke || this.strokeWidth === 0) {
          return;
        }
        var w = this.width / 2, h = this.height / 2;
        ctx.beginPath();
        ctx.moveTo(-w, -h);
        ctx.lineTo(w, -h);
        ctx.lineTo(w, h);
        ctx.lineTo(-w, h);
        ctx.lineTo(-w, -h);
        ctx.closePath();
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderDashedStroke: function(ctx) {
        var x = -this.width / 2,
            y = -this.height / 2,
            w = this.width,
            h = this.height;

        ctx.save();
        this._setStrokeStyles(ctx, this);

        ctx.beginPath();
        fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
        ctx.closePath();
        ctx.restore();
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} Object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        var filters = [];

        this.filters.forEach(function(filterObj) {
          if (filterObj) {
            filters.push(filterObj.toObject());
          }
        });
        var object = extend(
          this.callSuper(
            'toObject',
            ['crossOrigin', 'cropX', 'cropY'].concat(propertiesToInclude)
          ), {
            src: this.getSrc(),
            filters: filters,
          });
        if (this.resizeFilter) {
          object.resizeFilter = this.resizeFilter.toObject();
        }
        return object;
      },

      /**
       * Returns true if an image has crop applied, inspecting values of cropX,cropY,width,hight.
       * @return {Boolean}
       */
      hasCrop: function() {
        return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height;
      },

      /* _TO_SVG_START_ */
      /**
       * Returns SVG representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        var markup = this._createBaseSVGMarkup(), x = -this.width / 2, y = -this.height / 2, clipPath = '';
        if (this.hasCrop()) {
          var clipPathId = fabric.Object.__uid++;
          markup.push(
            '<clipPath id="imageCrop_' + clipPathId + '">\n',
            '\t<rect x="' + x + '" y="' + y + '" width="' + this.width + '" height="' + this.height + '" />\n',
            '</clipPath>\n'
          );
          clipPath = ' clip-path="url(#imageCrop_' + clipPathId + ')" ';
        }
        markup.push('<g transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '">\n');
        var imageMarkup = ['\t<image ', this.getSvgId(), 'xlink:href="', this.getSvgSrc(true),
          '" x="', x - this.cropX, '" y="', y - this.cropY,
          '" style="', this.getSvgStyles(),
          // we're essentially moving origin of transformation from top/left corner to the center of the shape
          // by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left
          // so that object's center aligns with container's left/top
          '" width="', this._element.width || this._element.naturalWidth,
          '" height="', this._element.height || this._element.height,
          '"', clipPath,
          '></image>\n'];
        if (this.paintFirst === 'fill') {
          Array.prototype.push.apply(markup, imageMarkup);
        }
        if (this.stroke || this.strokeDashArray) {
          var origFill = this.fill;
          this.fill = null;
          markup.push(
            '\t<rect ',
            'x="', x, '" y="', y,
            '" width="', this.width, '" height="', this.height,
            '" style="', this.getSvgStyles(),
            '"/>\n'
          );
          this.fill = origFill;
        }
        if (this.paintFirst !== 'fill') {
          Array.prototype.push.apply(markup, imageMarkup);
        }
        markup.push('</g>\n');

        return reviver ? reviver(markup.join('')) : markup.join('');
      },
      /* _TO_SVG_END_ */

      /**
       * Returns source of an image
       * @param {Boolean} filtered indicates if the src is needed for svg
       * @return {String} Source of an image
       */
      getSrc: function(filtered) {
        var element = filtered ? this._element : this._originalElement;
        if (element) {
          if (element.toDataURL) {
            return element.toDataURL();
          }
          return element.src;
        }
        else {
          return this.src || '';
        }
      },

      /**
       * Sets source of an image
       * @param {String} src Source string (URL)
       * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)
       * @param {Object} [options] Options object
       * @return {fabric.Image} thisArg
       * @chainable
       */
      setSrc: function(src, callback, options) {
        fabric.util.loadImage(src, function(img) {
          this.setElement(img, options);
          this._setWidthHeight();
          callback(this);
        }, this, options && options.crossOrigin);
        return this;
      },

      /**
       * Returns string representation of an instance
       * @return {String} String representation of an instance
       */
      toString: function() {
        return '#<fabric.Image: { src: "' + this.getSrc() + '" }>';
      },

      applyResizeFilters: function() {
        var filter = this.resizeFilter,
            retinaScaling = this.canvas ? this.canvas.getRetinaScaling() : 1,
            minimumScale = this.minimumScaleTrigger,
            scaleX = this.scaleX * retinaScaling,
            scaleY = this.scaleY * retinaScaling,
            elementToFilter = this._filteredEl || this._originalElement;
        if (this.group) {
          this.set('dirty', true);
        }
        if (!filter || (scaleX > minimumScale && scaleY > minimumScale)) {
          this._element = elementToFilter;
          this._filterScalingX = 1;
          this._filterScalingY = 1;
          return;
        }
        if (!fabric.filterBackend) {
          fabric.filterBackend = fabric.initFilterBackend();
        }
        var canvasEl = fabric.util.createCanvasElement(),
            cacheKey = this._filteredEl ? this.cacheKey : (this.cacheKey + '_filtered'),
            sourceWidth = elementToFilter.width, sourceHeight = elementToFilter.height;
        canvasEl.width = sourceWidth;
        canvasEl.height = sourceHeight;
        this._element = canvasEl;
        filter.scaleX = scaleX;
        filter.scaleY = scaleY;
        fabric.filterBackend.applyFilters(
          [filter], elementToFilter, sourceWidth, sourceHeight, this._element, cacheKey);
        this._filterScalingX = canvasEl.width / this._originalElement.width;
        this._filterScalingY = canvasEl.height / this._originalElement.height;
      },

      /**
       * Applies filters assigned to this image (from "filters" array) or from filter param
       * @method applyFilters
       * @param {Array} filters to be applied
       * @param {Boolean} forResizing specify if the filter operation is a resize operation
       * @return {thisArg} return the fabric.Image object
       * @chainable
       */
      applyFilters: function(filters) {

        filters = filters || this.filters || [];
        filters = filters.filter(function(filter) { return filter; });
        if (this.group) {
          this.set('dirty', true);
        }
        if (filters.length === 0) {
          this._element = this._originalElement;
          this._filteredEl = null;
          this._filterScalingX = 1;
          this._filterScalingY = 1;
          return this;
        }

        var imgElement = this._originalElement,
            sourceWidth = imgElement.naturalWidth || imgElement.width,
            sourceHeight = imgElement.naturalHeight || imgElement.height;

        if (this._element === this._originalElement) {
          // if the element is the same we need to create a new element
          var canvasEl = fabric.util.createCanvasElement();
          canvasEl.width = sourceWidth;
          canvasEl.height = sourceHeight;
          this._element = canvasEl;
          this._filteredEl = canvasEl;
        }
        else {
          // clear the existing element to get new filter data
          this._element.getContext('2d').clearRect(0, 0, sourceWidth, sourceHeight);
        }
        if (!fabric.filterBackend) {
          fabric.filterBackend = fabric.initFilterBackend();
        }
        fabric.filterBackend.applyFilters(
          filters, this._originalElement, sourceWidth, sourceHeight, this._element, this.cacheKey);
        if (this._originalElement.width !== this._element.width ||
          this._originalElement.height !== this._element.height) {
          this._filterScalingX = this._element.width / this._originalElement.width;
          this._filterScalingY = this._element.height / this._originalElement.height;
        }
        return this;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {
        if (this.isMoving === false && this.resizeFilter && this._needsResize()) {
          this._lastScaleX = this.scaleX;
          this._lastScaleY = this.scaleY;
          this.applyResizeFilters();
        }
        this._stroke(ctx);
        this._renderPaintInOrder(ctx);
      },

      _renderFill: function(ctx) {
        var w = this.width, h = this.height, sW = w * this._filterScalingX, sH = h * this._filterScalingY,
            x = -w / 2, y = -h / 2, elementToDraw = this._element;
        elementToDraw && ctx.drawImage(elementToDraw,
          this.cropX * this._filterScalingX,
          this.cropY * this._filterScalingY,
          sW,
          sH,
          x, y, w, h);
      },

      /**
       * @private, needed to check if image needs resize
       */
      _needsResize: function() {
        return (this.scaleX !== this._lastScaleX || this.scaleY !== this._lastScaleY);
      },

      /**
       * @private
       */
      _resetWidthHeight: function() {
        var element = this.getElement();

        this.set('width', element.width);
        this.set('height', element.height);
      },

      /**
       * The Image class's initialization method. This method is automatically
       * called by the constructor.
       * @private
       * @param {HTMLImageElement|String} element The element representing the image
       * @param {Object} [options] Options object
       */
      _initElement: function(element, options) {
        this.setElement(fabric.util.getById(element), options);
        fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);
      },

      /**
       * @private
       * @param {Object} [options] Options object
       */
      _initConfig: function(options) {
        options || (options = { });
        this.setOptions(options);
        this._setWidthHeight(options);
        if (this._element && this.crossOrigin) {
          this._element.crossOrigin = this.crossOrigin;
        }
      },

      /**
       * @private
       * @param {Array} filters to be initialized
       * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created
       */
      _initFilters: function(filters, callback) {
        if (filters && filters.length) {
          fabric.util.enlivenObjects(filters, function(enlivenedObjects) {
            callback && callback(enlivenedObjects);
          }, 'fabric.Image.filters');
        }
        else {
          callback && callback();
        }
      },

      /**
       * @private
       * @param {Object} [options] Object with width/height properties
       */
      _setWidthHeight: function(options) {
        this.width = options && ('width' in options)
          ? options.width
          : (this.getElement()
            ? this.getElement().width || 0
            : 0);

        this.height = options && ('height' in options)
          ? options.height
          : (this.getElement()
            ? this.getElement().height || 0
            : 0);
      },

      /**
       * Calculate offset for center and scale factor for the image in order to respect
       * the preserveAspectRatio attribute
       * @private
       * @return {Object}
       */
      parsePreserveAspectRatioAttribute: function() {
        var pAR = fabric.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || ''),
            rWidth = this._element.width, rHeight = this._element.height,
            scaleX = 1, scaleY = 1, offsetLeft = 0, offsetTop = 0, cropX = 0, cropY = 0,
            offset, pWidth = this.width, pHeight = this.height, parsedAttributes = { width: pWidth, height: pHeight };
        if (pAR && (pAR.alignX !== 'none' || pAR.alignY !== 'none')) {
          if (pAR.meetOrSlice === 'meet') {
            scaleX = scaleY = fabric.util.findScaleToFit(this._element, parsedAttributes);
            offset = (pWidth - rWidth * scaleX) / 2;
            if (pAR.alignX === 'Min') {
              offsetLeft = -offset;
            }
            if (pAR.alignX === 'Max') {
              offsetLeft = offset;
            }
            offset = (pHeight - rHeight * scaleY) / 2;
            if (pAR.alignY === 'Min') {
              offsetTop = -offset;
            }
            if (pAR.alignY === 'Max') {
              offsetTop = offset;
            }
          }
          if (pAR.meetOrSlice === 'slice') {
            scaleX = scaleY = fabric.util.findScaleToCover(this._element, parsedAttributes);
            offset = rWidth - pWidth / scaleX;
            if (pAR.alignX === 'Mid') {
              cropX = offset / 2;
            }
            if (pAR.alignX === 'Max') {
              cropX = offset;
            }
            offset = rHeight - pHeight / scaleY;
            if (pAR.alignY === 'Mid') {
              cropY = offset / 2;
            }
            if (pAR.alignY === 'Max') {
              cropY = offset;
            }
            rWidth = pWidth / scaleX;
            rHeight = pHeight / scaleY;
          }
        }
        else {
          scaleX = pWidth / rWidth;
          scaleY = pHeight / rHeight;
        }
        return {
          width: rWidth,
          height: rHeight,
          scaleX: scaleX,
          scaleY: scaleY,
          offsetLeft: offsetLeft,
          offsetTop: offsetTop,
          cropX: cropX,
          cropY: cropY
        };
      }
    });

    /**
     * Default CSS class name for canvas
     * @static
     * @type String
     * @default
     */
    fabric.Image.CSS_CANVAS = 'canvas-img';

    /**
     * Alias for getSrc
     * @static
     */
    fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;

    /**
     * Creates an instance of fabric.Image from its object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {Function} callback Callback to invoke when an image instance is created
     */
    fabric.Image.fromObject = function(_object, callback) {
      var object = fabric.util.object.clone(_object);
      fabric.util.loadImage(object.src, function(img, error) {
        if (error) {
          callback && callback(null, error);
          return;
        }
        fabric.Image.prototype._initFilters.call(object, object.filters, function(filters) {
          object.filters = filters || [];
          fabric.Image.prototype._initFilters.call(object, [object.resizeFilter], function(resizeFilters) {
            object.resizeFilter = resizeFilters[0];
            var image = new fabric.Image(img, object);
            callback(image);
          });
        });
      }, null, object.crossOrigin);
    };

    /**
     * Creates an instance of fabric.Image from an URL string
     * @static
     * @param {String} url URL to create an image from
     * @param {Function} [callback] Callback to invoke when image is created (newly created image is passed as a first argument)
     * @param {Object} [imgOptions] Options object
     */
    fabric.Image.fromURL = function(url, callback, imgOptions) {
      fabric.util.loadImage(url, function(img) {
        callback && callback(new fabric.Image(img, imgOptions));
      }, null, imgOptions && imgOptions.crossOrigin);
    };

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by {@link fabric.Image.fromElement})
     * @static
     * @see {@link http://www.w3.org/TR/SVG/struct.html#ImageElement}
     */
    fabric.Image.ATTRIBUTE_NAMES =
      fabric.SHARED_ATTRIBUTES.concat('x y width height preserveAspectRatio xlink:href crossOrigin'.split(' '));

    /**
     * Returns {@link fabric.Image} instance from an SVG element
     * @static
     * @param {SVGElement} element Element to parse
     * @param {Object} [options] Options object
     * @param {Function} callback Callback to execute when fabric.Image object is created
     * @return {fabric.Image} Instance of fabric.Image
     */
    fabric.Image.fromElement = function(element, callback, options) {
      var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES);
      fabric.Image.fromURL(parsedAttributes['xlink:href'], callback,
        extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
    };
    /* _FROM_SVG_END_ */

  })(exports);


  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * @private
     * @return {Number} angle value
     */
    _getAngleValueForStraighten: function() {
      var angle = this.angle % 360;
      if (angle > 0) {
        return Math.round((angle - 1) / 90) * 90;
      }
      return Math.round(angle / 90) * 90;
    },

    /**
     * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)
     * @return {fabric.Object} thisArg
     * @chainable
     */
    straighten: function() {
      this.rotate(this._getAngleValueForStraighten());
      return this;
    },

    /**
     * Same as {@link fabric.Object.prototype.straighten} but with animation
     * @param {Object} callbacks Object with callback functions
     * @param {Function} [callbacks.onComplete] Invoked on completion
     * @param {Function} [callbacks.onChange] Invoked on every step of animation
     * @return {fabric.Object} thisArg
     * @chainable
     */
    fxStraighten: function(callbacks) {
      callbacks = callbacks || { };

      var empty = function() { },
          onComplete = callbacks.onComplete || empty,
          onChange = callbacks.onChange || empty,
          _this = this;

      fabric.util.animate({
        startValue: this.get('angle'),
        endValue: this._getAngleValueForStraighten(),
        duration: this.FX_DURATION,
        onChange: function(value) {
          _this.rotate(value);
          onChange();
        },
        onComplete: function() {
          _this.setCoords();
          onComplete();
        },
      });

      return this;
    }
  });

  fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

    /**
     * Straightens object, then rerenders canvas
     * @param {fabric.Object} object Object to straighten
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    straightenObject: function (object) {
      object.straighten();
      this.requestRenderAll();
      return this;
    },

    /**
     * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated
     * @param {fabric.Object} object Object to straighten
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    fxStraightenObject: function (object) {
      object.fxStraighten({
        onChange: this.requestRenderAllBound
      });
      return this;
    }
  });


  (function() {

    /**
     * Tests if webgl supports certain precision
     * @param {WebGL} Canvas WebGL context to test on
     * @param {String} Precision to test can be any of following: 'lowp', 'mediump', 'highp'
     * @returns {Boolean} Whether the user's browser WebGL supports given precision.
     */
    function testPrecision(gl, precision){
      var fragmentSource = 'precision ' + precision + ' float;\nvoid main(){}';
      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fragmentSource);
      gl.compileShader(fragmentShader);
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        return false;
      }
      return true;
    }

    /**
     * Indicate whether this filtering backend is supported by the user's browser.
     * @param {Number} tileSize check if the tileSize is supported
     * @returns {Boolean} Whether the user's browser supports WebGL.
     */
    fabric.isWebglSupported = function(tileSize) {
      if (fabric.isLikelyNode) {
        return false;
      }
      tileSize = tileSize || fabric.WebglFilterBackend.prototype.tileSize;
      var canvas = document.createElement('canvas');
      var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      var isSupported = false;
      // eslint-disable-next-line
      if (gl) {
        fabric.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        isSupported = fabric.maxTextureSize >= tileSize;
        var precisions = ['highp', 'mediump', 'lowp'];
        for (var i = 0; i < 3; i++){
          if (testPrecision(gl, precisions[i])){
            fabric.webGlPrecision = precisions[i];
            break;
          }      }
      }
      this.isSupported = isSupported;
      return isSupported;
    };

    fabric.WebglFilterBackend = WebglFilterBackend;

    /**
     * WebGL filter backend.
     */
    function WebglFilterBackend(options) {
      if (options && options.tileSize) {
        this.tileSize = options.tileSize;
      }
      this.setupGLContext(this.tileSize, this.tileSize);
      this.captureGPUInfo();
    }
    WebglFilterBackend.prototype = /** @lends fabric.WebglFilterBackend.prototype */ {

      tileSize: 2048,

      /**
       * Experimental. This object is a sort of repository of help layers used to avoid
       * of recreating them during frequent filtering. If you are previewing a filter with
       * a slider you problably do not want to create help layers every filter step.
       * in this object there will be appended some canvases, created once, resized sometimes
       * cleared never. Clearing is left to the developer.
       **/
      resources: {

      },

      /**
       * Setup a WebGL context suitable for filtering, and bind any needed event handlers.
       */
      setupGLContext: function(width, height) {
        this.dispose();
        this.createWebGLCanvas(width, height);
        // eslint-disable-next-line
        this.aPosition = new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]);
        this.chooseFastestCopyGLTo2DMethod(width, height);
      },

      /**
       * Pick a method to copy data from GL context to 2d canvas.  In some browsers using
       * putImageData is faster than drawImage for that specific operation.
       */
      chooseFastestCopyGLTo2DMethod: function(width, height) {
        var canMeasurePerf = typeof window.performance !== 'undefined';
        var canUseImageData;
        try {
          new ImageData(1, 1);
          canUseImageData = true;
        }
        catch (e) {
          canUseImageData = false;
        }
        // eslint-disable-next-line no-undef
        var canUseArrayBuffer = typeof ArrayBuffer !== 'undefined';
        // eslint-disable-next-line no-undef
        var canUseUint8Clamped = typeof Uint8ClampedArray !== 'undefined';

        if (!(canMeasurePerf && canUseImageData && canUseArrayBuffer && canUseUint8Clamped)) {
          return;
        }

        var targetCanvas = fabric.util.createCanvasElement();
        // eslint-disable-next-line no-undef
        var imageBuffer = new ArrayBuffer(width * height * 4);
        var testContext = {
          imageBuffer: imageBuffer,
          destinationWidth: width,
          destinationHeight: height,
          targetCanvas: targetCanvas
        };
        var startTime, drawImageTime, putImageDataTime;
        targetCanvas.width = width;
        targetCanvas.height = height;

        startTime = window.performance.now();
        copyGLTo2DDrawImage.call(testContext, this.gl, testContext);
        drawImageTime = window.performance.now() - startTime;

        startTime = window.performance.now();
        copyGLTo2DPutImageData.call(testContext, this.gl, testContext);
        putImageDataTime = window.performance.now() - startTime;

        if (drawImageTime > putImageDataTime) {
          this.imageBuffer = imageBuffer;
          this.copyGLTo2D = copyGLTo2DPutImageData;
        }
        else {
          this.copyGLTo2D = copyGLTo2DDrawImage;
        }
      },

      /**
       * Create a canvas element and associated WebGL context and attaches them as
       * class properties to the GLFilterBackend class.
       */
      createWebGLCanvas: function(width, height) {
        var canvas = fabric.util.createCanvasElement();
        canvas.width = width;
        canvas.height = height;
        var glOptions = {
              alpha: true,
              premultipliedAlpha: false,
              depth: false,
              stencil: false,
              antialias: false
            },
            gl = canvas.getContext('webgl', glOptions);
        if (!gl) {
          gl = canvas.getContext('experimental-webgl', glOptions);
        }
        if (!gl) {
          return;
        }
        gl.clearColor(0, 0, 0, 0);
        // this canvas can fire webglcontextlost and webglcontextrestored
        this.canvas = canvas;
        this.gl = gl;
      },

      /**
       * Attempts to apply the requested filters to the source provided, drawing the filtered output
       * to the provided target canvas.
       *
       * @param {Array} filters The filters to apply.
       * @param {HTMLImageElement|HTMLCanvasElement} source The source to be filtered.
       * @param {Number} width The width of the source input.
       * @param {Number} height The height of the source input.
       * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.
       * @param {String|undefined} cacheKey A key used to cache resources related to the source. If
       * omitted, caching will be skipped.
       */
      applyFilters: function(filters, source, width, height, targetCanvas, cacheKey) {
        var gl = this.gl;
        var cachedTexture;
        if (cacheKey) {
          cachedTexture = this.getCachedTexture(cacheKey, source);
        }
        var pipelineState = {
          originalWidth: source.width || source.originalWidth,
          originalHeight: source.height || source.originalHeight,
          sourceWidth: width,
          sourceHeight: height,
          destinationWidth: width,
          destinationHeight: height,
          context: gl,
          sourceTexture: this.createTexture(gl, width, height, !cachedTexture && source),
          targetTexture: this.createTexture(gl, width, height),
          originalTexture: cachedTexture ||
            this.createTexture(gl, width, height, !cachedTexture && source),
          passes: filters.length,
          webgl: true,
          aPosition: this.aPosition,
          programCache: this.programCache,
          pass: 0,
          filterBackend: this,
          targetCanvas: targetCanvas
        };
        var tempFbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, tempFbo);
        filters.forEach(function(filter) { filter && filter.applyTo(pipelineState); });
        resizeCanvasIfNeeded(pipelineState);
        this.copyGLTo2D(gl, pipelineState);
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.deleteTexture(pipelineState.sourceTexture);
        gl.deleteTexture(pipelineState.targetTexture);
        gl.deleteFramebuffer(tempFbo);
        targetCanvas.getContext('2d').setTransform(1, 0, 0, 1, 0, 0);
        return pipelineState;
      },

      /**
       * The same as the applyFilter method but with additional logging of WebGL
       * errors.
       */
      applyFiltersDebug: function(filters, source, width, height, targetCanvas, cacheKey) {
        // The following code is useful when debugging a specific issue but adds ~10x slowdown.
        var gl = this.gl;
        var ret = this.applyFilters(filters, source, width, height, targetCanvas, cacheKey);
        var glError = gl.getError();
        if (glError !== gl.NO_ERROR) {
          var errorString = this.glErrorToString(gl, glError);
          var error = new Error('WebGL Error ' + errorString);
          error.glErrorCode = glError;
          throw error;
        }
        return ret;
      },

      glErrorToString: function(context, errorCode) {
        if (!context) {
          return 'Context undefined for error code: ' + errorCode;
        }
        else if (typeof errorCode !== 'number') {
          return 'Error code is not a number';
        }
        switch (errorCode) {
          case context.NO_ERROR:
            return 'NO_ERROR';
          case context.INVALID_ENUM:
            return 'INVALID_ENUM';
          case context.INVALID_VALUE:
            return 'INVALID_VALUE';
          case context.INVALID_OPERATION:
            return 'INVALID_OPERATION';
          case context.INVALID_FRAMEBUFFER_OPERATION:
            return 'INVALID_FRAMEBUFFER_OPERATION';
          case context.OUT_OF_MEMORY:
            return 'OUT_OF_MEMORY';
          case context.CONTEXT_LOST_WEBGL:
            return 'CONTEXT_LOST_WEBGL';
          default:
            return 'UNKNOWN_ERROR';
        }
      },

      /**
       * Detach event listeners, remove references, and clean up caches.
       */
      dispose: function() {
        if (this.canvas) {
          this.canvas = null;
          this.gl = null;
        }
        this.clearWebGLCaches();
      },

      /**
       * Wipe out WebGL-related caches.
       */
      clearWebGLCaches: function() {
        this.programCache = {};
        this.textureCache = {};
      },

      /**
       * Create a WebGL texture object.
       *
       * Accepts specific dimensions to initialize the textuer to or a source image.
       *
       * @param {WebGLRenderingContext} gl The GL context to use for creating the texture.
       * @param {Number} width The width to initialize the texture at.
       * @param {Number} height The height to initialize the texture.
       * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source for the texture data.
       * @returns {WebGLTexture}
       */
      createTexture: function(gl, width, height, textureImageSource) {
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        if (textureImageSource) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImageSource);
        }
        else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
        return texture;
      },

      /**
       * Can be optionally used to get a texture from the cache array
       *
       * If an existing texture is not found, a new texture is created and cached.
       *
       * @param {String} uniqueId A cache key to use to find an existing texture.
       * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source to use to create the
       * texture cache entry if one does not already exist.
       */
      getCachedTexture: function(uniqueId, textureImageSource) {
        if (this.textureCache[uniqueId]) {
          return this.textureCache[uniqueId];
        }
        else {
          var texture = this.createTexture(
            this.gl, textureImageSource.width, textureImageSource.height, textureImageSource);
          this.textureCache[uniqueId] = texture;
          return texture;
        }
      },

      /**
       * Clear out cached resources related to a source image that has been
       * filtered previously.
       *
       * @param {String} cacheKey The cache key provided when the source image was filtered.
       */
      evictCachesForKey: function(cacheKey) {
        if (this.textureCache[cacheKey]) {
          this.gl.deleteTexture(this.textureCache[cacheKey]);
          delete this.textureCache[cacheKey];
        }
      },

      copyGLTo2D: copyGLTo2DDrawImage,

      /**
       * Attempt to extract GPU information strings from a WebGL context.
       *
       * Useful information when debugging or blacklisting specific GPUs.
       *
       * @returns {Object} A GPU info object with renderer and vendor strings.
       */
      captureGPUInfo: function() {
        if (this.gpuInfo) {
          return this.gpuInfo;
        }
        var gl = this.gl;
        var ext = gl.getExtension('WEBGL_debug_renderer_info');
        var gpuInfo = { renderer: '', vendor: '' };
        if (ext) {
          var renderer = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);
          var vendor = gl.getParameter(ext.UNMASKED_VENDOR_WEBGL);
          if (renderer) {
            gpuInfo.renderer = renderer.toLowerCase();
          }
          if (vendor) {
            gpuInfo.vendor = vendor.toLowerCase();
          }
        }
        this.gpuInfo = gpuInfo;
        return gpuInfo;
      },
    };
  })();

  function resizeCanvasIfNeeded(pipelineState) {
    var targetCanvas = pipelineState.targetCanvas,
        width = targetCanvas.width, height = targetCanvas.height,
        dWidth = pipelineState.destinationWidth,
        dHeight = pipelineState.destinationHeight;

    if (width !== dWidth || height !== dHeight) {
      targetCanvas.width = dWidth;
      targetCanvas.height = dHeight;
    }
  }

  /**
   * Copy an input WebGL canvas on to an output 2D canvas.
   *
   * The WebGL canvas is assumed to be upside down, with the top-left pixel of the
   * desired output image appearing in the bottom-left corner of the WebGL canvas.
   *
   * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.
   * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.
   * @param {Object} pipelineState The 2D target canvas to copy on to.
   */
  function copyGLTo2DDrawImage(gl, pipelineState) {
    var glCanvas = gl.canvas, targetCanvas = pipelineState.targetCanvas,
        ctx = targetCanvas.getContext('2d');
    ctx.translate(0, targetCanvas.height); // move it down again
    ctx.scale(1, -1); // vertical flip
    // where is my image on the big glcanvas?
    var sourceY = glCanvas.height - targetCanvas.height;
    ctx.drawImage(glCanvas, 0, sourceY, targetCanvas.width, targetCanvas.height, 0, 0,
      targetCanvas.width, targetCanvas.height);
  }

  /**
   * Copy an input WebGL canvas on to an output 2D canvas using 2d canvas' putImageData
   * API. Measurably faster than using ctx.drawImage in Firefox (version 54 on OSX Sierra).
   *
   * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.
   * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.
   * @param {Object} pipelineState The 2D target canvas to copy on to.
   */
  function copyGLTo2DPutImageData(gl, pipelineState) {
    var targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext('2d'),
        dWidth = pipelineState.destinationWidth,
        dHeight = pipelineState.destinationHeight,
        numBytes = dWidth * dHeight * 4;

    // eslint-disable-next-line no-undef
    var u8 = new Uint8Array(this.imageBuffer, 0, numBytes);
    // eslint-disable-next-line no-undef
    var u8Clamped = new Uint8ClampedArray(this.imageBuffer, 0, numBytes);

    gl.readPixels(0, 0, dWidth, dHeight, gl.RGBA, gl.UNSIGNED_BYTE, u8);
    var imgData = new ImageData(u8Clamped, dWidth, dHeight);
    ctx.putImageData(imgData, 0, 0);
  }


  (function() {

    var noop = function() {};

    fabric.Canvas2dFilterBackend = Canvas2dFilterBackend;

    /**
     * Canvas 2D filter backend.
     */
    function Canvas2dFilterBackend() {}
    Canvas2dFilterBackend.prototype = /** @lends fabric.Canvas2dFilterBackend.prototype */ {
      evictCachesForKey: noop,
      dispose: noop,
      clearWebGLCaches: noop,

      /**
       * Experimental. This object is a sort of repository of help layers used to avoid
       * of recreating them during frequent filtering. If you are previewing a filter with
       * a slider you probably do not want to create help layers every filter step.
       * in this object there will be appended some canvases, created once, resized sometimes
       * cleared never. Clearing is left to the developer.
       **/
      resources: {

      },

      /**
       * Apply a set of filters against a source image and draw the filtered output
       * to the provided destination canvas.
       *
       * @param {EnhancedFilter} filters The filter to apply.
       * @param {HTMLImageElement|HTMLCanvasElement} sourceElement The source to be filtered.
       * @param {Number} sourceWidth The width of the source input.
       * @param {Number} sourceHeight The height of the source input.
       * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.
       */
      applyFilters: function(filters, sourceElement, sourceWidth, sourceHeight, targetCanvas) {
        var ctx = targetCanvas.getContext('2d');
        ctx.drawImage(sourceElement, 0, 0, sourceWidth, sourceHeight);
        var imageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
        var originalImageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
        var pipelineState = {
          sourceWidth: sourceWidth,
          sourceHeight: sourceHeight,
          imageData: imageData,
          originalEl: sourceElement,
          originalImageData: originalImageData,
          canvasEl: targetCanvas,
          ctx: ctx,
          filterBackend: this,
        };
        filters.forEach(function(filter) { filter.applyTo(pipelineState); });
        if (pipelineState.imageData.width !== sourceWidth || pipelineState.imageData.height !== sourceHeight) {
          targetCanvas.width = pipelineState.imageData.width;
          targetCanvas.height = pipelineState.imageData.height;
        }
        ctx.putImageData(pipelineState.imageData, 0, 0);
        return pipelineState;
      },

    };
  })();


  /**
   * @namespace fabric.Image.filters
   * @memberOf fabric.Image
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#image_filters}
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   */
  fabric.Image.filters = fabric.Image.filters || { };

  /**
   * Root filter class from which all filter classes inherit from
   * @class fabric.Image.filters.BaseFilter
   * @memberOf fabric.Image.filters
   */
  fabric.Image.filters.BaseFilter = fabric.util.createClass(/** @lends fabric.Image.filters.BaseFilter.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'BaseFilter',

    /**
     * Array of attributes to send with buffers. do not modify
     * @private
     */

    vertexSource: 'attribute vec2 aPosition;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vTexCoord = aPosition;\n' +
        'gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n' +
      '}',

    fragmentSource: 'precision highp float;\n' +
      'varying vec2 vTexCoord;\n' +
      'uniform sampler2D uTexture;\n' +
      'void main() {\n' +
        'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
      '}',

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      if (options) {
        this.setOptions(options);
      }
    },

    /**
     * Sets filter's properties from options
     * @param {Object} [options] Options object
     */
    setOptions: function(options) {
      for (var prop in options) {
        this[prop] = options[prop];
      }
    },

    /**
     * Compile this filter's shader program.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context to use for shader compilation.
     * @param {String} fragmentSource fragmentShader source for compilation
     * @param {String} vertexSource vertexShader source for compilation
     */
    createProgram: function(gl, fragmentSource, vertexSource) {
      fragmentSource = fragmentSource || this.fragmentSource;
      vertexSource = vertexSource || this.vertexSource;
      if (fabric.webGlPrecision !== 'highp'){
        fragmentSource = fragmentSource.replace(
          /precision highp float/g,
          'precision ' + fabric.webGlPrecision + ' float'
        );
      }
      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, vertexSource);
      gl.compileShader(vertexShader);
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        throw new Error(
          // eslint-disable-next-line prefer-template
          'Vertex shader compile error for ' + this.type + ': ' +
          gl.getShaderInfoLog(vertexShader)
        );
      }

      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fragmentSource);
      gl.compileShader(fragmentShader);
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        throw new Error(
          // eslint-disable-next-line prefer-template
          'Fragment shader compile error for ' + this.type + ': ' +
          gl.getShaderInfoLog(fragmentShader)
        );
      }

      var program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        throw new Error(
          // eslint-disable-next-line prefer-template
          'Shader link error for "${this.type}" ' +
          gl.getProgramInfoLog(program)
        );
      }

      var attributeLocations = this.getAttributeLocations(gl, program);
      var uniformLocations = this.getUniformLocations(gl, program) || { };
      uniformLocations.uStepW = gl.getUniformLocation(program, 'uStepW');
      uniformLocations.uStepH = gl.getUniformLocation(program, 'uStepH');
      return {
        program: program,
        attributeLocations: attributeLocations,
        uniformLocations: uniformLocations
      };
    },

    /**
     * Return a map of attribute names to WebGLAttributeLocation objects.
     *
     * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
     * @param {WebGLShaderProgram} program The shader program from which to take attribute locations.
     * @returns {Object} A map of attribute names to attribute locations.
     */
    getAttributeLocations: function(gl, program) {
      return {
        aPosition: gl.getAttribLocation(program, 'aPosition'),
      };
    },

    /**
     * Return a map of uniform names to WebGLUniformLocation objects.
     *
     * Intended to be overridden by subclasses.
     *
     * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
     * @param {WebGLShaderProgram} program The shader program from which to take uniform locations.
     * @returns {Object} A map of uniform names to uniform locations.
     */
    getUniformLocations: function (/* gl, program */) {
      // in case i do not need any special uniform i need to return an empty object
      return { };
    },

    /**
     * Send attribute data from this filter to its shader program on the GPU.
     *
     * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
     * @param {Object} attributeLocations A map of shader attribute names to their locations.
     */
    sendAttributeData: function(gl, attributeLocations, aPositionData) {
      var attributeLocation = attributeLocations.aPosition;
      var buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.enableVertexAttribArray(attributeLocation);
      gl.vertexAttribPointer(attributeLocation, 2, gl.FLOAT, false, 0, 0);
      gl.bufferData(gl.ARRAY_BUFFER, aPositionData, gl.STATIC_DRAW);
    },

    _setupFrameBuffer: function(options) {
      var gl = options.context, width, height;
      if (options.passes > 1) {
        width = options.destinationWidth;
        height = options.destinationHeight;
        if (options.sourceWidth !== width || options.sourceHeight !== height) {
          gl.deleteTexture(options.targetTexture);
          options.targetTexture = options.filterBackend.createTexture(gl, width, height);
        }
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D,
          options.targetTexture, 0);
      }
      else {
        // draw last filter on canvas and not to framebuffer.
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.finish();
      }
    },

    _swapTextures: function(options) {
      options.passes--;
      options.pass++;
      var temp = options.targetTexture;
      options.targetTexture = options.sourceTexture;
      options.sourceTexture = temp;
    },

    /**
     * Intentionally left blank, to be overridden in custom filters
     * @param {Object} options
     **/
    isNeutralState: function(/* options */) {
      return false;
    },

    /**
     * Apply this filter to the input image data provided.
     *
     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
     *
     * @param {Object} options
     * @param {Number} options.passes The number of filters remaining to be executed
     * @param {Boolean} options.webgl Whether to use webgl to render the filter.
     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    applyTo: function(options) {
      if (options.webgl) {
        if (options.passes > 1 && this.isNeutralState(options)) {
          // avoid doing something that we do not need
          return;
        }
        this._setupFrameBuffer(options);
        this.applyToWebGL(options);
        this._swapTextures(options);
      }
      else if (!this.isNeutralState()) {
        this.applyTo2d(options);
      }
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      if (!options.programCache.hasOwnProperty(this.type)) {
        options.programCache[this.type] = this.createProgram(options.context);
      }
      return options.programCache[this.type];
    },

    /**
     * Apply this filter using webgl.
     *
     * @param {Object} options
     * @param {Number} options.passes The number of filters remaining to be executed
     * @param {Boolean} options.webgl Whether to use webgl to render the filter.
     * @param {WebGLTexture} options.originalTexture The texture of the original input image.
     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    applyToWebGL: function(options) {
      var gl = options.context;
      var shader = this.retrieveShader(options);
      if (options.pass === 0 && options.originalTexture) {
        gl.bindTexture(gl.TEXTURE_2D, options.originalTexture);
      }
      else {
        gl.bindTexture(gl.TEXTURE_2D, options.sourceTexture);
      }
      gl.useProgram(shader.program);
      this.sendAttributeData(gl, shader.attributeLocations, options.aPosition);

      gl.uniform1f(shader.uniformLocations.uStepW, 1 / options.sourceWidth);
      gl.uniform1f(shader.uniformLocations.uStepH, 1 / options.sourceHeight);

      this.sendUniformData(gl, shader.uniformLocations);
      gl.viewport(0, 0, options.destinationWidth, options.destinationHeight);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    },

    bindAdditionalTexture: function(gl, texture, textureUnit) {
      gl.activeTexture(textureUnit);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      // reset active texture to 0 as usual
      gl.activeTexture(gl.TEXTURE0);
    },

    unbindAdditionalTexture: function(gl, textureUnit) {
      gl.activeTexture(textureUnit);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.activeTexture(gl.TEXTURE0);
    },

    getMainParameter: function() {
      return this[this.mainParameter];
    },

    setMainParameter: function(value) {
      this[this.mainParameter] = value;
    },

    /**
     * Send uniform data from this filter to its shader program on the GPU.
     *
     * Intended to be overridden by subclasses.
     *
     * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
     * @param {Object} uniformLocations A map of shader uniform names to their locations.
     */
    sendUniformData: function(/* gl, uniformLocations */) {
      // Intentionally left blank.  Override me in subclasses.
    },

    /**
     * If needed by a 2d filter, this functions can create an helper canvas to be used
     * remember that options.targetCanvas is available for use till end of chain.
     */
    createHelpLayer: function(options) {
      if (!options.helpLayer) {
        var helpLayer = document.createElement('canvas');
        helpLayer.width = options.sourceWidth;
        helpLayer.height = options.sourceHeight;
        options.helpLayer = helpLayer;
      }
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      var object = { type: this.type }, mainP = this.mainParameter;
      if (mainP) {
        object[mainP] = this[mainP];
      }
      return object;
    },

    /**
     * Returns a JSON representation of an instance
     * @return {Object} JSON
     */
    toJSON: function() {
      // delegate, not alias
      return this.toObject();
    }
  });

  fabric.Image.filters.BaseFilter.fromObject = function(object, callback) {
    var filter = new fabric.Image.filters[object.type](object);
    callback && callback(filter);
    return filter;
  };


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Color Matrix filter class
     * @class fabric.Image.filters.ColorMatrix
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.ColorMatrix#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @see {@Link http://www.webwasp.co.uk/tutorials/219/Color_Matrix_Filter.php}
     * @see {@Link http://phoboslab.org/log/2013/11/fast-image-filters-with-webgl}
     * @example <caption>Kodachrome filter</caption>
     * var filter = new fabric.Image.filters.ColorMatrix({
     *  matrix: [
         1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,
         -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,
         -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,
         0, 0, 0, 1, 0
        ]
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.ColorMatrix = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.ColorMatrix.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'ColorMatrix',

      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'varying vec2 vTexCoord;\n' +
        'uniform mat4 uColorMatrix;\n' +
        'uniform vec4 uConstants;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'color *= uColorMatrix;\n' +
          'color += uConstants;\n' +
          'gl_FragColor = color;\n' +
        '}',

      /**
       * Colormatrix for pixels.
       * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning
       * outside the -1, 1 range.
       * 0.0039215686 is the part of 1 that get translated to 1 in 2d
       * @param {Array} matrix array of 20 numbers.
       * @default
       */
      matrix: [
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        0, 0, 1, 0, 0,
        0, 0, 0, 1, 0
      ],

      mainParameter: 'matrix',

      /**
       * Lock the colormatrix on the color part, skipping alpha, manly for non webgl scenario
       * to save some calculation
       */
      colorsOnly: true,

      /**
       * Constructor
       * @param {Object} [options] Options object
       */
      initialize: function(options) {
        this.callSuper('initialize', options);
        // create a new array instead mutating the prototype with push
        this.matrix = this.matrix.slice(0);
      },

      /**
       * Intentionally left blank, to be overridden in custom filters
       * @param {Object} options
       **/
      isNeutralState: function(/* options */) {
        var _class = filters.ColorMatrix;
        for (var i = 20; i--;) {
          if (this.matrix[i] !== _class.prototype.matrix[i]) {
            return false;
          }
        }
        return true;
      },

      /**
       * Apply the ColorMatrix operation to a Uint8Array representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8Array to be filtered.
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            data = imageData.data,
            iLen = data.length,
            m = this.matrix,
            r, g, b, a, i, colorsOnly = this.colorsOnly;

        for (i = 0; i < iLen; i += 4) {
          r = data[i];
          g = data[i + 1];
          b = data[i + 2];
          if (colorsOnly) {
            data[i] = r * m[0] + g * m[1] + b * m[2] + m[4] * 255;
            data[i + 1] = r * m[5] + g * m[6] + b * m[7] + m[9] * 255;
            data[i + 2] = r * m[10] + g * m[11] + b * m[12] + m[14] * 255;
          }
          else {
            a = data[i + 3];
            data[i] = r * m[0] + g * m[1] + b * m[2] + a * m[3] + m[4] * 255;
            data[i + 1] = r * m[5] + g * m[6] + b * m[7] + a * m[8] + m[9] * 255;
            data[i + 2] = r * m[10] + g * m[11] + b * m[12] + a * m[13] + m[14] * 255;
            data[i + 3] = r * m[15] + g * m[16] + b * m[17] + a * m[18] + m[19] * 255;
          }
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uColorMatrix: gl.getUniformLocation(program, 'uColorMatrix'),
          uConstants: gl.getUniformLocation(program, 'uConstants'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        var m = this.matrix,
            matrix = [
              m[0], m[1], m[2], m[3],
              m[5], m[6], m[7], m[8],
              m[10], m[11], m[12], m[13],
              m[15], m[16], m[17], m[18]
            ],
            constants = [m[4], m[9], m[14], m[19]];
        gl.uniformMatrix4fv(uniformLocations.uColorMatrix, false, matrix);
        gl.uniform4fv(uniformLocations.uConstants, constants);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] function to invoke after filter creation
     * @return {fabric.Image.filters.ColorMatrix} Instance of fabric.Image.filters.ColorMatrix
     */
    fabric.Image.filters.ColorMatrix.fromObject = fabric.Image.filters.BaseFilter.fromObject;
  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Brightness filter class
     * @class fabric.Image.filters.Brightness
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Brightness#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Brightness({
     *   brightness: 0.05
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.Brightness = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Brightness.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Brightness',

      /**
       * Fragment source for the brightness program
       */
      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uBrightness;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'color.rgb += uBrightness;\n' +
          'gl_FragColor = color;\n' +
        '}',

      /**
       * Brightness value, from -1 to 1.
       * translated to -255 to 255 for 2d
       * 0.0039215686 is the part of 1 that get translated to 1 in 2d
       * @param {Number} brightness
       * @default
       */
      brightness: 0,

      /**
       * Describe the property that is the filter parameter
       * @param {String} m
       * @default
       */
      mainParameter: 'brightness',

      /**
      * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
      *
      * @param {Object} options
      * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
      */
      applyTo2d: function(options) {
        if (this.brightness === 0) {
          return;
        }
        var imageData = options.imageData,
            data = imageData.data, i, len = data.length,
            brightness = Math.round(this.brightness * 255);
        for (i = 0; i < len; i += 4) {
          data[i] = data[i] + brightness;
          data[i + 1] = data[i + 1] + brightness;
          data[i + 2] = data[i + 2] + brightness;
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uBrightness: gl.getUniformLocation(program, 'uBrightness'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform1f(uniformLocations.uBrightness, this.brightness);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Brightness} Instance of fabric.Image.filters.Brightness
     */
    fabric.Image.filters.Brightness.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Adapted from <a href="http://www.html5rocks.com/en/tutorials/canvas/imagefilters/">html5rocks article</a>
     * @class fabric.Image.filters.Convolute
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Convolute#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example <caption>Sharpen filter</caption>
     * var filter = new fabric.Image.filters.Convolute({
     *   matrix: [ 0, -1,  0,
     *            -1,  5, -1,
     *             0, -1,  0 ]
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     * @example <caption>Blur filter</caption>
     * var filter = new fabric.Image.filters.Convolute({
     *   matrix: [ 1/9, 1/9, 1/9,
     *             1/9, 1/9, 1/9,
     *             1/9, 1/9, 1/9 ]
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     * @example <caption>Emboss filter</caption>
     * var filter = new fabric.Image.filters.Convolute({
     *   matrix: [ 1,   1,  1,
     *             1, 0.7, -1,
     *            -1,  -1, -1 ]
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     * @example <caption>Emboss filter with opaqueness</caption>
     * var filter = new fabric.Image.filters.Convolute({
     *   opaque: true,
     *   matrix: [ 1,   1,  1,
     *             1, 0.7, -1,
     *            -1,  -1, -1 ]
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     */
    filters.Convolute = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Convolute.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Convolute',

      /*
       * Opaque value (true/false)
       */
      opaque: false,

      /*
       * matrix for the filter, max 9x9
       */
      matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0],

      /**
       * Fragment source for the brightness program
       */
      fragmentSource: {
        Convolute_3_1: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[9];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 0);\n' +
            'for (float h = 0.0; h < 3.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 3.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\n' +
                'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'gl_FragColor = color;\n' +
          '}',
        Convolute_3_0: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[9];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 1);\n' +
            'for (float h = 0.0; h < 3.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 3.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\n' +
                'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
            'gl_FragColor = color;\n' +
            'gl_FragColor.a = alpha;\n' +
          '}',
        Convolute_5_1: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[25];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 0);\n' +
            'for (float h = 0.0; h < 5.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 5.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n' +
                'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'gl_FragColor = color;\n' +
          '}',
        Convolute_5_0: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[25];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 1);\n' +
            'for (float h = 0.0; h < 5.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 5.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n' +
                'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
            'gl_FragColor = color;\n' +
            'gl_FragColor.a = alpha;\n' +
          '}',
        Convolute_7_1: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[49];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 0);\n' +
            'for (float h = 0.0; h < 7.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 7.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n' +
                'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'gl_FragColor = color;\n' +
          '}',
        Convolute_7_0: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[49];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 1);\n' +
            'for (float h = 0.0; h < 7.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 7.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n' +
                'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
            'gl_FragColor = color;\n' +
            'gl_FragColor.a = alpha;\n' +
          '}',
        Convolute_9_1: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[81];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 0);\n' +
            'for (float h = 0.0; h < 9.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 9.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n' +
                'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'gl_FragColor = color;\n' +
          '}',
        Convolute_9_0: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[81];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 1);\n' +
            'for (float h = 0.0; h < 9.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 9.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n' +
                'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
            'gl_FragColor = color;\n' +
            'gl_FragColor.a = alpha;\n' +
          '}',
      },

      /**
       * Constructor
       * @memberOf fabric.Image.filters.Convolute.prototype
       * @param {Object} [options] Options object
       * @param {Boolean} [options.opaque=false] Opaque value (true/false)
       * @param {Array} [options.matrix] Filter matrix
       */


      /**
      * Retrieves the cached shader.
      * @param {Object} options
      * @param {WebGLRenderingContext} options.context The GL context used for rendering.
      * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
      */
      retrieveShader: function(options) {
        var size = Math.sqrt(this.matrix.length);
        var cacheKey = this.type + '_' + size + '_' + (this.opaque ? 1 : 0);
        var shaderSource = this.fragmentSource[cacheKey];
        if (!options.programCache.hasOwnProperty(cacheKey)) {
          options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
        }
        return options.programCache[cacheKey];
      },

      /**
       * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            data = imageData.data,
            weights = this.matrix,
            side = Math.round(Math.sqrt(weights.length)),
            halfSide = Math.floor(side / 2),
            sw = imageData.width,
            sh = imageData.height,
            output = options.ctx.createImageData(sw, sh),
            dst = output.data,
            // go through the destination image pixels
            alphaFac = this.opaque ? 1 : 0,
            r, g, b, a, dstOff,
            scx, scy, srcOff, wt,
            x, y, cx, cy;

        for (y = 0; y < sh; y++) {
          for (x = 0; x < sw; x++) {
            dstOff = (y * sw + x) * 4;
            // calculate the weighed sum of the source image pixels that
            // fall under the convolution matrix
            r = 0; g = 0; b = 0; a = 0;

            for (cy = 0; cy < side; cy++) {
              for (cx = 0; cx < side; cx++) {
                scy = y + cy - halfSide;
                scx = x + cx - halfSide;

                // eslint-disable-next-line max-depth
                if (scy < 0 || scy > sh || scx < 0 || scx > sw) {
                  continue;
                }

                srcOff = (scy * sw + scx) * 4;
                wt = weights[cy * side + cx];

                r += data[srcOff] * wt;
                g += data[srcOff + 1] * wt;
                b += data[srcOff + 2] * wt;
                // eslint-disable-next-line max-depth
                if (!alphaFac) {
                  a += data[srcOff + 3] * wt;
                }
              }
            }
            dst[dstOff] = r;
            dst[dstOff + 1] = g;
            dst[dstOff + 2] = b;
            if (!alphaFac) {
              dst[dstOff + 3] = a;
            }
            else {
              dst[dstOff + 3] = data[dstOff + 3];
            }
          }
        }
        options.imageData = output;
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uMatrix: gl.getUniformLocation(program, 'uMatrix'),
          uOpaque: gl.getUniformLocation(program, 'uOpaque'),
          uHalfSize: gl.getUniformLocation(program, 'uHalfSize'),
          uSize: gl.getUniformLocation(program, 'uSize'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform1fv(uniformLocations.uMatrix, this.matrix);
      },

      /**
       * Returns object representation of an instance
       * @return {Object} Object representation of an instance
       */
      toObject: function() {
        return extend(this.callSuper('toObject'), {
          opaque: this.opaque,
          matrix: this.matrix
        });
      }
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Convolute} Instance of fabric.Image.filters.Convolute
     */
    fabric.Image.filters.Convolute.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Grayscale image filter class
     * @class fabric.Image.filters.Grayscale
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Grayscale();
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.Grayscale = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Grayscale.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Grayscale',

      fragmentSource: {
        average: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = texture2D(uTexture, vTexCoord);\n' +
            'float average = (color.r + color.b + color.g) / 3.0;\n' +
            'gl_FragColor = vec4(average, average, average, color.a);\n' +
          '}',
        lightness: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform int uMode;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 col = texture2D(uTexture, vTexCoord);\n' +
            'float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\n' +
            'gl_FragColor = vec4(average, average, average, col.a);\n' +
          '}',
        luminosity: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform int uMode;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 col = texture2D(uTexture, vTexCoord);\n' +
            'float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\n' +
            'gl_FragColor = vec4(average, average, average, col.a);\n' +
          '}',
      },


      /**
       * Grayscale mode, between 'average', 'lightness', 'luminosity'
       * @param {String} type
       * @default
       */
      mode: 'average',

      mainParameter: 'mode',

      /**
       * Apply the Grayscale operation to a Uint8Array representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8Array to be filtered.
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            data = imageData.data, i,
            len = data.length, value,
            mode = this.mode;
        for (i = 0; i < len; i += 4) {
          if (mode === 'average') {
            value = (data[i] + data[i + 1] + data[i + 2]) / 3;
          }
          else if (mode === 'lightness') {
            value = (Math.min(data[i], data[i + 1], data[i + 2]) +
              Math.max(data[i], data[i + 1], data[i + 2])) / 2;
          }
          else if (mode === 'luminosity') {
            value = 0.21 * data[i] + 0.72 * data[i + 1] + 0.07 * data[i + 2];
          }
          data[i] = value;
          data[i + 1] = value;
          data[i + 2] = value;
        }
      },

      /**
       * Retrieves the cached shader.
       * @param {Object} options
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      retrieveShader: function(options) {
        var cacheKey = this.type + '_' + this.mode;
        if (!options.programCache.hasOwnProperty(cacheKey)) {
          var shaderSource = this.fragmentSource[this.mode];
          options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
        }
        return options.programCache[cacheKey];
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uMode: gl.getUniformLocation(program, 'uMode'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        // default average mode.
        var mode = 1;
        gl.uniform1i(uniformLocations.uMode, mode);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Grayscale} Instance of fabric.Image.filters.Grayscale
     */
    fabric.Image.filters.Grayscale.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Invert filter class
     * @class fabric.Image.filters.Invert
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Invert();
     * object.filters.push(filter);
     * object.applyFilters(canvas.renderAll.bind(canvas));
     */
    filters.Invert = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Invert.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Invert',

      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform int uInvert;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'if (uInvert == 1) {\n' +
            'gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\n' +
          '} else {\n' +
            'gl_FragColor = color;\n' +
          '}\n' +
        '}',

      /**
       * Filter invert. if false, does nothing
       * @param {Boolean} invert
       * @default
       */
      invert: true,

      mainParameter: 'invert',

      /**
       * Apply the Invert operation to a Uint8Array representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8Array to be filtered.
       */
      applyTo2d: function(options) {
        if (!this.invert) {
          return;
        }
        var imageData = options.imageData,
            data = imageData.data, i,
            len = data.length;
        for (i = 0; i < len; i += 4) {
          data[i] = 255 - data[i];
          data[i + 1] = 255 - data[i + 1];
          data[i + 2] = 255 - data[i + 2];
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uInvert: gl.getUniformLocation(program, 'uInvert'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform1i(uniformLocations.uInvert, this.invert);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Invert} Instance of fabric.Image.filters.Invert
     */
    fabric.Image.filters.Invert.fromObject = fabric.Image.filters.BaseFilter.fromObject;


  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Noise filter class
     * @class fabric.Image.filters.Noise
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Noise#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Noise({
     *   noise: 700
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     */
    filters.Noise = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Noise.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Noise',

      /**
       * Fragment source for the noise program
       */
      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uStepH;\n' +
        'uniform float uNoise;\n' +
        'uniform float uSeed;\n' +
        'varying vec2 vTexCoord;\n' +
        'float rand(vec2 co, float seed, float vScale) {\n' +
          'return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\n' +
        '}\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\n' +
          'gl_FragColor = color;\n' +
        '}',

      /**
       * Describe the property that is the filter parameter
       * @param {String} m
       * @default
       */
      mainParameter: 'noise',

      /**
       * Noise value, from
       * @param {Number} noise
       * @default
       */
      noise: 0,

      /**
       * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
       */
      applyTo2d: function(options) {
        if (this.noise === 0) {
          return;
        }
        var imageData = options.imageData,
            data = imageData.data, i, len = data.length,
            noise = this.noise, rand;

        for (i = 0, len = data.length; i < len; i += 4) {

          rand = (0.5 - Math.random()) * noise;

          data[i] += rand;
          data[i + 1] += rand;
          data[i + 2] += rand;
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uNoise: gl.getUniformLocation(program, 'uNoise'),
          uSeed: gl.getUniformLocation(program, 'uSeed'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform1f(uniformLocations.uNoise, this.noise / 255);
        gl.uniform1f(uniformLocations.uSeed, Math.random());
      },

      /**
       * Returns object representation of an instance
       * @return {Object} Object representation of an instance
       */
      toObject: function() {
        return extend(this.callSuper('toObject'), {
          noise: this.noise
        });
      }
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Noise} Instance of fabric.Image.filters.Noise
     */
    fabric.Image.filters.Noise.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Pixelate filter class
     * @class fabric.Image.filters.Pixelate
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Pixelate#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Pixelate({
     *   blocksize: 8
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.Pixelate = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Pixelate.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Pixelate',

      blocksize: 4,

      mainParameter: 'blocksize',

      /**
       * Fragment source for the Pixelate program
       */
      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uBlocksize;\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'float blockW = uBlocksize * uStepW;\n' +
          'float blockH = uBlocksize * uStepW;\n' +
          'int posX = int(vTexCoord.x / blockW);\n' +
          'int posY = int(vTexCoord.y / blockH);\n' +
          'float fposX = float(posX);\n' +
          'float fposY = float(posY);\n' +
          'vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\n' +
          'vec4 color = texture2D(uTexture, squareCoords);\n' +
          'gl_FragColor = color;\n' +
        '}',

      /**
       * Apply the Pixelate operation to a Uint8ClampedArray representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
       */
      applyTo2d: function(options) {
        if (this.blocksize === 1) {
          return;
        }
        var imageData = options.imageData,
            data = imageData.data,
            iLen = imageData.height,
            jLen = imageData.width,
            index, i, j, r, g, b, a,
            _i, _j, _iLen, _jLen;

        for (i = 0; i < iLen; i += this.blocksize) {
          for (j = 0; j < jLen; j += this.blocksize) {

            index = (i * 4) * jLen + (j * 4);

            r = data[index];
            g = data[index + 1];
            b = data[index + 2];
            a = data[index + 3];

            _iLen = Math.min(i + this.blocksize, iLen);
            _jLen = Math.min(j + this.blocksize, jLen);
            for (_i = i; _i < _iLen; _i++) {
              for (_j = j; _j < _jLen; _j++) {
                index = (_i * 4) * jLen + (_j * 4);
                data[index] = r;
                data[index + 1] = g;
                data[index + 2] = b;
                data[index + 3] = a;
              }
            }
          }
        }
      },

      /**
       * Indicate when the filter is not gonna apply changes to the image
       **/
      isNeutralState: function() {
        return this.blocksize === 1;
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uBlocksize: gl.getUniformLocation(program, 'uBlocksize'),
          uStepW: gl.getUniformLocation(program, 'uStepW'),
          uStepH: gl.getUniformLocation(program, 'uStepH'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform1f(uniformLocations.uBlocksize, this.blocksize);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Pixelate} Instance of fabric.Image.filters.Pixelate
     */
    fabric.Image.filters.Pixelate.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Remove white filter class
     * @class fabric.Image.filters.RemoveColor
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.RemoveColor#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.RemoveColor({
     *   threshold: 0.2,
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     */
    filters.RemoveColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.RemoveColor.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'RemoveColor',

      /**
       * Color to remove, in any format understood by fabric.Color.
       * @param {String} type
       * @default
       */
      color: '#FFFFFF',

      /**
       * Fragment source for the brightness program
       */
      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec4 uLow;\n' +
        'uniform vec4 uHigh;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
          'if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\n' +
            'gl_FragColor.a = 0.0;\n' +
          '}\n' +
        '}',

      /**
       * distance to actual color, as value up or down from each r,g,b
       * between 0 and 1
       **/
      distance: 0.02,

      /**
       * For color to remove inside distance, use alpha channel for a smoother deletion
       * NOT IMPLEMENTED YET
       **/
      useAlpha: false,

      /**
       * Constructor
       * @memberOf fabric.Image.filters.RemoveWhite.prototype
       * @param {Object} [options] Options object
       * @param {Number} [options.color=#RRGGBB] Threshold value
       * @param {Number} [options.distance=10] Distance value
       */

      /**
       * Applies filter to canvas element
       * @param {Object} canvasEl Canvas element to apply filter to
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            data = imageData.data, i,
            distance = this.distance * 255,
            r, g, b,
            source = new fabric.Color(this.color).getSource(),
            lowC = [
              source[0] - distance,
              source[1] - distance,
              source[2] - distance,
            ],
            highC = [
              source[0] + distance,
              source[1] + distance,
              source[2] + distance,
            ];


        for (i = 0; i < data.length; i += 4) {
          r = data[i];
          g = data[i + 1];
          b = data[i + 2];

          if (r > lowC[0] &&
              g > lowC[1] &&
              b > lowC[2] &&
              r < highC[0] &&
              g < highC[1] &&
              b < highC[2]) {
            data[i + 3] = 0;
          }
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uLow: gl.getUniformLocation(program, 'uLow'),
          uHigh: gl.getUniformLocation(program, 'uHigh'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        var source = new fabric.Color(this.color).getSource(),
            distance = parseFloat(this.distance),
            lowC = [
              0 + source[0] / 255 - distance,
              0 + source[1] / 255 - distance,
              0 + source[2] / 255 - distance,
              1
            ],
            highC = [
              source[0] / 255 + distance,
              source[1] / 255 + distance,
              source[2] / 255 + distance,
              1
            ];
        gl.uniform4fv(uniformLocations.uLow, lowC);
        gl.uniform4fv(uniformLocations.uHigh, highC);
      },

      /**
       * Returns object representation of an instance
       * @return {Object} Object representation of an instance
       */
      toObject: function() {
        return extend(this.callSuper('toObject'), {
          color: this.color,
          distance: this.distance
        });
      }
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.RemoveColor} Instance of fabric.Image.filters.RemoveWhite
     */
    fabric.Image.filters.RemoveColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    var matrices = {
      Brownie: [
        0.59970,0.34553,-0.27082,0,0.186,
        -0.03770,0.86095,0.15059,0,-0.1449,
        0.24113,-0.07441,0.44972,0,-0.02965,
        0,0,0,1,0
      ],
      Vintage: [
        0.62793,0.32021,-0.03965,0,0.03784,
        0.02578,0.64411,0.03259,0,0.02926,
        0.04660,-0.08512,0.52416,0,0.02023,
        0,0,0,1,0
      ],
      Kodachrome: [
        1.12855,-0.39673,-0.03992,0,0.24991,
        -0.16404,1.08352,-0.05498,0,0.09698,
        -0.16786,-0.56034,1.60148,0,0.13972,
        0,0,0,1,0
      ],
      Technicolor: [
        1.91252,-0.85453,-0.09155,0,0.04624,
        -0.30878,1.76589,-0.10601,0,-0.27589,
        -0.23110,-0.75018,1.84759,0,0.12137,
        0,0,0,1,0
      ],
      Polaroid: [
        1.438,-0.062,-0.062,0,0,
        -0.122,1.378,-0.122,0,0,
        -0.016,-0.016,1.483,0,0,
        0,0,0,1,0
      ],
      Sepia: [
        0.393, 0.769, 0.189, 0, 0,
        0.349, 0.686, 0.168, 0, 0,
        0.272, 0.534, 0.131, 0, 0,
        0, 0, 0, 1, 0
      ],
      BlackWhite: [
        1.5, 1.5, 1.5, 0, -1,
        1.5, 1.5, 1.5, 0, -1,
        1.5, 1.5, 1.5, 0, -1,
        0, 0, 0, 1, 0,
      ]
    };

    for (var key in matrices) {
      filters[key] = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.Sepia.prototype */ {

        /**
         * Filter type
         * @param {String} type
         * @default
         */
        type: key,

        /**
         * Colormatrix for the effect
         * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning
         * outside the -1, 1 range.
         * @param {Array} matrix array of 20 numbers.
         * @default
         */
        matrix: matrices[key],

        /**
         * Lock the matrix export for this kind of static, parameter less filters.
         */
        mainParameter: false,
        /**
         * Lock the colormatrix on the color part, skipping alpha
         */
        colorsOnly: true,

      });
      fabric.Image.filters[key].fromObject = fabric.Image.filters.BaseFilter.fromObject;
    }
  })(exports);


  (function(global) {

    var fabric = global.fabric,
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Color Blend filter class
     * @class fabric.Image.filter.BlendColor
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @example
     * var filter = new fabric.Image.filters.BlendColor({
     *  color: '#000',
     *  mode: 'multiply'
     * });
     *
     * var filter = new fabric.Image.filters.BlendImage({
     *  image: fabricImageObject,
     *  mode: 'multiply',
     *  alpha: 0.5
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     */

    filters.BlendColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blend.prototype */ {
      type: 'BlendColor',

      /**
       * Color to make the blend operation with. default to a reddish color since black or white
       * gives always strong result.
       **/
      color: '#F95C63',

      /**
       * Blend mode for the filter: one of multiply, add, diff, screen, subtract,
       * darken, lighten, overlay, exclusion, tint.
       **/
      mode: 'multiply',

      /**
       * alpha value. represent the strength of the blend color operation.
       **/
      alpha: 1,

      /**
       * Fragment source for the Multiply program
       */
      fragmentSource: {
        multiply: 'gl_FragColor.rgb *= uColor.rgb;\n',
        screen: 'gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\n',
        add: 'gl_FragColor.rgb += uColor.rgb;\n',
        diff: 'gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\n',
        subtract: 'gl_FragColor.rgb -= uColor.rgb;\n',
        lighten: 'gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\n',
        darken: 'gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\n',
        exclusion: 'gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\n',
        overlay: 'if (uColor.r < 0.5) {\n' +
            'gl_FragColor.r *= 2.0 * uColor.r;\n' +
          '} else {\n' +
            'gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\n' +
          '}\n' +
          'if (uColor.g < 0.5) {\n' +
            'gl_FragColor.g *= 2.0 * uColor.g;\n' +
          '} else {\n' +
            'gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\n' +
          '}\n' +
          'if (uColor.b < 0.5) {\n' +
            'gl_FragColor.b *= 2.0 * uColor.b;\n' +
          '} else {\n' +
            'gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\n' +
          '}\n',
        tint: 'gl_FragColor.rgb *= (1.0 - uColor.a);\n' +
          'gl_FragColor.rgb += uColor.rgb;\n',
      },

      /**
       * build the fragment source for the filters, joining the common part with
       * the specific one.
       * @param {String} mode the mode of the filter, a key of this.fragmentSource
       * @return {String} the source to be compiled
       * @private
       */
      buildSource: function(mode) {
        return 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform vec4 uColor;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = texture2D(uTexture, vTexCoord);\n' +
            'gl_FragColor = color;\n' +
            'if (color.a > 0.0) {\n' +
              this.fragmentSource[mode] +
            '}\n' +
          '}';
      },

      /**
       * Retrieves the cached shader.
       * @param {Object} options
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      retrieveShader: function(options) {
        var cacheKey = this.type + '_' + this.mode, shaderSource;
        if (!options.programCache.hasOwnProperty(cacheKey)) {
          shaderSource = this.buildSource(this.mode);
          options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
        }
        return options.programCache[cacheKey];
      },

      /**
       * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            data = imageData.data, iLen = data.length,
            tr, tg, tb,
            r, g, b,
            source, alpha1 = 1 - this.alpha;

        source = new fabric.Color(this.color).getSource();
        tr = source[0] * this.alpha;
        tg = source[1] * this.alpha;
        tb = source[2] * this.alpha;

        for (var i = 0; i < iLen; i += 4) {

          r = data[i];
          g = data[i + 1];
          b = data[i + 2];

          switch (this.mode) {
            case 'multiply':
              data[i] = r * tr / 255;
              data[i + 1] = g * tg / 255;
              data[i + 2] = b * tb / 255;
              break;
            case 'screen':
              data[i] = 255 - (255 - r) * (255 - tr) / 255;
              data[i + 1] = 255 - (255 - g) * (255 - tg) / 255;
              data[i + 2] = 255 - (255 - b) * (255 - tb) / 255;
              break;
            case 'add':
              data[i] = r + tr;
              data[i + 1] = g + tg;
              data[i + 2] = b + tb;
              break;
            case 'diff':
            case 'difference':
              data[i] = Math.abs(r - tr);
              data[i + 1] = Math.abs(g - tg);
              data[i + 2] = Math.abs(b - tb);
              break;
            case 'subtract':
              data[i] = r - tr;
              data[i + 1] = g - tg;
              data[i + 2] = b - tb;
              break;
            case 'darken':
              data[i] = Math.min(r, tr);
              data[i + 1] = Math.min(g, tg);
              data[i + 2] = Math.min(b, tb);
              break;
            case 'lighten':
              data[i] = Math.max(r, tr);
              data[i + 1] = Math.max(g, tg);
              data[i + 2] = Math.max(b, tb);
              break;
            case 'overlay':
              data[i] = tr < 128 ? (2 * r * tr / 255) : (255 - 2 * (255 - r) * (255 - tr) / 255);
              data[i + 1] = tg < 128 ? (2 * g * tg / 255) : (255 - 2 * (255 - g) * (255 - tg) / 255);
              data[i + 2] = tb < 128 ? (2 * b * tb / 255) : (255 - 2 * (255 - b) * (255 - tb) / 255);
              break;
            case 'exclusion':
              data[i] = tr + r - ((2 * tr * r) / 255);
              data[i + 1] = tg + g - ((2 * tg * g) / 255);
              data[i + 2] = tb + b - ((2 * tb * b) / 255);
              break;
            case 'tint':
              data[i] = tr + r * alpha1;
              data[i + 1] = tg + g * alpha1;
              data[i + 2] = tb + b * alpha1;
          }
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uColor: gl.getUniformLocation(program, 'uColor'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        var source = new fabric.Color(this.color).getSource();
        source[0] = this.alpha * source[0] / 255;
        source[1] = this.alpha * source[1] / 255;
        source[2] = this.alpha * source[2] / 255;
        source[3] = this.alpha;
        gl.uniform4fv(uniformLocations.uColor, source);
      },

      /**
       * Returns object representation of an instance
       * @return {Object} Object representation of an instance
       */
      toObject: function() {
        return {
          type: this.type,
          color: this.color,
          mode: this.mode,
          alpha: this.alpha
        };
      }
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.BlendColor} Instance of fabric.Image.filters.BlendColor
     */
    fabric.Image.filters.BlendColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric = global.fabric,
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Image Blend filter class
     * @class fabric.Image.filter.BlendImage
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @example
     * var filter = new fabric.Image.filters.BlendColor({
     *  color: '#000',
     *  mode: 'multiply'
     * });
     *
     * var filter = new fabric.Image.filters.BlendImage({
     *  image: fabricImageObject,
     *  mode: 'multiply',
     *  alpha: 0.5
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     */

    filters.BlendImage = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.BlendImage.prototype */ {
      type: 'BlendImage',

      /**
       * Color to make the blend operation with. default to a reddish color since black or white
       * gives always strong result.
       **/
      image: null,

      /**
       * Blend mode for the filter: one of multiply, add, diff, screen, subtract,
       * darken, lighten, overlay, exclusion, tint.
       **/
      mode: 'multiply',

      /**
       * alpha value. represent the strength of the blend color operation.
       **/
      alpha: 1,

      vertexSource: 'attribute vec2 aPosition;\n' +
        'varying vec2 vTexCoord;\n' +
        'varying vec2 vTexCoord2;\n' +
        'uniform mat3 uTransformMatrix;\n' +
        'void main() {\n' +
          'vTexCoord = aPosition;\n' +
          'vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\n' +
          'gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n' +
        '}',

      /**
       * Fragment source for the Multiply program
       */
      fragmentSource: {
        multiply: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform sampler2D uImage;\n' +
          'uniform vec4 uColor;\n' +
          'varying vec2 vTexCoord;\n' +
          'varying vec2 vTexCoord2;\n' +
          'void main() {\n' +
            'vec4 color = texture2D(uTexture, vTexCoord);\n' +
            'vec4 color2 = texture2D(uImage, vTexCoord2);\n' +
            'color.rgba *= color2.rgba;\n' +
            'gl_FragColor = color;\n' +
          '}',
        mask: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform sampler2D uImage;\n' +
          'uniform vec4 uColor;\n' +
          'varying vec2 vTexCoord;\n' +
          'varying vec2 vTexCoord2;\n' +
          'void main() {\n' +
            'vec4 color = texture2D(uTexture, vTexCoord);\n' +
            'vec4 color2 = texture2D(uImage, vTexCoord2);\n' +
            'color.a = color2.a;\n' +
            'gl_FragColor = color;\n' +
          '}',
      },

      /**
       * Retrieves the cached shader.
       * @param {Object} options
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      retrieveShader: function(options) {
        var cacheKey = this.type + '_' + this.mode;
        var shaderSource = this.fragmentSource[this.mode];
        if (!options.programCache.hasOwnProperty(cacheKey)) {
          options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
        }
        return options.programCache[cacheKey];
      },

      applyToWebGL: function(options) {
        // load texture to blend.
        var gl = options.context,
            texture = this.createTexture(options.filterBackend, this.image);
        this.bindAdditionalTexture(gl, texture, gl.TEXTURE1);
        this.callSuper('applyToWebGL', options);
        this.unbindAdditionalTexture(gl, gl.TEXTURE1);
      },

      createTexture: function(backend, image) {
        return backend.getCachedTexture(image.cacheKey, image._element);
      },

      /**
       * Calculate a transformMatrix to adapt the image to blend over
       * @param {Object} options
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      calculateMatrix: function() {
        var image = this.image,
            width = image._element.width,
            height = image._element.height;
        return [
          1 / image.scaleX, 0, 0,
          0, 1 / image.scaleY, 0,
          -image.left / width, -image.top / height, 1
        ];
      },

      /**
       * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            resources = options.filterBackend.resources,
            data = imageData.data, iLen = data.length,
            width = options.imageData.width,
            height = options.imageData.height,
            tr, tg, tb, ta,
            r, g, b, a,
            canvas1, context, image = this.image, blendData;

        if (!resources.blendImage) {
          resources.blendImage = document.createElement('canvas');
        }
        canvas1 = resources.blendImage;
        if (canvas1.width !== width || canvas1.height !== height) {
          canvas1.width = width;
          canvas1.height = height;
        }
        context = canvas1.getContext('2d');
        context.setTransform(image.scaleX, 0, 0, image.scaleY, image.left, image.top);
        context.drawImage(image._element, 0, 0, width, height);
        blendData = context.getImageData(0, 0, width, height).data;
        for (var i = 0; i < iLen; i += 4) {

          r = data[i];
          g = data[i + 1];
          b = data[i + 2];
          a = data[i + 3];

          tr = blendData[i];
          tg = blendData[i + 1];
          tb = blendData[i + 2];
          ta = blendData[i + 3];

          switch (this.mode) {
            case 'multiply':
              data[i] = r * tr / 255;
              data[i + 1] = g * tg / 255;
              data[i + 2] = b * tb / 255;
              data[i + 3] = a * ta / 255;
              break;
            case 'mask':
              data[i + 3] = ta;
              break;
          }
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uTransformMatrix: gl.getUniformLocation(program, 'uTransformMatrix'),
          uImage: gl.getUniformLocation(program, 'uImage'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        var matrix = this.calculateMatrix();
        gl.uniform1i(uniformLocations.uImage, 1); // texture unit 1.
        gl.uniformMatrix3fv(uniformLocations.uTransformMatrix, false, matrix);
      },

      /**
       * Returns object representation of an instance
       * @return {Object} Object representation of an instance
       */
      toObject: function() {
        return {
          type: this.type,
          image: this.image && this.image.toObject(),
          mode: this.mode,
          alpha: this.alpha
        };
      }
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} callback to be invoked after filter creation
     * @return {fabric.Image.filters.BlendImage} Instance of fabric.Image.filters.BlendImage
     */
    fabric.Image.filters.BlendImage.fromObject = function(object, callback) {
      fabric.Image.fromObject(object.image, function(image) {
        var options = fabric.util.object.clone(object);
        options.image = image;
        callback(new fabric.Image.filters.BlendImage(options));
      });
    };

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }), pow = Math.pow, floor = Math.floor,
        sqrt = Math.sqrt, abs = Math.abs, round = Math.round, sin = Math.sin,
        ceil = Math.ceil,
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Resize image filter class
     * @class fabric.Image.filters.Resize
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Resize();
     * object.filters.push(filter);
     * object.applyFilters(canvas.renderAll.bind(canvas));
     */
    filters.Resize = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Resize.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Resize',

      /**
       * Resize type
       * @param {String} resizeType
       * @default
       */
      resizeType: 'hermite',

      /**
       * Scale factor for resizing, x axis
       * @param {Number} scaleX
       * @default
       */
      scaleX: 0,

      /**
       * Scale factor for resizing, y axis
       * @param {Number} scaleY
       * @default
       */
      scaleY: 0,

      /**
       * LanczosLobes parameter for lanczos filter
       * @param {Number} lanczosLobes
       * @default
       */
      lanczosLobes: 3,


      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uDelta: gl.getUniformLocation(program, 'uDelta'),
          uTaps: gl.getUniformLocation(program, 'uTaps'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform2fv(uniformLocations.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]);
        gl.uniform1fv(uniformLocations.uTaps, this.taps);
      },

      /**
       * Retrieves the cached shader.
       * @param {Object} options
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      retrieveShader: function(options) {
        var filterWindow = this.getFilterWindow(), cacheKey = this.type + '_' + filterWindow;
        if (!options.programCache.hasOwnProperty(cacheKey)) {
          var fragmentShader = this.generateShader(filterWindow);
          options.programCache[cacheKey] = this.createProgram(options.context, fragmentShader);
        }
        return options.programCache[cacheKey];
      },

      getFilterWindow: function() {
        var scale = this.tempScale;
        return Math.ceil(this.lanczosLobes / scale);
      },

      getTaps: function() {
        var lobeFunction = this.lanczosCreate(this.lanczosLobes), scale = this.tempScale,
            filterWindow = this.getFilterWindow(), taps = new Array(filterWindow);
        for (var i = 1; i <= filterWindow; i++) {
          taps[i - 1] = lobeFunction(i * scale);
        }
        return taps;
      },

      /**
       * Generate vertex and shader sources from the necessary steps numbers
       * @param {Number} filterWindow
       */
      generateShader: function(filterWindow) {
        var offsets = new Array(filterWindow),
            fragmentShader = this.fragmentSourceTOP, filterWindow;

        for (var i = 1; i <= filterWindow; i++) {
          offsets[i - 1] = i + '.0 * uDelta';
        }

        fragmentShader += 'uniform float uTaps[' + filterWindow + '];\n';
        fragmentShader += 'void main() {\n';
        fragmentShader += '  vec4 color = texture2D(uTexture, vTexCoord);\n';
        fragmentShader += '  float sum = 1.0;\n';

        offsets.forEach(function(offset, i) {
          fragmentShader += '  color += texture2D(uTexture, vTexCoord + ' + offset + ') * uTaps[' + i + '];\n';
          fragmentShader += '  color += texture2D(uTexture, vTexCoord - ' + offset + ') * uTaps[' + i + '];\n';
          fragmentShader += '  sum += 2.0 * uTaps[' + i + '];\n';
        });
        fragmentShader += '  gl_FragColor = color / sum;\n';
        fragmentShader += '}';
        return fragmentShader;
      },

      fragmentSourceTOP: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec2 uDelta;\n' +
        'varying vec2 vTexCoord;\n',

      /**
       * Apply the resize filter to the image
       * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
       *
       * @param {Object} options
       * @param {Number} options.passes The number of filters remaining to be executed
       * @param {Boolean} options.webgl Whether to use webgl to render the filter.
       * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
       * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      applyTo: function(options) {
        if (options.webgl) {
          if (options.passes > 1 && this.isNeutralState(options)) {
            // avoid doing something that we do not need
            return;
          }
          options.passes++;
          this.width = options.sourceWidth;
          this.horizontal = true;
          this.dW = Math.round(this.width * this.scaleX);
          this.dH = options.sourceHeight;
          this.tempScale = this.dW / this.width;
          this.taps = this.getTaps();
          options.destinationWidth = this.dW;
          this._setupFrameBuffer(options);
          this.applyToWebGL(options);
          this._swapTextures(options);
          options.sourceWidth = options.destinationWidth;

          this.height = options.sourceHeight;
          this.horizontal = false;
          this.dH = Math.round(this.height * this.scaleY);
          this.tempScale = this.dH / this.height;
          this.taps = this.getTaps();
          options.destinationHeight = this.dH;
          this._setupFrameBuffer(options);
          this.applyToWebGL(options);
          this._swapTextures(options);
          options.sourceHeight = options.destinationHeight;
        }
        else if (!this.isNeutralState(options)) {
          this.applyTo2d(options);
        }
      },

      isNeutralState: function(options) {
        var scaleX = options.scaleX || this.scaleX,
            scaleY = options.scaleY || this.scaleY;
        return scaleX === 1 && scaleY === 1;
      },

      lanczosCreate: function(lobes) {
        return function(x) {
          if (x >= lobes || x <= -lobes) {
            return 0.0;
          }
          if (x < 1.19209290E-07 && x > -1.19209290E-07) {
            return 1.0;
          }
          x *= Math.PI;
          var xx = x / lobes;
          return (sin(x) / x) * sin(xx) / xx;
        };
      },

      /**
       * Applies filter to canvas element
       * @memberOf fabric.Image.filters.Resize.prototype
       * @param {Object} canvasEl Canvas element to apply filter to
       * @param {Number} scaleX
       * @param {Number} scaleY
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            scaleX = this.scaleX,
            scaleY = this.scaleY;

        this.rcpScaleX = 1 / scaleX;
        this.rcpScaleY = 1 / scaleY;

        var oW = imageData.width, oH = imageData.height,
            dW = round(oW * scaleX), dH = round(oH * scaleY),
            newData;

        if (this.resizeType === 'sliceHack') {
          newData = this.sliceByTwo(options, oW, oH, dW, dH);
        }
        else if (this.resizeType === 'hermite') {
          newData = this.hermiteFastResize(options, oW, oH, dW, dH);
        }
        else if (this.resizeType === 'bilinear') {
          newData = this.bilinearFiltering(options, oW, oH, dW, dH);
        }
        else if (this.resizeType === 'lanczos') {
          newData = this.lanczosResize(options, oW, oH, dW, dH);
        }
        options.imageData = newData;
      },

      /**
       * Filter sliceByTwo
       * @param {Object} canvasEl Canvas element to apply filter to
       * @param {Number} oW Original Width
       * @param {Number} oH Original Height
       * @param {Number} dW Destination Width
       * @param {Number} dH Destination Height
       * @returns {ImageData}
       */
      sliceByTwo: function(options, oW, oH, dW, dH) {
        var imageData = options.imageData,
            mult = 0.5, doneW = false, doneH = false, stepW = oW * mult,
            stepH = oH * mult, resources = fabric.filterBackend.resources,
            tmpCanvas, ctx, sX = 0, sY = 0, dX = oW, dY = 0;
        if (!resources.sliceByTwo) {
          resources.sliceByTwo = document.createElement('canvas');
        }
        tmpCanvas = resources.sliceByTwo;
        if (tmpCanvas.width < oW * 1.5 || tmpCanvas.height < oH) {
          tmpCanvas.width = oW * 1.5;
          tmpCanvas.height = oH;
        }
        ctx = tmpCanvas.getContext('2d');
        ctx.clearRect(0, 0, oW * 1.5, oH);
        ctx.putImageData(imageData, 0, 0);

        dW = floor(dW);
        dH = floor(dH);

        while (!doneW || !doneH) {
          oW = stepW;
          oH = stepH;
          if (dW < floor(stepW * mult)) {
            stepW = floor(stepW * mult);
          }
          else {
            stepW = dW;
            doneW = true;
          }
          if (dH < floor(stepH * mult)) {
            stepH = floor(stepH * mult);
          }
          else {
            stepH = dH;
            doneH = true;
          }
          ctx.drawImage(tmpCanvas, sX, sY, oW, oH, dX, dY, stepW, stepH);
          sX = dX;
          sY = dY;
          dY += stepH;
        }
        return ctx.getImageData(sX, sY, dW, dH);
      },

      /**
       * Filter lanczosResize
       * @param {Object} canvasEl Canvas element to apply filter to
       * @param {Number} oW Original Width
       * @param {Number} oH Original Height
       * @param {Number} dW Destination Width
       * @param {Number} dH Destination Height
       * @returns {ImageData}
       */
      lanczosResize: function(options, oW, oH, dW, dH) {

        function process(u) {
          var v, i, weight, idx, a, red, green,
              blue, alpha, fX, fY;
          center.x = (u + 0.5) * ratioX;
          icenter.x = floor(center.x);
          for (v = 0; v < dH; v++) {
            center.y = (v + 0.5) * ratioY;
            icenter.y = floor(center.y);
            a = 0; red = 0; green = 0; blue = 0; alpha = 0;
            for (i = icenter.x - range2X; i <= icenter.x + range2X; i++) {
              if (i < 0 || i >= oW) {
                continue;
              }
              fX = floor(1000 * abs(i - center.x));
              if (!cacheLanc[fX]) {
                cacheLanc[fX] = { };
              }
              for (var j = icenter.y - range2Y; j <= icenter.y + range2Y; j++) {
                if (j < 0 || j >= oH) {
                  continue;
                }
                fY = floor(1000 * abs(j - center.y));
                if (!cacheLanc[fX][fY]) {
                  cacheLanc[fX][fY] = lanczos(sqrt(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1000);
                }
                weight = cacheLanc[fX][fY];
                if (weight > 0) {
                  idx = (j * oW + i) * 4;
                  a += weight;
                  red += weight * srcData[idx];
                  green += weight * srcData[idx + 1];
                  blue += weight * srcData[idx + 2];
                  alpha += weight * srcData[idx + 3];
                }
              }
            }
            idx = (v * dW + u) * 4;
            destData[idx] = red / a;
            destData[idx + 1] = green / a;
            destData[idx + 2] = blue / a;
            destData[idx + 3] = alpha / a;
          }

          if (++u < dW) {
            return process(u);
          }
          else {
            return destImg;
          }
        }

        var srcData = options.imageData.data,
            destImg = options.ctx.createImageData(dW, dH),
            destData = destImg.data,
            lanczos = this.lanczosCreate(this.lanczosLobes),
            ratioX = this.rcpScaleX, ratioY = this.rcpScaleY,
            rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY,
            range2X = ceil(ratioX * this.lanczosLobes / 2),
            range2Y = ceil(ratioY * this.lanczosLobes / 2),
            cacheLanc = { }, center = { }, icenter = { };

        return process(0);
      },

      /**
       * bilinearFiltering
       * @param {Object} canvasEl Canvas element to apply filter to
       * @param {Number} oW Original Width
       * @param {Number} oH Original Height
       * @param {Number} dW Destination Width
       * @param {Number} dH Destination Height
       * @returns {ImageData}
       */
      bilinearFiltering: function(options, oW, oH, dW, dH) {
        var a, b, c, d, x, y, i, j, xDiff, yDiff, chnl,
            color, offset = 0, origPix, ratioX = this.rcpScaleX,
            ratioY = this.rcpScaleY,
            w4 = 4 * (oW - 1), img = options.imageData,
            pixels = img.data, destImage = options.ctx.createImageData(dW, dH),
            destPixels = destImage.data;
        for (i = 0; i < dH; i++) {
          for (j = 0; j < dW; j++) {
            x = floor(ratioX * j);
            y = floor(ratioY * i);
            xDiff = ratioX * j - x;
            yDiff = ratioY * i - y;
            origPix = 4 * (y * oW + x);

            for (chnl = 0; chnl < 4; chnl++) {
              a = pixels[origPix + chnl];
              b = pixels[origPix + 4 + chnl];
              c = pixels[origPix + w4 + chnl];
              d = pixels[origPix + w4 + 4 + chnl];
              color = a * (1 - xDiff) * (1 - yDiff) + b * xDiff * (1 - yDiff) +
                      c * yDiff * (1 - xDiff) + d * xDiff * yDiff;
              destPixels[offset++] = color;
            }
          }
        }
        return destImage;
      },

      /**
       * hermiteFastResize
       * @param {Object} canvasEl Canvas element to apply filter to
       * @param {Number} oW Original Width
       * @param {Number} oH Original Height
       * @param {Number} dW Destination Width
       * @param {Number} dH Destination Height
       * @returns {ImageData}
       */
      hermiteFastResize: function(options, oW, oH, dW, dH) {
        var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY,
            ratioWHalf = ceil(ratioW / 2),
            ratioHHalf = ceil(ratioH / 2),
            img = options.imageData, data = img.data,
            img2 = options.ctx.createImageData(dW, dH), data2 = img2.data;
        for (var j = 0; j < dH; j++) {
          for (var i = 0; i < dW; i++) {
            var x2 = (i + j * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0,
                gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j + 0.5) * ratioH;
            for (var yy = floor(j * ratioH); yy < (j + 1) * ratioH; yy++) {
              var dy = abs(centerY - (yy + 0.5)) / ratioHHalf,
                  centerX = (i + 0.5) * ratioW, w0 = dy * dy;
              for (var xx = floor(i * ratioW); xx < (i + 1) * ratioW; xx++) {
                var dx = abs(centerX - (xx + 0.5)) / ratioWHalf,
                    w = sqrt(w0 + dx * dx);
                /* eslint-disable max-depth */
                if (w > 1 && w < -1) {
                  continue;
                }
                //hermite filter
                weight = 2 * w * w * w - 3 * w * w + 1;
                if (weight > 0) {
                  dx = 4 * (xx + yy * oW);
                  //alpha
                  gxA += weight * data[dx + 3];
                  weightsAlpha += weight;
                  //colors
                  if (data[dx + 3] < 255) {
                    weight = weight * data[dx + 3] / 250;
                  }
                  gxR += weight * data[dx];
                  gxG += weight * data[dx + 1];
                  gxB += weight * data[dx + 2];
                  weights += weight;
                }
                /* eslint-enable max-depth */
              }
            }
            data2[x2] = gxR / weights;
            data2[x2 + 1] = gxG / weights;
            data2[x2 + 2] = gxB / weights;
            data2[x2 + 3] = gxA / weightsAlpha;
          }
        }
        return img2;
      },

      /**
       * Returns object representation of an instance
       * @return {Object} Object representation of an instance
       */
      toObject: function() {
        return {
          type: this.type,
          scaleX: this.scaleX,
          scaleY: this.scaleY,
          resizeType: this.resizeType,
          lanczosLobes: this.lanczosLobes
        };
      }
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Resize} Instance of fabric.Image.filters.Resize
     */
    fabric.Image.filters.Resize.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Contrast filter class
     * @class fabric.Image.filters.Contrast
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Contrast#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Contrast({
     *   contrast: 40
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.Contrast = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Contrast.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Contrast',

      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uContrast;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\n' +
          'color.rgb = contrastF * (color.rgb - 0.5) + 0.5;\n' +
          'gl_FragColor = color;\n' +
        '}',

      contrast: 0,

      mainParameter: 'contrast',

      /**
       * Constructor
       * @memberOf fabric.Image.filters.Contrast.prototype
       * @param {Object} [options] Options object
       * @param {Number} [options.contrast=0] Value to contrast the image up (-1...1)
       */

      /**
        * Apply the Contrast operation to a Uint8Array representing the pixels of an image.
        *
        * @param {Object} options
        * @param {ImageData} options.imageData The Uint8Array to be filtered.
        */
      applyTo2d: function(options) {
        if (this.contrast === 0) {
          return;
        }
        var imageData = options.imageData, i, len,
            data = imageData.data, len = data.length,
            contrast = Math.floor(this.contrast * 255),
            contrastF = 259 * (contrast + 255) / (255 * (259 - contrast));

        for (i = 0; i < len; i += 4) {
          data[i] = contrastF * (data[i] - 128) + 128;
          data[i + 1] = contrastF * (data[i + 1] - 128) + 128;
          data[i + 2] = contrastF * (data[i + 2] - 128) + 128;
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uContrast: gl.getUniformLocation(program, 'uContrast'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform1f(uniformLocations.uContrast, this.contrast);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Contrast} Instance of fabric.Image.filters.Contrast
     */
    fabric.Image.filters.Contrast.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Saturate filter class
     * @class fabric.Image.filters.Saturation
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Saturation#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Saturation({
     *   saturation: 100
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.Saturation = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Saturation.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Saturation',

      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uSaturation;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'float rgMax = max(color.r, color.g);\n' +
          'float rgbMax = max(rgMax, color.b);\n' +
          'color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\n' +
          'color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\n' +
          'color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\n' +
          'gl_FragColor = color;\n' +
        '}',

      saturation: 0,

      mainParameter: 'saturation',

      /**
       * Constructor
       * @memberOf fabric.Image.filters.Saturate.prototype
       * @param {Object} [options] Options object
       * @param {Number} [options.saturate=0] Value to saturate the image (-1...1)
       */

      /**
       * Apply the Saturation operation to a Uint8ClampedArray representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
       */
      applyTo2d: function(options) {
        if (this.saturation === 0) {
          return;
        }
        var imageData = options.imageData,
            data = imageData.data, len = data.length,
            adjust = -this.saturation, i, max;

        for (i = 0; i < len; i += 4) {
          max = Math.max(data[i], data[i + 1], data[i + 2]);
          data[i] += max !== data[i] ? (max - data[i]) * adjust : 0;
          data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * adjust : 0;
          data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * adjust : 0;
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uSaturation: gl.getUniformLocation(program, 'uSaturation'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform1f(uniformLocations.uSaturation, -this.saturation);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Saturation} Instance of fabric.Image.filters.Saturate
     */
    fabric.Image.filters.Saturation.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Blur filter class
     * @class fabric.Image.filters.Blur
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Blur#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Blur({
     *   blur: 0.5
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     */
    filters.Blur = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blur.prototype */ {

      type: 'Blur',

      /*
  'gl_FragColor = vec4(0.0);',
  'gl_FragColor += texture2D(texture, vTexCoord + -7 * uDelta)*0.0044299121055113265;',
  'gl_FragColor += texture2D(texture, vTexCoord + -6 * uDelta)*0.00895781211794;',
  'gl_FragColor += texture2D(texture, vTexCoord + -5 * uDelta)*0.0215963866053;',
  'gl_FragColor += texture2D(texture, vTexCoord + -4 * uDelta)*0.0443683338718;',
  'gl_FragColor += texture2D(texture, vTexCoord + -3 * uDelta)*0.0776744219933;',
  'gl_FragColor += texture2D(texture, vTexCoord + -2 * uDelta)*0.115876621105;',
  'gl_FragColor += texture2D(texture, vTexCoord + -1 * uDelta)*0.147308056121;',
  'gl_FragColor += texture2D(texture, vTexCoord              )*0.159576912161;',
  'gl_FragColor += texture2D(texture, vTexCoord + 1 * uDelta)*0.147308056121;',
  'gl_FragColor += texture2D(texture, vTexCoord + 2 * uDelta)*0.115876621105;',
  'gl_FragColor += texture2D(texture, vTexCoord + 3 * uDelta)*0.0776744219933;',
  'gl_FragColor += texture2D(texture, vTexCoord + 4 * uDelta)*0.0443683338718;',
  'gl_FragColor += texture2D(texture, vTexCoord + 5 * uDelta)*0.0215963866053;',
  'gl_FragColor += texture2D(texture, vTexCoord + 6 * uDelta)*0.00895781211794;',
  'gl_FragColor += texture2D(texture, vTexCoord + 7 * uDelta)*0.0044299121055113265;',
  */

      /* eslint-disable max-len */
      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec2 uDelta;\n' +
        'varying vec2 vTexCoord;\n' +
        'const float nSamples = 15.0;\n' +
        'vec3 v3offset = vec3(12.9898, 78.233, 151.7182);\n' +
        'float random(vec3 scale) {\n' +
          /* use the fragment position for a different seed per-pixel */
          'return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\n' +
        '}\n' +
        'void main() {\n' +
          'vec4 color = vec4(0.0);\n' +
          'float total = 0.0;\n' +
          'float offset = random(v3offset);\n' +
          'for (float t = -nSamples; t <= nSamples; t++) {\n' +
            'float percent = (t + offset - 0.5) / nSamples;\n' +
            'float weight = 1.0 - abs(percent);\n' +
            'color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\n' +
            'total += weight;\n' +
          '}\n' +
          'gl_FragColor = color / total;\n' +
        '}',
      /* eslint-enable max-len */

      /**
       * blur value, in percentage of image dimensions.
       * specific to keep the image blur constant at different resolutions
       * range bewteen 0 and 1.
       */
      blur: 0,

      mainParameter: 'blur',

      applyTo: function(options) {
        if (options.webgl) {
          // this aspectRatio is used to give the same blur to vertical and horizontal
          this.aspectRatio = options.sourceWidth / options.sourceHeight;
          options.passes++;
          this._setupFrameBuffer(options);
          this.horizontal = true;
          this.applyToWebGL(options);
          this._swapTextures(options);
          this._setupFrameBuffer(options);
          this.horizontal = false;
          this.applyToWebGL(options);
          this._swapTextures(options);
        }
        else {
          this.applyTo2d(options);
        }
      },

      applyTo2d: function(options) {
        // paint canvasEl with current image data.
        //options.ctx.putImageData(options.imageData, 0, 0);
        options.imageData = this.simpleBlur(options);
      },

      simpleBlur: function(options) {
        var resources = options.filterBackend.resources, canvas1, canvas2,
            width = options.imageData.width,
            height = options.imageData.height;

        if (!resources.blurLayer1) {
          resources.blurLayer1 = fabric.util.createCanvasElement();
          resources.blurLayer2 = fabric.util.createCanvasElement();
        }
        canvas1 = resources.blurLayer1;
        canvas2 = resources.blurLayer2;
        if (canvas1.width !== width || canvas1.height !== height) {
          canvas2.width = canvas1.width = width;
          canvas2.height = canvas1.height = height;
        }
        var ctx1 = canvas1.getContext('2d'),
            ctx2 = canvas2.getContext('2d'),
            nSamples = 15,
            random, percent, j, i,
            blur = this.blur * 0.06 * 0.5;

        // load first canvas
        ctx1.putImageData(options.imageData, 0, 0);
        ctx2.clearRect(0, 0, width, height);

        for (i = -nSamples; i <= nSamples; i++) {
          random = (Math.random() - 0.5) / 4;
          percent = i / nSamples;
          j = blur * percent * width + random;
          ctx2.globalAlpha = 1 - Math.abs(percent);
          ctx2.drawImage(canvas1, j, random);
          ctx1.drawImage(canvas2, 0, 0);
          ctx2.globalAlpha = 1;
          ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
        }
        for (i = -nSamples; i <= nSamples; i++) {
          random = (Math.random() - 0.5) / 4;
          percent = i / nSamples;
          j = blur * percent * height + random;
          ctx2.globalAlpha = 1 - Math.abs(percent);
          ctx2.drawImage(canvas1, random, j);
          ctx1.drawImage(canvas2, 0, 0);
          ctx2.globalAlpha = 1;
          ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
        }
        options.ctx.drawImage(canvas1, 0, 0);
        var newImageData = options.ctx.getImageData(0, 0, canvas1.width, canvas1.height);
        ctx1.globalAlpha = 1;
        ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
        return newImageData;
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          delta: gl.getUniformLocation(program, 'uDelta'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        var delta = this.chooseRightDelta();
        gl.uniform2fv(uniformLocations.delta, delta);
      },

      /**
       * choose right value of image percentage to blur with
       * @returns {Array} a numeric array with delta values
       */
      chooseRightDelta: function() {
        var blurScale = 1, delta = [0, 0], blur;
        if (this.horizontal) {
          if (this.aspectRatio > 1) {
            // image is wide, i want to shrink radius horizontal
            blurScale = 1 / this.aspectRatio;
          }
        }
        else {
          if (this.aspectRatio < 1) {
            // image is tall, i want to shrink radius vertical
            blurScale = this.aspectRatio;
          }
        }
        blur = blurScale * this.blur * 0.12;
        if (this.horizontal) {
          delta[0] = blur;
        }
        else {
          delta[1] = blur;
        }
        return delta;
      },
    });

    /**
     * Deserialize a JSON definition of a BlurFilter into a concrete instance.
     */
    filters.Blur.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Gamma filter class
     * @class fabric.Image.filters.Gamma
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Gamma#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Gamma({
     *   brightness: 200
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.Gamma = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Gamma.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Gamma',

      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec3 uGamma;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'vec3 correction = (1.0 / uGamma);\n' +
          'color.r = pow(color.r, correction.r);\n' +
          'color.g = pow(color.g, correction.g);\n' +
          'color.b = pow(color.b, correction.b);\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.rgb *= color.a;\n' +
        '}',

      /**
       * Gamma array value, from 0.01 to 2.2.
       * @param {Array} gamma
       * @default
       */
      gamma: [1, 1, 1],

      /**
       * Describe the property that is the filter parameter
       * @param {String} m
       * @default
       */
      mainParameter: 'gamma',

      /**
       * Apply the Gamma operation to a Uint8Array representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8Array to be filtered.
       */
      applyTo2d: function(options) {
        var imageData = options.imageData, data = imageData.data,
            gamma = this.gamma, len = data.length,
            rInv = 1 / gamma[0], gInv = 1 / gamma[1],
            bInv = 1 / gamma[2], i;

        if (!this.rVals) {
          // eslint-disable-next-line
          this.rVals = new Uint8Array(256);
          // eslint-disable-next-line
          this.gVals = new Uint8Array(256);
          // eslint-disable-next-line
          this.bVals = new Uint8Array(256);
        }

        // This is an optimization - pre-compute a look-up table for each color channel
        // instead of performing these pow calls for each pixel in the image.
        for (i = 0, len = 256; i < len; i++) {
          this.rVals[i] = Math.pow(i / 255, rInv) * 255;
          this.gVals[i] = Math.pow(i / 255, gInv) * 255;
          this.bVals[i] = Math.pow(i / 255, bInv) * 255;
        }
        for (i = 0, len = data.length; i < len; i += 4) {
          data[i] = this.rVals[data[i]];
          data[i + 1] = this.gVals[data[i + 1]];
          data[i + 2] = this.bVals[data[i + 2]];
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uGamma: gl.getUniformLocation(program, 'uGamma'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform3fv(uniformLocations.uGamma, this.gamma);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Gamma} Instance of fabric.Image.filters.Gamma
     */
    fabric.Image.filters.Gamma.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * A container class that knows how to apply a sequence of filters to an input image.
     */
    filters.Composed = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Composed.prototype */ {

      type: 'Composed',

      /**
       * A non sparse array of filters to apply
       */
      subFilters: [],

      /**
       * Constructor
       * @param {Object} [options] Options object
       */
      initialize: function(options) {
        this.callSuper('initialize', options);
        // create a new array instead mutating the prototype with push
        this.subFilters = this.subFilters.slice(0);
      },

      /**
       * Apply this container's filters to the input image provided.
       *
       * @param {Object} options
       * @param {Number} options.passes The number of filters remaining to be applied.
       */
      applyTo: function(options) {
        options.passes += this.subFilters.length - 1;
        this.subFilters.forEach(function(filter) {
          filter.applyTo(options);
        });
      },

      /**
       * Serialize this filter into JSON.
       *
       * @returns {Object} A JSON representation of this filter.
       */
      toObject: function() {
        return fabric.util.object.extend(this.callSuper('toObject'), {
          subFilters: this.subFilters.map(function(filter) { return filter.toObject(); }),
        });
      },
    });

    /**
     * Deserialize a JSON definition of a ComposedFilter into a concrete instance.
     */
    fabric.Image.filters.Composed.fromObject = function(object, callback) {
      var filters = object.subFilters || [],
          subFilters = filters.map(function(filter) {
            return new fabric.Image.filters[filter.type](filter);
          }),
          instance = new fabric.Image.filters.Composed({ subFilters: subFilters });
      callback && callback(instance);
      return instance;
    };
  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * HueRotation filter class
     * @class fabric.Image.filters.HueRotation
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.HueRotation#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.HueRotation({
     *   rotation: -0.5
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.HueRotation = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.HueRotation.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'HueRotation',

      /**
       * HueRotation value, from -1 to 1.
       * the unit is radians
       * @param {Number} myParameter
       * @default
       */
      rotation: 0,

      /**
       * Describe the property that is the filter parameter
       * @param {String} m
       * @default
       */
      mainParameter: 'rotation',

      calculateMatrix: function() {
        var rad = this.rotation * Math.PI, cos = fabric.util.cos(rad), sin = fabric.util.sin(rad),
            aThird = 1 / 3, aThirdSqtSin = Math.sqrt(aThird) * sin, OneMinusCos = 1 - cos;
        this.matrix = [
          1, 0, 0, 0, 0,
          0, 1, 0, 0, 0,
          0, 0, 1, 0, 0,
          0, 0, 0, 1, 0
        ];
        this.matrix[0] = cos + OneMinusCos / 3;
        this.matrix[1] = aThird * OneMinusCos - aThirdSqtSin;
        this.matrix[2] = aThird * OneMinusCos + aThirdSqtSin;
        this.matrix[5] = aThird * OneMinusCos + aThirdSqtSin;
        this.matrix[6] = cos + aThird * OneMinusCos;
        this.matrix[7] = aThird * OneMinusCos - aThirdSqtSin;
        this.matrix[10] = aThird * OneMinusCos - aThirdSqtSin;
        this.matrix[11] = aThird * OneMinusCos + aThirdSqtSin;
        this.matrix[12] = cos + aThird * OneMinusCos;
      },

      /**
       * Apply this filter to the input image data provided.
       *
       * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
       *
       * @param {Object} options
       * @param {Number} options.passes The number of filters remaining to be executed
       * @param {Boolean} options.webgl Whether to use webgl to render the filter.
       * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
       * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      applyTo: function(options) {
        this.calculateMatrix();
        fabric.Image.filters.BaseFilter.prototype.applyTo.call(this, options);
      },

    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.HueRotation} Instance of fabric.Image.filters.HueRotation
     */
    fabric.Image.filters.HueRotation.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        clone = fabric.util.object.clone;

    if (fabric.Text) {
      fabric.warn('fabric.Text is already defined');
      return;
    }

    /**
     * Text class
     * @class fabric.Text
     * @extends fabric.Object
     * @return {fabric.Text} thisArg
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#text}
     * @see {@link fabric.Text#initialize} for constructor definition
     */
    fabric.Text = fabric.util.createClass(fabric.Object, /** @lends fabric.Text.prototype */ {

      /**
       * Properties which when set cause object to change dimensions
       * @type Array
       * @private
       */
      _dimensionAffectingProps: [
        'fontSize',
        'fontWeight',
        'fontFamily',
        'fontStyle',
        'lineHeight',
        'text',
        'charSpacing',
        'textAlign',
        'styles',
      ],

      /**
       * @private
       */
      _reNewline: /\r?\n/,

      /**
       * Use this regular expression to filter for whitespaces that is not a new line.
       * Mostly used when text is 'justify' aligned.
       * @private
       */
      _reSpacesAndTabs: /[ \t\r]/g,

      /**
       * Use this regular expression to filter for whitespace that is not a new line.
       * Mostly used when text is 'justify' aligned.
       * @private
       */
      _reSpaceAndTab: /[ \t\r]/,

      /**
       * Use this regular expression to filter consecutive groups of non spaces.
       * Mostly used when text is 'justify' aligned.
       * @private
       */
      _reWords: /\S+/g,

      /**
       * Type of an object
       * @type String
       * @default
       */
      type:                 'text',

      /**
       * Font size (in pixels)
       * @type Number
       * @default
       */
      fontSize:             40,

      /**
       * Font weight (e.g. bold, normal, 400, 600, 800)
       * @type {(Number|String)}
       * @default
       */
      fontWeight:           'normal',

      /**
       * Font family
       * @type String
       * @default
       */
      fontFamily:           'Times New Roman',

      /**
       * Text decoration underline.
       * @type String
       * @default
       */
      underline:       false,

      /**
       * Text decoration overline.
       * @type String
       * @default
       */
      overline:       false,

      /**
       * Text decoration linethrough.
       * @type String
       * @default
       */
      linethrough:       false,

      /**
       * Text alignment. Possible values: "left", "center", "right", "justify",
       * "justify-left", "justify-center" or "justify-right".
       * @type String
       * @default
       */
      textAlign:            'left',

      /**
       * Font style . Possible values: "", "normal", "italic" or "oblique".
       * @type String
       * @default
       */
      fontStyle:            'normal',

      /**
       * Line height
       * @type Number
       * @default
       */
      lineHeight:           1.16,

      /**
       * Superscript schema object (minimum overlap)
       * @type {Object}
       * @default
       */
      superscript: {
        size:      0.60, // fontSize factor
        baseline: -0.35  // baseline-shift factor (upwards)
      },

      /**
       * Subscript schema object (minimum overlap)
       * @type {Object}
       * @default
       */
      subscript: {
        size:      0.60, // fontSize factor
        baseline:  0.11  // baseline-shift factor (downwards)
      },

      /**
       * Background color of text lines
       * @type String
       * @default
       */
      textBackgroundColor:  '',

      /**
       * List of properties to consider when checking if
       * state of an object is changed ({@link fabric.Object#hasStateChanged})
       * as well as for history (undo/redo) purposes
       * @type Array
       */
      stateProperties: fabric.Object.prototype.stateProperties.concat('fontFamily',
        'fontWeight',
        'fontSize',
        'text',
        'underline',
        'overline',
        'linethrough',
        'textAlign',
        'fontStyle',
        'lineHeight',
        'textBackgroundColor',
        'charSpacing',
        'styles'),

      /**
       * List of properties to consider when checking if cache needs refresh
       * @type Array
       */
      cacheProperties: fabric.Object.prototype.cacheProperties.concat('fontFamily',
        'fontWeight',
        'fontSize',
        'text',
        'underline',
        'overline',
        'linethrough',
        'textAlign',
        'fontStyle',
        'lineHeight',
        'textBackgroundColor',
        'charSpacing',
        'styles'),

      /**
       * When defined, an object is rendered via stroke and this property specifies its color.
       * <b>Backwards incompatibility note:</b> This property was named "strokeStyle" until v1.1.6
       * @type String
       * @default
       */
      stroke:               null,

      /**
       * Shadow object representing shadow of this shape.
       * <b>Backwards incompatibility note:</b> This property was named "textShadow" (String) until v1.2.11
       * @type fabric.Shadow
       * @default
       */
      shadow:               null,

      /**
       * @private
       */
      _fontSizeFraction: 0.222,

      /**
       * @private
       */
      offsets: {
        underline: 0.10,
        linethrough: -0.315,
        overline: -0.88
      },

      /**
       * Text Line proportion to font Size (in pixels)
       * @type Number
       * @default
       */
      _fontSizeMult:             1.13,

      /**
       * additional space between characters
       * expressed in thousands of em unit
       * @type Number
       * @default
       */
      charSpacing:             0,

      /**
       * Object containing character styles - top-level properties -> line numbers,
       * 2nd-level properties - charater numbers
       * @type Object
       * @default
       */
      styles: null,

      /**
       * Reference to a context to measure text char or couple of chars
       * the cacheContext of the canvas will be used or a freshly created one if the object is not on canvas
       * once created it will be referenced on fabric._measuringContext to avoide creating a canvas for every
       * text object created.
       * @type {CanvasRenderingContext2D}
       * @default
       */
      _measuringContext: null,

      /**
       * Baseline shift, stlyes only, keep at 0 for the main text object
       * @type {Number}
       * @default
       */
      deltaY: 0,

      /**
       * Array of properties that define a style unit (of 'styles').
       * @type {Array}
       * @default
       */
      _styleProperties: [
        'stroke',
        'strokeWidth',
        'fill',
        'fontFamily',
        'fontSize',
        'fontWeight',
        'fontStyle',
        'underline',
        'overline',
        'linethrough',
        'deltaY',
        'textBackgroundColor',
      ],

      /**
       * contains characters bounding boxes
       */
      __charBounds: [],

      /**
       * use this size when measuring text. To avoid IE11 rounding errors
       * @type {Number}
       * @default
       * @readonly
       * @private
       */
      CACHE_FONT_SIZE: 400,

      /**
       * contains the min text width to avoid getting 0
       * @type {Number}
       * @default
       */
      MIN_TEXT_WIDTH: 2,

      /**
       * Constructor
       * @param {String} text Text string
       * @param {Object} [options] Options object
       * @return {fabric.Text} thisArg
       */
      initialize: function(text, options) {
        this.styles = options ? (options.styles || { }) : { };
        this.text = text;
        this.__skipDimension = true;
        this.callSuper('initialize', options);
        this.__skipDimension = false;
        this.initDimensions();
        this.setCoords();
        this.setupState({ propertySet: '_dimensionAffectingProps' });
      },

      /**
       * Return a contex for measurement of text string.
       * if created it gets stored for reuse
       * @param {String} text Text string
       * @param {Object} [options] Options object
       * @return {fabric.Text} thisArg
       */
      getMeasuringContext: function() {
        // if we did not return we have to measure something.
        if (!fabric._measuringContext) {
          fabric._measuringContext = this.canvas && this.canvas.contextCache ||
            fabric.util.createCanvasElement().getContext('2d');
        }
        return fabric._measuringContext;
      },

      /**
       * @private
       * Divides text into lines of text and lines of graphemes.
       */
      _splitText: function() {
        var newLines = this._splitTextIntoLines(this.text);
        this.textLines = newLines.lines;
        this._textLines = newLines.graphemeLines;
        this._unwrappedTextLines = newLines._unwrappedLines;
        this._text = newLines.graphemeText;
        return newLines;
      },

      /**
       * Initialize or update text dimensions.
       * Updates this.width and this.height with the proper values.
       * Does not return dimensions.
       */
      initDimensions: function() {
        if (this.__skipDimension) {
          return;
        }
        this._splitText();
        this._clearCache();
        this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH;
        if (this.textAlign.indexOf('justify') !== -1) {
          // once text is measured we need to make space fatter to make justified text.
          this.enlargeSpaces();
        }
        this.height = this.calcTextHeight();
        this.saveState({ propertySet: '_dimensionAffectingProps' });
      },

      /**
       * Enlarge space boxes and shift the others
       */
      enlargeSpaces: function() {
        var diffSpace, currentLineWidth, numberOfSpaces, accumulatedSpace, line, charBound, spaces;
        for (var i = 0, len = this._textLines.length; i < len; i++) {
          if (this.textAlign !== 'justify' && (i === len - 1 || this.isEndOfWrapping(i))) {
            continue;
          }
          accumulatedSpace = 0;
          line = this._textLines[i];
          currentLineWidth = this.getLineWidth(i);
          if (currentLineWidth < this.width && (spaces = this.textLines[i].match(this._reSpacesAndTabs))) {
            numberOfSpaces = spaces.length;
            diffSpace = (this.width - currentLineWidth) / numberOfSpaces;
            for (var j = 0, jlen = line.length; j <= jlen; j++) {
              charBound = this.__charBounds[i][j];
              if (this._reSpaceAndTab.test(line[j])) {
                charBound.width += diffSpace;
                charBound.kernedWidth += diffSpace;
                charBound.left += accumulatedSpace;
                accumulatedSpace += diffSpace;
              }
              else {
                charBound.left += accumulatedSpace;
              }
            }
          }
        }
      },

      /**
       * Detect if the text line is ended with an hard break
       * text and itext do not have wrapping, return false
       * @return {Boolean}
       */
      isEndOfWrapping: function(lineIndex) {
        return lineIndex === this._textLines.length - 1;
      },

      /**
       * Returns string representation of an instance
       * @return {String} String representation of text object
       */
      toString: function() {
        return '#<fabric.Text (' + this.complexity() +
          '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>';
      },

      /**
       * Return the dimension and the zoom level needed to create a cache canvas
       * big enough to host the object to be cached.
       * @private
       * @param {Object} dim.x width of object to be cached
       * @param {Object} dim.y height of object to be cached
       * @return {Object}.width width of canvas
       * @return {Object}.height height of canvas
       * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
       * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
       */
      _getCacheCanvasDimensions: function() {
        var dims = this.callSuper('_getCacheCanvasDimensions');
        var fontSize = this.fontSize;
        dims.width += fontSize * dims.zoomX;
        dims.height += fontSize * dims.zoomY;
        return dims;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {
        this._setTextStyles(ctx);
        this._renderTextLinesBackground(ctx);
        this._renderTextDecoration(ctx, 'underline');
        this._renderText(ctx);
        this._renderTextDecoration(ctx, 'overline');
        this._renderTextDecoration(ctx, 'linethrough');
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderText: function(ctx) {
        if (this.paintFirst === 'stroke') {
          this._renderTextStroke(ctx);
          this._renderTextFill(ctx);
        }
        else {
          this._renderTextFill(ctx);
          this._renderTextStroke(ctx);
        }
      },

      /**
       * Set the font parameter of the context with the object properties or with charStyle
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {Object} [charStyle] object with font style properties
       * @param {String} [charStyle.fontFamily] Font Family
       * @param {Number} [charStyle.fontSize] Font size in pixels. ( without px suffix )
       * @param {String} [charStyle.fontWeight] Font weight
       * @param {String} [charStyle.fontStyle] Font style (italic|normal)
       */
      _setTextStyles: function(ctx, charStyle, forMeasuring) {
        ctx.textBaseline = 'alphabetic';
        ctx.font = this._getFontDeclaration(charStyle, forMeasuring);
      },

      /**
       * calculate and return the text Width measuring each line.
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @return {Number} Maximum width of fabric.Text object
       */
      calcTextWidth: function() {
        var maxWidth = this.getLineWidth(0);

        for (var i = 1, len = this._textLines.length; i < len; i++) {
          var currentLineWidth = this.getLineWidth(i);
          if (currentLineWidth > maxWidth) {
            maxWidth = currentLineWidth;
          }
        }
        return maxWidth;
      },

      /**
       * @private
       * @param {String} method Method name ("fillText" or "strokeText")
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {String} line Text to render
       * @param {Number} left Left position of text
       * @param {Number} top Top position of text
       * @param {Number} lineIndex Index of a line in a text
       */
      _renderTextLine: function(method, ctx, line, left, top, lineIndex) {
        this._renderChars(method, ctx, line, left, top, lineIndex);
      },

      /**
       * Renders the text background for lines, taking care of style
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderTextLinesBackground: function(ctx) {
        if (!this.textBackgroundColor && !this.styleHas('textBackgroundColor')) {
          return;
        }
        var lineTopOffset = 0, heightOfLine,
            lineLeftOffset, originalFill = ctx.fillStyle,
            line, lastColor,
            leftOffset = this._getLeftOffset(),
            topOffset = this._getTopOffset(),
            boxStart = 0, boxWidth = 0, charBox, currentColor;

        for (var i = 0, len = this._textLines.length; i < len; i++) {
          heightOfLine = this.getHeightOfLine(i);
          if (!this.textBackgroundColor && !this.styleHas('textBackgroundColor', i)) {
            lineTopOffset += heightOfLine;
            continue;
          }
          line = this._textLines[i];
          lineLeftOffset = this._getLineLeftOffset(i);
          boxWidth = 0;
          boxStart = 0;
          lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');
          for (var j = 0, jlen = line.length; j < jlen; j++) {
            charBox = this.__charBounds[i][j];
            currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');
            if (currentColor !== lastColor) {
              ctx.fillStyle = lastColor;
              lastColor && ctx.fillRect(
                leftOffset + lineLeftOffset + boxStart,
                topOffset + lineTopOffset,
                boxWidth,
                heightOfLine / this.lineHeight
              );
              boxStart = charBox.left;
              boxWidth = charBox.width;
              lastColor = currentColor;
            }
            else {
              boxWidth += charBox.kernedWidth;
            }
          }
          if (currentColor) {
            ctx.fillStyle = currentColor;
            ctx.fillRect(
              leftOffset + lineLeftOffset + boxStart,
              topOffset + lineTopOffset,
              boxWidth,
              heightOfLine / this.lineHeight
            );
          }
          lineTopOffset += heightOfLine;
        }
        ctx.fillStyle = originalFill;
        // if there is text background color no
        // other shadows should be casted
        this._removeShadow(ctx);
      },

      /**
       * @private
       * @param {Object} decl style declaration for cache
       * @param {String} decl.fontFamily fontFamily
       * @param {String} decl.fontStyle fontStyle
       * @param {String} decl.fontWeight fontWeight
       * @return {Object} reference to cache
       */
      getFontCache: function(decl) {
        var fontFamily = decl.fontFamily.toLowerCase();
        if (!fabric.charWidthsCache[fontFamily]) {
          fabric.charWidthsCache[fontFamily] = { };
        }
        var cache = fabric.charWidthsCache[fontFamily],
            cacheProp = decl.fontStyle.toLowerCase() + '_' + (decl.fontWeight + '').toLowerCase();
        if (!cache[cacheProp]) {
          cache[cacheProp] = { };
        }
        return cache[cacheProp];
      },

      /**
       * apply all the character style to canvas for rendering
       * @private
       * @param {String} _char
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @param {Object} [decl]
       */
      _applyCharStyles: function(method, ctx, lineIndex, charIndex, styleDeclaration) {

        this._setFillStyles(ctx, styleDeclaration);
        this._setStrokeStyles(ctx, styleDeclaration);

        ctx.font = this._getFontDeclaration(styleDeclaration);
      },

      /**
       * measure and return the width of a single character.
       * possibly overridden to accommodate different measure logic or
       * to hook some external lib for character measurement
       * @private
       * @param {String} char to be measured
       * @param {Object} charStyle style of char to be measured
       * @param {String} [previousChar] previous char
       * @param {Object} [prevCharStyle] style of previous char
       */
      _measureChar: function(_char, charStyle, previousChar, prevCharStyle) {
        // first i try to return from cache
        var fontCache = this.getFontCache(charStyle), fontDeclaration = this._getFontDeclaration(charStyle),
            previousFontDeclaration = this._getFontDeclaration(prevCharStyle), couple = previousChar + _char,
            stylesAreEqual = fontDeclaration === previousFontDeclaration, width, coupleWidth, previousWidth,
            fontMultiplier = charStyle.fontSize / this.CACHE_FONT_SIZE, kernedWidth;

        if (previousChar && fontCache[previousChar] !== undefined) {
          previousWidth = fontCache[previousChar];
        }
        if (fontCache[_char] !== undefined) {
          kernedWidth = width = fontCache[_char];
        }
        if (stylesAreEqual && fontCache[couple] !== undefined) {
          coupleWidth = fontCache[couple];
          kernedWidth = coupleWidth - previousWidth;
        }
        if (width === undefined || previousWidth === undefined || coupleWidth === undefined) {
          var ctx = this.getMeasuringContext();
          // send a TRUE to specify measuring font size CACHE_FONT_SIZE
          this._setTextStyles(ctx, charStyle, true);
        }
        if (width === undefined) {
          kernedWidth = width = ctx.measureText(_char).width;
          fontCache[_char] = width;
        }
        if (previousWidth === undefined && stylesAreEqual && previousChar) {
          previousWidth = ctx.measureText(previousChar).width;
          fontCache[previousChar] = previousWidth;
        }
        if (stylesAreEqual && coupleWidth === undefined) {
          // we can measure the kerning couple and subtract the width of the previous character
          coupleWidth = ctx.measureText(couple).width;
          fontCache[couple] = coupleWidth;
          kernedWidth = coupleWidth - previousWidth;
        }
        return { width: width * fontMultiplier, kernedWidth: kernedWidth * fontMultiplier };
      },

      /**
       * Computes height of character at given position
       * @param {Number} line the line number
       * @param {Number} char the character number
       * @return {Number} fontSize of the character
       */
      getHeightOfChar: function(line, char) {
        return this.getValueOfPropertyAt(line, char, 'fontSize');
      },

      /**
       * measure a text line measuring all characters.
       * @param {Number} lineIndex line number
       * @return {Number} Line width
       */
      measureLine: function(lineIndex) {
        var lineInfo = this._measureLine(lineIndex);
        if (this.charSpacing !== 0) {
          lineInfo.width -= this._getWidthOfCharSpacing();
        }
        if (lineInfo.width < 0) {
          lineInfo.width = 0;
        }
        return lineInfo;
      },

      /**
       * measure every grapheme of a line, populating __charBounds
       * @param {Number} lineIndex
       * @return {Object} object.width total width of characters
       * @return {Object} object.widthOfSpaces length of chars that match this._reSpacesAndTabs
       */
      _measureLine: function(lineIndex) {
        var width = 0, i, grapheme, line = this._textLines[lineIndex], prevGrapheme,
            graphemeInfo, numOfSpaces = 0, lineBounds = new Array(line.length);

        this.__charBounds[lineIndex] = lineBounds;
        for (i = 0; i < line.length; i++) {
          grapheme = line[i];
          graphemeInfo = this._getGraphemeBox(grapheme, lineIndex, i, prevGrapheme);
          lineBounds[i] = graphemeInfo;
          width += graphemeInfo.kernedWidth;
          prevGrapheme = grapheme;
        }
        // this latest bound box represent the last character of the line
        // to simplify cursor handling in interactive mode.
        lineBounds[i] = {
          left: graphemeInfo ? graphemeInfo.left + graphemeInfo.width : 0,
          width: 0,
          kernedWidth: 0,
          height: this.fontSize
        };
        return { width: width, numOfSpaces: numOfSpaces };
      },

      /**
       * Measure and return the info of a single grapheme.
       * needs the the info of previous graphemes already filled
       * @private
       * @param {String} grapheme to be measured
       * @param {Number} lineIndex index of the line where the char is
       * @param {Number} charIndex position in the line
       * @param {String} [prevGrapheme] character preceding the one to be measured
       */
      _getGraphemeBox: function(grapheme, lineIndex, charIndex, prevGrapheme, skipLeft) {
        var style = this.getCompleteStyleDeclaration(lineIndex, charIndex),
            prevStyle = prevGrapheme ? this.getCompleteStyleDeclaration(lineIndex, charIndex - 1) : { },
            info = this._measureChar(grapheme, style, prevGrapheme, prevStyle),
            kernedWidth = info.kernedWidth,
            width = info.width, charSpacing;

        if (this.charSpacing !== 0) {
          charSpacing = this._getWidthOfCharSpacing();
          width += charSpacing;
          kernedWidth += charSpacing;
        }

        var box = {
          width: width,
          left: 0,
          height: style.fontSize,
          kernedWidth: kernedWidth,
          deltaY: style.deltaY,
        };
        if (charIndex > 0 && !skipLeft) {
          var previousBox = this.__charBounds[lineIndex][charIndex - 1];
          box.left = previousBox.left + previousBox.width + info.kernedWidth - info.width;
        }
        return box;
      },

      /**
       * Calculate height of line at 'lineIndex'
       * @param {Number} lineIndex index of line to calculate
       * @return {Number}
       */
      getHeightOfLine: function(lineIndex) {
        if (this.__lineHeights[lineIndex]) {
          return this.__lineHeights[lineIndex];
        }

        var line = this._textLines[lineIndex],
            // char 0 is measured before the line cycle because it nneds to char
            // emptylines
            maxHeight = this.getHeightOfChar(lineIndex, 0);
        for (var i = 1, len = line.length; i < len; i++) {
          maxHeight = Math.max(this.getHeightOfChar(lineIndex, i), maxHeight);
        }

        return this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;
      },

      /**
       * Calculate text box height
       */
      calcTextHeight: function() {
        var lineHeight, height = 0;
        for (var i = 0, len = this._textLines.length; i < len; i++) {
          lineHeight = this.getHeightOfLine(i);
          height += (i === len - 1 ? lineHeight / this.lineHeight : lineHeight);
        }
        return height;
      },

      /**
       * @private
       * @return {Number} Left offset
       */
      _getLeftOffset: function() {
        return -this.width / 2;
      },

      /**
       * @private
       * @return {Number} Top offset
       */
      _getTopOffset: function() {
        return -this.height / 2;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {String} method Method name ("fillText" or "strokeText")
       */
      _renderTextCommon: function(ctx, method) {
        ctx.save();
        var lineHeights = 0, left = this._getLeftOffset(), top = this._getTopOffset(),
            offsets = this._applyPatternGradientTransform(ctx, method === 'fillText' ? this.fill : this.stroke);
        for (var i = 0, len = this._textLines.length; i < len; i++) {
          var heightOfLine = this.getHeightOfLine(i),
              maxHeight = heightOfLine / this.lineHeight,
              leftOffset = this._getLineLeftOffset(i);
          this._renderTextLine(
            method,
            ctx,
            this._textLines[i],
            left + leftOffset - offsets.offsetX,
            top + lineHeights + maxHeight - offsets.offsetY,
            i
          );
          lineHeights += heightOfLine;
        }
        ctx.restore();
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderTextFill: function(ctx) {
        if (!this.fill && !this.styleHas('fill')) {
          return;
        }

        this._renderTextCommon(ctx, 'fillText');
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderTextStroke: function(ctx) {
        if ((!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles()) {
          return;
        }

        if (this.shadow && !this.shadow.affectStroke) {
          this._removeShadow(ctx);
        }

        ctx.save();
        this._setLineDash(ctx, this.strokeDashArray);
        ctx.beginPath();
        this._renderTextCommon(ctx, 'strokeText');
        ctx.closePath();
        ctx.restore();
      },

      /**
       * @private
       * @param {String} method
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {String} line Content of the line
       * @param {Number} left
       * @param {Number} top
       * @param {Number} lineIndex
       * @param {Number} charOffset
       */
      _renderChars: function(method, ctx, line, left, top, lineIndex) {
        // set proper line offset
        var lineHeight = this.getHeightOfLine(lineIndex),
            isJustify = this.textAlign.indexOf('justify') !== -1,
            actualStyle,
            nextStyle,
            charsToRender = '',
            charBox,
            boxWidth = 0,
            timeToRender,
            shortCut = !isJustify && this.charSpacing === 0 && this.isEmptyStyles(lineIndex);

        ctx.save();
        top -= lineHeight * this._fontSizeFraction / this.lineHeight;
        if (shortCut) {
          // render all the line in one pass without checking
          this._renderChar(method, ctx, lineIndex, 0, this.textLines[lineIndex], left, top, lineHeight);
          ctx.restore();
          return;
        }
        for (var i = 0, len = line.length - 1; i <= len; i++) {
          timeToRender = i === len || this.charSpacing;
          charsToRender += line[i];
          charBox = this.__charBounds[lineIndex][i];
          if (boxWidth === 0) {
            left += charBox.kernedWidth - charBox.width;
            boxWidth += charBox.width;
          }
          else {
            boxWidth += charBox.kernedWidth;
          }
          if (isJustify && !timeToRender) {
            if (this._reSpaceAndTab.test(line[i])) {
              timeToRender = true;
            }
          }
          if (!timeToRender) {
            // if we have charSpacing, we render char by char
            actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);
            nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);
            timeToRender = this._hasStyleChanged(actualStyle, nextStyle);
          }
          if (timeToRender) {
            this._renderChar(method, ctx, lineIndex, i, charsToRender, left, top, lineHeight);
            charsToRender = '';
            actualStyle = nextStyle;
            left += boxWidth;
            boxWidth = 0;
          }
        }
        ctx.restore();
      },

      /**
       * @private
       * @param {String} method
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @param {String} _char
       * @param {Number} left Left coordinate
       * @param {Number} top Top coordinate
       * @param {Number} lineHeight Height of the line
       */
      _renderChar: function(method, ctx, lineIndex, charIndex, _char, left, top) {
        var decl = this._getStyleDeclaration(lineIndex, charIndex),
            fullDecl = this.getCompleteStyleDeclaration(lineIndex, charIndex),
            shouldFill = method === 'fillText' && fullDecl.fill,
            shouldStroke = method === 'strokeText' && fullDecl.stroke && fullDecl.strokeWidth;

        if (!shouldStroke && !shouldFill) {
          return;
        }
        decl && ctx.save();

        this._applyCharStyles(method, ctx, lineIndex, charIndex, fullDecl);

        if (decl && decl.textBackgroundColor) {
          this._removeShadow(ctx);
        }
        if (decl && decl.deltaY) {
          top += decl.deltaY;
        }

        shouldFill && ctx.fillText(_char, left, top);
        shouldStroke && ctx.strokeText(_char, left, top);
        decl && ctx.restore();
      },

      /**
       * Turns the character into a 'superior figure' (i.e. 'superscript')
       * @param {Number} start selection start
       * @param {Number} end selection end
       * @returns {fabric.Text} thisArg
       * @chainable
       */
      setSuperscript: function(start, end) {
        return this._setScript(start, end, this.superscript);
      },

      /**
       * Turns the character into an 'inferior figure' (i.e. 'subscript')
       * @param {Number} start selection start
       * @param {Number} end selection end
       * @returns {fabric.Text} thisArg
       * @chainable
       */
      setSubscript: function(start, end) {
        return this._setScript(start, end, this.subscript);
      },

      /**
       * Applies 'schema' at given position
       * @private
       * @param {Number} start selection start
       * @param {Number} end selection end
       * @param {Number} schema
       * @returns {fabric.Text} thisArg
       * @chainable
       */
      _setScript: function(start, end, schema) {
        var loc = this.get2DCursorLocation(start, true),
            fontSize = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, 'fontSize'),
            dy = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, 'deltaY'),
            style = { fontSize: fontSize * schema.size, deltaY: dy + fontSize * schema.baseline };
        this.setSelectionStyles(style, start, end);
        return this;
      },

      /**
       * @private
       * @param {Object} prevStyle
       * @param {Object} thisStyle
       */
      _hasStyleChanged: function(prevStyle, thisStyle) {
        return prevStyle.fill !== thisStyle.fill ||
                prevStyle.stroke !== thisStyle.stroke ||
                prevStyle.strokeWidth !== thisStyle.strokeWidth ||
                prevStyle.fontSize !== thisStyle.fontSize ||
                prevStyle.fontFamily !== thisStyle.fontFamily ||
                prevStyle.fontWeight !== thisStyle.fontWeight ||
                prevStyle.fontStyle !== thisStyle.fontStyle ||
                prevStyle.deltaY !== thisStyle.deltaY;
      },

      /**
       * @private
       * @param {Object} prevStyle
       * @param {Object} thisStyle
       */
      _hasStyleChangedForSvg: function(prevStyle, thisStyle) {
        return this._hasStyleChanged(prevStyle, thisStyle) ||
          prevStyle.overline !== thisStyle.overline ||
          prevStyle.underline !== thisStyle.underline ||
          prevStyle.linethrough !== thisStyle.linethrough;
      },

      /**
       * @private
       * @param {Number} lineIndex index text line
       * @return {Number} Line left offset
       */
      _getLineLeftOffset: function(lineIndex) {
        var lineWidth = this.getLineWidth(lineIndex);
        if (this.textAlign === 'center') {
          return (this.width - lineWidth) / 2;
        }
        if (this.textAlign === 'right') {
          return this.width - lineWidth;
        }
        if (this.textAlign === 'justify-center' && this.isEndOfWrapping(lineIndex)) {
          return (this.width - lineWidth) / 2;
        }
        if (this.textAlign === 'justify-right' && this.isEndOfWrapping(lineIndex)) {
          return this.width - lineWidth;
        }
        return 0;
      },

      /**
       * @private
       */
      _clearCache: function() {
        this.__lineWidths = [];
        this.__lineHeights = [];
        this.__charBounds = [];
      },

      /**
       * @private
       */
      _shouldClearDimensionCache: function() {
        var shouldClear = this._forceClearCache;
        shouldClear || (shouldClear = this.hasStateChanged('_dimensionAffectingProps'));
        if (shouldClear) {
          this.dirty = true;
          this._forceClearCache = false;
        }
        return shouldClear;
      },

      /**
       * Measure a single line given its index. Used to calculate the initial
       * text bounding box. The values are calculated and stored in __lineWidths cache.
       * @private
       * @param {Number} lineIndex line number
       * @return {Number} Line width
       */
      getLineWidth: function(lineIndex) {
        if (this.__lineWidths[lineIndex]) {
          return this.__lineWidths[lineIndex];
        }

        var width, line = this._textLines[lineIndex], lineInfo;

        if (line === '') {
          width = 0;
        }
        else {
          lineInfo = this.measureLine(lineIndex);
          width = lineInfo.width;
        }
        this.__lineWidths[lineIndex] = width;
        return width;
      },

      _getWidthOfCharSpacing: function() {
        if (this.charSpacing !== 0) {
          return this.fontSize * this.charSpacing / 1000;
        }
        return 0;
      },

      /**
       * Retrieves the value of property at given character position
       * @param {Number} lineIndex the line number
       * @param {Number} charIndex the charater number
       * @param {String} property the property name
       * @returns the value of 'property'
       */
      getValueOfPropertyAt: function(lineIndex, charIndex, property) {
        var charStyle = this._getStyleDeclaration(lineIndex, charIndex);
        if (charStyle && typeof charStyle[property] !== 'undefined') {
          return charStyle[property];
        }
        return this[property];
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderTextDecoration: function(ctx, type) {
        if (!this[type] && !this.styleHas(type)) {
          return;
        }
        var heightOfLine, size, _size,
            lineLeftOffset, dy, _dy,
            line, lastDecoration,
            leftOffset = this._getLeftOffset(),
            topOffset = this._getTopOffset(), top,
            boxStart, boxWidth, charBox, currentDecoration,
            maxHeight, currentFill, lastFill,
            charSpacing = this._getWidthOfCharSpacing();

        for (var i = 0, len = this._textLines.length; i < len; i++) {
          heightOfLine = this.getHeightOfLine(i);
          if (!this[type] && !this.styleHas(type, i)) {
            topOffset += heightOfLine;
            continue;
          }
          line = this._textLines[i];
          maxHeight = heightOfLine / this.lineHeight;
          lineLeftOffset = this._getLineLeftOffset(i);
          boxStart = 0;
          boxWidth = 0;
          lastDecoration = this.getValueOfPropertyAt(i, 0, type);
          lastFill = this.getValueOfPropertyAt(i, 0, 'fill');
          top = topOffset + maxHeight * (1 - this._fontSizeFraction);
          size = this.getHeightOfChar(i, 0);
          dy = this.getValueOfPropertyAt(i, 0, 'deltaY');
          for (var j = 0, jlen = line.length; j < jlen; j++) {
            charBox = this.__charBounds[i][j];
            currentDecoration = this.getValueOfPropertyAt(i, j, type);
            currentFill = this.getValueOfPropertyAt(i, j, 'fill');
            _size = this.getHeightOfChar(i, j);
            _dy = this.getValueOfPropertyAt(i, j, 'deltaY');
            if ((currentDecoration !== lastDecoration || currentFill !== lastFill || _size !== size || _dy !== dy) &&
                boxWidth > 0) {
              ctx.fillStyle = lastFill;
              lastDecoration && lastFill && ctx.fillRect(
                leftOffset + lineLeftOffset + boxStart,
                top + this.offsets[type] * size + dy,
                boxWidth,
                this.fontSize / 15
              );
              boxStart = charBox.left;
              boxWidth = charBox.width;
              lastDecoration = currentDecoration;
              lastFill = currentFill;
              size = _size;
              dy = _dy;
            }
            else {
              boxWidth += charBox.kernedWidth;
            }
          }
          ctx.fillStyle = currentFill;
          currentDecoration && currentFill && ctx.fillRect(
            leftOffset + lineLeftOffset + boxStart,
            top + this.offsets[type] * size + dy,
            boxWidth - charSpacing,
            this.fontSize / 15
          );
          topOffset += heightOfLine;
        }
        // if there is text background color no
        // other shadows should be casted
        this._removeShadow(ctx);
      },

      /**
       * return font declaration string for canvas context
       * @param {Object} [styleObject] object
       * @returns {String} font declaration formatted for canvas context.
       */
      _getFontDeclaration: function(styleObject, forMeasuring) {
        var style = styleObject || this, family = this.fontFamily,
            fontIsGeneric = fabric.Text.genericFonts.indexOf(family.toLowerCase()) > -1;
        var fontFamily = family === undefined ||
        family.indexOf('\'') > -1 ||
        family.indexOf('"') > -1 || fontIsGeneric
          ? style.fontFamily : '"' + style.fontFamily + '"';
        return [
          // node-canvas needs "weight style", while browsers need "style weight"
          (fabric.isLikelyNode ? style.fontWeight : style.fontStyle),
          (fabric.isLikelyNode ? style.fontStyle : style.fontWeight),
          forMeasuring ? this.CACHE_FONT_SIZE + 'px' : style.fontSize + 'px',
          fontFamily
        ].join(' ');
      },

      /**
       * Renders text instance on a specified context
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      render: function(ctx) {
        // do not render if object is not visible
        if (!this.visible) {
          return;
        }
        if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
          return;
        }
        if (this._shouldClearDimensionCache()) {
          this.initDimensions();
        }
        this.callSuper('render', ctx);
      },

      /**
       * Returns the text as an array of lines.
       * @param {String} text text to split
       * @returns {Array} Lines in the text
       */
      _splitTextIntoLines: function(text) {
        var lines = text.split(this._reNewline),
            newLines = new Array(lines.length),
            newLine = ['\n'],
            newText = [];
        for (var i = 0; i < lines.length; i++) {
          newLines[i] = fabric.util.string.graphemeSplit(lines[i]);
          newText = newText.concat(newLines[i], newLine);
        }
        newText.pop();
        return { _unwrappedLines: newLines, lines: lines, graphemeText: newText, graphemeLines: newLines };
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} Object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        var additionalProperties = [
          'text',
          'fontSize',
          'fontWeight',
          'fontFamily',
          'fontStyle',
          'lineHeight',
          'underline',
          'overline',
          'linethrough',
          'textAlign',
          'textBackgroundColor',
          'charSpacing',
        ].concat(propertiesToInclude);
        var obj = this.callSuper('toObject', additionalProperties);
        obj.styles = clone(this.styles, true);
        return obj;
      },

      /**
       * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
       * @param {String|Object} key Property name or object (if object, iterate over the object properties)
       * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
       * @return {fabric.Object} thisArg
       * @chainable
       */
      set: function(key, value) {
        this.callSuper('set', key, value);
        var needsDims = false;
        if (typeof key === 'object') {
          for (var _key in key) {
            needsDims = needsDims || this._dimensionAffectingProps.indexOf(_key) !== -1;
          }
        }
        else {
          needsDims = this._dimensionAffectingProps.indexOf(key) !== -1;
        }
        if (needsDims) {
          this.initDimensions();
          this.setCoords();
        }
        return this;
      },

      /**
       * Returns complexity of an instance
       * @return {Number} complexity
       */
      complexity: function() {
        return 1;
      }
    });

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by {@link fabric.Text.fromElement})
     * @static
     * @memberOf fabric.Text
     * @see: http://www.w3.org/TR/SVG/text.html#TextElement
     */
    fabric.Text.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(
      'x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor'.split(' '));

    /**
     * Default SVG font size
     * @static
     * @memberOf fabric.Text
     */
    fabric.Text.DEFAULT_SVG_FONT_SIZE = 16;

    /**
     * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)
     * @static
     * @memberOf fabric.Text
     * @param {SVGElement} element Element to parse
     * @param {Function} callback callback function invoked after parsing
     * @param {Object} [options] Options object
     */
    fabric.Text.fromElement = function(element, callback, options) {
      if (!element) {
        return callback(null);
      }

      var parsedAttributes = fabric.parseAttributes(element, fabric.Text.ATTRIBUTE_NAMES),
          parsedAnchor = parsedAttributes.textAnchor || 'left';
      options = fabric.util.object.extend((options ? clone(options) : { }), parsedAttributes);

      options.top = options.top || 0;
      options.left = options.left || 0;
      if (parsedAttributes.textDecoration) {
        var textDecoration = parsedAttributes.textDecoration;
        if (textDecoration.indexOf('underline') !== -1) {
          options.underline = true;
        }
        if (textDecoration.indexOf('overline') !== -1) {
          options.overline = true;
        }
        if (textDecoration.indexOf('line-through') !== -1) {
          options.linethrough = true;
        }
        delete options.textDecoration;
      }
      if ('dx' in parsedAttributes) {
        options.left += parsedAttributes.dx;
      }
      if ('dy' in parsedAttributes) {
        options.top += parsedAttributes.dy;
      }
      if (!('fontSize' in options)) {
        options.fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
      }

      var textContent = '';

      // The XML is not properly parsed in IE9 so a workaround to get
      // textContent is through firstChild.data. Another workaround would be
      // to convert XML loaded from a file to be converted using DOMParser (same way loadSVGFromString() does)
      if (!('textContent' in element)) {
        if ('firstChild' in element && element.firstChild !== null) {
          if ('data' in element.firstChild && element.firstChild.data !== null) {
            textContent = element.firstChild.data;
          }
        }
      }
      else {
        textContent = element.textContent;
      }

      textContent = textContent.replace(/^\s+|\s+$|\n+/g, '').replace(/\s+/g, ' ');
      var originalStrokeWidth = options.strokeWidth;
      options.strokeWidth = 0;

      var text = new fabric.Text(textContent, options),
          textHeightScaleFactor = text.getScaledHeight() / text.height,
          lineHeightDiff = (text.height + text.strokeWidth) * text.lineHeight - text.height,
          scaledDiff = lineHeightDiff * textHeightScaleFactor,
          textHeight = text.getScaledHeight() + scaledDiff,
          offX = 0;
      /*
        Adjust positioning:
          x/y attributes in SVG correspond to the bottom-left corner of text bounding box
          fabric output by default at top, left.
      */
      if (parsedAnchor === 'center') {
        offX = text.getScaledWidth() / 2;
      }
      if (parsedAnchor === 'right') {
        offX = text.getScaledWidth();
      }
      text.set({
        left: text.left - offX,
        top: text.top - (textHeight - text.fontSize * (0.07 + text._fontSizeFraction)) / text.lineHeight,
        strokeWidth: typeof originalStrokeWidth !== 'undefined' ? originalStrokeWidth : 1,
      });
      callback(text);
    };
    /* _FROM_SVG_END_ */

    /**
     * Returns fabric.Text instance from an object representation
     * @static
     * @memberOf fabric.Text
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] Callback to invoke when an fabric.Text instance is created
     */
    fabric.Text.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Text', object, callback, 'text');
    };

    fabric.Text.genericFonts = ['sans-serif', 'serif', 'cursive', 'fantasy', 'monospace'];

    fabric.util.createAccessors && fabric.util.createAccessors(fabric.Text);

  })(exports);


  (function() {
    fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {
      /**
       * Returns true if object has no styling or no styling in a line
       * @param {Number} lineIndex , lineIndex is on wrapped lines.
       * @return {Boolean}
       */
      isEmptyStyles: function(lineIndex) {
        if (!this.styles) {
          return true;
        }
        if (typeof lineIndex !== 'undefined' && !this.styles[lineIndex]) {
          return true;
        }
        var obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };
        for (var p1 in obj) {
          for (var p2 in obj[p1]) {
            // eslint-disable-next-line no-unused-vars
            for (var p3 in obj[p1][p2]) {
              return false;
            }
          }
        }
        return true;
      },

      /**
       * Returns true if object has a style property or has it ina specified line
       * @param {Number} lineIndex
       * @return {Boolean}
       */
      styleHas: function(property, lineIndex) {
        if (!this.styles || !property || property === '') {
          return false;
        }
        if (typeof lineIndex !== 'undefined' && !this.styles[lineIndex]) {
          return false;
        }
        var obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };
        // eslint-disable-next-line
        for (var p1 in obj) {
          // eslint-disable-next-line
          for (var p2 in obj[p1]) {
            if (typeof obj[p1][p2][property] !== 'undefined') {
              return true;
            }
          }
        }
        return false;
      },

      /**
       * Check if characters in a text have a value for a property
       * whose value matches the textbox's value for that property.  If so,
       * the character-level property is deleted.  If the character
       * has no other properties, then it is also deleted.  Finally,
       * if the line containing that character has no other characters
       * then it also is deleted.
       *
       * @param {string} property The property to compare between characters and text.
       */
      cleanStyle: function(property) {
        if (!this.styles || !property || property === '') {
          return false;
        }
        var obj = this.styles, stylesCount = 0, letterCount, stylePropertyValue,
            allStyleObjectPropertiesMatch = true, graphemeCount = 0, styleObject;
        // eslint-disable-next-line
        for (var p1 in obj) {
          letterCount = 0;
          // eslint-disable-next-line
          for (var p2 in obj[p1]) {
            var styleObject = obj[p1][p2],
                stylePropertyHasBeenSet = styleObject.hasOwnProperty(property);

            stylesCount++;

            if (stylePropertyHasBeenSet) {
              if (!stylePropertyValue) {
                stylePropertyValue = styleObject[property];
              }
              else if (styleObject[property] !== stylePropertyValue) {
                allStyleObjectPropertiesMatch = false;
              }

              if (styleObject[property] === this[property]) {
                delete styleObject[property];
              }
            }
            else {
              allStyleObjectPropertiesMatch = false;
            }

            if (Object.keys(styleObject).length !== 0) {
              letterCount++;
            }
            else {
              delete obj[p1][p2];
            }
          }

          if (letterCount === 0) {
            delete obj[p1];
          }
        }
        // if every grapheme has the same style set then
        // delete those styles and set it on the parent
        for (var i = 0; i < this._textLines.length; i++) {
          graphemeCount += this._textLines[i].length;
        }
        if (allStyleObjectPropertiesMatch && stylesCount === graphemeCount) {
          this[property] = stylePropertyValue;
          this.removeStyle(property);
        }
      },

      /**
       * Remove a style property or properties from all individual character styles
       * in a text object.  Deletes the character style object if it contains no other style
       * props.  Deletes a line style object if it contains no other character styles.
       *
       * @param {String} props The property to remove from character styles.
       */
      removeStyle: function(property) {
        if (!this.styles || !property || property === '') {
          return;
        }
        var obj = this.styles, line, lineNum, charNum;
        for (lineNum in obj) {
          line = obj[lineNum];
          for (charNum in line) {
            delete line[charNum][property];
            if (Object.keys(line[charNum]).length === 0) {
              delete line[charNum];
            }
          }
          if (Object.keys(line).length === 0) {
            delete obj[lineNum];
          }
        }
      },

      /**
       * @private
       */
      _extendStyles: function(index, styles) {
        var loc = this.get2DCursorLocation(index);

        if (!this._getLineStyle(loc.lineIndex)) {
          this._setLineStyle(loc.lineIndex, {});
        }

        if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {
          this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});
        }

        fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);
      },

      /**
       * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)
       * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.
       * @param {Boolean} [skipWrapping] consider the location for unwrapped lines. usefull to manage styles.
       */
      get2DCursorLocation: function(selectionStart, skipWrapping) {
        if (typeof selectionStart === 'undefined') {
          selectionStart = this.selectionStart;
        }
        var lines = skipWrapping ? this._unwrappedTextLines : this._textLines;
        var len = lines.length;
        for (var i = 0; i < len; i++) {
          if (selectionStart <= lines[i].length) {
            return {
              lineIndex: i,
              charIndex: selectionStart
            };
          }
          selectionStart -= lines[i].length + 1;
        }
        return {
          lineIndex: i - 1,
          charIndex: lines[i - 1].length < selectionStart ? lines[i - 1].length : selectionStart
        };
      },

      /**
       * Gets style of a current selection/cursor (at the start position)
       * if startIndex or endIndex are not provided, slectionStart or selectionEnd will be used.
       * @param {Number} [startIndex] Start index to get styles at
       * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1
       * @param {Boolean} [complete] get full style or not
       * @return {Array} styles an array with one, zero or more Style objects
       */
      getSelectionStyles: function(startIndex, endIndex, complete) {
        if (typeof startIndex === 'undefined') {
          startIndex = this.selectionStart || 0;
        }
        if (typeof endIndex === 'undefined') {
          endIndex = this.selectionEnd || startIndex;
        }
        var styles = [];
        for (var i = startIndex; i < endIndex; i++) {
          styles.push(this.getStyleAtPosition(i, complete));
        }
        return styles;
      },

      /**
       * Gets style of a current selection/cursor position
       * @param {Number} position  to get styles at
       * @param {Boolean} [complete] full style if true
       * @return {Object} style Style object at a specified index
       * @private
       */
      getStyleAtPosition: function(position, complete) {
        var loc = this.get2DCursorLocation(position),
            style = complete ? this.getCompleteStyleDeclaration(loc.lineIndex, loc.charIndex) :
              this._getStyleDeclaration(loc.lineIndex, loc.charIndex);
        return style || {};
      },

      /**
       * Sets style of a current selection, if no selection exist, do not set anything.
       * @param {Object} [styles] Styles object
       * @param {Number} [startIndex] Start index to get styles at
       * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1
       * @return {fabric.IText} thisArg
       * @chainable
       */
      setSelectionStyles: function(styles, startIndex, endIndex) {
        if (typeof startIndex === 'undefined') {
          startIndex = this.selectionStart || 0;
        }
        if (typeof endIndex === 'undefined') {
          endIndex = this.selectionEnd || startIndex;
        }
        for (var i = startIndex; i < endIndex; i++) {
          this._extendStyles(i, styles);
        }
        /* not included in _extendStyles to avoid clearing cache more than once */
        this._forceClearCache = true;
        return this;
      },

      /**
       * get the reference, not a clone, of the style object for a given character
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @return {Object} style object
       */
      _getStyleDeclaration: function(lineIndex, charIndex) {
        var lineStyle = this.styles && this.styles[lineIndex];
        if (!lineStyle) {
          return null;
        }
        return lineStyle[charIndex];
      },

      /**
       * return a new object that contains all the style property for a character
       * the object returned is newly created
       * @param {Number} lineIndex of the line where the character is
       * @param {Number} charIndex position of the character on the line
       * @return {Object} style object
       */
      getCompleteStyleDeclaration: function(lineIndex, charIndex) {
        var style = this._getStyleDeclaration(lineIndex, charIndex) || { },
            styleObject = { }, prop;
        for (var i = 0; i < this._styleProperties.length; i++) {
          prop = this._styleProperties[i];
          styleObject[prop] = typeof style[prop] === 'undefined' ? this[prop] : style[prop];
        }
        return styleObject;
      },

      /**
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @param {Object} style
       * @private
       */
      _setStyleDeclaration: function(lineIndex, charIndex, style) {
        this.styles[lineIndex][charIndex] = style;
      },

      /**
       *
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @private
       */
      _deleteStyleDeclaration: function(lineIndex, charIndex) {
        delete this.styles[lineIndex][charIndex];
      },

      /**
       * @param {Number} lineIndex
       * @private
       */
      _getLineStyle: function(lineIndex) {
        return this.styles[lineIndex];
      },

      /**
       * @param {Number} lineIndex
       * @param {Object} style
       * @private
       */
      _setLineStyle: function(lineIndex, style) {
        this.styles[lineIndex] = style;
      },

      /**
       * @param {Number} lineIndex
       * @private
       */
      _deleteLineStyle: function(lineIndex) {
        delete this.styles[lineIndex];
      }
    });
  })();


  (function() {

    function parseDecoration(object) {
      if (object.textDecoration) {
        object.textDecoration.indexOf('underline') > -1 && (object.underline = true);
        object.textDecoration.indexOf('line-through') > -1 && (object.linethrough = true);
        object.textDecoration.indexOf('overline') > -1 && (object.overline = true);
        delete object.textDecoration;
      }
    }

    /**
     * IText class (introduced in <b>v1.4</b>) Events are also fired with "text:"
     * prefix when observing canvas.
     * @class fabric.IText
     * @extends fabric.Text
     * @mixes fabric.Observable
     *
     * @fires changed
     * @fires selection:changed
     * @fires editing:entered
     * @fires editing:exited
     *
     * @return {fabric.IText} thisArg
     * @see {@link fabric.IText#initialize} for constructor definition
     *
     * <p>Supported key combinations:</p>
     * <pre>
     *   Move cursor:                    left, right, up, down
     *   Select character:               shift + left, shift + right
     *   Select text vertically:         shift + up, shift + down
     *   Move cursor by word:            alt + left, alt + right
     *   Select words:                   shift + alt + left, shift + alt + right
     *   Move cursor to line start/end:  cmd + left, cmd + right or home, end
     *   Select till start/end of line:  cmd + shift + left, cmd + shift + right or shift + home, shift + end
     *   Jump to start/end of text:      cmd + up, cmd + down
     *   Select till start/end of text:  cmd + shift + up, cmd + shift + down or shift + pgUp, shift + pgDown
     *   Delete character:               backspace
     *   Delete word:                    alt + backspace
     *   Delete line:                    cmd + backspace
     *   Forward delete:                 delete
     *   Copy text:                      ctrl/cmd + c
     *   Paste text:                     ctrl/cmd + v
     *   Cut text:                       ctrl/cmd + x
     *   Select entire text:             ctrl/cmd + a
     *   Quit editing                    tab or esc
     * </pre>
     *
     * <p>Supported mouse/touch combination</p>
     * <pre>
     *   Position cursor:                click/touch
     *   Create selection:               click/touch & drag
     *   Create selection:               click & shift + click
     *   Select word:                    double click
     *   Select line:                    triple click
     * </pre>
     */
    fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, /** @lends fabric.IText.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'i-text',

      /**
       * Index where text selection starts (or where cursor is when there is no selection)
       * @type Number
       * @default
       */
      selectionStart: 0,

      /**
       * Index where text selection ends
       * @type Number
       * @default
       */
      selectionEnd: 0,

      /**
       * Color of text selection
       * @type String
       * @default
       */
      selectionColor: 'rgba(17,119,255,0.3)',

      /**
       * Indicates whether text is in editing mode
       * @type Boolean
       * @default
       */
      isEditing: false,

      /**
       * Indicates whether a text can be edited
       * @type Boolean
       * @default
       */
      editable: true,

      /**
       * Border color of text object while it's in editing mode
       * @type String
       * @default
       */
      editingBorderColor: 'rgba(102,153,255,0.25)',

      /**
       * Width of cursor (in px)
       * @type Number
       * @default
       */
      cursorWidth: 2,

      /**
       * Color of default cursor (when not overwritten by character style)
       * @type String
       * @default
       */
      cursorColor: '#333',

      /**
       * Delay between cursor blink (in ms)
       * @type Number
       * @default
       */
      cursorDelay: 1000,

      /**
       * Duration of cursor fadein (in ms)
       * @type Number
       * @default
       */
      cursorDuration: 600,

      /**
       * Indicates whether internal text char widths can be cached
       * @type Boolean
       * @default
       */
      caching: true,

      /**
       * @private
       */
      _reSpace: /\s|\n/,

      /**
       * @private
       */
      _currentCursorOpacity: 0,

      /**
       * @private
       */
      _selectionDirection: null,

      /**
       * @private
       */
      _abortCursorAnimation: false,

      /**
       * @private
       */
      __widthOfSpace: [],

      /**
       * Helps determining when the text is in composition, so that the cursor
       * rendering is altered.
       */
      inCompositionMode: false,

      /**
       * Constructor
       * @param {String} text Text string
       * @param {Object} [options] Options object
       * @return {fabric.IText} thisArg
       */
      initialize: function(text, options) {
        this.callSuper('initialize', text, options);
        this.initBehavior();
      },

      /**
       * Sets selection start (left boundary of a selection)
       * @param {Number} index Index to set selection start to
       */
      setSelectionStart: function(index) {
        index = Math.max(index, 0);
        this._updateAndFire('selectionStart', index);
      },

      /**
       * Sets selection end (right boundary of a selection)
       * @param {Number} index Index to set selection end to
       */
      setSelectionEnd: function(index) {
        index = Math.min(index, this.text.length);
        this._updateAndFire('selectionEnd', index);
      },

      /**
       * @private
       * @param {String} property 'selectionStart' or 'selectionEnd'
       * @param {Number} index new position of property
       */
      _updateAndFire: function(property, index) {
        if (this[property] !== index) {
          this._fireSelectionChanged();
          this[property] = index;
        }
        this._updateTextarea();
      },

      /**
       * Fires the even of selection changed
       * @private
       */
      _fireSelectionChanged: function() {
        this.fire('selection:changed');
        this.canvas && this.canvas.fire('text:selection:changed', { target: this });
      },

      /**
       * Initialize text dimensions. Render all text on given context
       * or on a offscreen canvas to get the text width with measureText.
       * Updates this.width and this.height with the proper values.
       * Does not return dimensions.
       * @private
       */
      initDimensions: function() {
        this.isEditing && this.initDelayedCursor();
        this.clearContextTop();
        this.callSuper('initDimensions');
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      render: function(ctx) {
        this.clearContextTop();
        this.callSuper('render', ctx);
        // clear the cursorOffsetCache, so we ensure to calculate once per renderCursor
        // the correct position but not at every cursor animation.
        this.cursorOffsetCache = { };
        this.renderCursorOrSelection();
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {
        this.callSuper('_render', ctx);
      },

      /**
       * Prepare and clean the contextTop
       */
      clearContextTop: function(skipRestore) {
        if (!this.isEditing) {
          return;
        }
        if (this.canvas && this.canvas.contextTop) {
          var ctx = this.canvas.contextTop, v = this.canvas.viewportTransform;
          ctx.save();
          ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
          this.transform(ctx);
          this.transformMatrix && ctx.transform.apply(ctx, this.transformMatrix);
          this._clearTextArea(ctx);
          skipRestore || ctx.restore();
        }
      },

      /**
       * Renders cursor or selection (depending on what exists)
       */
      renderCursorOrSelection: function() {
        if (!this.isEditing || !this.canvas) {
          return;
        }
        var boundaries = this._getCursorBoundaries(), ctx;
        if (this.canvas && this.canvas.contextTop) {
          ctx = this.canvas.contextTop;
          this.clearContextTop(true);
        }
        else {
          ctx = this.canvas.contextContainer;
          ctx.save();
        }
        if (this.selectionStart === this.selectionEnd) {
          this.renderCursor(boundaries, ctx);
        }
        else {
          this.renderSelection(boundaries, ctx);
        }
        ctx.restore();
      },

      _clearTextArea: function(ctx) {
        // we add 4 pixel, to be sure to do not leave any pixel out
        var width = this.width + 4, height = this.height + 4;
        ctx.clearRect(-width / 2, -height / 2, width, height);
      },

      /**
       * Returns cursor boundaries (left, top, leftOffset, topOffset)
       * @private
       * @param {Array} chars Array of characters
       * @param {String} typeOfBoundaries
       */
      _getCursorBoundaries: function(position) {

        // left/top are left/top of entire text box
        // leftOffset/topOffset are offset from that left/top point of a text box

        if (typeof position === 'undefined') {
          position = this.selectionStart;
        }

        var left = this._getLeftOffset(),
            top = this._getTopOffset(),
            offsets = this._getCursorBoundariesOffsets(position);

        return {
          left: left,
          top: top,
          leftOffset: offsets.left,
          topOffset: offsets.top
        };
      },

      /**
       * @private
       */
      _getCursorBoundariesOffsets: function(position) {
        if (this.cursorOffsetCache && 'top' in this.cursorOffsetCache) {
          return this.cursorOffsetCache;
        }
        var lineLeftOffset,
            lineIndex,
            charIndex,
            topOffset = 0,
            leftOffset = 0,
            boundaries,
            cursorPosition = this.get2DCursorLocation(position);
        charIndex = cursorPosition.charIndex;
        lineIndex = cursorPosition.lineIndex;
        for (var i = 0; i < lineIndex; i++) {
          topOffset += this.getHeightOfLine(i);
        }
        lineLeftOffset = this._getLineLeftOffset(lineIndex);
        var bound = this.__charBounds[lineIndex][charIndex];
        bound && (leftOffset = bound.left);
        if (this.charSpacing !== 0 && charIndex === this._textLines[lineIndex].length) {
          leftOffset -= this._getWidthOfCharSpacing();
        }
        boundaries = {
          top: topOffset,
          left: lineLeftOffset + (leftOffset > 0 ? leftOffset : 0),
        };
        this.cursorOffsetCache = boundaries;
        return this.cursorOffsetCache;
      },

      /**
       * Renders cursor
       * @param {Object} boundaries
       * @param {CanvasRenderingContext2D} ctx transformed context to draw on
       */
      renderCursor: function(boundaries, ctx) {
        var cursorLocation = this.get2DCursorLocation(),
            lineIndex = cursorLocation.lineIndex,
            charIndex = cursorLocation.charIndex > 0 ? cursorLocation.charIndex - 1 : 0,
            charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, 'fontSize'),
            multiplier = this.scaleX * this.canvas.getZoom(),
            cursorWidth = this.cursorWidth / multiplier,
            topOffset = boundaries.topOffset,
            dy = this.getValueOfPropertyAt(lineIndex, charIndex, 'deltaY');

        topOffset += (1 - this._fontSizeFraction) * this.getHeightOfLine(lineIndex) / this.lineHeight
          - charHeight * (1 - this._fontSizeFraction);

        if (this.inCompositionMode) {
          this.renderSelection(boundaries, ctx);
        }

        ctx.fillStyle = this.getValueOfPropertyAt(lineIndex, charIndex, 'fill');
        ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;
        ctx.fillRect(
          boundaries.left + boundaries.leftOffset - cursorWidth / 2,
          topOffset + boundaries.top + dy,
          cursorWidth,
          charHeight);
      },

      /**
       * Renders text selection
       * @param {Object} boundaries Object with left/top/leftOffset/topOffset
       * @param {CanvasRenderingContext2D} ctx transformed context to draw on
       */
      renderSelection: function(boundaries, ctx) {

        var selectionStart = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart,
            selectionEnd = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd,
            isJustify = this.textAlign.indexOf('justify') !== -1,
            start = this.get2DCursorLocation(selectionStart),
            end = this.get2DCursorLocation(selectionEnd),
            startLine = start.lineIndex,
            endLine = end.lineIndex,
            startChar = start.charIndex < 0 ? 0 : start.charIndex,
            endChar = end.charIndex < 0 ? 0 : end.charIndex;

        for (var i = startLine; i <= endLine; i++) {
          var lineOffset = this._getLineLeftOffset(i) || 0,
              lineHeight = this.getHeightOfLine(i),
              realLineHeight = 0, boxStart = 0, boxEnd = 0;

          if (i === startLine) {
            boxStart = this.__charBounds[startLine][startChar].left;
          }
          if (i >= startLine && i < endLine) {
            boxEnd = isJustify && !this.isEndOfWrapping(i) ? this.width : this.getLineWidth(i) || 5; // WTF is this 5?
          }
          else if (i === endLine) {
            if (endChar === 0) {
              boxEnd = this.__charBounds[endLine][endChar].left;
            }
            else {
              var charSpacing = this._getWidthOfCharSpacing();
              boxEnd = this.__charBounds[endLine][endChar - 1].left
                + this.__charBounds[endLine][endChar - 1].width - charSpacing;
            }
          }
          realLineHeight = lineHeight;
          if (this.lineHeight < 1 || (i === endLine && this.lineHeight > 1)) {
            lineHeight /= this.lineHeight;
          }
          if (this.inCompositionMode) {
            ctx.fillStyle = this.compositionColor || 'black';
            ctx.fillRect(
              boundaries.left + lineOffset + boxStart,
              boundaries.top + boundaries.topOffset + lineHeight,
              boxEnd - boxStart,
              1);
          }
          else {
            ctx.fillStyle = this.selectionColor;
            ctx.fillRect(
              boundaries.left + lineOffset + boxStart,
              boundaries.top + boundaries.topOffset,
              boxEnd - boxStart,
              lineHeight);
          }


          boundaries.topOffset += realLineHeight;
        }
      },

      /**
       * High level function to know the height of the cursor.
       * the currentChar is the one that precedes the cursor
       * Returns fontSize of char at the current cursor
       * @return {Number} Character font size
       */
      getCurrentCharFontSize: function() {
        var cp = this._getCurrentCharIndex();
        return this.getValueOfPropertyAt(cp.l, cp.c, 'fontSize');
      },

      /**
       * High level function to know the color of the cursor.
       * the currentChar is the one that precedes the cursor
       * Returns color (fill) of char at the current cursor
       * @return {String} Character color (fill)
       */
      getCurrentCharColor: function() {
        var cp = this._getCurrentCharIndex();
        return this.getValueOfPropertyAt(cp.l, cp.c, 'fill');
      },

      /**
       * Returns the cursor position for the getCurrent.. functions
       * @private
       */
      _getCurrentCharIndex: function() {
        var cursorPosition = this.get2DCursorLocation(this.selectionStart, true),
            charIndex = cursorPosition.charIndex > 0 ? cursorPosition.charIndex - 1 : 0;
        return { l: cursorPosition.lineIndex, c: charIndex };
      }
    });

    /**
     * Returns fabric.IText instance from an object representation
     * @static
     * @memberOf fabric.IText
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] invoked with new instance as argument
     */
    fabric.IText.fromObject = function(object, callback) {
      parseDecoration(object);
      if (object.styles) {
        for (var i in object.styles) {
          for (var j in object.styles[i]) {
            parseDecoration(object.styles[i][j]);
          }
        }
      }
      fabric.Object._fromObject('IText', object, callback, 'text');
    };
  })();


  (function() {

    var clone = fabric.util.object.clone;

    fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {

      /**
       * Initializes all the interactive behavior of IText
       */
      initBehavior: function() {
        this.initAddedHandler();
        this.initRemovedHandler();
        this.initCursorSelectionHandlers();
        this.initDoubleClickSimulation();
        this.mouseMoveHandler = this.mouseMoveHandler.bind(this);
      },

      onDeselect: function() {
        this.isEditing && this.exitEditing();
        this.selected = false;
      },

      /**
       * Initializes "added" event handler
       */
      initAddedHandler: function() {
        var _this = this;
        this.on('added', function() {
          var canvas = _this.canvas;
          if (canvas) {
            if (!canvas._hasITextHandlers) {
              canvas._hasITextHandlers = true;
              _this._initCanvasHandlers(canvas);
            }
            canvas._iTextInstances = canvas._iTextInstances || [];
            canvas._iTextInstances.push(_this);
          }
        });
      },

      initRemovedHandler: function() {
        var _this = this;
        this.on('removed', function() {
          var canvas = _this.canvas;
          if (canvas) {
            canvas._iTextInstances = canvas._iTextInstances || [];
            fabric.util.removeFromArray(canvas._iTextInstances, _this);
            if (canvas._iTextInstances.length === 0) {
              canvas._hasITextHandlers = false;
              _this._removeCanvasHandlers(canvas);
            }
          }
        });
      },

      /**
       * register canvas event to manage exiting on other instances
       * @private
       */
      _initCanvasHandlers: function(canvas) {
        canvas._mouseUpITextHandler = function() {
          if (canvas._iTextInstances) {
            canvas._iTextInstances.forEach(function(obj) {
              obj.__isMousedown = false;
            });
          }
        };
        canvas.on('mouse:up', canvas._mouseUpITextHandler);
      },

      /**
       * remove canvas event to manage exiting on other instances
       * @private
       */
      _removeCanvasHandlers: function(canvas) {
        canvas.off('mouse:up', canvas._mouseUpITextHandler);
      },

      /**
       * @private
       */
      _tick: function() {
        this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, '_onTickComplete');
      },

      /**
       * @private
       */
      _animateCursor: function(obj, targetOpacity, duration, completeMethod) {

        var tickState;

        tickState = {
          isAborted: false,
          abort: function() {
            this.isAborted = true;
          },
        };

        obj.animate('_currentCursorOpacity', targetOpacity, {
          duration: duration,
          onComplete: function() {
            if (!tickState.isAborted) {
              obj[completeMethod]();
            }
          },
          onChange: function() {
            // we do not want to animate a selection, only cursor
            if (obj.canvas && obj.selectionStart === obj.selectionEnd) {
              obj.renderCursorOrSelection();
            }
          },
          abort: function() {
            return tickState.isAborted;
          }
        });
        return tickState;
      },

      /**
       * @private
       */
      _onTickComplete: function() {

        var _this = this;

        if (this._cursorTimeout1) {
          clearTimeout(this._cursorTimeout1);
        }
        this._cursorTimeout1 = setTimeout(function() {
          _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, '_tick');
        }, 100);
      },

      /**
       * Initializes delayed cursor
       */
      initDelayedCursor: function(restart) {
        var _this = this,
            delay = restart ? 0 : this.cursorDelay;

        this.abortCursorAnimation();
        this._currentCursorOpacity = 1;
        this._cursorTimeout2 = setTimeout(function() {
          _this._tick();
        }, delay);
      },

      /**
       * Aborts cursor animation and clears all timeouts
       */
      abortCursorAnimation: function() {
        var shouldClear = this._currentTickState || this._currentTickCompleteState,
            canvas = this.canvas;
        this._currentTickState && this._currentTickState.abort();
        this._currentTickCompleteState && this._currentTickCompleteState.abort();

        clearTimeout(this._cursorTimeout1);
        clearTimeout(this._cursorTimeout2);

        this._currentCursorOpacity = 0;
        // to clear just itext area we need to transform the context
        // it may not be worth it
        if (shouldClear && canvas) {
          canvas.clearContext(canvas.contextTop || canvas.contextContainer);
        }

      },

      /**
       * Selects entire text
       * @return {fabric.IText} thisArg
       * @chainable
       */
      selectAll: function() {
        this.selectionStart = 0;
        this.selectionEnd = this._text.length;
        this._fireSelectionChanged();
        this._updateTextarea();
        return this;
      },

      /**
       * Returns selected text
       * @return {String}
       */
      getSelectedText: function() {
        return this._text.slice(this.selectionStart, this.selectionEnd).join('');
      },

      /**
       * Find new selection index representing start of current word according to current selection index
       * @param {Number} startFrom Surrent selection index
       * @return {Number} New selection index
       */
      findWordBoundaryLeft: function(startFrom) {
        var offset = 0, index = startFrom - 1;

        // remove space before cursor first
        if (this._reSpace.test(this._text[index])) {
          while (this._reSpace.test(this._text[index])) {
            offset++;
            index--;
          }
        }
        while (/\S/.test(this._text[index]) && index > -1) {
          offset++;
          index--;
        }

        return startFrom - offset;
      },

      /**
       * Find new selection index representing end of current word according to current selection index
       * @param {Number} startFrom Current selection index
       * @return {Number} New selection index
       */
      findWordBoundaryRight: function(startFrom) {
        var offset = 0, index = startFrom;

        // remove space after cursor first
        if (this._reSpace.test(this._text[index])) {
          while (this._reSpace.test(this._text[index])) {
            offset++;
            index++;
          }
        }
        while (/\S/.test(this._text[index]) && index < this.text.length) {
          offset++;
          index++;
        }

        return startFrom + offset;
      },

      /**
       * Find new selection index representing start of current line according to current selection index
       * @param {Number} startFrom Current selection index
       * @return {Number} New selection index
       */
      findLineBoundaryLeft: function(startFrom) {
        var offset = 0, index = startFrom - 1;

        while (!/\n/.test(this._text[index]) && index > -1) {
          offset++;
          index--;
        }

        return startFrom - offset;
      },

      /**
       * Find new selection index representing end of current line according to current selection index
       * @param {Number} startFrom Current selection index
       * @return {Number} New selection index
       */
      findLineBoundaryRight: function(startFrom) {
        var offset = 0, index = startFrom;

        while (!/\n/.test(this._text[index]) && index < this.text.length) {
          offset++;
          index++;
        }

        return startFrom + offset;
      },

      /**
       * Finds index corresponding to beginning or end of a word
       * @param {Number} selectionStart Index of a character
       * @param {Number} direction 1 or -1
       * @return {Number} Index of the beginning or end of a word
       */
      searchWordBoundary: function(selectionStart, direction) {
        var index     = this._reSpace.test(this.text.charAt(selectionStart)) ? selectionStart - 1 : selectionStart,
            _char     = this.text.charAt(index),
            reNonWord = /[ \n\.,;!\?\-]/;

        while (!reNonWord.test(_char) && index > 0 && index < this.text.length) {
          index += direction;
          _char = this.text.charAt(index);
        }
        if (reNonWord.test(_char) && _char !== '\n') {
          index += direction === 1 ? 0 : 1;
        }
        return index;
      },

      /**
       * Selects a word based on the index
       * @param {Number} selectionStart Index of a character
       */
      selectWord: function(selectionStart) {
        selectionStart = selectionStart || this.selectionStart;
        var newSelectionStart = this.searchWordBoundary(selectionStart, -1), /* search backwards */
            newSelectionEnd = this.searchWordBoundary(selectionStart, 1); /* search forward */

        this.selectionStart = newSelectionStart;
        this.selectionEnd = newSelectionEnd;
        this._fireSelectionChanged();
        this._updateTextarea();
        this.renderCursorOrSelection();
      },

      /**
       * Selects a line based on the index
       * @param {Number} selectionStart Index of a character
       * @return {fabric.IText} thisArg
       * @chainable
       */
      selectLine: function(selectionStart) {
        selectionStart = selectionStart || this.selectionStart;
        var newSelectionStart = this.findLineBoundaryLeft(selectionStart),
            newSelectionEnd = this.findLineBoundaryRight(selectionStart);

        this.selectionStart = newSelectionStart;
        this.selectionEnd = newSelectionEnd;
        this._fireSelectionChanged();
        this._updateTextarea();
        return this;
      },

      /**
       * Enters editing state
       * @return {fabric.IText} thisArg
       * @chainable
       */
      enterEditing: function(e) {
        if (this.isEditing || !this.editable) {
          return;
        }

        if (this.canvas) {
          this.canvas.calcOffset();
          this.exitEditingOnOthers(this.canvas);
        }

        this.isEditing = true;

        this.initHiddenTextarea(e);
        this.hiddenTextarea.focus();
        this.hiddenTextarea.value = this.text;
        this._updateTextarea();
        this._saveEditingProps();
        this._setEditingProps();
        this._textBeforeEdit = this.text;

        this._tick();
        this.fire('editing:entered');
        this._fireSelectionChanged();
        if (!this.canvas) {
          return this;
        }
        this.canvas.fire('text:editing:entered', { target: this });
        this.initMouseMoveHandler();
        this.canvas.requestRenderAll();
        return this;
      },

      exitEditingOnOthers: function(canvas) {
        if (canvas._iTextInstances) {
          canvas._iTextInstances.forEach(function(obj) {
            obj.selected = false;
            if (obj.isEditing) {
              obj.exitEditing();
            }
          });
        }
      },

      /**
       * Initializes "mousemove" event handler
       */
      initMouseMoveHandler: function() {
        this.canvas.on('mouse:move', this.mouseMoveHandler);
      },

      /**
       * @private
       */
      mouseMoveHandler: function(options) {
        if (!this.__isMousedown || !this.isEditing) {
          return;
        }

        var newSelectionStart = this.getSelectionStartFromPointer(options.e),
            currentStart = this.selectionStart,
            currentEnd = this.selectionEnd;
        if (
          (newSelectionStart !== this.__selectionStartOnMouseDown || currentStart === currentEnd)
          &&
          (currentStart === newSelectionStart || currentEnd === newSelectionStart)
        ) {
          return;
        }
        if (newSelectionStart > this.__selectionStartOnMouseDown) {
          this.selectionStart = this.__selectionStartOnMouseDown;
          this.selectionEnd = newSelectionStart;
        }
        else {
          this.selectionStart = newSelectionStart;
          this.selectionEnd = this.__selectionStartOnMouseDown;
        }
        if (this.selectionStart !== currentStart || this.selectionEnd !== currentEnd) {
          this.restartCursorIfNeeded();
          this._fireSelectionChanged();
          this._updateTextarea();
          this.renderCursorOrSelection();
        }
      },

      /**
       * @private
       */
      _setEditingProps: function() {
        this.hoverCursor = 'text';

        if (this.canvas) {
          this.canvas.defaultCursor = this.canvas.moveCursor = 'text';
        }

        this.borderColor = this.editingBorderColor;

        this.hasControls = this.selectable = false;
        this.lockMovementX = this.lockMovementY = true;
      },

      /**
       * convert from textarea to grapheme indexes
       */
      fromStringToGraphemeSelection: function(start, end, text) {
        var smallerTextStart = text.slice(0, start),
            graphemeStart = fabric.util.string.graphemeSplit(smallerTextStart).length;
        if (start === end) {
          return { selectionStart: graphemeStart, selectionEnd: graphemeStart };
        }
        var smallerTextEnd = text.slice(start, end),
            graphemeEnd = fabric.util.string.graphemeSplit(smallerTextEnd).length;
        return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };
      },

      /**
       * convert from fabric to textarea values
       */
      fromGraphemeToStringSelection: function(start, end, _text) {
        var smallerTextStart = _text.slice(0, start),
            graphemeStart = smallerTextStart.join('').length;
        if (start === end) {
          return { selectionStart: graphemeStart, selectionEnd: graphemeStart };
        }
        var smallerTextEnd = _text.slice(start, end),
            graphemeEnd = smallerTextEnd.join('').length;
        return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };
      },

      /**
       * @private
       */
      _updateTextarea: function() {
        this.cursorOffsetCache = { };
        if (!this.hiddenTextarea) {
          return;
        }
        if (!this.inCompositionMode) {
          var newSelection = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
          this.hiddenTextarea.selectionStart = newSelection.selectionStart;
          this.hiddenTextarea.selectionEnd = newSelection.selectionEnd;
        }
        this.updateTextareaPosition();
      },

      /**
       * @private
       */
      updateFromTextArea: function() {
        if (!this.hiddenTextarea) {
          return;
        }
        this.cursorOffsetCache = { };
        this.text = this.hiddenTextarea.value;
        if (this._shouldClearDimensionCache()) {
          this.initDimensions();
          this.setCoords();
        }
        var newSelection = this.fromStringToGraphemeSelection(
          this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);
        this.selectionEnd = this.selectionStart = newSelection.selectionEnd;
        if (!this.inCompositionMode) {
          this.selectionStart = newSelection.selectionStart;
        }
        this.updateTextareaPosition();
      },

      /**
       * @private
       */
      updateTextareaPosition: function() {
        if (this.selectionStart === this.selectionEnd) {
          var style = this._calcTextareaPosition();
          this.hiddenTextarea.style.left = style.left;
          this.hiddenTextarea.style.top = style.top;
        }
      },

      /**
       * @private
       * @return {Object} style contains style for hiddenTextarea
       */
      _calcTextareaPosition: function() {
        if (!this.canvas) {
          return { x: 1, y: 1 };
        }
        var desiredPostion = this.inCompositionMode ? this.compositionStart : this.selectionStart,
            boundaries = this._getCursorBoundaries(desiredPostion),
            cursorLocation = this.get2DCursorLocation(desiredPostion),
            lineIndex = cursorLocation.lineIndex,
            charIndex = cursorLocation.charIndex,
            charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, 'fontSize') * this.lineHeight,
            leftOffset = boundaries.leftOffset,
            m = this.calcTransformMatrix(),
            p = {
              x: boundaries.left + leftOffset,
              y: boundaries.top + boundaries.topOffset + charHeight
            },
            upperCanvas = this.canvas.upperCanvasEl,
            upperCanvasWidth = upperCanvas.width,
            upperCanvasHeight = upperCanvas.height,
            maxWidth = upperCanvasWidth - charHeight,
            maxHeight = upperCanvasHeight - charHeight,
            scaleX = upperCanvas.clientWidth / upperCanvasWidth,
            scaleY = upperCanvas.clientHeight / upperCanvasHeight;

        p = fabric.util.transformPoint(p, m);
        p = fabric.util.transformPoint(p, this.canvas.viewportTransform);
        p.x *= scaleX;
        p.y *= scaleY;
        if (p.x < 0) {
          p.x = 0;
        }
        if (p.x > maxWidth) {
          p.x = maxWidth;
        }
        if (p.y < 0) {
          p.y = 0;
        }
        if (p.y > maxHeight) {
          p.y = maxHeight;
        }

        // add canvas offset on document
        p.x += this.canvas._offset.left;
        p.y += this.canvas._offset.top;

        return { left: p.x + 'px', top: p.y + 'px', fontSize: charHeight + 'px', charHeight: charHeight };
      },

      /**
       * @private
       */
      _saveEditingProps: function() {
        this._savedProps = {
          hasControls: this.hasControls,
          borderColor: this.borderColor,
          lockMovementX: this.lockMovementX,
          lockMovementY: this.lockMovementY,
          hoverCursor: this.hoverCursor,
          defaultCursor: this.canvas && this.canvas.defaultCursor,
          moveCursor: this.canvas && this.canvas.moveCursor
        };
      },

      /**
       * @private
       */
      _restoreEditingProps: function() {
        if (!this._savedProps) {
          return;
        }

        this.hoverCursor = this._savedProps.hoverCursor;
        this.hasControls = this._savedProps.hasControls;
        this.borderColor = this._savedProps.borderColor;
        this.lockMovementX = this._savedProps.lockMovementX;
        this.lockMovementY = this._savedProps.lockMovementY;

        if (this.canvas) {
          this.canvas.defaultCursor = this._savedProps.defaultCursor;
          this.canvas.moveCursor = this._savedProps.moveCursor;
        }
      },

      /**
       * Exits from editing state
       * @return {fabric.IText} thisArg
       * @chainable
       */
      exitEditing: function() {
        var isTextChanged = (this._textBeforeEdit !== this.text);
        this.selected = false;
        this.isEditing = false;
        this.selectable = true;

        this.selectionEnd = this.selectionStart;

        if (this.hiddenTextarea) {
          this.hiddenTextarea.blur && this.hiddenTextarea.blur();
          this.canvas && this.hiddenTextarea.parentNode.removeChild(this.hiddenTextarea);
          this.hiddenTextarea = null;
        }

        this.abortCursorAnimation();
        this._restoreEditingProps();
        this._currentCursorOpacity = 0;
        if (this._shouldClearDimensionCache()) {
          this.initDimensions();
          this.setCoords();
        }
        this.fire('editing:exited');
        isTextChanged && this.fire('modified');
        if (this.canvas) {
          this.canvas.off('mouse:move', this.mouseMoveHandler);
          this.canvas.fire('text:editing:exited', { target: this });
          isTextChanged && this.canvas.fire('object:modified', { target: this });
        }
        return this;
      },

      /**
       * @private
       */
      _removeExtraneousStyles: function() {
        for (var prop in this.styles) {
          if (!this._textLines[prop]) {
            delete this.styles[prop];
          }
        }
      },

      /**
       * remove and reflow a style block from start to end.
       * @param {Number} start linear start position for removal (included in removal)
       * @param {Number} end linear end position for removal ( excluded from removal )
       */
      removeStyleFromTo: function(start, end) {
        var cursorStart = this.get2DCursorLocation(start, true),
            cursorEnd = this.get2DCursorLocation(end, true),
            lineStart = cursorStart.lineIndex,
            charStart = cursorStart.charIndex,
            lineEnd = cursorEnd.lineIndex,
            charEnd = cursorEnd.charIndex,
            i, styleObj;
        if (lineStart !== lineEnd) {
          // step1 remove the trailing of lineStart
          if (this.styles[lineStart]) {
            for (i = charStart; i < this._unwrappedTextLines[lineStart].length; i++) {
              delete this.styles[lineStart][i];
            }
          }
          // step2 move the trailing of lineEnd to lineStart if needed
          if (this.styles[lineEnd]) {
            for (i = charEnd; i < this._unwrappedTextLines[lineEnd].length; i++) {
              styleObj = this.styles[lineEnd][i];
              if (styleObj) {
                this.styles[lineStart] || (this.styles[lineStart] = { });
                this.styles[lineStart][charStart + i - charEnd] = styleObj;
              }
            }
          }
          // step3 detects lines will be completely removed.
          for (i = lineStart + 1; i <= lineEnd; i++) {
            delete this.styles[i];
          }
          // step4 shift remaining lines.
          this.shiftLineStyles(lineEnd, lineStart - lineEnd);
        }
        else {
          // remove and shift left on the same line
          if (this.styles[lineStart]) {
            styleObj = this.styles[lineStart];
            var diff = charEnd - charStart, numericChar, _char;
            for (i = charStart; i < charEnd; i++) {
              delete styleObj[i];
            }
            for (_char in this.styles[lineStart]) {
              numericChar = parseInt(_char, 10);
              if (numericChar >= charEnd) {
                styleObj[numericChar - diff] = styleObj[_char];
                delete styleObj[_char];
              }
            }
          }
        }
      },

      /**
       * Shifts line styles up or down
       * @param {Number} lineIndex Index of a line
       * @param {Number} offset Can any number?
       */
      shiftLineStyles: function(lineIndex, offset) {
        // shift all line styles by offset upward or downward
        // do not clone deep. we need new array, not new style objects
        var clonedStyles = clone(this.styles);
        for (var line in this.styles) {
          var numericLine = parseInt(line, 10);
          if (numericLine > lineIndex) {
            this.styles[numericLine + offset] = clonedStyles[numericLine];
            if (!clonedStyles[numericLine - offset]) {
              delete this.styles[numericLine];
            }
          }
        }
      },

      restartCursorIfNeeded: function() {
        if (!this._currentTickState || this._currentTickState.isAborted
          || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted
        ) {
          this.initDelayedCursor();
        }
      },

      /**
       * Inserts new style object
       * @param {Number} lineIndex Index of a line
       * @param {Number} charIndex Index of a char
       * @param {Number} qty number of lines to add
       * @param {Array} copiedStyle Array of objects styles
       */
      insertNewlineStyleObject: function(lineIndex, charIndex, qty, copiedStyle) {
        var currentCharStyle,
            newLineStyles = {},
            somethingAdded = false;

        qty || (qty = 1);
        this.shiftLineStyles(lineIndex, qty);
        if (this.styles[lineIndex]) {
          currentCharStyle = this.styles[lineIndex][charIndex === 0 ? charIndex : charIndex - 1];
        }

        // we clone styles of all chars
        // after cursor onto the current line
        for (var index in this.styles[lineIndex]) {
          var numIndex = parseInt(index, 10);
          if (numIndex >= charIndex) {
            somethingAdded = true;
            newLineStyles[numIndex - charIndex] = this.styles[lineIndex][index];
            // remove lines from the previous line since they're on a new line now
            delete this.styles[lineIndex][index];
          }
        }
        if (somethingAdded) {
          this.styles[lineIndex + qty] = newLineStyles;
        }
        else {
          delete this.styles[lineIndex + qty];
        }
        // for the other lines
        // we clone current char style onto the next (otherwise empty) line
        while (qty > 1) {
          qty--;
          if (copiedStyle && copiedStyle[qty]) {
            this.styles[lineIndex + qty] = { 0: clone(copiedStyle[qty]) };
          }
          else if (currentCharStyle) {
            this.styles[lineIndex + qty] = { 0: clone(currentCharStyle) };
          }
          else {
            delete this.styles[lineIndex + qty];
          }
        }
        this._forceClearCache = true;
      },

      /**
       * Inserts style object for a given line/char index
       * @param {Number} lineIndex Index of a line
       * @param {Number} charIndex Index of a char
       * @param {Number} quantity number Style object to insert, if given
       * @param {Array} copiedStyle array of style objecs
       */
      insertCharStyleObject: function(lineIndex, charIndex, quantity, copiedStyle) {
        if (!this.styles) {
          this.styles = {};
        }
        var currentLineStyles       = this.styles[lineIndex],
            currentLineStylesCloned = currentLineStyles ? clone(currentLineStyles) : {};

        quantity || (quantity = 1);
        // shift all char styles by quantity forward
        // 0,1,2,3 -> (charIndex=2) -> 0,1,3,4 -> (insert 2) -> 0,1,2,3,4
        for (var index in currentLineStylesCloned) {
          var numericIndex = parseInt(index, 10);
          if (numericIndex >= charIndex) {
            currentLineStyles[numericIndex + quantity] = currentLineStylesCloned[numericIndex];
            // only delete the style if there was nothing moved there
            if (!currentLineStylesCloned[numericIndex - quantity]) {
              delete currentLineStyles[numericIndex];
            }
          }
        }
        this._forceClearCache = true;
        if (copiedStyle) {
          while (quantity--) {
            if (!Object.keys(copiedStyle[quantity]).length) {
              continue;
            }
            if (!this.styles[lineIndex]) {
              this.styles[lineIndex] = {};
            }
            this.styles[lineIndex][charIndex + quantity] = clone(copiedStyle[quantity]);
          }
          return;
        }
        if (!currentLineStyles) {
          return;
        }
        var newStyle = currentLineStyles[charIndex ? charIndex - 1 : 1];
        while (newStyle && quantity--) {
          this.styles[lineIndex][charIndex + quantity] = clone(newStyle);
        }
      },

      /**
       * Inserts style object(s)
       * @param {Array} insertedText Characters at the location where style is inserted
       * @param {Number} start cursor index for inserting style
       * @param {Array} [copiedStyle] array of style objects to insert.
       */
      insertNewStyleBlock: function(insertedText, start, copiedStyle) {
        var cursorLoc = this.get2DCursorLocation(start, true),
            addedLines = [0], linesLenght = 0;
        for (var i = 0; i < insertedText.length; i++) {
          if (insertedText[i] === '\n') {
            linesLenght++;
            addedLines[linesLenght] = 0;
          }
          else {
            addedLines[linesLenght]++;
          }
        }
        if (addedLines[0] > 0) {
          this.insertCharStyleObject(cursorLoc.lineIndex, cursorLoc.charIndex, addedLines[0], copiedStyle);
          copiedStyle = copiedStyle && copiedStyle.slice(addedLines[0] + 1);
        }
        linesLenght && this.insertNewlineStyleObject(
          cursorLoc.lineIndex, cursorLoc.charIndex + addedLines[0], linesLenght);
        for (var i = 1; i < linesLenght; i++) {
          if (addedLines[i] > 0) {
            this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);
          }
          else if (copiedStyle) {
            this.styles[cursorLoc.lineIndex + i][0] = copiedStyle[0];
          }
          copiedStyle = copiedStyle && copiedStyle.slice(addedLines[i] + 1);
        }
        // we use i outside the loop to get it like linesLength
        if (addedLines[i] > 0) {
          this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);
        }
      },

      /**
       * Set the selectionStart and selectionEnd according to the ne postion of cursor
       * mimic the key - mouse navigation when shift is pressed.
       */
      setSelectionStartEndWithShift: function(start, end, newSelection) {
        if (newSelection <= start) {
          if (end === start) {
            this._selectionDirection = 'left';
          }
          else if (this._selectionDirection === 'right') {
            this._selectionDirection = 'left';
            this.selectionEnd = start;
          }
          this.selectionStart = newSelection;
        }
        else if (newSelection > start && newSelection < end) {
          if (this._selectionDirection === 'right') {
            this.selectionEnd = newSelection;
          }
          else {
            this.selectionStart = newSelection;
          }
        }
        else {
          // newSelection is > selection start and end
          if (end === start) {
            this._selectionDirection = 'right';
          }
          else if (this._selectionDirection === 'left') {
            this._selectionDirection = 'right';
            this.selectionStart = end;
          }
          this.selectionEnd = newSelection;
        }
      },

      setSelectionInBoundaries: function() {
        var length = this.text.length;
        if (this.selectionStart > length) {
          this.selectionStart = length;
        }
        else if (this.selectionStart < 0) {
          this.selectionStart = 0;
        }
        if (this.selectionEnd > length) {
          this.selectionEnd = length;
        }
        else if (this.selectionEnd < 0) {
          this.selectionEnd = 0;
        }
      }
    });
  })();


  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
    /**
     * Initializes "dbclick" event handler
     */
    initDoubleClickSimulation: function() {

      // for double click
      this.__lastClickTime = +new Date();

      // for triple click
      this.__lastLastClickTime = +new Date();

      this.__lastPointer = { };

      this.on('mousedown', this.onMouseDown);
    },

    /**
     * Default event handler to simulate triple click
     * @private
     */
    onMouseDown: function(options) {
      if (!this.canvas) {
        return;
      }
      this.__newClickTime = +new Date();
      var newPointer = options.pointer;
      if (this.isTripleClick(newPointer)) {
        this.fire('tripleclick', options);
        this._stopEvent(options.e);
      }
      this.__lastLastClickTime = this.__lastClickTime;
      this.__lastClickTime = this.__newClickTime;
      this.__lastPointer = newPointer;
      this.__lastIsEditing = this.isEditing;
      this.__lastSelected = this.selected;
    },

    isTripleClick: function(newPointer) {
      return this.__newClickTime - this.__lastClickTime < 500 &&
          this.__lastClickTime - this.__lastLastClickTime < 500 &&
          this.__lastPointer.x === newPointer.x &&
          this.__lastPointer.y === newPointer.y;
    },

    /**
     * @private
     */
    _stopEvent: function(e) {
      e.preventDefault && e.preventDefault();
      e.stopPropagation && e.stopPropagation();
    },

    /**
     * Initializes event handlers related to cursor or selection
     */
    initCursorSelectionHandlers: function() {
      this.initMousedownHandler();
      this.initMouseupHandler();
      this.initClicks();
    },

    /**
     * Initializes double and triple click event handlers
     */
    initClicks: function() {
      this.on('mousedblclick', function(options) {
        this.selectWord(this.getSelectionStartFromPointer(options.e));
      });
      this.on('tripleclick', function(options) {
        this.selectLine(this.getSelectionStartFromPointer(options.e));
      });
    },

    /**
     * Default event handler for the basic functionalities needed on _mouseDown
     * can be overridden to do something different.
     * Scope of this implementation is: find the click position, set selectionStart
     * find selectionEnd, initialize the drawing of either cursor or selection area
     */
    _mouseDownHandler: function(options) {
      if (!this.canvas || !this.editable || (options.e.button && options.e.button !== 1)) {
        return;
      }

      this.__isMousedown = true;

      if (this.selected) {
        this.setCursorByClick(options.e);
      }

      if (this.isEditing) {
        this.__selectionStartOnMouseDown = this.selectionStart;
        if (this.selectionStart === this.selectionEnd) {
          this.abortCursorAnimation();
        }
        this.renderCursorOrSelection();
      }
    },

    /**
     * Default event handler for the basic functionalities needed on mousedown:before
     * can be overridden to do something different.
     * Scope of this implementation is: verify the object is already selected when mousing down
     */
    _mouseDownHandlerBefore: function(options) {
      if (!this.canvas || !this.editable || (options.e.button && options.e.button !== 1)) {
        return;
      }
      if (this === this.canvas._activeObject) {
        this.selected = true;
      }
    },

    /**
     * Initializes "mousedown" event handler
     */
    initMousedownHandler: function() {
      this.on('mousedown', this._mouseDownHandler);
      this.on('mousedown:before', this._mouseDownHandlerBefore);
    },

    /**
     * Initializes "mouseup" event handler
     */
    initMouseupHandler: function() {
      this.on('mouseup', this.mouseUpHandler);
    },

    /**
     * standard hander for mouse up, overridable
     * @private
     */
    mouseUpHandler: function(options) {
      this.__isMousedown = false;
      if (!this.editable ||
        (options.transform && options.transform.actionPerformed) ||
        (options.e.button && options.e.button !== 1)) {
        return;
      }

      if (this.__lastSelected && !this.__corner) {
        this.enterEditing(options.e);
        if (this.selectionStart === this.selectionEnd) {
          this.initDelayedCursor(true);
        }
        else {
          this.renderCursorOrSelection();
        }
      }
      this.selected = true;
    },

    /**
     * Changes cursor location in a text depending on passed pointer (x/y) object
     * @param {Event} e Event object
     */
    setCursorByClick: function(e) {
      var newSelection = this.getSelectionStartFromPointer(e),
          start = this.selectionStart, end = this.selectionEnd;
      if (e.shiftKey) {
        this.setSelectionStartEndWithShift(start, end, newSelection);
      }
      else {
        this.selectionStart = newSelection;
        this.selectionEnd = newSelection;
      }
      if (this.isEditing) {
        this._fireSelectionChanged();
        this._updateTextarea();
      }
    },

    /**
     * Returns index of a character corresponding to where an object was clicked
     * @param {Event} e Event object
     * @return {Number} Index of a character
     */
    getSelectionStartFromPointer: function(e) {
      var mouseOffset = this.getLocalPointer(e),
          prevWidth = 0,
          width = 0,
          height = 0,
          charIndex = 0,
          lineIndex = 0,
          lineLeftOffset,
          line;

      for (var i = 0, len = this._textLines.length; i < len; i++) {
        if (height <= mouseOffset.y) {
          height += this.getHeightOfLine(i) * this.scaleY;
          lineIndex = i;
          if (i > 0) {
            charIndex += this._textLines[i - 1].length + 1;
          }
        }
        else {
          break;
        }
      }
      lineLeftOffset = this._getLineLeftOffset(lineIndex);
      width = lineLeftOffset * this.scaleX;
      line = this._textLines[lineIndex];
      for (var j = 0, jlen = line.length; j < jlen; j++) {
        prevWidth = width;
        // i removed something about flipX here, check.
        width += this.__charBounds[lineIndex][j].kernedWidth * this.scaleX;
        if (width <= mouseOffset.x) {
          charIndex++;
        }
        else {
          break;
        }
      }
      return this._getNewSelectionStartFromOffset(mouseOffset, prevWidth, width, charIndex, jlen);
    },

    /**
     * @private
     */
    _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {
      // we need Math.abs because when width is after the last char, the offset is given as 1, while is 0
      var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth,
          distanceBtwNextCharAndCursor = width - mouseOffset.x,
          offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor ||
            distanceBtwNextCharAndCursor < 0 ? 0 : 1,
          newSelectionStart = index + offset;
      // if object is horizontally flipped, mirror cursor location from the end
      if (this.flipX) {
        newSelectionStart = jlen - newSelectionStart;
      }

      if (newSelectionStart > this._text.length) {
        newSelectionStart = this._text.length;
      }

      return newSelectionStart;
    }
  });


  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {

    /**
     * Initializes hidden textarea (needed to bring up keyboard in iOS)
     */
    initHiddenTextarea: function() {
      this.hiddenTextarea = fabric.document.createElement('textarea');
      this.hiddenTextarea.setAttribute('autocapitalize', 'off');
      this.hiddenTextarea.setAttribute('autocorrect', 'off');
      this.hiddenTextarea.setAttribute('autocomplete', 'off');
      this.hiddenTextarea.setAttribute('spellcheck', 'false');
      this.hiddenTextarea.setAttribute('data-fabric-hiddentextarea', '');
      this.hiddenTextarea.setAttribute('wrap', 'off');
      var style = this._calcTextareaPosition();
      this.hiddenTextarea.style.cssText = 'position: absolute; top: ' + style.top +
      '; left: ' + style.left + '; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px;' +
      ' line-height: 1px; paddingｰtop: ' + style.fontSize + ';';
      fabric.document.body.appendChild(this.hiddenTextarea);

      fabric.util.addListener(this.hiddenTextarea, 'keydown', this.onKeyDown.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'keyup', this.onKeyUp.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'input', this.onInput.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'copy', this.copy.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'cut', this.copy.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'paste', this.paste.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'compositionstart', this.onCompositionStart.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'compositionupdate', this.onCompositionUpdate.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'compositionend', this.onCompositionEnd.bind(this));

      if (!this._clickHandlerInitialized && this.canvas) {
        fabric.util.addListener(this.canvas.upperCanvasEl, 'click', this.onClick.bind(this));
        this._clickHandlerInitialized = true;
      }
    },

    /**
     * For functionalities on keyDown
     * Map a special key to a function of the instance/prototype
     * If you need different behaviour for ESC or TAB or arrows, you have to change
     * this map setting the name of a function that you build on the fabric.Itext or
     * your prototype.
     * the map change will affect all Instances unless you need for only some text Instances
     * in that case you have to clone this object and assign your Instance.
     * this.keysMap = fabric.util.object.clone(this.keysMap);
     * The function must be in fabric.Itext.prototype.myFunction And will receive event as args[0]
     */
    keysMap: {
      9:  'exitEditing',
      27: 'exitEditing',
      33: 'moveCursorUp',
      34: 'moveCursorDown',
      35: 'moveCursorRight',
      36: 'moveCursorLeft',
      37: 'moveCursorLeft',
      38: 'moveCursorUp',
      39: 'moveCursorRight',
      40: 'moveCursorDown',
    },

    /**
     * For functionalities on keyUp + ctrl || cmd
     */
    ctrlKeysMapUp: {
      67: 'copy',
      88: 'cut'
    },

    /**
     * For functionalities on keyDown + ctrl || cmd
     */
    ctrlKeysMapDown: {
      65: 'selectAll'
    },

    onClick: function() {
      // No need to trigger click event here, focus is enough to have the keyboard appear on Android
      this.hiddenTextarea && this.hiddenTextarea.focus();
    },

    /**
     * Handles keyup event
     * @param {Event} e Event object
     */
    onKeyDown: function(e) {
      if (!this.isEditing || this.inCompositionMode) {
        return;
      }
      if (e.keyCode in this.keysMap) {
        this[this.keysMap[e.keyCode]](e);
      }
      else if ((e.keyCode in this.ctrlKeysMapDown) && (e.ctrlKey || e.metaKey)) {
        this[this.ctrlKeysMapDown[e.keyCode]](e);
      }
      else {
        return;
      }
      e.stopImmediatePropagation();
      e.preventDefault();
      if (e.keyCode >= 33 && e.keyCode <= 40) {
        // if i press an arrow key just update selection
        this.clearContextTop();
        this.renderCursorOrSelection();
      }
      else {
        this.canvas && this.canvas.requestRenderAll();
      }
    },

    /**
     * Handles keyup event
     * We handle KeyUp because ie11 and edge have difficulties copy/pasting
     * if a copy/cut event fired, keyup is dismissed
     * @param {Event} e Event object
     */
    onKeyUp: function(e) {
      if (!this.isEditing || this._copyDone || this.inCompositionMode) {
        this._copyDone = false;
        return;
      }
      if ((e.keyCode in this.ctrlKeysMapUp) && (e.ctrlKey || e.metaKey)) {
        this[this.ctrlKeysMapUp[e.keyCode]](e);
      }
      else {
        return;
      }
      e.stopImmediatePropagation();
      e.preventDefault();
      this.canvas && this.canvas.requestRenderAll();
    },

    /**
     * Handles onInput event
     * @param {Event} e Event object
     */
    onInput: function(e) {
      var fromPaste = this.fromPaste;
      this.fromPaste = false;
      e && e.stopPropagation();
      if (!this.isEditing) {
        return;
      }
      // decisions about style changes.
      var nextText = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText,
          charCount = this._text.length,
          nextCharCount = nextText.length,
          removedText, insertedText,
          charDiff = nextCharCount - charCount;
      if (this.hiddenTextarea.value === '') {
        this.styles = { };
        this.updateFromTextArea();
        this.fire('changed');
        if (this.canvas) {
          this.canvas.fire('text:changed', { target: this });
          this.canvas.requestRenderAll();
        }
        return;
      }

      var textareaSelection = this.fromStringToGraphemeSelection(
        this.hiddenTextarea.selectionStart,
        this.hiddenTextarea.selectionEnd,
        this.hiddenTextarea.value
      );
      var backDelete = this.selectionStart > textareaSelection.selectionStart;

      if (this.selectionStart !== this.selectionEnd) {
        removedText = this._text.slice(this.selectionStart, this.selectionEnd);
        charDiff += this.selectionEnd - this.selectionStart;
      }
      else if (nextCharCount < charCount) {
        if (backDelete) {
          removedText = this._text.slice(this.selectionEnd + charDiff, this.selectionEnd);
        }
        else {
          removedText = this._text.slice(this.selectionStart, this.selectionStart - charDiff);
        }
      }
      insertedText = nextText.slice(textareaSelection.selectionEnd - charDiff, textareaSelection.selectionEnd);
      if (removedText && removedText.length) {
        if (this.selectionStart !== this.selectionEnd) {
          this.removeStyleFromTo(this.selectionStart, this.selectionEnd);
        }
        else if (backDelete) {
          // detect differencies between forwardDelete and backDelete
          this.removeStyleFromTo(this.selectionEnd - removedText.length, this.selectionEnd);
        }
        else {
          this.removeStyleFromTo(this.selectionEnd, this.selectionEnd + removedText.length);
        }
      }
      if (insertedText.length) {
        if (fromPaste && insertedText.join('') === fabric.copiedText) {
          this.insertNewStyleBlock(insertedText, this.selectionStart, fabric.copiedTextStyle);
        }
        else {
          this.insertNewStyleBlock(insertedText, this.selectionStart);
        }
      }
      this.updateFromTextArea();
      this.fire('changed');
      if (this.canvas) {
        this.canvas.fire('text:changed', { target: this });
        this.canvas.requestRenderAll();
      }
    },
    /**
     * Composition start
     */
    onCompositionStart: function() {
      this.inCompositionMode = true;
    },

    /**
     * Composition end
     */
    onCompositionEnd: function() {
      this.inCompositionMode = false;
    },

    // /**
    //  * Composition update
    //  */
    onCompositionUpdate: function(e) {
      this.compositionStart = e.target.selectionStart;
      this.compositionEnd = e.target.selectionEnd;
      this.updateTextareaPosition();
    },

    /**
     * Copies selected text
     * @param {Event} e Event object
     */
    copy: function() {
      if (this.selectionStart === this.selectionEnd) {
        //do not cut-copy if no selection
        return;
      }

      fabric.copiedText = this.getSelectedText();
      fabric.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, true);
      this._copyDone = true;
    },

    /**
     * Pastes text
     * @param {Event} e Event object
     */
    paste: function() {
      this.fromPaste = true;
    },

    /**
     * @private
     * @param {Event} e Event object
     * @return {Object} Clipboard data object
     */
    _getClipboardData: function(e) {
      return (e && e.clipboardData) || fabric.window.clipboardData;
    },

    /**
     * Finds the width in pixels before the cursor on the same line
     * @private
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @return {Number} widthBeforeCursor width before cursor
     */
    _getWidthBeforeCursor: function(lineIndex, charIndex) {
      var widthBeforeCursor = this._getLineLeftOffset(lineIndex), bound;

      if (charIndex > 0) {
        bound = this.__charBounds[lineIndex][charIndex - 1];
        widthBeforeCursor += bound.left + bound.width;
      }
      return widthBeforeCursor;
    },

    /**
     * Gets start offset of a selection
     * @param {Event} e Event object
     * @param {Boolean} isRight
     * @return {Number}
     */
    getDownCursorOffset: function(e, isRight) {
      var selectionProp = this._getSelectionForOffset(e, isRight),
          cursorLocation = this.get2DCursorLocation(selectionProp),
          lineIndex = cursorLocation.lineIndex;
      // if on last line, down cursor goes to end of line
      if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {
        // move to the end of a text
        return this._text.length - selectionProp;
      }
      var charIndex = cursorLocation.charIndex,
          widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
          indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor),
          textAfterCursor = this._textLines[lineIndex].slice(charIndex);
      return textAfterCursor.length + indexOnOtherLine + 2;
    },

    /**
     * private
     * Helps finding if the offset should be counted from Start or End
     * @param {Event} e Event object
     * @param {Boolean} isRight
     * @return {Number}
     */
    _getSelectionForOffset: function(e, isRight) {
      if (e.shiftKey && this.selectionStart !== this.selectionEnd && isRight) {
        return this.selectionEnd;
      }
      else {
        return this.selectionStart;
      }
    },

    /**
     * @param {Event} e Event object
     * @param {Boolean} isRight
     * @return {Number}
     */
    getUpCursorOffset: function(e, isRight) {
      var selectionProp = this._getSelectionForOffset(e, isRight),
          cursorLocation = this.get2DCursorLocation(selectionProp),
          lineIndex = cursorLocation.lineIndex;
      if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {
        // if on first line, up cursor goes to start of line
        return -selectionProp;
      }
      var charIndex = cursorLocation.charIndex,
          widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
          indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor),
          textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex);
      // return a negative offset
      return -this._textLines[lineIndex - 1].length + indexOnOtherLine - textBeforeCursor.length;
    },

    /**
     * for a given width it founds the matching character.
     * @private
     */
    _getIndexOnLine: function(lineIndex, width) {

      var line = this._textLines[lineIndex],
          lineLeftOffset = this._getLineLeftOffset(lineIndex),
          widthOfCharsOnLine = lineLeftOffset,
          indexOnLine = 0, charWidth, foundMatch;

      for (var j = 0, jlen = line.length; j < jlen; j++) {
        charWidth = this.__charBounds[lineIndex][j].width;
        widthOfCharsOnLine += charWidth;
        if (widthOfCharsOnLine > width) {
          foundMatch = true;
          var leftEdge = widthOfCharsOnLine - charWidth,
              rightEdge = widthOfCharsOnLine,
              offsetFromLeftEdge = Math.abs(leftEdge - width),
              offsetFromRightEdge = Math.abs(rightEdge - width);

          indexOnLine = offsetFromRightEdge < offsetFromLeftEdge ? j : (j - 1);
          break;
        }
      }

      // reached end
      if (!foundMatch) {
        indexOnLine = line.length - 1;
      }

      return indexOnLine;
    },


    /**
     * Moves cursor down
     * @param {Event} e Event object
     */
    moveCursorDown: function(e) {
      if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
        return;
      }
      this._moveCursorUpOrDown('Down', e);
    },

    /**
     * Moves cursor up
     * @param {Event} e Event object
     */
    moveCursorUp: function(e) {
      if (this.selectionStart === 0 && this.selectionEnd === 0) {
        return;
      }
      this._moveCursorUpOrDown('Up', e);
    },

    /**
     * Moves cursor up or down, fires the events
     * @param {String} direction 'Up' or 'Down'
     * @param {Event} e Event object
     */
    _moveCursorUpOrDown: function(direction, e) {
      // getUpCursorOffset
      // getDownCursorOffset
      var action = 'get' + direction + 'CursorOffset',
          offset = this[action](e, this._selectionDirection === 'right');
      if (e.shiftKey) {
        this.moveCursorWithShift(offset);
      }
      else {
        this.moveCursorWithoutShift(offset);
      }
      if (offset !== 0) {
        this.setSelectionInBoundaries();
        this.abortCursorAnimation();
        this._currentCursorOpacity = 1;
        this.initDelayedCursor();
        this._fireSelectionChanged();
        this._updateTextarea();
      }
    },

    /**
     * Moves cursor with shift
     * @param {Number} offset
     */
    moveCursorWithShift: function(offset) {
      var newSelection = this._selectionDirection === 'left'
        ? this.selectionStart + offset
        : this.selectionEnd + offset;
      this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, newSelection);
      return offset !== 0;
    },

    /**
     * Moves cursor up without shift
     * @param {Number} offset
     */
    moveCursorWithoutShift: function(offset) {
      if (offset < 0) {
        this.selectionStart += offset;
        this.selectionEnd = this.selectionStart;
      }
      else {
        this.selectionEnd += offset;
        this.selectionStart = this.selectionEnd;
      }
      return offset !== 0;
    },

    /**
     * Moves cursor left
     * @param {Event} e Event object
     */
    moveCursorLeft: function(e) {
      if (this.selectionStart === 0 && this.selectionEnd === 0) {
        return;
      }
      this._moveCursorLeftOrRight('Left', e);
    },

    /**
     * @private
     * @return {Boolean} true if a change happened
     */
    _move: function(e, prop, direction) {
      var newValue;
      if (e.altKey) {
        newValue = this['findWordBoundary' + direction](this[prop]);
      }
      else if (e.metaKey || e.keyCode === 35 ||  e.keyCode === 36 ) {
        newValue = this['findLineBoundary' + direction](this[prop]);
      }
      else {
        this[prop] += direction === 'Left' ? -1 : 1;
        return true;
      }
      if (typeof newValue !== undefined && this[prop] !== newValue) {
        this[prop] = newValue;
        return true;
      }
    },

    /**
     * @private
     */
    _moveLeft: function(e, prop) {
      return this._move(e, prop, 'Left');
    },

    /**
     * @private
     */
    _moveRight: function(e, prop) {
      return this._move(e, prop, 'Right');
    },

    /**
     * Moves cursor left without keeping selection
     * @param {Event} e
     */
    moveCursorLeftWithoutShift: function(e) {
      var change = true;
      this._selectionDirection = 'left';

      // only move cursor when there is no selection,
      // otherwise we discard it, and leave cursor on same place
      if (this.selectionEnd === this.selectionStart && this.selectionStart !== 0) {
        change = this._moveLeft(e, 'selectionStart');

      }
      this.selectionEnd = this.selectionStart;
      return change;
    },

    /**
     * Moves cursor left while keeping selection
     * @param {Event} e
     */
    moveCursorLeftWithShift: function(e) {
      if (this._selectionDirection === 'right' && this.selectionStart !== this.selectionEnd) {
        return this._moveLeft(e, 'selectionEnd');
      }
      else if (this.selectionStart !== 0){
        this._selectionDirection = 'left';
        return this._moveLeft(e, 'selectionStart');
      }
    },

    /**
     * Moves cursor right
     * @param {Event} e Event object
     */
    moveCursorRight: function(e) {
      if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
        return;
      }
      this._moveCursorLeftOrRight('Right', e);
    },

    /**
     * Moves cursor right or Left, fires event
     * @param {String} direction 'Left', 'Right'
     * @param {Event} e Event object
     */
    _moveCursorLeftOrRight: function(direction, e) {
      var actionName = 'moveCursor' + direction + 'With';
      this._currentCursorOpacity = 1;

      if (e.shiftKey) {
        actionName += 'Shift';
      }
      else {
        actionName += 'outShift';
      }
      if (this[actionName](e)) {
        this.abortCursorAnimation();
        this.initDelayedCursor();
        this._fireSelectionChanged();
        this._updateTextarea();
      }
    },

    /**
     * Moves cursor right while keeping selection
     * @param {Event} e
     */
    moveCursorRightWithShift: function(e) {
      if (this._selectionDirection === 'left' && this.selectionStart !== this.selectionEnd) {
        return this._moveRight(e, 'selectionStart');
      }
      else if (this.selectionEnd !== this._text.length) {
        this._selectionDirection = 'right';
        return this._moveRight(e, 'selectionEnd');
      }
    },

    /**
     * Moves cursor right without keeping selection
     * @param {Event} e Event object
     */
    moveCursorRightWithoutShift: function(e) {
      var changed = true;
      this._selectionDirection = 'right';

      if (this.selectionStart === this.selectionEnd) {
        changed = this._moveRight(e, 'selectionStart');
        this.selectionEnd = this.selectionStart;
      }
      else {
        this.selectionStart = this.selectionEnd;
      }
      return changed;
    },

    /**
     * Removes characters from start/end
     * start/end ar per grapheme position in _text array.
     *
     * @param {Number} start
     * @param {Number} end default to start + 1
     */
    removeChars: function(start, end) {
      if (typeof end === 'undefined') {
        end = start + 1;
      }
      this.removeStyleFromTo(start, end);
      this._text.splice(start, end - start);
      this.text = this._text.join('');
      this.set('dirty', true);
      if (this._shouldClearDimensionCache()) {
        this.initDimensions();
        this.setCoords();
      }
      this._removeExtraneousStyles();
    },

    /**
     * insert characters at start position, before start position.
     * start  equal 1 it means the text get inserted between actual grapheme 0 and 1
     * if style array is provided, it must be as the same length of text in graphemes
     * if end is provided and is bigger than start, old text is replaced.
     * start/end ar per grapheme position in _text array.
     *
     * @param {String} text text to insert
     * @param {Array} style array of style objects
     * @param {Number} start
     * @param {Number} end default to start + 1
     */
    insertChars: function(text, style, start, end) {
      if (typeof end === 'undefined') {
        end = start;
      }
      if (end > start) {
        this.removeStyleFromTo(start, end);
      }
      var graphemes = fabric.util.string.graphemeSplit(text);
      this.insertNewStyleBlock(graphemes, start, style);
      this._text = [].concat(this._text.slice(0, start), graphemes, this._text.slice(end));
      this.text = this._text.join('');
      this.set('dirty', true);
      if (this._shouldClearDimensionCache()) {
        this.initDimensions();
        this.setCoords();
      }
      this._removeExtraneousStyles();
    },

  });


  /* _TO_SVG_START_ */
  (function() {
    var toFixed = fabric.util.toFixed,
        multipleSpacesRegex = /  +/g;

    fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {

      /**
       * Returns SVG representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        var markup = this._createBaseSVGMarkup(),
            offsets = this._getSVGLeftTopOffsets(),
            textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);
        this._wrapSVGTextAndBg(markup, textAndBg);

        return reviver ? reviver(markup.join('')) : markup.join('');
      },

      /**
       * @private
       */
      _getSVGLeftTopOffsets: function() {
        return {
          textLeft: -this.width / 2,
          textTop: -this.height / 2,
          lineTop: this.getHeightOfLine(0)
        };
      },

      /**
       * @private
       */
      _wrapSVGTextAndBg: function(markup, textAndBg) {
        var noShadow = true, filter = this.getSvgFilter(),
            style = filter === '' ? '' : ' style="' + filter + '"',
            textDecoration = this.getSvgTextDecoration(this);
        markup.push(
          '\t<g ', this.getSvgId(), 'transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '"',
          style, '>\n',
          textAndBg.textBgRects.join(''),
          '\t\t<text xml:space="preserve" ',
          (this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, '\'') + '" ' : ''),
          (this.fontSize ? 'font-size="' + this.fontSize + '" ' : ''),
          (this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : ''),
          (this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : ''),
          (textDecoration ? 'text-decoration="' + textDecoration + '" ' : ''),
          'style="', this.getSvgStyles(noShadow), '"', this.addPaintOrder(), ' >',
          textAndBg.textSpans.join(''),
          '</text>\n',
          '\t</g>\n'
        );
      },

      /**
       * @private
       * @param {Number} textTopOffset Text top offset
       * @param {Number} textLeftOffset Text left offset
       * @return {Object}
       */
      _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {
        var textSpans = [],
            textBgRects = [],
            height = textTopOffset, lineOffset;
        // bounding-box background
        this._setSVGBg(textBgRects);

        // text and text-background
        for (var i = 0, len = this._textLines.length; i < len; i++) {
          lineOffset = this._getLineLeftOffset(i);
          if (this.textBackgroundColor || this.styleHas('textBackgroundColor', i)) {
            this._setSVGTextLineBg(textBgRects, i, textLeftOffset + lineOffset, height);
          }
          this._setSVGTextLineText(textSpans, i, textLeftOffset + lineOffset, height);
          height += this.getHeightOfLine(i);
        }

        return {
          textSpans: textSpans,
          textBgRects: textBgRects
        };
      },

      /**
       * @private
       */
      _createTextCharSpan: function(_char, styleDecl, left, top) {
        var shouldUseWhitespace = _char !== _char.trim() || _char.match(multipleSpacesRegex),
            styleProps = this.getSvgSpanStyles(styleDecl, shouldUseWhitespace),
            fillStyles = styleProps ? 'style="' + styleProps + '"' : '',
            dy = styleDecl.deltaY, dySpan = '',
            NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
        if (dy) {
          dySpan = ' dy="' + toFixed(dy, NUM_FRACTION_DIGITS) + '" ';
        }
        return [
          '<tspan x="', toFixed(left, NUM_FRACTION_DIGITS), '" y="',
          toFixed(top, NUM_FRACTION_DIGITS), '" ', dySpan,
          fillStyles, '>',
          fabric.util.string.escapeXml(_char),
          '</tspan>'
        ].join('');
      },

      _setSVGTextLineText: function(textSpans, lineIndex, textLeftOffset, textTopOffset) {
        // set proper line offset
        var lineHeight = this.getHeightOfLine(lineIndex),
            isJustify = this.textAlign.indexOf('justify') !== -1,
            actualStyle,
            nextStyle,
            charsToRender = '',
            charBox, style,
            boxWidth = 0,
            line = this._textLines[lineIndex],
            timeToRender;

        textTopOffset += lineHeight * (1 - this._fontSizeFraction) / this.lineHeight;
        for (var i = 0, len = line.length - 1; i <= len; i++) {
          timeToRender = i === len || this.charSpacing;
          charsToRender += line[i];
          charBox = this.__charBounds[lineIndex][i];
          if (boxWidth === 0) {
            textLeftOffset += charBox.kernedWidth - charBox.width;
            boxWidth += charBox.width;
          }
          else {
            boxWidth += charBox.kernedWidth;
          }
          if (isJustify && !timeToRender) {
            if (this._reSpaceAndTab.test(line[i])) {
              timeToRender = true;
            }
          }
          if (!timeToRender) {
            // if we have charSpacing, we render char by char
            actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);
            nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);
            timeToRender = this._hasStyleChangedForSvg(actualStyle, nextStyle);
          }
          if (timeToRender) {
            style = this._getStyleDeclaration(lineIndex, i) || { };
            textSpans.push(this._createTextCharSpan(charsToRender, style, textLeftOffset, textTopOffset));
            charsToRender = '';
            actualStyle = nextStyle;
            textLeftOffset += boxWidth;
            boxWidth = 0;
          }
        }
      },

      _pushTextBgRect: function(textBgRects, color, left, top, width, height) {
        var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
        textBgRects.push(
          '\t\t<rect ',
          this._getFillAttributes(color),
          ' x="',
          toFixed(left, NUM_FRACTION_DIGITS),
          '" y="',
          toFixed(top, NUM_FRACTION_DIGITS),
          '" width="',
          toFixed(width, NUM_FRACTION_DIGITS),
          '" height="',
          toFixed(height, NUM_FRACTION_DIGITS),
          '"></rect>\n');
      },

      _setSVGTextLineBg: function(textBgRects, i, leftOffset, textTopOffset) {
        var line = this._textLines[i],
            heightOfLine = this.getHeightOfLine(i) / this.lineHeight,
            boxWidth = 0,
            boxStart = 0,
            charBox, currentColor,
            lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');
        for (var j = 0, jlen = line.length; j < jlen; j++) {
          charBox = this.__charBounds[i][j];
          currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');
          if (currentColor !== lastColor) {
            lastColor && this._pushTextBgRect(textBgRects, lastColor, leftOffset + boxStart,
              textTopOffset, boxWidth, heightOfLine);
            boxStart = charBox.left;
            boxWidth = charBox.width;
            lastColor = currentColor;
          }
          else {
            boxWidth += charBox.kernedWidth;
          }
        }
        currentColor && this._pushTextBgRect(textBgRects, currentColor, leftOffset + boxStart,
          textTopOffset, boxWidth, heightOfLine);
      },

      /**
       * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values
       * we work around it by "moving" alpha channel into opacity attribute and setting fill's alpha to 1
       *
       * @private
       * @param {*} value
       * @return {String}
       */
      _getFillAttributes: function(value) {
        var fillColor = (value && typeof value === 'string') ? new fabric.Color(value) : '';
        if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {
          return 'fill="' + value + '"';
        }
        return 'opacity="' + fillColor.getAlpha() + '" fill="' + fillColor.setAlpha(1).toRgb() + '"';
      },

      /**
       * @private
       */
      _getSVGLineTopOffset: function(lineIndex) {
        var lineTopOffset = 0, lastHeight = 0;
        for (var j = 0; j < lineIndex; j++) {
          lineTopOffset += this.getHeightOfLine(j);
        }
        lastHeight = this.getHeightOfLine(j);
        return {
          lineTop: lineTopOffset,
          offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)
        };
      },

      /**
       * Returns styles-string for svg-export
       * @param {Boolean} skipShadow a boolean to skip shadow filter output
       * @return {String}
       */
      getSvgStyles: function(skipShadow) {
        var svgStyle = fabric.Object.prototype.getSvgStyles.call(this, skipShadow);
        return svgStyle + ' white-space: pre;';
      },
    });
  })();
  /* _TO_SVG_END_ */


  (function(global) {

    var fabric = global.fabric || (global.fabric = {});

    /**
     * Textbox class, based on IText, allows the user to resize the text rectangle
     * and wraps lines automatically. Textboxes have their Y scaling locked, the
     * user can only change width. Height is adjusted automatically based on the
     * wrapping of lines.
     * @class fabric.Textbox
     * @extends fabric.IText
     * @mixes fabric.Observable
     * @return {fabric.Textbox} thisArg
     * @see {@link fabric.Textbox#initialize} for constructor definition
     */
    fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'textbox',

      /**
       * Minimum width of textbox, in pixels.
       * @type Number
       * @default
       */
      minWidth: 20,

      /**
       * Minimum calculated width of a textbox, in pixels.
       * fixed to 2 so that an empty textbox cannot go to 0
       * and is still selectable without text.
       * @type Number
       * @default
       */
      dynamicMinWidth: 2,

      /**
       * Cached array of text wrapping.
       * @type Array
       */
      __cachedLines: null,

      /**
       * Override standard Object class values
       */
      lockScalingFlip: true,

      /**
       * Override standard Object class values
       * Textbox needs this on false
       */
      noScaleCache: false,

      /**
       * Properties which when set cause object to change dimensions
       * @type Object
       * @private
       */
      _dimensionAffectingProps: fabric.Text.prototype._dimensionAffectingProps.concat('width'),

      /**
       * Unlike superclass's version of this function, Textbox does not update
       * its width.
       * @private
       * @override
       */
      initDimensions: function() {
        if (this.__skipDimension) {
          return;
        }
        this.isEditing && this.initDelayedCursor();
        this.clearContextTop();
        this._clearCache();
        // clear dynamicMinWidth as it will be different after we re-wrap line
        this.dynamicMinWidth = 0;
        // wrap lines
        this._styleMap = this._generateStyleMap(this._splitText());
        // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap
        if (this.dynamicMinWidth > this.width) {
          this._set('width', this.dynamicMinWidth);
        }
        if (this.textAlign.indexOf('justify') !== -1) {
          // once text is measured we need to make space fatter to make justified text.
          this.enlargeSpaces();
        }
        // clear cache and re-calculate height
        this.height = this.calcTextHeight();
        this.saveState({ propertySet: '_dimensionAffectingProps' });
      },

      /**
       * Generate an object that translates the style object so that it is
       * broken up by visual lines (new lines and automatic wrapping).
       * The original text styles object is broken up by actual lines (new lines only),
       * which is only sufficient for Text / IText
       * @private
       */
      _generateStyleMap: function(textInfo) {
        var realLineCount     = 0,
            realLineCharCount = 0,
            charCount         = 0,
            map               = {};

        for (var i = 0; i < textInfo.graphemeLines.length; i++) {
          if (textInfo.graphemeText[charCount] === '\n' && i > 0) {
            realLineCharCount = 0;
            charCount++;
            realLineCount++;
          }
          else if (this._reSpaceAndTab.test(textInfo.graphemeText[charCount]) && i > 0) {
            // this case deals with space's that are removed from end of lines when wrapping
            realLineCharCount++;
            charCount++;
          }

          map[i] = { line: realLineCount, offset: realLineCharCount };

          charCount += textInfo.graphemeLines[i].length;
          realLineCharCount += textInfo.graphemeLines[i].length;
        }

        return map;
      },

      /**
       * Returns true if object has a style property or has it ina specified line
       * @param {Number} lineIndex
       * @return {Boolean}
       */
      styleHas: function(property, lineIndex) {
        if (this._styleMap && !this.isWrapping) {
          var map = this._styleMap[lineIndex];
          if (map) {
            lineIndex = map.line;
          }
        }
        return fabric.Text.prototype.styleHas.call(this, property, lineIndex);
      },

      /**
       * Returns true if object has no styling or no styling in a line
       * @param {Number} lineIndex , lineIndex is on wrapped lines.
       * @return {Boolean}
       */
      isEmptyStyles: function(lineIndex) {
        var offset = 0, nextLineIndex = lineIndex + 1, nextOffset, obj, shouldLimit = false;
        var map = this._styleMap[lineIndex];
        var mapNextLine = this._styleMap[lineIndex + 1];
        if (map) {
          lineIndex = map.line;
          offset = map.offset;
        }
        if (mapNextLine) {
          nextLineIndex = mapNextLine.line;
          shouldLimit = nextLineIndex === lineIndex;
          nextOffset = mapNextLine.offset;
        }
        obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };
        for (var p1 in obj) {
          for (var p2 in obj[p1]) {
            if (p2 >= offset && (!shouldLimit || p2 < nextOffset)) {
              // eslint-disable-next-line no-unused-vars
              for (var p3 in obj[p1][p2]) {
                return false;
              }
            }
          }
        }
        return true;
      },

      /**
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @private
       */
      _getStyleDeclaration: function(lineIndex, charIndex) {
        if (this._styleMap && !this.isWrapping) {
          var map = this._styleMap[lineIndex];
          if (!map) {
            return null;
          }
          lineIndex = map.line;
          charIndex = map.offset + charIndex;
        }
        return this.callSuper('_getStyleDeclaration', lineIndex, charIndex);
      },

      /**
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @param {Object} style
       * @private
       */
      _setStyleDeclaration: function(lineIndex, charIndex, style) {
        var map = this._styleMap[lineIndex];
        lineIndex = map.line;
        charIndex = map.offset + charIndex;

        this.styles[lineIndex][charIndex] = style;
      },

      /**
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @private
       */
      _deleteStyleDeclaration: function(lineIndex, charIndex) {
        var map = this._styleMap[lineIndex];
        lineIndex = map.line;
        charIndex = map.offset + charIndex;

        delete this.styles[lineIndex][charIndex];
      },

      /**
      * probably broken need a fix
       * @param {Number} lineIndex
       * @private
       */
      _getLineStyle: function(lineIndex) {
        var map = this._styleMap[lineIndex];
        return this.styles[map.line];
      },

      /**
       * probably broken need a fix
       * @param {Number} lineIndex
       * @param {Object} style
       * @private
       */
      _setLineStyle: function(lineIndex, style) {
        var map = this._styleMap[lineIndex];
        this.styles[map.line] = style;
      },

      /**
       * probably broken need a fix
       * @param {Number} lineIndex
       * @private
       */
      _deleteLineStyle: function(lineIndex) {
        var map = this._styleMap[lineIndex];
        delete this.styles[map.line];
      },

      /**
       * Wraps text using the 'width' property of Textbox. First this function
       * splits text on newlines, so we preserve newlines entered by the user.
       * Then it wraps each line using the width of the Textbox by calling
       * _wrapLine().
       * @param {Array} lines The string array of text that is split into lines
       * @param {Number} desiredWidth width you want to wrap to
       * @returns {Array} Array of lines
       */
      _wrapText: function(lines, desiredWidth) {
        var wrapped = [], i;
        this.isWrapping = true;
        for (i = 0; i < lines.length; i++) {
          wrapped = wrapped.concat(this._wrapLine(lines[i], i, desiredWidth));
        }
        this.isWrapping = false;
        return wrapped;
      },

      /**
       * Helper function to measure a string of text, given its lineIndex and charIndex offset
       * it gets called when charBounds are not available yet.
       * @param {CanvasRenderingContext2D} ctx
       * @param {String} text
       * @param {number} lineIndex
       * @param {number} charOffset
       * @returns {number}
       * @private
       */
      _measureWord: function(word, lineIndex, charOffset) {
        var width = 0, prevGrapheme, skipLeft = true;
        charOffset = charOffset || 0;
        for (var i = 0, len = word.length; i < len; i++) {
          var box = this._getGraphemeBox(word[i], lineIndex, i + charOffset, prevGrapheme, skipLeft);
          width += box.kernedWidth;
          prevGrapheme = word[i];
        }
        return width;
      },

      /**
       * Wraps a line of text using the width of the Textbox and a context.
       * @param {Array} line The grapheme array that represent the line
       * @param {Number} lineIndex
       * @param {Number} desiredWidth width you want to wrap the line to
       * @param {Number} reservedSpace space to remove from wrapping for custom functionalities
       * @returns {Array} Array of line(s) into which the given text is wrapped
       * to.
       */
      _wrapLine: function(_line, lineIndex, desiredWidth, reservedSpace) {
        var lineWidth        = 0,
            graphemeLines    = [],
            line             = [],
            // spaces in different languges?
            words            = _line.split(this._reSpaceAndTab),
            word             = '',
            offset           = 0,
            infix            = ' ',
            wordWidth        = 0,
            infixWidth       = 0,
            largestWordWidth = 0,
            lineJustStarted = true,
            additionalSpace = this._getWidthOfCharSpacing(),
            reservedSpace = reservedSpace || 0;

        desiredWidth -= reservedSpace;
        for (var i = 0; i < words.length; i++) {
          // i would avoid resplitting the graphemes
          word = fabric.util.string.graphemeSplit(words[i]);
          wordWidth = this._measureWord(word, lineIndex, offset);
          offset += word.length;

          lineWidth += infixWidth + wordWidth - additionalSpace;

          if (lineWidth >= desiredWidth && !lineJustStarted) {
            graphemeLines.push(line);
            line = [];
            lineWidth = wordWidth;
            lineJustStarted = true;
          }
          else {
            lineWidth += additionalSpace;
          }

          if (!lineJustStarted) {
            line.push(infix);
          }
          line = line.concat(word);

          infixWidth = this._measureWord([infix], lineIndex, offset);
          offset++;
          lineJustStarted = false;
          // keep track of largest word
          if (wordWidth > largestWordWidth) {
            largestWordWidth = wordWidth;
          }
        }

        i && graphemeLines.push(line);

        if (largestWordWidth + reservedSpace > this.dynamicMinWidth) {
          this.dynamicMinWidth = largestWordWidth - additionalSpace + reservedSpace;
        }

        return graphemeLines;
      },

      /**
       * Detect if the text line is ended with an hard break
       * text and itext do not have wrapping, return false
       * @param {Number} lineIndex text to split
       * @return {Boolean}
       */
      isEndOfWrapping: function(lineIndex) {
        if (!this._styleMap[lineIndex + 1]) {
          // is last line, return true;
          return true;
        }
        if (this._styleMap[lineIndex + 1].line !== this._styleMap[lineIndex].line) {
          // this is last line before a line break, return true;
          return true;
        }
        return false;
      },

      /**
      * Gets lines of text to render in the Textbox. This function calculates
      * text wrapping on the fly every time it is called.
      * @param {String} text text to split
      * @returns {Array} Array of lines in the Textbox.
      * @override
      */
      _splitTextIntoLines: function(text) {
        var newText = fabric.Text.prototype._splitTextIntoLines.call(this, text),
            graphemeLines = this._wrapText(newText.lines, this.width),
            lines = new Array(graphemeLines.length);

        for (var i = 0; i < graphemeLines.length; i++) {
          lines[i] = graphemeLines[i].join('');
        }
        newText.lines = lines;
        newText.graphemeLines = graphemeLines;
        return newText;
      },

      getMinWidth: function() {
        return Math.max(this.minWidth, this.dynamicMinWidth);
      },

      /**
       * Returns object representation of an instance
       * @method toObject
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        return this.callSuper('toObject', ['minWidth'].concat(propertiesToInclude));
      }
    });

    /**
     * Returns fabric.Textbox instance from an object representation
     * @static
     * @memberOf fabric.Textbox
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] Callback to invoke when an fabric.Textbox instance is created
     */
    fabric.Textbox.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Textbox', object, callback, 'text');
    };
  })(exports);


  (function() {

    /**
     * Override _setObjectScale and add Textbox specific resizing behavior. Resizing
     * a Textbox doesn't scale text, it only changes width and makes text wrap automatically.
     */
    var setObjectScaleOverridden = fabric.Canvas.prototype._setObjectScale;

    fabric.Canvas.prototype._setObjectScale = function(localMouse, transform,
      lockScalingX, lockScalingY, by, lockScalingFlip, _dim) {

      var t = transform.target;
      if (by === 'x' && t instanceof fabric.Textbox) {
        var tw = t._getTransformedDimensions().x;
        var w = t.width * (localMouse.x / tw);
        if (w >= t.getMinWidth()) {
          t.set('width', w);
          return true;
        }
      }
      else {
        return setObjectScaleOverridden.call(fabric.Canvas.prototype, localMouse, transform,
          lockScalingX, lockScalingY, by, lockScalingFlip, _dim);
      }
    };

    fabric.util.object.extend(fabric.Textbox.prototype, /** @lends fabric.IText.prototype */ {
      /**
       * @private
       */
      _removeExtraneousStyles: function() {
        for (var prop in this._styleMap) {
          if (!this._textLines[prop]) {
            delete this.styles[this._styleMap[prop].line];
          }
        }
      },

    });
  })();
  });
  var fabric_2 = fabric_1.fabric;

  var toolTypes = {
    SELECTOR: 0,
    CIRCLE: 1,
    TEXT: 2,
    PEN: 3,
    MARKPEN: 4,
    ERASER: 5
  };

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  var _freeGlobal = freeGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = _freeGlobal || freeSelf || Function('return this')();

  var _root = root;

  /** Built-in value references. */
  var Symbol$1 = _root.Symbol;

  var _Symbol = Symbol$1;

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  var _arrayMap = arrayMap;

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray$1 = Array.isArray;

  var isArray_1 = isArray$1;

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /** Built-in value references. */
  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
    } catch (e) {}

    var result = nativeObjectToString.call(value);
    {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }

  var _getRawTag = getRawTag;

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$1.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString$1.call(value);
  }

  var _objectToString = objectToString;

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag$1 && symToStringTag$1 in Object(value))
      ? _getRawTag(value)
      : _objectToString(value);
  }

  var _baseGetTag = baseGetTag;

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  var isObjectLike_1 = isObjectLike;

  /** `Object#toString` result references. */
  var symbolTag = '[object Symbol]';

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' ||
      (isObjectLike_1(value) && _baseGetTag(value) == symbolTag);
  }

  var isSymbol_1 = isSymbol;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0;

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = _Symbol ? _Symbol.prototype : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;

  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    if (isArray_1(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return _arrayMap(value, baseToString) + '';
    }
    if (isSymbol_1(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
  }

  var _baseToString = baseToString;

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString$1(value) {
    return value == null ? '' : _baseToString(value);
  }

  var toString_1 = toString$1;

  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : (length + start);
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : ((end - start) >>> 0);
    start >>>= 0;

    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }

  var _baseSlice = baseSlice;

  /**
   * Casts `array` to a slice if it's needed.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {number} start The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the cast slice.
   */
  function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return (!start && end >= length) ? array : _baseSlice(array, start, end);
  }

  var _castSlice = castSlice;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsVarRange = '\\ufe0e\\ufe0f';

  /** Used to compose unicode capture groups. */
  var rsZWJ = '\\u200d';

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  var _hasUnicode = hasUnicode;

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  var _asciiToArray = asciiToArray;

  /** Used to compose unicode character classes. */
  var rsAstralRange$1 = '\\ud800-\\udfff',
      rsComboMarksRange$1 = '\\u0300-\\u036f',
      reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
      rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
      rsVarRange$1 = '\\ufe0e\\ufe0f';

  /** Used to compose unicode capture groups. */
  var rsAstral = '[' + rsAstralRange$1 + ']',
      rsCombo = '[' + rsComboRange$1 + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange$1 + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsZWJ$1 = '\\u200d';

  /** Used to compose unicode regexes. */
  var reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange$1 + ']?',
      rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  var _unicodeToArray = unicodeToArray;

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return _hasUnicode(string)
      ? _unicodeToArray(string)
      : _asciiToArray(string);
  }

  var _stringToArray = stringToArray;

  /**
   * Creates a function like `_.lowerFirst`.
   *
   * @private
   * @param {string} methodName The name of the `String` case method to use.
   * @returns {Function} Returns the new case function.
   */
  function createCaseFirst(methodName) {
    return function(string) {
      string = toString_1(string);

      var strSymbols = _hasUnicode(string)
        ? _stringToArray(string)
        : undefined;

      var chr = strSymbols
        ? strSymbols[0]
        : string.charAt(0);

      var trailing = strSymbols
        ? _castSlice(strSymbols, 1).join('')
        : string.slice(1);

      return chr[methodName]() + trailing;
    };
  }

  var _createCaseFirst = createCaseFirst;

  /**
   * Converts the first character of `string` to upper case.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.upperFirst('fred');
   * // => 'Fred'
   *
   * _.upperFirst('FRED');
   * // => 'FRED'
   */
  var upperFirst = _createCaseFirst('toUpperCase');

  var upperFirst_1 = upperFirst;

  /**
   * Converts the first character of `string` to upper case and the remaining
   * to lower case.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to capitalize.
   * @returns {string} Returns the capitalized string.
   * @example
   *
   * _.capitalize('FRED');
   * // => 'Fred'
   */
  function capitalize(string) {
    return upperFirst_1(toString_1(string).toLowerCase());
  }

  var capitalize_1 = capitalize;

  /** Used to generate unique IDs. */
  var idCounter = 0;

  /**
   * Generates a unique ID. If `prefix` is given, the ID is appended to it.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {string} [prefix=''] The value to prefix the ID with.
   * @returns {string} Returns the unique ID.
   * @example
   *
   * _.uniqueId('contact_');
   * // => 'contact_104'
   *
   * _.uniqueId();
   * // => '105'
   */
  function uniqueId(prefix) {
    var id = ++idCounter;
    return toString_1(prefix) + id;
  }

  var uniqueId_1 = uniqueId;

  var pathEvents = [{
    origin: 'moving',
    instance: 'onMovingHandle'
  }, {
    origin: 'scaling',
    instance: 'onScalingHandle'
  }, {
    origin: 'rotating',
    instance: 'onRotatingHandle'
  }];

  var ToolBase =
  /*#__PURE__*/
  function () {
    function ToolBase(canvas, style) {
      _classCallCheck(this, ToolBase);

      this.cxt = canvas;
      this.style = style;
      this.isMouseDown = false;
      this.hasSelected = false;
      this.bindEvent();
    }

    _createClass(ToolBase, [{
      key: "bindEvent",
      value: function bindEvent() {// this.cxt.on('text:changed', ({
        //   target
        // }) => {
        //   console.log(target.text);
        // });
      }
    }, {
      key: "onMousedownHandle",
      value: function onMousedownHandle(event) {
        this.isMouseDown = true;
      }
    }, {
      key: "onMouseupHandle",
      value: function onMouseupHandle(event) {
        this.isMouseDown = false;
      }
    }, {
      key: "onMousemoveHandle",
      value: function onMousemoveHandle(event) {
        var _event$0$e = event[0].e,
            movementX = _event$0$e.movementX,
            movementY = _event$0$e.movementY;

        if (movementX < 0 && movementY < 0) {
          this.direction = 'leftTop';
        } else if (movementX < 0 && movementY > 0) {
          this.direction = 'leftBottom';
        } else if (movementX > 0 && movementY < 0) {
          this.direction = 'rightTop';
        } else if (movementX > 0 && movementY > 0) {
          this.direction = 'rightBottom';
        }

        if (this.isMouseDown) {
          this.onMouseDragHandle(event);
        }
      }
    }, {
      key: "onMouseDragHandle",
      value: function onMouseDragHandle(event) {}
    }, {
      key: "onMovingHandle",
      value: function onMovingHandle(e) {}
    }, {
      key: "onRotatingHandle",
      value: function onRotatingHandle(e) {}
    }, {
      key: "onScalingHandle",
      value: function onScalingHandle(e) {}
    }, {
      key: "renderPath",
      value: function renderPath(path) {
        var ignoreRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        if (!path) return;
        path.id = uniqueId_1('wbPath');
        path.toolType = this.toolType;
        !ignoreRender && this.cxt.add(path);
        this.bindEvent(path);
      }
    }, {
      key: "bindEvent",
      value: function bindEvent(path) {
        var _this = this;

        if (!path) return;
        pathEvents.forEach(function (event) {
          path.on(event.origin, _this[event.instance]);
        });
        path.on('selected', function (e) {
          _this.hasSelected = true;
          console.log(path);
          path.hasControls = true;
        });
        path.on('deselected', function (e) {
          _this.hasSelected = false;
          path.hasControls = false;
        });
      }
    }, {
      key: "selected",
      set: function set(selected) {
        this.toolActive = selected;
      }
    }]);

    return ToolBase;
  }();

  var Circle =
  /*#__PURE__*/
  function (_ToolBase) {
    _inherits(Circle, _ToolBase);

    function Circle() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, Circle);

      for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
        arg[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Circle)).call.apply(_getPrototypeOf2, [this].concat(arg)));
      _this.toolType = toolTypes.CIRCLE;
      return _this;
    }

    _createClass(Circle, [{
      key: "onMousedownHandle",
      value: function onMousedownHandle(event) {
        _get(_getPrototypeOf(Circle.prototype), "onMousedownHandle", this).call(this, event);

        this.downPointer = event[0].pointer;
      }
    }, {
      key: "onMouseDragHandle",
      value: function onMouseDragHandle(event) {
        if (!this.hasSelected) {
          var _this$downPointer = this.downPointer,
              x = _this$downPointer.x,
              y = _this$downPointer.y;

          if (this.circle) {
            this.cxt.remove(this.circle);
            this.circle = null;
          }
          var radius = Math.abs(event[0].pointer.y - this.downPointer.y);
          var beginPointer = {
            left: x,
            top: y
          };

          if (this.direction === ('leftTop')) {
            beginPointer = {
              left: event[0].pointer.x,
              top: event[0].pointer.y
            };
          }

          var options = Object.assign({}, this.style, {
            radius: radius,
            left: beginPointer.left,
            top: beginPointer.top
          });
          this.circle = new fabric_2.Circle(options);
          this.renderPath(this.circle);
        }
      }
    }, {
      key: "onMouseupHandle",
      value: function onMouseupHandle(e) {
        _get(_getPrototypeOf(Circle.prototype), "onMouseupHandle", this).call(this, e);

        if (!this.circle) return;
        this.renderPath(this.circle);
        this.circle = null;
        this.downPointer = null;
      }
    }, {
      key: "getLineLength",
      value: function getLineLength(start, end) {
        return Math.sqrt(Math.pow(start.x - end.x, 2) + Math.pow(start.y - end.y, 2));
      }
    }]);

    return Circle;
  }(ToolBase);

  var Text =
  /*#__PURE__*/
  function (_ToolBase) {
    _inherits(Text, _ToolBase);

    function Text() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, Text);

      for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
        arg[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Text)).call.apply(_getPrototypeOf2, [this].concat(arg)));

      _this.bindLintener();

      _this.toolType = toolTypes.TEXT;
      return _this;
    }

    _createClass(Text, [{
      key: "onMousedownHandle",
      value: function onMousedownHandle(event) {
        _get(_getPrototypeOf(Text.prototype), "onMousedownHandle", this).call(this, event);

        if (!this.hasSelected) {
          this.text = new fabric_2.Textbox(' ', {
            left: event[0].pointer.x,
            top: event[0].pointer.y,
            width: 100,
            lineHeight: 0.9,
            height: 40
          });
        }
      }
    }, {
      key: "bindLintener",
      value: function bindLintener() {
        this.cxt.on('text:changed', function (_ref) {
          var target = _ref.target;
          console.log(target);
        });
      }
    }, {
      key: "onMouseupHandle",
      value: function onMouseupHandle(event) {
        _get(_getPrototypeOf(Text.prototype), "onMouseupHandle", this).call(this, event);

        this.renderPath(this.text);
        this.text.enterEditing(event);
      }
    }]);

    return Text;
  }(ToolBase);

  var Pen =
  /*#__PURE__*/
  function (_ToolBase) {
    _inherits(Pen, _ToolBase);

    function Pen() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, Pen);

      for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
        arg[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Pen)).call.apply(_getPrototypeOf2, [this].concat(arg)));
      _this.toolType = toolTypes.PEN;

      _this.cxt.on('path:created', function (object) {
        if (_this.toolActive) {
          _this.renderPath(object.path, true);
        }
      });

      return _this;
    }

    _createClass(Pen, [{
      key: "selected",
      set: function set(selected) {
        this.toolActive = selected;
        this.cxt.isDrawingMode = selected;
      }
    }, {
      key: "style",
      set: function set(style) {
        this.cxt.freeDrawingBrush.color = style.color;
        this.cxt.freeDrawingBrush.width = style.width;
      }
    }]);

    return Pen;
  }(ToolBase);

  var MarkPen =
  /*#__PURE__*/
  function (_ToolBase) {
    _inherits(MarkPen, _ToolBase);

    function MarkPen() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, MarkPen);

      for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
        arg[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MarkPen)).call.apply(_getPrototypeOf2, [this].concat(arg)));
      _this.toolType = toolTypes.MARKPEN;

      _this.cxt.on('path:created', function (object) {
        if (_this.toolActive) {
          _this.renderPath(object.path, true);
        }
      });

      return _this;
    }

    _createClass(MarkPen, [{
      key: "selected",
      set: function set(selected) {
        this.toolActive = selected;

        if (selected) {
          this.cxt.isDrawingMode = true;
        }
      }
    }, {
      key: "style",
      set: function set(style) {
        this.cxt.freeDrawingBrush.color = style.color;
        this.cxt.freeDrawingBrush.width = style.width;
      }
    }]);

    return MarkPen;
  }(ToolBase);

  var Eraser =
  /*#__PURE__*/
  function (_ToolBase) {
    _inherits(Eraser, _ToolBase);

    function Eraser() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, Eraser);

      for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
        arg[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Eraser)).call.apply(_getPrototypeOf2, [this].concat(arg)));
      _this.toolType = toolTypes.ERASER;

      _this.cxt.on('path:created', function (object) {
        if (_this.toolActive) {
          object.path.selectable = false;

          _this.renderPath(object.path, true);
        }
      });

      return _this;
    }

    _createClass(Eraser, [{
      key: "selected",
      set: function set(selected) {
        this.toolActive = selected;

        if (selected) {
          this.cxt.freeDrawingBrush.color = '#fff';
          this.cxt.isDrawingMode = true;
        }
      }
    }, {
      key: "style",
      set: function set(style) {
        this.cxt.freeDrawingBrush.width = style.width;
      }
    }]);

    return Eraser;
  }(ToolBase);

  var Eraser$1 =
  /*#__PURE__*/
  function (_ToolBase) {
    _inherits(Eraser, _ToolBase);

    function Eraser() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, Eraser);

      for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
        arg[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Eraser)).call.apply(_getPrototypeOf2, [this].concat(arg)));
      _this.toolType = toolTypes.SELECTOR;
      return _this;
    }

    _createClass(Eraser, [{
      key: "selected",
      set: function set(selected) {
        this.toolActive = selected;
        this.cxt.selection = true;
      }
    }]);

    return Eraser;
  }(ToolBase);

  var Tools =
  /*#__PURE__*/
  function () {
    function Tools(canvas, style) {
      var _this = this;

      _classCallCheck(this, Tools);

      this.drawJSON = function (data) {
        var constructor = capitalize_1(data.type);
        fabric[constructor].fromObject(data, function (path) {
          _this.cxt.add(path);
        });
      };

      this.cxt = canvas;
      this.style = Object.assign({}, {
        fill: 'transparent'
      }, style);
      this.initTools();
    }

    _createClass(Tools, [{
      key: "initTools",
      value: function initTools() {
        this.toolList = [new Circle(this.cxt, this.style), new Text(this.cxt, this.style), new Pen(this.cxt, this.style), new MarkPen(this.cxt, this.style), new Eraser(this.cxt, this.style), new Eraser$1(this.cxt, this.style)];
      }
    }, {
      key: "tools",
      get: function get() {
        return this.toolList;
      }
    }]);

    return Tools;
  }();

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  var _arrayFilter = arrayFilter;

  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }

  var _createBaseFor = createBaseFor;

  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */
  var baseFor = _createBaseFor();

  var _baseFor = baseFor;

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  var _baseTimes = baseTimes;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
  }

  var _baseIsArguments = baseIsArguments;

  /** Used for built-in method references. */
  var objectProto$2 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
    return isObjectLike_1(value) && hasOwnProperty$1.call(value, 'callee') &&
      !propertyIsEnumerable.call(value, 'callee');
  };

  var isArguments_1 = isArguments;

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  var stubFalse_1 = stubFalse;

  var isBuffer_1 = createCommonjsModule(function (module, exports) {
  /** Detect free variable `exports`. */
  var freeExports = exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Built-in value references. */
  var Buffer = moduleExports ? _root.Buffer : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse_1;

  module.exports = isBuffer;
  });

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;

    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }

  var _isIndex = isIndex;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
  }

  var isLength_1 = isLength;

  /** `Object#toString` result references. */
  var argsTag$1 = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike_1(value) &&
      isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
  }

  var _baseIsTypedArray = baseIsTypedArray;

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  var _baseUnary = baseUnary;

  var _nodeUtil = createCommonjsModule(function (module, exports) {
  /** Detect free variable `exports`. */
  var freeExports = exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && _freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  module.exports = nodeUtil;
  });

  /* Node.js helper references. */
  var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

  var isTypedArray_1 = isTypedArray;

  /** Used for built-in method references. */
  var objectProto$3 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray_1(value),
        isArg = !isArr && isArguments_1(value),
        isBuff = !isArr && !isArg && isBuffer_1(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? _baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$2.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             _isIndex(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }

  var _arrayLikeKeys = arrayLikeKeys;

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$4;

    return value === proto;
  }

  var _isPrototype = isPrototype;

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  var _overArg = overArg;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeKeys = _overArg(Object.keys, Object);

  var _nativeKeys = nativeKeys;

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$5.hasOwnProperty;

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!_isPrototype(object)) {
      return _nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$3.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  var _baseKeys = baseKeys;

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1 = isObject;

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
      funcTag$1 = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject_1(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = _baseGetTag(value);
    return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  var isFunction_1 = isFunction;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength_1(value.length) && !isFunction_1(value);
  }

  var isArrayLike_1 = isArrayLike;

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys(object) {
    return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
  }

  var keys_1 = keys;

  /**
   * The base implementation of `_.forOwn` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */
  function baseForOwn(object, iteratee) {
    return object && _baseFor(object, iteratee, keys_1);
  }

  var _baseForOwn = baseForOwn;

  /**
   * Creates a `baseEach` or `baseEachRight` function.
   *
   * @private
   * @param {Function} eachFunc The function to iterate over a collection.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike_1(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length,
          index = fromRight ? length : -1,
          iterable = Object(collection);

      while ((fromRight ? index-- : ++index < length)) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }

  var _createBaseEach = createBaseEach;

  /**
   * The base implementation of `_.forEach` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   */
  var baseEach = _createBaseEach(_baseForOwn);

  var _baseEach = baseEach;

  /**
   * The base implementation of `_.filter` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function baseFilter(collection, predicate) {
    var result = [];
    _baseEach(collection, function(value, index, collection) {
      if (predicate(value, index, collection)) {
        result.push(value);
      }
    });
    return result;
  }

  var _baseFilter = baseFilter;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  var _listCacheClear = listCacheClear;

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  var eq_1 = eq;

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq_1(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  var _assocIndexOf = assocIndexOf;

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  var _listCacheDelete = listCacheDelete;

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  var _listCacheGet = listCacheGet;

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return _assocIndexOf(this.__data__, key) > -1;
  }

  var _listCacheHas = listCacheHas;

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  var _listCacheSet = listCacheSet;

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = _listCacheClear;
  ListCache.prototype['delete'] = _listCacheDelete;
  ListCache.prototype.get = _listCacheGet;
  ListCache.prototype.has = _listCacheHas;
  ListCache.prototype.set = _listCacheSet;

  var _ListCache = ListCache;

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new _ListCache;
    this.size = 0;
  }

  var _stackClear = stackClear;

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);

    this.size = data.size;
    return result;
  }

  var _stackDelete = stackDelete;

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  var _stackGet = stackGet;

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  var _stackHas = stackHas;

  /** Used to detect overreaching core-js shims. */
  var coreJsData = _root['__core-js_shared__'];

  var _coreJsData = coreJsData;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  var _isMasked = isMasked;

  /** Used for built-in method references. */
  var funcProto = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  var _toSource = toSource;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype,
      objectProto$6 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$4 = objectProto$6.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString$1.call(hasOwnProperty$4).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject_1(value) || _isMasked(value)) {
      return false;
    }
    var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(_toSource(value));
  }

  var _baseIsNative = baseIsNative;

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  var _getValue = getValue;

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = _getValue(object, key);
    return _baseIsNative(value) ? value : undefined;
  }

  var _getNative = getNative;

  /* Built-in method references that are verified to be native. */
  var Map$1 = _getNative(_root, 'Map');

  var _Map = Map$1;

  /* Built-in method references that are verified to be native. */
  var nativeCreate = _getNative(Object, 'create');

  var _nativeCreate = nativeCreate;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
    this.size = 0;
  }

  var _hashClear = hashClear;

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  var _hashDelete = hashDelete;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$7 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (_nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty$5.call(data, key) ? data[key] : undefined;
  }

  var _hashGet = hashGet;

  /** Used for built-in method references. */
  var objectProto$8 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$6.call(data, key);
  }

  var _hashHas = hashHas;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
    return this;
  }

  var _hashSet = hashSet;

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = _hashClear;
  Hash.prototype['delete'] = _hashDelete;
  Hash.prototype.get = _hashGet;
  Hash.prototype.has = _hashHas;
  Hash.prototype.set = _hashSet;

  var _Hash = Hash;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new _Hash,
      'map': new (_Map || _ListCache),
      'string': new _Hash
    };
  }

  var _mapCacheClear = mapCacheClear;

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  var _isKeyable = isKeyable;

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return _isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  var _getMapData = getMapData;

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = _getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  var _mapCacheDelete = mapCacheDelete;

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return _getMapData(this, key).get(key);
  }

  var _mapCacheGet = mapCacheGet;

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return _getMapData(this, key).has(key);
  }

  var _mapCacheHas = mapCacheHas;

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = _getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  var _mapCacheSet = mapCacheSet;

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = _mapCacheClear;
  MapCache.prototype['delete'] = _mapCacheDelete;
  MapCache.prototype.get = _mapCacheGet;
  MapCache.prototype.has = _mapCacheHas;
  MapCache.prototype.set = _mapCacheSet;

  var _MapCache = MapCache;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof _ListCache) {
      var pairs = data.__data__;
      if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new _MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  var _stackSet = stackSet;

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    var data = this.__data__ = new _ListCache(entries);
    this.size = data.size;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = _stackClear;
  Stack.prototype['delete'] = _stackDelete;
  Stack.prototype.get = _stackGet;
  Stack.prototype.has = _stackHas;
  Stack.prototype.set = _stackSet;

  var _Stack = Stack;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED$2);
    return this;
  }

  var _setCacheAdd = setCacheAdd;

  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */
  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  var _setCacheHas = setCacheHas;

  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */
  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;

    this.__data__ = new _MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }

  // Add methods to `SetCache`.
  SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
  SetCache.prototype.has = _setCacheHas;

  var _SetCache = SetCache;

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  var _arraySome = arraySome;

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  var _cacheHas = cacheHas;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index = -1,
        result = true,
        seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new _SetCache : undefined;

    stack.set(array, other);
    stack.set(other, array);

    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, arrValue, index, other, array, stack)
          : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (seen) {
        if (!_arraySome(other, function(othValue, othIndex) {
              if (!_cacheHas(seen, othIndex) &&
                  (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
          result = false;
          break;
        }
      } else if (!(
            arrValue === othValue ||
              equalFunc(arrValue, othValue, bitmask, customizer, stack)
          )) {
        result = false;
        break;
      }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  var _equalArrays = equalArrays;

  /** Built-in value references. */
  var Uint8Array$1 = _root.Uint8Array;

  var _Uint8Array = Uint8Array$1;

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  var _mapToArray = mapToArray;

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  var _setToArray = setToArray;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$1 = 1,
      COMPARE_UNORDERED_FLAG$1 = 2;

  /** `Object#toString` result references. */
  var boolTag$1 = '[object Boolean]',
      dateTag$1 = '[object Date]',
      errorTag$1 = '[object Error]',
      mapTag$1 = '[object Map]',
      numberTag$1 = '[object Number]',
      regexpTag$1 = '[object RegExp]',
      setTag$1 = '[object Set]',
      stringTag$1 = '[object String]',
      symbolTag$1 = '[object Symbol]';

  var arrayBufferTag$1 = '[object ArrayBuffer]',
      dataViewTag$1 = '[object DataView]';

  /** Used to convert symbols to primitives and strings. */
  var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;

  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag$1:
        if ((object.byteLength != other.byteLength) ||
            (object.byteOffset != other.byteOffset)) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag$1:
        if ((object.byteLength != other.byteLength) ||
            !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
          return false;
        }
        return true;

      case boolTag$1:
      case dateTag$1:
      case numberTag$1:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq_1(+object, +other);

      case errorTag$1:
        return object.name == other.name && object.message == other.message;

      case regexpTag$1:
      case stringTag$1:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == (other + '');

      case mapTag$1:
        var convert = _mapToArray;

      case setTag$1:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
        convert || (convert = _setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG$1;

        // Recursively compare objects (susceptible to call stack limits).
        stack.set(object, other);
        var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;

      case symbolTag$1:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }

  var _equalByTag = equalByTag;

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  var _arrayPush = arrayPush;

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
  }

  var _baseGetAllKeys = baseGetAllKeys;

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }

  var stubArray_1 = stubArray;

  /** Used for built-in method references. */
  var objectProto$9 = Object.prototype;

  /** Built-in value references. */
  var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols = Object.getOwnPropertySymbols;

  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return _arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable$1.call(object, symbol);
    });
  };

  var _getSymbols = getSymbols;

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys(object) {
    return _baseGetAllKeys(object, keys_1, _getSymbols);
  }

  var _getAllKeys = getAllKeys;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$2 = 1;

  /** Used for built-in method references. */
  var objectProto$a = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$7 = objectProto$a.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
        objProps = _getAllKeys(object),
        objLength = objProps.length,
        othProps = _getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty$7.call(other, key))) {
        return false;
      }
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);

    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, objValue, key, other, object, stack)
          : customizer(objValue, othValue, key, object, other, stack);
      }
      // Recursively compare objects (susceptible to call stack limits).
      if (!(compared === undefined
            ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
            : compared
          )) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      // Non `Object` object instances with different constructors are not equal.
      if (objCtor != othCtor &&
          ('constructor' in object && 'constructor' in other) &&
          !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
            typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  var _equalObjects = equalObjects;

  /* Built-in method references that are verified to be native. */
  var DataView = _getNative(_root, 'DataView');

  var _DataView = DataView;

  /* Built-in method references that are verified to be native. */
  var Promise$1 = _getNative(_root, 'Promise');

  var _Promise = Promise$1;

  /* Built-in method references that are verified to be native. */
  var Set = _getNative(_root, 'Set');

  var _Set = Set;

  /* Built-in method references that are verified to be native. */
  var WeakMap = _getNative(_root, 'WeakMap');

  var _WeakMap = WeakMap;

  /** `Object#toString` result references. */
  var mapTag$2 = '[object Map]',
      objectTag$1 = '[object Object]',
      promiseTag = '[object Promise]',
      setTag$2 = '[object Set]',
      weakMapTag$1 = '[object WeakMap]';

  var dataViewTag$2 = '[object DataView]';

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = _toSource(_DataView),
      mapCtorString = _toSource(_Map),
      promiseCtorString = _toSource(_Promise),
      setCtorString = _toSource(_Set),
      weakMapCtorString = _toSource(_WeakMap);

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag = _baseGetTag;

  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$2) ||
      (_Map && getTag(new _Map) != mapTag$2) ||
      (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
      (_Set && getTag(new _Set) != setTag$2) ||
      (_WeakMap && getTag(new _WeakMap) != weakMapTag$1)) {
    getTag = function(value) {
      var result = _baseGetTag(value),
          Ctor = result == objectTag$1 ? value.constructor : undefined,
          ctorString = Ctor ? _toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString: return dataViewTag$2;
          case mapCtorString: return mapTag$2;
          case promiseCtorString: return promiseTag;
          case setCtorString: return setTag$2;
          case weakMapCtorString: return weakMapTag$1;
        }
      }
      return result;
    };
  }

  var _getTag = getTag;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$3 = 1;

  /** `Object#toString` result references. */
  var argsTag$2 = '[object Arguments]',
      arrayTag$1 = '[object Array]',
      objectTag$2 = '[object Object]';

  /** Used for built-in method references. */
  var objectProto$b = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$8 = objectProto$b.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray_1(object),
        othIsArr = isArray_1(other),
        objTag = objIsArr ? arrayTag$1 : _getTag(object),
        othTag = othIsArr ? arrayTag$1 : _getTag(other);

    objTag = objTag == argsTag$2 ? objectTag$2 : objTag;
    othTag = othTag == argsTag$2 ? objectTag$2 : othTag;

    var objIsObj = objTag == objectTag$2,
        othIsObj = othTag == objectTag$2,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer_1(object)) {
      if (!isBuffer_1(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new _Stack);
      return (objIsArr || isTypedArray_1(object))
        ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack)
        : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
      var objIsWrapped = objIsObj && hasOwnProperty$8.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty$8.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;

        stack || (stack = new _Stack);
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new _Stack);
    return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  var _baseIsEqualDeep = baseIsEqualDeep;

  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || (!isObjectLike_1(value) && !isObjectLike_1(other))) {
      return value !== value && other !== other;
    }
    return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  var _baseIsEqual = baseIsEqual;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$4 = 1,
      COMPARE_UNORDERED_FLAG$2 = 2;

  /**
   * The base implementation of `_.isMatch` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Object} source The object of property values to match.
   * @param {Array} matchData The property names, values, and compare flags to match.
   * @param {Function} [customizer] The function to customize comparisons.
   * @returns {boolean} Returns `true` if `object` is a match, else `false`.
   */
  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length,
        length = index,
        noCustomizer = !customizer;

    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if ((noCustomizer && data[2])
            ? data[1] !== object[data[0]]
            : !(data[0] in object)
          ) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0],
          objValue = object[key],
          srcValue = data[1];

      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new _Stack;
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === undefined
              ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack)
              : result
            )) {
          return false;
        }
      }
    }
    return true;
  }

  var _baseIsMatch = baseIsMatch;

  /**
   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` if suitable for strict
   *  equality comparisons, else `false`.
   */
  function isStrictComparable(value) {
    return value === value && !isObject_1(value);
  }

  var _isStrictComparable = isStrictComparable;

  /**
   * Gets the property names, values, and compare flags of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the match data of `object`.
   */
  function getMatchData(object) {
    var result = keys_1(object),
        length = result.length;

    while (length--) {
      var key = result[length],
          value = object[key];

      result[length] = [key, value, _isStrictComparable(value)];
    }
    return result;
  }

  var _getMatchData = getMatchData;

  /**
   * A specialized version of `matchesProperty` for source values suitable
   * for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue &&
        (srcValue !== undefined || (key in Object(object)));
    };
  }

  var _matchesStrictComparable = matchesStrictComparable;

  /**
   * The base implementation of `_.matches` which doesn't clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatches(source) {
    var matchData = _getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || _baseIsMatch(object, source, matchData);
    };
  }

  var _baseMatches = baseMatches;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;

  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */
  function isKey(value, object) {
    if (isArray_1(value)) {
      return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' ||
        value == null || isSymbol_1(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
      (object != null && value in Object(object));
  }

  var _isKey = isKey;

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize(func, resolver) {
    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || _MapCache);
    return memoized;
  }

  // Expose `MapCache`.
  memoize.Cache = _MapCache;

  var memoize_1 = memoize;

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */
  function memoizeCapped(func) {
    var result = memoize_1(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });

    var cache = result.cache;
    return result;
  }

  var _memoizeCapped = memoizeCapped;

  /** Used to match property names within property paths. */
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */
  var stringToPath = _memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */) {
      result.push('');
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
    });
    return result;
  });

  var _stringToPath = stringToPath;

  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */
  function castPath(value, object) {
    if (isArray_1(value)) {
      return value;
    }
    return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
  }

  var _castPath = castPath;

  /** Used as references for various `Number` constants. */
  var INFINITY$1 = 1 / 0;

  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */
  function toKey(value) {
    if (typeof value == 'string' || isSymbol_1(value)) {
      return value;
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
  }

  var _toKey = toKey;

  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */
  function baseGet(object, path) {
    path = _castPath(path, object);

    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[_toKey(path[index++])];
    }
    return (index && index == length) ? object : undefined;
  }

  var _baseGet = baseGet;

  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */
  function get(object, path, defaultValue) {
    var result = object == null ? undefined : _baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  var get_1 = get;

  /**
   * The base implementation of `_.hasIn` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  var _baseHasIn = baseHasIn;

  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */
  function hasPath(object, path, hasFunc) {
    path = _castPath(path, object);

    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = _toKey(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength_1(length) && _isIndex(key, length) &&
      (isArray_1(object) || isArguments_1(object));
  }

  var _hasPath = hasPath;

  /**
   * Checks if `path` is a direct or inherited property of `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.hasIn(object, 'a');
   * // => true
   *
   * _.hasIn(object, 'a.b');
   * // => true
   *
   * _.hasIn(object, ['a', 'b']);
   * // => true
   *
   * _.hasIn(object, 'b');
   * // => false
   */
  function hasIn(object, path) {
    return object != null && _hasPath(object, path, _baseHasIn);
  }

  var hasIn_1 = hasIn;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$5 = 1,
      COMPARE_UNORDERED_FLAG$3 = 2;

  /**
   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
   *
   * @private
   * @param {string} path The path of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatchesProperty(path, srcValue) {
    if (_isKey(path) && _isStrictComparable(srcValue)) {
      return _matchesStrictComparable(_toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get_1(object, path);
      return (objValue === undefined && objValue === srcValue)
        ? hasIn_1(object, path)
        : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
    };
  }

  var _baseMatchesProperty = baseMatchesProperty;

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity(value) {
    return value;
  }

  var identity_1 = identity;

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  var _baseProperty = baseProperty;

  /**
   * A specialized version of `baseProperty` which supports deep paths.
   *
   * @private
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyDeep(path) {
    return function(object) {
      return _baseGet(object, path);
    };
  }

  var _basePropertyDeep = basePropertyDeep;

  /**
   * Creates a function that returns the value at `path` of a given object.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   * @example
   *
   * var objects = [
   *   { 'a': { 'b': 2 } },
   *   { 'a': { 'b': 1 } }
   * ];
   *
   * _.map(objects, _.property('a.b'));
   * // => [2, 1]
   *
   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
   * // => [1, 2]
   */
  function property(path) {
    return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
  }

  var property_1 = property;

  /**
   * The base implementation of `_.iteratee`.
   *
   * @private
   * @param {*} [value=_.identity] The value to convert to an iteratee.
   * @returns {Function} Returns the iteratee.
   */
  function baseIteratee(value) {
    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    if (typeof value == 'function') {
      return value;
    }
    if (value == null) {
      return identity_1;
    }
    if (typeof value == 'object') {
      return isArray_1(value)
        ? _baseMatchesProperty(value[0], value[1])
        : _baseMatches(value);
    }
    return property_1(value);
  }

  var _baseIteratee = baseIteratee;

  /**
   * Iterates over elements of `collection`, returning an array of all elements
   * `predicate` returns truthy for. The predicate is invoked with three
   * arguments: (value, index|key, collection).
   *
   * **Note:** Unlike `_.remove`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   * @see _.reject
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': true },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * _.filter(users, function(o) { return !o.active; });
   * // => objects for ['fred']
   *
   * // The `_.matches` iteratee shorthand.
   * _.filter(users, { 'age': 36, 'active': true });
   * // => objects for ['barney']
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.filter(users, ['active', false]);
   * // => objects for ['fred']
   *
   * // The `_.property` iteratee shorthand.
   * _.filter(users, 'active');
   * // => objects for ['barney']
   */
  function filter(collection, predicate) {
    var func = isArray_1(collection) ? _arrayFilter : _baseFilter;
    return func(collection, _baseIteratee(predicate, 3));
  }

  var filter_1 = filter;

  var Store =
  /*#__PURE__*/
  function () {
    function Store(props) {
      _classCallCheck(this, Store);

      var renderPath = props.renderPath;
      this.cxt = props.cxt;
      this.items = [];
      this.redos = [];
      this.undos = [];
    }

    _createClass(Store, [{
      key: "add",
      value: function add(pathInfo) {
        this.items.push(pathInfo);
      }
    }, {
      key: "drawPath",
      value: function drawPath(ptah) {
        this.cxt.add(path);
      }
    }, {
      key: "delete",
      value: function _delete(id) {
        var _this = this;

        var paths = [];

        if (!id) {
          //delete selected
          paths = filter_1(this.items, function (item) {
            return item.hasControls;
          });
        }
        paths = filter_1(this.items, function (item) {
          return item.id === id;
        });
        this.items = filter_1(this.items, function (item) {
          return item.id !== id;
        });
        paths.map(function (path) {
          return _this.cxt.remove(path);
        });
      }
    }, {
      key: "clearAll",
      value: function clearAll() {
        this.items = [];
        this.cxt.clear();
      }
    }, {
      key: "redo",
      value: function redo() {
        debugger;

        if (this.redos.length > 0) {
          var length = this.redos.length;
          var redoPath = this.redos[length - 1];
          this.cxt.add(redoPath);
          this.add(redoPath);
          this.redos = filter_1(this.redos, function (item) {
            return item.id !== redoPath.id;
          });
        }
      }
    }, {
      key: "undo",
      value: function undo() {
        debugger;
        var length = this.items.length;
        if (length === 0) return;
        var undoPath = this.items[length - 1];
        this.redos = _toConsumableArray(this.redos).concat([undoPath]);
        this.delete(undoPath.id);
      }
    }]);

    return Store;
  }();

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  var _arrayEach = arrayEach;

  /**
   * Casts `value` to `identity` if it's not a function.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {Function} Returns cast function.
   */
  function castFunction(value) {
    return typeof value == 'function' ? value : identity_1;
  }

  var _castFunction = castFunction;

  /**
   * Iterates over elements of `collection` and invokes `iteratee` for each element.
   * The iteratee is invoked with three arguments: (value, index|key, collection).
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * **Note:** As with other "Collections" methods, objects with a "length"
   * property are iterated like arrays. To avoid this behavior use `_.forIn`
   * or `_.forOwn` for object iteration.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @alias each
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   * @see _.forEachRight
   * @example
   *
   * _.forEach([1, 2], function(value) {
   *   console.log(value);
   * });
   * // => Logs `1` then `2`.
   *
   * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
   *   console.log(key);
   * });
   * // => Logs 'a' then 'b' (iteration order is not guaranteed).
   */
  function forEach(collection, iteratee) {
    var func = isArray_1(collection) ? _arrayEach : _baseEach;
    return func(collection, _castFunction(iteratee));
  }

  var forEach_1 = forEach;

  var mouseEvents = [{
    origin: 'mouse:up',
    instance: 'onMouseupHandle'
  }, {
    origin: 'mouse:down',
    instance: 'onMousedownHandle'
  }, {
    origin: 'mouse:move',
    instance: 'onMousemoveHandle'
  }];

  var whiteboard =
  /*#__PURE__*/
  function () {
    function whiteboard(props) {
      var _this = this;

      _classCallCheck(this, whiteboard);

      this.changeTool = function (tool) {
        forEach_1(_this.toolGroup.tools, function (itemTool) {
          if (tool === itemTool.toolType) {
            _this.currentTool = itemTool;
            itemTool.selected = true;
          } else {
            itemTool.selected = false;
          }
        });
        return _this.currentTool;
      };

      var id = props.id,
          _props$width = props.width,
          width = _props$width === void 0 ? 1000 : _props$width,
          _props$height = props.height,
          height = _props$height === void 0 ? 700 : _props$height;
      this.props = props;
      this.originCanvas = findDom("#".concat(id));
      this.canvas = new fabric_2.Canvas(id, {
        width: width,
        height: height,
        selection: false
      });
      this.store = new Store({
        cxt: this.canvas
      });
      window.cxt = this.canvas; // need delete

      window.store = this.store;
      this.toolGroup = new Tools(this.canvas, {
        borderColor: '#00B8FC',
        cornerColor: '#FF4B59',
        cornerSize: 6,
        strokeWidth: 1,
        stroke: '#000000',
        hasControls: false,
        fontSize: 20,
        transparentCorners: true,
        color: 'rgba(26, 209, 255, .7)',
        width: 10
      });
      window.changeTool = this.changeTool;
      this.changeTool(toolTypes.SELECTOR); // 初始画笔

      this.bindListener();
      this.checkParams();
    }

    _createClass(whiteboard, [{
      key: "redo",
      value: function redo() {
        this.store.redo();
      }
    }, {
      key: "undo",
      value: function undo() {
        this.store.undo();
      }
      /**
       * tool is one of toolTypes
       */

    }, {
      key: "drawJSON",

      /**
       * 
       * @param {JASON} data path instance json
       * draw receive data
       */
      value: function drawJSON(data) {
        this.toolGroup.drawJSON(data);
      }
    }, {
      key: "deleteAll",
      value: function deleteAll() {
        this.store.clearAll();
      }
      /**
       * param[id] path instance id
       */

    }, {
      key: "delete",
      value: function _delete(id) {
        this.store.delete(id);
      }
    }, {
      key: "bindListener",
      value: function bindListener() {
        var _this2 = this;

        mouseEvents.forEach(function (item) {
          _this2.canvas.on(item.origin, function () {
            for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
              arg[_key] = arguments[_key];
            }

            _this2.currentTool && _this2.currentTool[item.instance] && _this2.currentTool[item.instance](arg);
          });
        });
        this.canvas.on('path:created', function (object) {
          var path = object.path;
          var id = path.id,
              toolType = path.toolType;

          _this2.store.add(path);
        });
        this.canvas.on('selection:created', function (path) {});
        this.canvas.on('object:moving', function (path) {});
        this.canvas.on('object:rotating', function (path) {});
        this.canvas.on('object:skewing', function (path) {});
      }
    }, {
      key: "checkParams",
      value: function checkParams() {
        if (!this.props.id) {
          log.error('need whiteboard ID');
        }
      }
    }, {
      key: "currentToolInfo",
      set: function set(toolInfo) {
        var tool = toolInfo.tool;
        this.changeTool(tool);
      }
      /**
       * 设置可选
       */

    }, {
      key: "selection",
      set: function set(selection) {
        this.canvas && (this.canvas.selection = selection);
      }
    }]);

    return whiteboard;
  }();

  window.whitebord = whiteboard;

  return whiteboard;

}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2hpdGVib2FyZC5qcyIsInNvdXJjZXMiOlsiLi4vc3JjL3V0aWxzL2RvbS5qcyIsIi4uL3NyYy91dGlscy9lcnJvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9yb2xsdXAtcGx1Z2luLW5vZGUtZ2xvYmFscy9zcmMvZ2xvYmFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2J1ZmZlci1lczYvYmFzZTY0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2J1ZmZlci1lczYvaWVlZTc1NC5qcyIsIi4uL25vZGVfbW9kdWxlcy9idWZmZXItZXM2L2lzQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvYnVmZmVyLWVzNi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9yb2xsdXAtcGx1Z2luLW5vZGUtcmVzb2x2ZS9zcmMvZW1wdHkuanMiLCIuLi9ub2RlX21vZHVsZXMvZmFicmljL2Rpc3QvZmFicmljLmpzIiwiLi4vc3JjL2NvbnN0YW50cy90b29scy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVG9TdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNsaWNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFNsaWNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzVW5pY29kZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FzY2lpVG9BcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3VuaWNvZGVUb0FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9BcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUNhc2VGaXJzdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdXBwZXJGaXJzdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY2FwaXRhbGl6ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdW5pcXVlSWQuanMiLCIuLi9zcmMvdG9vbHMvVG9vbEJhc2UuanMiLCIuLi9zcmMvdG9vbHMvQ2lyY2xlLmpzIiwiLi4vc3JjL3Rvb2xzL1RleHQuanMiLCIuLi9zcmMvdG9vbHMvUGVuLmpzIiwiLi4vc3JjL3Rvb2xzL01hcmtQZW4uanMiLCIuLi9zcmMvdG9vbHMvRXJhc2VyLmpzIiwiLi4vc3JjL3Rvb2xzL1NlbGVjdG9yLmpzIiwiLi4vc3JjL3Rvb2xzL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlGaWx0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJGYWxzZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNCdWZmZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvck93bi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VFYWNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUVhY2guanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmlsdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2VxLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTGlzdENhY2hlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tDbGVhci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0hhcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUFkZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0Q2FjaGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVNvbWUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQXJyYXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcFRvQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxCeVRhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fUHJvbWlzZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1dlYWtNYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRUYWcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbERlZXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hdGNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNTdHJpY3RDb21wYXJhYmxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWF0Y2hEYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9nZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSGFzSW4uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNQYXRoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXNJbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzUHJvcGVydHkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5RGVlcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcHJvcGVydHkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXRlcmF0ZWUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZpbHRlci5qcyIsIi4uL3NyYy9TdG9yZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RWFjaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RGdW5jdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZm9yRWFjaC5qcyIsIi4uL3NyYy9XaGl0ZWJvYXJkLmpzIiwiLi4vc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBjcmVhdGVEb20gPSBmdW5jdGlvbiAoZWwgPSAnZGl2JywgdHBsID0gJycsIGF0dHJzID0ge30sIGNuYW1lID0gJycpIHtcbiAgbGV0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWwpXG4gIGRvbS5jbGFzc05hbWUgPSBjbmFtZVxuICBkb20uaW5uZXJIVE1MID0gdHBsXG4gIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgIGxldCBrZXkgPSBpdGVtO1xuICAgIGxldCB2YWx1ZSA9IGF0dHJzW2l0ZW1dXG4gICAgaWYgKGVsID09PSAndmlkZW8nIHx8IGVsID09PSAnYXVkaW8nKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkb20uc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpXG4gICAgfVxuICB9KVxuICByZXR1cm4gZG9tXG59XG5cbmV4cG9ydCBjb25zdCBoYXNDbGFzcyA9IGZ1bmN0aW9uIChlbCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbChlbC5jbGFzc0xpc3QsIGl0ZW0gPT4gaXRlbSA9PT0gY2xhc3NOYW1lKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAhIWVsLmNsYXNzTmFtZS5tYXRjaChuZXcgUmVnRXhwKCcoXFxcXHN8XiknICsgY2xhc3NOYW1lICsgJyhcXFxcc3wkKScpKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBhZGRDbGFzcyA9IGZ1bmN0aW9uIChlbCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBjbGFzc05hbWUucmVwbGFjZSgvKF5cXHMrfFxccyskKS9nLCAnJykuc3BsaXQoL1xccysvZykuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGl0ZW0gJiYgZWwuY2xhc3NMaXN0LmFkZChpdGVtKVxuICAgIH0pXG4gIH0gZWxzZSBpZiAoIWhhc0NsYXNzKGVsLCBjbGFzc05hbWUpKSB7XG4gICAgZWwuY2xhc3NOYW1lICs9ICcgJyArIGNsYXNzTmFtZVxuICB9XG59XG5leHBvcnQgY29uc3QgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoZWwsIGNsYXNzTmFtZSkge1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgY2xhc3NOYW1lLnNwbGl0KC9cXHMrL2cpLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGl0ZW0pXG4gICAgfSlcbiAgfSBlbHNlIGlmIChoYXNDbGFzcyhlbCwgY2xhc3NOYW1lKSkge1xuICAgIGNsYXNzTmFtZS5zcGxpdCgvXFxzKy9nKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgbGV0IHJlZyA9IG5ldyBSZWdFeHAoJyhcXFxcc3xeKScgKyBpdGVtICsgJyhcXFxcc3wkKScpXG4gICAgICBlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWUucmVwbGFjZShyZWcsICcgJylcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB0b2dnbGVDbGFzcyA9IGZ1bmN0aW9uIChlbCwgY2xhc3NOYW1lKSB7XG4gIGNsYXNzTmFtZS5zcGxpdCgvXFxzKy9nKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgIGlmIChoYXNDbGFzcyhlbCwgaXRlbSkpIHtcbiAgICAgIHJlbW92ZUNsYXNzKGVsLCBpdGVtKVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRDbGFzcyhlbCwgaXRlbSlcbiAgICB9XG4gIH0pXG59XG5cbmV4cG9ydCBjb25zdCBmaW5kRG9tID0gZnVuY3Rpb24gKHNlbCwgZWwgPSBkb2N1bWVudCkge1xuICByZXR1cm4gZWwucXVlcnlTZWxlY3RvcihzZWwpXG59XG5cbmV4cG9ydCBjb25zdCBwYWRTdGFydCA9IGZ1bmN0aW9uIChzdHIsIGxlbmd0aCwgcGFkKSB7XG4gIGxldCBjaGFyc3RyID0gU3RyaW5nKHBhZCk7XG4gIGxldCBsZW4gPSBsZW5ndGggPj4gMDtcbiAgbGV0IG1heGxlbiA9IE1hdGguY2VpbChsZW4gLyBjaGFyc3RyLmxlbmd0aClcbiAgbGV0IGNoYXJzID0gW107XG4gIGxldCByID0gU3RyaW5nKHN0cilcbiAgd2hpbGUgKG1heGxlbi0tKSB7XG4gICAgY2hhcnMucHVzaChjaGFyc3RyKVxuICB9XG4gIHJldHVybiBjaGFycy5qb2luKCcnKS5zdWJzdHJpbmcoMCwgbGVuIC0gci5sZW5ndGgpICsgclxufVxuXG5leHBvcnQgY29uc3QgZm9ybWF0ID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgaWYgKHdpbmRvdy5pc05hTih0aW1lKSkge1xuICAgIHJldHVybiAnJ1xuICB9XG4gIGxldCBob3VyID0gcGFkU3RhcnQoTWF0aC5mbG9vcih0aW1lIC8gMzYwMCksIDIsIDApXG4gIGxldCBtaW51dGUgPSBwYWRTdGFydChNYXRoLmZsb29yKCh0aW1lIC0gaG91ciAqIDM2MDApIC8gNjApLCAyLCAwKVxuICBsZXQgc2Vjb25kID0gcGFkU3RhcnQoTWF0aC5mbG9vcigodGltZSAtIGhvdXIgKiAzNjAwIC0gbWludXRlICogNjApKSwgMiwgMClcbiAgcmV0dXJuIChob3VyID09PSAnMDAnID8gW21pbnV0ZSwgc2Vjb25kXSA6IFtob3VyLCBtaW51dGUsIHNlY29uZF0pLmpvaW4oJzonKVxufVxuXG5leHBvcnQgY29uc3QgZXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICBpZiAoZS50b3VjaGVzKSB7XG4gICAgbGV0IHRvdWNoID0gZS50b3VjaGVzWzBdIHx8IGUuY2hhbmdlZFRvdWNoZXNbMF1cbiAgICBlLmNsaWVudFggPSB0b3VjaC5jbGllbnRYIHx8IDBcbiAgICBlLmNsaWVudFkgPSB0b3VjaC5jbGllbnRZIHx8IDBcbiAgICBlLm9mZnNldFggPSB0b3VjaC5wYWdlWCAtIHRvdWNoLnRhcmdldC5vZmZzZXRMZWZ0XG4gICAgZS5vZmZzZXRZID0gdG91Y2gucGFnZVkgLSB0b3VjaC50YXJnZXQub2Zmc2V0VG9wXG4gIH1cbiAgZS5fdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50XG59XG5cbmV4cG9ydCBjb25zdCB0eXBlT2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKS5tYXRjaCgvKFteXFxzLipdKykoPz1dJCkvZylbMF1cbn1cblxuZXhwb3J0IGNvbnN0IGRlZXBDb3B5ID0gZnVuY3Rpb24gKGRzdCwgc3JjKSB7XG4gIGlmICh0eXBlT2Yoc3JjKSA9PT0gJ09iamVjdCcgJiYgdHlwZU9mKGRzdCkgPT09ICdPYmplY3QnKSB7XG4gICAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAodHlwZU9mKHNyY1trZXldKSA9PT0gJ09iamVjdCcgJiYgIShzcmNba2V5XSBpbnN0YW5jZW9mIE5vZGUpKSB7XG4gICAgICAgIGlmICghZHN0W2tleV0pIHtcbiAgICAgICAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVlcENvcHkoZHN0W2tleV0sIHNyY1trZXldKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gZHN0XG4gIH1cbn0iLCJleHBvcnQgZGVmYXVsdCB7XG4gICdsb2cnOiBmdW5jdGlvbiAobG9nTXNnKSB7XG4gICAgY29uc29sZS5sb2cobG9nTXNnKTtcbiAgfSxcbiAgJ2Vycm9yJzogKG1zZykgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgfVxufSIsImV4cG9ydCBkZWZhdWx0ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDpcbiAgICAgICAgICAgIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6XG4gICAgICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pO1xuIiwiXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxudmFyIGluaXRlZCA9IGZhbHNlO1xuZnVuY3Rpb24gaW5pdCAoKSB7XG4gIGluaXRlZCA9IHRydWU7XG4gIHZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbG9va3VwW2ldID0gY29kZVtpXVxuICAgIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxuICB9XG5cbiAgcmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG4gIHJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICBpZiAoIWluaXRlZCkge1xuICAgIGluaXQoKTtcbiAgfVxuICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICBwbGFjZUhvbGRlcnMgPSBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXG5cbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgaWYgKCFpbml0ZWQpIHtcbiAgICBpbml0KCk7XG4gIH1cbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiXG5leHBvcnQgZnVuY3Rpb24gcmVhZCAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZSAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5leHBvcnQgZGVmYXVsdCBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cblxuaW1wb3J0ICogYXMgYmFzZTY0IGZyb20gJy4vYmFzZTY0J1xuaW1wb3J0ICogYXMgaWVlZTc1NCBmcm9tICcuL2llZWU3NTQnXG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXknXG5cbmV4cG9ydCB2YXIgSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHRydWVcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xudmFyIF9rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5leHBvcnQge19rTWF4TGVuZ3RoIGFzIGtNYXhMZW5ndGh9O1xuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICByZXR1cm4gdHJ1ZTtcbiAgLy8gcm9sbHVwIGlzc3Vlc1xuICAvLyB0cnkge1xuICAvLyAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAvLyAgIGFyci5fX3Byb3RvX18gPSB7XG4gIC8vICAgICBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLFxuICAvLyAgICAgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gIC8vICAgfVxuICAvLyAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gIC8vICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gIC8vICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIC8vIH0gY2F0Y2ggKGUpIHtcbiAgLy8gICByZXR1cm4gZmFsc2VcbiAgLy8gfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICAvLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIC8vICAgdmFsdWU6IG51bGwsXG4gICAgLy8gICBjb25maWd1cmFibGU6IHRydWVcbiAgICAvLyB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuQnVmZmVyLmlzQnVmZmVyID0gaXNCdWZmZXI7XG5mdW5jdGlvbiBpbnRlcm5hbElzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYSkgfHwgIWludGVybmFsSXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghaW50ZXJuYWxJc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBJTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBpbnRlcm5hbElzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG5cbi8vIHRoZSBmb2xsb3dpbmcgaXMgZnJvbSBpcy1idWZmZXIsIGFsc28gYnkgRmVyb3NzIEFib3VraGFkaWplaCBhbmQgd2l0aCBzYW1lIGxpc2VuY2Vcbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbmV4cG9ydCBmdW5jdGlvbiBpc0J1ZmZlcihvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmICghIW9iai5faXNCdWZmZXIgfHwgaXNGYXN0QnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikpXG59XG5cbmZ1bmN0aW9uIGlzRmFzdEJ1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzRmFzdEJ1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG4iLCJleHBvcnQgZGVmYXVsdCB7fTtcbiIsIi8qIGJ1aWxkOiBgbm9kZSBidWlsZC5qcyBtb2R1bGVzPUFMTCBleGNsdWRlPWdlc3R1cmVzLGFjY2Vzc29ycyByZXF1aXJlanMgbWluaWZpZXI9dWdsaWZ5anNgICovXG4vKiEgRmFicmljLmpzIENvcHlyaWdodCAyMDA4LTIwMTUsIFByaW50aW8gKEp1cml5IFpheXRzZXYsIE1heGltIENoZXJueWFrKSAqL1xuXG52YXIgZmFicmljID0gZmFicmljIHx8IHsgdmVyc2lvbjogJzIuMy4zJyB9O1xuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBleHBvcnRzLmZhYnJpYyA9IGZhYnJpYztcbn1cbi8qIF9BTURfU1RBUlRfICovXG5lbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZhYnJpYzsgfSk7XG59XG4vKiBfQU1EX0VORF8gKi9cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGZhYnJpYy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICBmYWJyaWMud2luZG93ID0gd2luZG93O1xufVxuZWxzZSB7XG4gIC8vIGFzc3VtZSB3ZSdyZSBydW5uaW5nIHVuZGVyIG5vZGUuanMgd2hlbiBkb2N1bWVudC93aW5kb3cgYXJlIG5vdCBwcmVzZW50XG4gIGZhYnJpYy5kb2N1bWVudCA9IHJlcXVpcmUoJ2pzZG9tJylcbiAgICAuanNkb20oXG4gICAgICBkZWNvZGVVUklDb21wb25lbnQoJyUzQyFET0NUWVBFJTIwaHRtbCUzRSUzQ2h0bWwlM0UlM0NoZWFkJTNFJTNDJTJGaGVhZCUzRSUzQ2JvZHklM0UlM0MlMkZib2R5JTNFJTNDJTJGaHRtbCUzRScpLFxuICAgICAgeyBmZWF0dXJlczoge1xuICAgICAgICBGZXRjaEV4dGVybmFsUmVzb3VyY2VzOiBbJ2ltZyddXG4gICAgICB9XG4gICAgICB9KTtcbiAgZmFicmljLmpzZG9tSW1wbEZvcldyYXBwZXIgPSByZXF1aXJlKCdqc2RvbS9saWIvanNkb20vbGl2aW5nL2dlbmVyYXRlZC91dGlscycpLmltcGxGb3JXcmFwcGVyO1xuICBmYWJyaWMubm9kZUNhbnZhcyA9IHJlcXVpcmUoJ2pzZG9tL2xpYi9qc2RvbS91dGlscycpLkNhbnZhcztcbiAgZmFicmljLndpbmRvdyA9IGZhYnJpYy5kb2N1bWVudC5kZWZhdWx0VmlldztcbiAgRE9NUGFyc2VyID0gcmVxdWlyZSgneG1sZG9tJykuRE9NUGFyc2VyO1xufVxuXG4vKipcbiAqIFRydWUgd2hlbiBpbiBlbnZpcm9ubWVudCB0aGF0IHN1cHBvcnRzIHRvdWNoIGV2ZW50c1xuICogQHR5cGUgYm9vbGVhblxuICovXG5mYWJyaWMuaXNUb3VjaFN1cHBvcnRlZCA9ICdvbnRvdWNoc3RhcnQnIGluIGZhYnJpYy53aW5kb3c7XG5cbi8qKlxuICogVHJ1ZSB3aGVuIGluIGVudmlyb25tZW50IHRoYXQncyBwcm9iYWJseSBOb2RlLmpzXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbmZhYnJpYy5pc0xpa2VseU5vZGUgPSB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuXG4vKiBfRlJPTV9TVkdfU1RBUlRfICovXG4vKipcbiAqIEF0dHJpYnV0ZXMgcGFyc2VkIGZyb20gYWxsIFNWRyBlbGVtZW50c1xuICogQHR5cGUgYXJyYXlcbiAqL1xuZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTID0gW1xuICBcImRpc3BsYXlcIixcbiAgXCJ0cmFuc2Zvcm1cIixcbiAgXCJmaWxsXCIsIFwiZmlsbC1vcGFjaXR5XCIsIFwiZmlsbC1ydWxlXCIsXG4gIFwib3BhY2l0eVwiLFxuICBcInN0cm9rZVwiLCBcInN0cm9rZS1kYXNoYXJyYXlcIiwgXCJzdHJva2UtbGluZWNhcFwiLFxuICBcInN0cm9rZS1saW5lam9pblwiLCBcInN0cm9rZS1taXRlcmxpbWl0XCIsXG4gIFwic3Ryb2tlLW9wYWNpdHlcIiwgXCJzdHJva2Utd2lkdGhcIixcbiAgXCJpZFwiLCBcInBhaW50LW9yZGVyXCIsXG4gIFwiaW5zdGFudGlhdGVkX2J5X3VzZVwiXG5dO1xuLyogX0ZST01fU1ZHX0VORF8gKi9cblxuLyoqXG4gKiBQaXhlbCBwZXIgSW5jaCBhcyBhIGRlZmF1bHQgdmFsdWUgc2V0IHRvIDk2LiBDYW4gYmUgY2hhbmdlZCBmb3IgbW9yZSByZWFsaXN0aWMgY29udmVyc2lvbi5cbiAqL1xuZmFicmljLkRQSSA9IDk2O1xuZmFicmljLnJlTnVtID0gJyg/OlstK10/KD86XFxcXGQrfFxcXFxkKlxcXFwuXFxcXGQrKSg/OmVbLStdP1xcXFxkKyk/KSc7XG5mYWJyaWMuZm9udFBhdGhzID0geyB9O1xuZmFicmljLmlNYXRyaXggPSBbMSwgMCwgMCwgMSwgMCwgMF07XG5mYWJyaWMuY2FudmFzTW9kdWxlID0gJ2NhbnZhcyc7XG5cbi8qKlxuICogUGl4ZWwgbGltaXQgZm9yIGNhY2hlIGNhbnZhc2VzLiAxTXB4ICwgNE1weCBzaG91bGQgYmUgZmluZS5cbiAqIEBzaW5jZSAxLjcuMTRcbiAqIEB0eXBlIE51bWJlclxuICogQGRlZmF1bHRcbiAqL1xuZmFicmljLnBlcmZMaW1pdFNpemVUb3RhbCA9IDIwOTcxNTI7XG5cbi8qKlxuICogUGl4ZWwgbGltaXQgZm9yIGNhY2hlIGNhbnZhc2VzIHdpZHRoIG9yIGhlaWdodC4gSUUgZml4ZXMgdGhlIG1heGltdW0gYXQgNTAwMFxuICogQHNpbmNlIDEuNy4xNFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMubWF4Q2FjaGVTaWRlTGltaXQgPSA0MDk2O1xuXG4vKipcbiAqIExvd2VzdCBwaXhlbCBsaW1pdCBmb3IgY2FjaGUgY2FudmFzZXMsIHNldCBhdCAyNTZQWFxuICogQHNpbmNlIDEuNy4xNFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMubWluQ2FjaGVTaWRlTGltaXQgPSAyNTY7XG5cbi8qKlxuICogQ2FjaGUgT2JqZWN0IGZvciB3aWR0aHMgb2YgY2hhcnMgaW4gdGV4dCByZW5kZXJpbmcuXG4gKi9cbmZhYnJpYy5jaGFyV2lkdGhzQ2FjaGUgPSB7IH07XG5cbi8qKlxuICogaWYgd2ViZ2wgaXMgZW5hYmxlZCBhbmQgYXZhaWxhYmxlLCB0ZXh0dXJlU2l6ZSB3aWxsIGRldGVybWluZSB0aGUgc2l6ZVxuICogb2YgdGhlIGNhbnZhcyBiYWNrZW5kXG4gKiBAc2luY2UgMi4wLjBcbiAqIEB0eXBlIE51bWJlclxuICogQGRlZmF1bHRcbiAqL1xuZmFicmljLnRleHR1cmVTaXplID0gMjA0ODtcblxuLyoqXG4gKiBFbmFibGUgd2ViZ2wgZm9yIGZpbHRlcmluZyBwaWN0dXJlIGlzIGF2YWlsYWJsZVxuICogQSBmaWx0ZXJpbmcgYmFja2VuZCB3aWxsIGJlIGluaXRpYWxpemVkLCB0aGlzIHdpbGwgYm90aCB0YWtlIG1lbW9yeSBhbmRcbiAqIHRpbWUgc2luY2UgYSBkZWZhdWx0IDIwNDh4MjA0OCBjYW52YXMgd2lsbCBiZSBjcmVhdGVkIGZvciB0aGUgZ2wgY29udGV4dFxuICogQHNpbmNlIDIuMC4wXG4gKiBAdHlwZSBCb29sZWFuXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMuZW5hYmxlR0xGaWx0ZXJpbmcgPSB0cnVlO1xuXG4vKipcbiAqIERldmljZSBQaXhlbCBSYXRpb1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9zYWZhcmkvZG9jdW1lbnRhdGlvbi9BdWRpb1ZpZGVvL0NvbmNlcHR1YWwvSFRNTC1jYW52YXMtZ3VpZGUvU2V0dGluZ1VwdGhlQ2FudmFzL1NldHRpbmdVcHRoZUNhbnZhcy5odG1sXG4gKi9cbmZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvID0gZmFicmljLndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cud2Via2l0RGV2aWNlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm1vekRldmljZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMTtcbi8qKlxuICogQnJvd3Nlci1zcGVjaWZpYyBjb25zdGFudCB0byBhZGp1c3QgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnNoYWRvd0JsdXIgdmFsdWUsXG4gKiB3aGljaCBpcyB1bml0bGVzcyBhbmQgbm90IHJlbmRlcmVkIGVxdWFsbHkgYWNyb3NzIGJyb3dzZXJzLlxuICpcbiAqIFZhbHVlcyB0aGF0IHdvcmsgcXVpdGUgd2VsbCAoYXMgb2YgT2N0b2JlciAyMDE3KSBhcmU6XG4gKiAtIENocm9tZTogMS41XG4gKiAtIEVkZ2U6IDEuNzVcbiAqIC0gRmlyZWZveDogMC45XG4gKiAtIFNhZmFyaTogMC45NVxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdCAxXG4gKi9cbmZhYnJpYy5icm93c2VyU2hhZG93Qmx1ckNvbnN0YW50ID0gMTtcblxuZmFicmljLmluaXRGaWx0ZXJCYWNrZW5kID0gZnVuY3Rpb24oKSB7XG4gIGlmIChmYWJyaWMuZW5hYmxlR0xGaWx0ZXJpbmcgJiYgZmFicmljLmlzV2ViZ2xTdXBwb3J0ZWQgJiYgZmFicmljLmlzV2ViZ2xTdXBwb3J0ZWQoZmFicmljLnRleHR1cmVTaXplKSkge1xuICAgIGNvbnNvbGUubG9nKCdtYXggdGV4dHVyZSBzaXplOiAnICsgZmFicmljLm1heFRleHR1cmVTaXplKTtcbiAgICByZXR1cm4gKG5ldyBmYWJyaWMuV2ViZ2xGaWx0ZXJCYWNrZW5kKHsgdGlsZVNpemU6IGZhYnJpYy50ZXh0dXJlU2l6ZSB9KSk7XG4gIH1cbiAgZWxzZSBpZiAoZmFicmljLkNhbnZhczJkRmlsdGVyQmFja2VuZCkge1xuICAgIHJldHVybiAobmV3IGZhYnJpYy5DYW52YXMyZEZpbHRlckJhY2tlbmQoKSk7XG4gIH1cbn07XG5cblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gZW5zdXJlIGdsb2JhbGl0eSBldmVuIGlmIGVudGlyZSBsaWJyYXJ5IHdlcmUgZnVuY3Rpb24gd3JhcHBlZCAoYXMgaW4gTWV0ZW9yLmpzIHBhY2thZ2luZyBzeXN0ZW0pXG4gIHdpbmRvdy5mYWJyaWMgPSBmYWJyaWM7XG59XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGZ1bmN0aW9uIF9yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIGlmICghdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGV2ZW50TGlzdGVuZXIgPSB0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgZXZlbnRMaXN0ZW5lcltldmVudExpc3RlbmVyLmluZGV4T2YoaGFuZGxlcildID0gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZmFicmljLnV0aWwuYXJyYXkuZmlsbChldmVudExpc3RlbmVyLCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9ic2VydmVzIHNwZWNpZmllZCBldmVudFxuICAgKiBAZGVwcmVjYXRlZCBgb2JzZXJ2ZWAgZGVwcmVjYXRlZCBzaW5jZSAwLjguMzQgKHVzZSBgb25gIGluc3RlYWQpXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAYWxpYXMgb25cbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBldmVudE5hbWUgRXZlbnQgbmFtZSAoZWcuICdhZnRlcjpyZW5kZXInKSBvciBvYmplY3Qgd2l0aCBrZXkvdmFsdWUgcGFpcnMgKGVnLiB7J2FmdGVyOnJlbmRlcic6IGhhbmRsZXIsICdzZWxlY3Rpb246Y2xlYXJlZCc6IGhhbmRsZXJ9KVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSBub3RpZmljYXRpb24gd2hlbiBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb2NjdXJzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gb2JzZXJ2ZShldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXMuX19ldmVudExpc3RlbmVycykge1xuICAgICAgdGhpcy5fX2V2ZW50TGlzdGVuZXJzID0geyB9O1xuICAgIH1cbiAgICAvLyBvbmUgb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHBhaXJzIHdhcyBwYXNzZWRcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBldmVudE5hbWUpIHtcbiAgICAgICAgdGhpcy5vbihwcm9wLCBldmVudE5hbWVbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdLnB1c2goaGFuZGxlcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIGV2ZW50IG9ic2VydmluZyBmb3IgYSBwYXJ0aWN1bGFyIGV2ZW50IGhhbmRsZXIuIENhbGxpbmcgdGhpcyBtZXRob2RcbiAgICogd2l0aG91dCBhcmd1bWVudHMgcmVtb3ZlcyBhbGwgaGFuZGxlcnMgZm9yIGFsbCBldmVudHNcbiAgICogQGRlcHJlY2F0ZWQgYHN0b3BPYnNlcnZpbmdgIGRlcHJlY2F0ZWQgc2luY2UgMC44LjM0ICh1c2UgYG9mZmAgaW5zdGVhZClcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEBhbGlhcyBvZmZcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBldmVudE5hbWUgRXZlbnQgbmFtZSAoZWcuICdhZnRlcjpyZW5kZXInKSBvciBvYmplY3Qgd2l0aCBrZXkvdmFsdWUgcGFpcnMgKGVnLiB7J2FmdGVyOnJlbmRlcic6IGhhbmRsZXIsICdzZWxlY3Rpb246Y2xlYXJlZCc6IGhhbmRsZXJ9KVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEZ1bmN0aW9uIHRvIGJlIGRlbGV0ZWQgZnJvbSBFdmVudExpc3RlbmVyc1xuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIHN0b3BPYnNlcnZpbmcoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgaWYgKCF0aGlzLl9fZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYWxsIGtleS92YWx1ZSBwYWlycyAoZXZlbnQgbmFtZSAtPiBldmVudCBoYW5kbGVyKVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBmb3IgKGV2ZW50TmFtZSBpbiB0aGlzLl9fZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgX3JlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBvbmUgb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHBhaXJzIHdhcyBwYXNzZWRcbiAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIGV2ZW50TmFtZSkge1xuICAgICAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIHByb3AsIGV2ZW50TmFtZVtwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgX3JlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyBldmVudCB3aXRoIGFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0XG4gICAqIEBkZXByZWNhdGVkIGBmaXJlYCBkZXByZWNhdGVkIHNpbmNlIDEuMC43ICh1c2UgYHRyaWdnZXJgIGluc3RlYWQpXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAYWxpYXMgdHJpZ2dlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWUgdG8gZmlyZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gZmlyZShldmVudE5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuX19ldmVudExpc3RlbmVycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnNGb3JFdmVudCA9IHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdO1xuICAgIGlmICghbGlzdGVuZXJzRm9yRXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzRm9yRXZlbnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc0ZvckV2ZW50W2ldICYmIGxpc3RlbmVyc0ZvckV2ZW50W2ldLmNhbGwodGhpcywgb3B0aW9ucyB8fCB7IH0pO1xuICAgIH1cbiAgICB0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXSA9IGxpc3RlbmVyc0ZvckV2ZW50LmZpbHRlcihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9PSBmYWxzZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI2V2ZW50c31cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9ldmVudHN8RXZlbnRzIGRlbW99XG4gICAqL1xuICBmYWJyaWMuT2JzZXJ2YWJsZSA9IHtcbiAgICBvYnNlcnZlOiBvYnNlcnZlLFxuICAgIHN0b3BPYnNlcnZpbmc6IHN0b3BPYnNlcnZpbmcsXG4gICAgZmlyZTogZmlyZSxcblxuICAgIG9uOiBvYnNlcnZlLFxuICAgIG9mZjogc3RvcE9ic2VydmluZyxcbiAgICB0cmlnZ2VyOiBmaXJlXG4gIH07XG59KSgpO1xuXG5cbi8qKlxuICogQG5hbWVzcGFjZSBmYWJyaWMuQ29sbGVjdGlvblxuICovXG5mYWJyaWMuQ29sbGVjdGlvbiA9IHtcblxuICBfb2JqZWN0czogW10sXG5cbiAgLyoqXG4gICAqIEFkZHMgb2JqZWN0cyB0byBjb2xsZWN0aW9uLCBDYW52YXMgb3IgR3JvdXAsIHRoZW4gcmVuZGVycyBjYW52YXNcbiAgICogKGlmIGByZW5kZXJPbkFkZFJlbW92ZWAgaXMgbm90IGBmYWxzZWApLlxuICAgKiBpbiBjYXNlIG9mIEdyb3VwIG5vIGNoYW5nZXMgdG8gYm91bmRpbmcgYm94IGFyZSBtYWRlLlxuICAgKiBPYmplY3RzIHNob3VsZCBiZSBpbnN0YW5jZXMgb2YgKG9yIGluaGVyaXQgZnJvbSkgZmFicmljLk9iamVjdFxuICAgKiBVc2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyBoaWdobHkgZGlzY291cmFnZWQgZm9yIGdyb3Vwcy5cbiAgICogeW91IGNhbiBhZGQgYSBidW5jaCBvZiBvYmplY3RzIHdpdGggdGhlIGFkZCBtZXRob2QgYnV0IHRoZW4geW91IE5FRURcbiAgICogdG8gcnVuIGEgYWRkV2l0aFVwZGF0ZSBjYWxsIGZvciB0aGUgR3JvdXAgY2xhc3Mgb3IgcG9zaXRpb24vYmJveCB3aWxsIGJlIHdyb25nLlxuICAgKiBAcGFyYW0gey4uLmZhYnJpYy5PYmplY3R9IG9iamVjdCBaZXJvIG9yIG1vcmUgZmFicmljIGluc3RhbmNlc1xuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGFkZDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX29iamVjdHMucHVzaC5hcHBseSh0aGlzLl9vYmplY3RzLCBhcmd1bWVudHMpO1xuICAgIGlmICh0aGlzLl9vbk9iamVjdEFkZGVkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX29uT2JqZWN0QWRkZWQoYXJndW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogSW5zZXJ0cyBhbiBvYmplY3QgaW50byBjb2xsZWN0aW9uIGF0IHNwZWNpZmllZCBpbmRleCwgdGhlbiByZW5kZXJzIGNhbnZhcyAoaWYgYHJlbmRlck9uQWRkUmVtb3ZlYCBpcyBub3QgYGZhbHNlYClcbiAgICogQW4gb2JqZWN0IHNob3VsZCBiZSBhbiBpbnN0YW5jZSBvZiAob3IgaW5oZXJpdCBmcm9tKSBmYWJyaWMuT2JqZWN0XG4gICAqIFVzZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIGhpZ2hseSBkaXNjb3VyYWdlZCBmb3IgZ3JvdXBzLlxuICAgKiB5b3UgY2FuIGFkZCBhIGJ1bmNoIG9mIG9iamVjdHMgd2l0aCB0aGUgaW5zZXJ0QXQgbWV0aG9kIGJ1dCB0aGVuIHlvdSBORUVEXG4gICAqIHRvIHJ1biBhIGFkZFdpdGhVcGRhdGUgY2FsbCBmb3IgdGhlIEdyb3VwIGNsYXNzIG9yIHBvc2l0aW9uL2Jib3ggd2lsbCBiZSB3cm9uZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBJbmRleCB0byBpbnNlcnQgb2JqZWN0IGF0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbm9uU3BsaWNpbmcgV2hlbiBgdHJ1ZWAsIG5vIHNwbGljaW5nIChzaGlmdGluZykgb2Ygb2JqZWN0cyBvY2N1cnNcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBpbnNlcnRBdDogZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgsIG5vblNwbGljaW5nKSB7XG4gICAgdmFyIG9iamVjdHMgPSB0aGlzLmdldE9iamVjdHMoKTtcbiAgICBpZiAobm9uU3BsaWNpbmcpIHtcbiAgICAgIG9iamVjdHNbaW5kZXhdID0gb2JqZWN0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG9iamVjdHMuc3BsaWNlKGluZGV4LCAwLCBvYmplY3QpO1xuICAgIH1cbiAgICB0aGlzLl9vbk9iamVjdEFkZGVkICYmIHRoaXMuX29uT2JqZWN0QWRkZWQob2JqZWN0KTtcbiAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIG9iamVjdHMgZnJvbSBhIGNvbGxlY3Rpb24sIHRoZW4gcmVuZGVycyBjYW52YXMgKGlmIGByZW5kZXJPbkFkZFJlbW92ZWAgaXMgbm90IGBmYWxzZWApXG4gICAqIEBwYXJhbSB7Li4uZmFicmljLk9iamVjdH0gb2JqZWN0IFplcm8gb3IgbW9yZSBmYWJyaWMgaW5zdGFuY2VzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2JqZWN0cyA9IHRoaXMuZ2V0T2JqZWN0cygpLFxuICAgICAgICBpbmRleCwgc29tZXRoaW5nUmVtb3ZlZCA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaW5kZXggPSBvYmplY3RzLmluZGV4T2YoYXJndW1lbnRzW2ldKTtcblxuICAgICAgLy8gb25seSBjYWxsIG9uT2JqZWN0UmVtb3ZlZCBpZiBhbiBvYmplY3Qgd2FzIGFjdHVhbGx5IHJlbW92ZWRcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgc29tZXRoaW5nUmVtb3ZlZCA9IHRydWU7XG4gICAgICAgIG9iamVjdHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5fb25PYmplY3RSZW1vdmVkICYmIHRoaXMuX29uT2JqZWN0UmVtb3ZlZChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgc29tZXRoaW5nUmVtb3ZlZCAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogRXhlY3V0ZXMgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2ggb2JqZWN0IGluIHRoaXMgZ3JvdXBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogICAgICAgICAgICAgICAgICAgQ2FsbGJhY2sgaW52b2tlZCB3aXRoIGN1cnJlbnQgb2JqZWN0IGFzIGZpcnN0IGFyZ3VtZW50LFxuICAgKiAgICAgICAgICAgICAgICAgICBpbmRleCAtIGFzIHNlY29uZCBhbmQgYW4gYXJyYXkgb2YgYWxsIG9iamVjdHMgLSBhcyB0aGlyZC5cbiAgICogICAgICAgICAgICAgICAgICAgQ2FsbGJhY2sgaXMgaW52b2tlZCBpbiBhIGNvbnRleHQgb2YgR2xvYmFsIE9iamVjdCAoZS5nLiBgd2luZG93YClcbiAgICogICAgICAgICAgICAgICAgICAgd2hlbiBubyBgY29udGV4dGAgYXJndW1lbnQgaXMgZ2l2ZW5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgQ29udGV4dCAoYWthIHRoaXNPYmplY3QpXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZm9yRWFjaE9iamVjdDogZnVuY3Rpb24oY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB2YXIgb2JqZWN0cyA9IHRoaXMuZ2V0T2JqZWN0cygpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG9iamVjdHNbaV0sIGksIG9iamVjdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBjaGlsZHJlbiBvYmplY3RzIG9mIHRoaXMgaW5zdGFuY2VcbiAgICogVHlwZSBwYXJhbWV0ZXIgaW50cm9kdWNlZCBpbiAxLjMuMTBcbiAgICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSBXaGVuIHNwZWNpZmllZCwgb25seSBvYmplY3RzIG9mIHRoaXMgdHlwZSBhcmUgcmV0dXJuZWRcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBnZXRPYmplY3RzOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRoaXMuX29iamVjdHM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9vYmplY3RzLmZpbHRlcihmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gby50eXBlID09PSB0eXBlO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG9iamVjdCBhdCBzcGVjaWZpZWQgaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICovXG4gIGl0ZW06IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldE9iamVjdHMoKVtpbmRleF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBjb2xsZWN0aW9uIGNvbnRhaW5zIG5vIG9iamVjdHNcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBjb2xsZWN0aW9uIGlzIGVtcHR5XG4gICAqL1xuICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0cygpLmxlbmd0aCA9PT0gMDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHNpemUgb2YgYSBjb2xsZWN0aW9uIChpLmU6IGxlbmd0aCBvZiBhbiBhcnJheSBjb250YWluaW5nIGl0cyBvYmplY3RzKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IENvbGxlY3Rpb24gc2l6ZVxuICAgKi9cbiAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0cygpLmxlbmd0aDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGNvbGxlY3Rpb24gY29udGFpbnMgYW4gb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNoZWNrIGFnYWluc3RcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGNvbGxlY3Rpb24gY29udGFpbnMgYW4gb2JqZWN0XG4gICAqL1xuICBjb250YWluczogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0cygpLmluZGV4T2Yob2JqZWN0KSA+IC0xO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG51bWJlciByZXByZXNlbnRhdGlvbiBvZiBhIGNvbGxlY3Rpb24gY29tcGxleGl0eVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHlcbiAgICovXG4gIGNvbXBsZXhpdHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RzKCkucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBjdXJyZW50KSB7XG4gICAgICBtZW1vICs9IGN1cnJlbnQuY29tcGxleGl0eSA/IGN1cnJlbnQuY29tcGxleGl0eSgpIDogMDtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIDApO1xuICB9XG59O1xuXG5cbi8qKlxuICogQG5hbWVzcGFjZSBmYWJyaWMuQ29tbW9uTWV0aG9kc1xuICovXG5mYWJyaWMuQ29tbW9uTWV0aG9kcyA9IHtcblxuICAvKipcbiAgICogU2V0cyBvYmplY3QncyBwcm9wZXJ0aWVzIGZyb20gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBfc2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgICAgdGhpcy5zZXQocHJvcCwgb3B0aW9uc1twcm9wXSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2ZpbGxlcl0gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gcHJvcGVydHkgdG8gc2V0IHRoZSBHcmFkaWVudCB0b1xuICAgKi9cbiAgX2luaXRHcmFkaWVudDogZnVuY3Rpb24oZmlsbGVyLCBwcm9wZXJ0eSkge1xuICAgIGlmIChmaWxsZXIgJiYgZmlsbGVyLmNvbG9yU3RvcHMgJiYgIShmaWxsZXIgaW5zdGFuY2VvZiBmYWJyaWMuR3JhZGllbnQpKSB7XG4gICAgICB0aGlzLnNldChwcm9wZXJ0eSwgbmV3IGZhYnJpYy5HcmFkaWVudChmaWxsZXIpKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsbGVyXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSBwcm9wZXJ0eSB0byBzZXQgdGhlIFBhdHRlcm4gdG9cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayB0byBpbnZva2UgYWZ0ZXIgcGF0dGVybiBsb2FkXG4gICAqL1xuICBfaW5pdFBhdHRlcm46IGZ1bmN0aW9uKGZpbGxlciwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgaWYgKGZpbGxlciAmJiBmaWxsZXIuc291cmNlICYmICEoZmlsbGVyIGluc3RhbmNlb2YgZmFicmljLlBhdHRlcm4pKSB7XG4gICAgICB0aGlzLnNldChwcm9wZXJ0eSwgbmV3IGZhYnJpYy5QYXR0ZXJuKGZpbGxlciwgY2FsbGJhY2spKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgX2luaXRDbGlwcGluZzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5jbGlwVG8gfHwgdHlwZW9mIG9wdGlvbnMuY2xpcFRvICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmdW5jdGlvbkJvZHkgPSBmYWJyaWMudXRpbC5nZXRGdW5jdGlvbkJvZHkob3B0aW9ucy5jbGlwVG8pO1xuICAgIGlmICh0eXBlb2YgZnVuY3Rpb25Cb2R5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5jbGlwVG8gPSBuZXcgRnVuY3Rpb24oJ2N0eCcsIGZ1bmN0aW9uQm9keSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldE9iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgIHRoaXMuX3NldChwcm9wLCBvYmpbcHJvcF0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBwcm9wZXJ0eSB0byBhIGdpdmVuIHZhbHVlLiBXaGVuIGNoYW5naW5nIHBvc2l0aW9uL2RpbWVuc2lvbiAtcmVsYXRlZCBwcm9wZXJ0aWVzIChsZWZ0LCB0b3AsIHNjYWxlLCBhbmdsZSwgZXRjLikgYHNldGAgZG9lcyBub3QgdXBkYXRlIHBvc2l0aW9uIG9mIG9iamVjdCdzIGJvcmRlcnMvY29udHJvbHMuIElmIHlvdSBuZWVkIHRvIHVwZGF0ZSB0aG9zZSwgY2FsbCBgc2V0Q29vcmRzKClgLlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGtleSBQcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCAoaWYgb2JqZWN0LCBpdGVyYXRlIG92ZXIgdGhlIG9iamVjdCBwcm9wZXJ0aWVzKVxuICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gdmFsdWUgUHJvcGVydHkgdmFsdWUgKGlmIGZ1bmN0aW9uLCB0aGUgdmFsdWUgaXMgcGFzc2VkIGludG8gaXQgYW5kIGl0cyByZXR1cm4gdmFsdWUgaXMgdXNlZCBhcyBhIG5ldyBvbmUpXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLl9zZXRPYmplY3Qoa2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIGtleSAhPT0gJ2NsaXBUbycpIHtcbiAgICAgICAgdGhpcy5fc2V0KGtleSwgdmFsdWUodGhpcy5nZXQoa2V5KSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3NldChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHNwZWNpZmllZCBwcm9wZXJ0eSBmcm9tIGB0cnVlYCB0byBgZmFsc2VgIG9yIGZyb20gYGZhbHNlYCB0byBgdHJ1ZWBcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIHRvZ2dsZVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHRvZ2dsZTogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldChwcm9wZXJ0eSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aGlzLnNldChwcm9wZXJ0eSwgIXZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJhc2ljIGdldHRlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgKiBAcmV0dXJuIHsqfSB2YWx1ZSBvZiBhIHByb3BlcnR5XG4gICAqL1xuICBnZXQ6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIHRoaXNbcHJvcGVydHldO1xuICB9XG59O1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICB2YXIgc3FydCA9IE1hdGguc3FydCxcbiAgICAgIGF0YW4yID0gTWF0aC5hdGFuMixcbiAgICAgIHBvdyA9IE1hdGgucG93LFxuICAgICAgYWJzID0gTWF0aC5hYnMsXG4gICAgICBQaUJ5MTgwID0gTWF0aC5QSSAvIDE4MCxcbiAgICAgIFBpQnkyID0gTWF0aC5QSSAvIDI7XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2UgZmFicmljLnV0aWxcbiAgICovXG4gIGZhYnJpYy51dGlsID0ge1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb3Mgb2YgYW4gYW5nbGUsIGF2b2lkaW5nIHJldHVybmluZyBmbG9hdHMgZm9yIGtub3duIHJlc3VsdHNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIHRoZSBhbmdsZSBpbiByYWRpYW5zIG9yIGluIGRlZ3JlZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBjb3M6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IDApIHsgcmV0dXJuIDE7IH1cbiAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgLy8gY29zKGEpID0gY29zKC1hKVxuICAgICAgICBhbmdsZSA9IC1hbmdsZTtcbiAgICAgIH1cbiAgICAgIHZhciBhbmdsZVNsaWNlID0gYW5nbGUgLyBQaUJ5MjtcbiAgICAgIHN3aXRjaCAoYW5nbGVTbGljZSkge1xuICAgICAgICBjYXNlIDE6IGNhc2UgMzogcmV0dXJuIDA7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGguY29zKGFuZ2xlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBzaW4gb2YgYW4gYW5nbGUsIGF2b2lkaW5nIHJldHVybmluZyBmbG9hdHMgZm9yIGtub3duIHJlc3VsdHNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIHRoZSBhbmdsZSBpbiByYWRpYW5zIG9yIGluIGRlZ3JlZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBzaW46IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IDApIHsgcmV0dXJuIDA7IH1cbiAgICAgIHZhciBhbmdsZVNsaWNlID0gYW5nbGUgLyBQaUJ5Miwgc2lnbiA9IDE7XG4gICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgIC8vIHNpbigtYSkgPSAtc2luKGEpXG4gICAgICAgIHNpZ24gPSAtMTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoYW5nbGVTbGljZSkge1xuICAgICAgICBjYXNlIDE6IHJldHVybiBzaWduO1xuICAgICAgICBjYXNlIDI6IHJldHVybiAwO1xuICAgICAgICBjYXNlIDM6IHJldHVybiAtc2lnbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLnNpbihhbmdsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdmFsdWUgZnJvbSBhbiBhcnJheS5cbiAgICAgKiBQcmVzZW5jZSBvZiB2YWx1ZSAoYW5kIGl0cyBwb3NpdGlvbiBpbiBhbiBhcnJheSkgaXMgZGV0ZXJtaW5lZCB2aWEgYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gb3JpZ2luYWwgYXJyYXlcbiAgICAgKi9cbiAgICByZW1vdmVGcm9tQXJyYXk6IGZ1bmN0aW9uKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGlkeCA9IGFycmF5LmluZGV4T2YodmFsdWUpO1xuICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgYXJyYXkuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmFuZG9tIG51bWJlciBiZXR3ZWVuIDIgc3BlY2lmaWVkIG9uZXMuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW4gbG93ZXIgbGltaXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4IHVwcGVyIGxpbWl0XG4gICAgICogQHJldHVybiB7TnVtYmVyfSByYW5kb20gdmFsdWUgKGJldHdlZW4gbWluIGFuZCBtYXgpXG4gICAgICovXG4gICAgZ2V0UmFuZG9tSW50OiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgZGVncmVlcyB0byByYWRpYW5zLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVncmVlcyB2YWx1ZSBpbiBkZWdyZWVzXG4gICAgICogQHJldHVybiB7TnVtYmVyfSB2YWx1ZSBpbiByYWRpYW5zXG4gICAgICovXG4gICAgZGVncmVlc1RvUmFkaWFuczogZnVuY3Rpb24oZGVncmVlcykge1xuICAgICAgcmV0dXJuIGRlZ3JlZXMgKiBQaUJ5MTgwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHJhZGlhbnMgdG8gZGVncmVlcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGlhbnMgdmFsdWUgaW4gcmFkaWFuc1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gdmFsdWUgaW4gZGVncmVlc1xuICAgICAqL1xuICAgIHJhZGlhbnNUb0RlZ3JlZXM6IGZ1bmN0aW9uKHJhZGlhbnMpIHtcbiAgICAgIHJldHVybiByYWRpYW5zIC8gUGlCeTE4MDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyBgcG9pbnRgIGFyb3VuZCBgb3JpZ2luYCB3aXRoIGByYWRpYW5zYFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHRvIHJvdGF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBvcmlnaW4gVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaWFucyBUaGUgcmFkaWFucyBvZiB0aGUgYW5nbGUgZm9yIHRoZSByb3RhdGlvblxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gVGhlIG5ldyByb3RhdGVkIHBvaW50XG4gICAgICovXG4gICAgcm90YXRlUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBvcmlnaW4sIHJhZGlhbnMpIHtcbiAgICAgIHBvaW50LnN1YnRyYWN0RXF1YWxzKG9yaWdpbik7XG4gICAgICB2YXIgdiA9IGZhYnJpYy51dGlsLnJvdGF0ZVZlY3Rvcihwb2ludCwgcmFkaWFucyk7XG4gICAgICByZXR1cm4gbmV3IGZhYnJpYy5Qb2ludCh2LngsIHYueSkuYWRkRXF1YWxzKG9yaWdpbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgYHZlY3RvcmAgd2l0aCBgcmFkaWFuc2BcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZlY3RvciBUaGUgdmVjdG9yIHRvIHJvdGF0ZSAoeCBhbmQgeSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaWFucyBUaGUgcmFkaWFucyBvZiB0aGUgYW5nbGUgZm9yIHRoZSByb3RhdGlvblxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyByb3RhdGVkIHBvaW50XG4gICAgICovXG4gICAgcm90YXRlVmVjdG9yOiBmdW5jdGlvbih2ZWN0b3IsIHJhZGlhbnMpIHtcbiAgICAgIHZhciBzaW4gPSBmYWJyaWMudXRpbC5zaW4ocmFkaWFucyksXG4gICAgICAgICAgY29zID0gZmFicmljLnV0aWwuY29zKHJhZGlhbnMpLFxuICAgICAgICAgIHJ4ID0gdmVjdG9yLnggKiBjb3MgLSB2ZWN0b3IueSAqIHNpbixcbiAgICAgICAgICByeSA9IHZlY3Rvci54ICogc2luICsgdmVjdG9yLnkgKiBjb3M7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiByeCxcbiAgICAgICAgeTogcnlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRyYW5zZm9ybSB0IHRvIHBvaW50IHBcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7ZmFicmljLlBvaW50fSBwIFRoZSBwb2ludCB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gdCBUaGUgdHJhbnNmb3JtXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW2lnbm9yZU9mZnNldF0gSW5kaWNhdGVzIHRoYXQgdGhlIG9mZnNldCBzaG91bGQgbm90IGJlIGFwcGxpZWRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IFRoZSB0cmFuc2Zvcm1lZCBwb2ludFxuICAgICAqL1xuICAgIHRyYW5zZm9ybVBvaW50OiBmdW5jdGlvbihwLCB0LCBpZ25vcmVPZmZzZXQpIHtcbiAgICAgIGlmIChpZ25vcmVPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQoXG4gICAgICAgICAgdFswXSAqIHAueCArIHRbMl0gKiBwLnksXG4gICAgICAgICAgdFsxXSAqIHAueCArIHRbM10gKiBwLnlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KFxuICAgICAgICB0WzBdICogcC54ICsgdFsyXSAqIHAueSArIHRbNF0sXG4gICAgICAgIHRbMV0gKiBwLnggKyB0WzNdICogcC55ICsgdFs1XVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb29yZGluYXRlcyBvZiBwb2ludHMncyBib3VuZGluZyByZWN0YW5nbGUgKGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodClcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgNCBwb2ludHMgYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgbWFrZUJvdW5kaW5nQm94RnJvbVBvaW50czogZnVuY3Rpb24ocG9pbnRzKSB7XG4gICAgICB2YXIgeFBvaW50cyA9IFtwb2ludHNbMF0ueCwgcG9pbnRzWzFdLngsIHBvaW50c1syXS54LCBwb2ludHNbM10ueF0sXG4gICAgICAgICAgbWluWCA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbih4UG9pbnRzKSxcbiAgICAgICAgICBtYXhYID0gZmFicmljLnV0aWwuYXJyYXkubWF4KHhQb2ludHMpLFxuICAgICAgICAgIHdpZHRoID0gbWF4WCAtIG1pblgsXG4gICAgICAgICAgeVBvaW50cyA9IFtwb2ludHNbMF0ueSwgcG9pbnRzWzFdLnksIHBvaW50c1syXS55LCBwb2ludHNbM10ueV0sXG4gICAgICAgICAgbWluWSA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbih5UG9pbnRzKSxcbiAgICAgICAgICBtYXhZID0gZmFicmljLnV0aWwuYXJyYXkubWF4KHlQb2ludHMpLFxuICAgICAgICAgIGhlaWdodCA9IG1heFkgLSBtaW5ZO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBtaW5YLFxuICAgICAgICB0b3A6IG1pblksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludmVydCB0cmFuc2Zvcm1hdGlvbiB0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHQgVGhlIHRyYW5zZm9ybVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgaW52ZXJ0ZWQgdHJhbnNmb3JtXG4gICAgICovXG4gICAgaW52ZXJ0VHJhbnNmb3JtOiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgYSA9IDEgLyAodFswXSAqIHRbM10gLSB0WzFdICogdFsyXSksXG4gICAgICAgICAgciA9IFthICogdFszXSwgLWEgKiB0WzFdLCAtYSAqIHRbMl0sIGEgKiB0WzBdXSxcbiAgICAgICAgICBvID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoeyB4OiB0WzRdLCB5OiB0WzVdIH0sIHIsIHRydWUpO1xuICAgICAgcls0XSA9IC1vLng7XG4gICAgICByWzVdID0gLW8ueTtcbiAgICAgIHJldHVybiByO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHdyYXBwZXIgYXJvdW5kIE51bWJlciN0b0ZpeGVkLCB3aGljaCBjb250cmFyeSB0byBuYXRpdmUgbWV0aG9kIHJldHVybnMgbnVtYmVyLCBub3Qgc3RyaW5nLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IG51bWJlciBudW1iZXIgdG8gb3BlcmF0ZSBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFjdGlvbkRpZ2l0cyBudW1iZXIgb2YgZnJhY3Rpb24gZGlnaXRzIHRvIFwibGVhdmVcIlxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICB0b0ZpeGVkOiBmdW5jdGlvbihudW1iZXIsIGZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChOdW1iZXIobnVtYmVyKS50b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGZyb20gYXR0cmlidXRlIHZhbHVlIHRvIHBpeGVsIHZhbHVlIGlmIGFwcGxpY2FibGUuXG4gICAgICogUmV0dXJucyBjb252ZXJ0ZWQgcGl4ZWxzIG9yIG9yaWdpbmFsIHZhbHVlIG5vdCBjb252ZXJ0ZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZSBudW1iZXIgdG8gb3BlcmF0ZSBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmb250U2l6ZVxuICAgICAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9XG4gICAgICovXG4gICAgcGFyc2VVbml0OiBmdW5jdGlvbih2YWx1ZSwgZm9udFNpemUpIHtcbiAgICAgIHZhciB1bml0ID0gL1xcRHswLDJ9JC8uZXhlYyh2YWx1ZSksXG4gICAgICAgICAgbnVtYmVyID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICBpZiAoIWZvbnRTaXplKSB7XG4gICAgICAgIGZvbnRTaXplID0gZmFicmljLlRleHQuREVGQVVMVF9TVkdfRk9OVF9TSVpFO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh1bml0WzBdKSB7XG4gICAgICAgIGNhc2UgJ21tJzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZmFicmljLkRQSSAvIDI1LjQ7XG5cbiAgICAgICAgY2FzZSAnY20nOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmYWJyaWMuRFBJIC8gMi41NDtcblxuICAgICAgICBjYXNlICdpbic6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZhYnJpYy5EUEk7XG5cbiAgICAgICAgY2FzZSAncHQnOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmYWJyaWMuRFBJIC8gNzI7IC8vIG9yICogNCAvIDNcblxuICAgICAgICBjYXNlICdwYyc6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZhYnJpYy5EUEkgLyA3MiAqIDEyOyAvLyBvciAqIDE2XG5cbiAgICAgICAgY2FzZSAnZW0nOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmb250U2l6ZTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHdoaWNoIGFsd2F5cyByZXR1cm5zIGBmYWxzZWAuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZmFsc2VGdW5jdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMga2xhc3MgXCJDbGFzc1wiIG9iamVjdCBvZiBnaXZlbiBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9mIG9iamVjdCAoZWcuICdjaXJjbGUnKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgTmFtZXNwYWNlIHRvIGdldCBrbGFzcyBcIkNsYXNzXCIgb2JqZWN0IGZyb21cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGtsYXNzIFwiQ2xhc3NcIlxuICAgICAqL1xuICAgIGdldEtsYXNzOiBmdW5jdGlvbih0eXBlLCBuYW1lc3BhY2UpIHtcbiAgICAgIC8vIGNhcGl0YWxpemUgZmlyc3QgbGV0dGVyIG9ubHlcbiAgICAgIHR5cGUgPSBmYWJyaWMudXRpbC5zdHJpbmcuY2FtZWxpemUodHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR5cGUuc2xpY2UoMSkpO1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnJlc29sdmVOYW1lc3BhY2UobmFtZXNwYWNlKVt0eXBlXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhcnJheSBvZiBhdHRyaWJ1dGVzIGZvciBnaXZlbiBzdmcgdGhhdCBmYWJyaWMgcGFyc2VzXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSBvZiBzdmcgZWxlbWVudCAoZWcuICdjaXJjbGUnKVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBzdHJpbmcgbmFtZXMgb2Ygc3VwcG9ydGVkIGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICBnZXRTdmdBdHRyaWJ1dGVzOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IFtcbiAgICAgICAgJ2luc3RhbnRpYXRlZF9ieV91c2UnLFxuICAgICAgICAnc3R5bGUnLFxuICAgICAgICAnaWQnLFxuICAgICAgICAnY2xhc3MnXG4gICAgICBdO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2xpbmVhckdyYWRpZW50JzpcbiAgICAgICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5jb25jYXQoWyd4MScsICd5MScsICd4MicsICd5MicsICdncmFkaWVudFVuaXRzJywgJ2dyYWRpZW50VHJhbnNmb3JtJ10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyYWRpYWxHcmFkaWVudCc6XG4gICAgICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuY29uY2F0KFsnZ3JhZGllbnRVbml0cycsICdncmFkaWVudFRyYW5zZm9ybScsICdjeCcsICdjeScsICdyJywgJ2Z4JywgJ2Z5JywgJ2ZyJ10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdG9wJzpcbiAgICAgICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5jb25jYXQoWydvZmZzZXQnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3Qgb2YgZ2l2ZW4gbmFtZXNwYWNlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBOYW1lc3BhY2Ugc3RyaW5nIGUuZy4gJ2ZhYnJpYy5JbWFnZS5maWx0ZXInIG9yICdmYWJyaWMnXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgZm9yIGdpdmVuIG5hbWVzcGFjZSAoZGVmYXVsdCBmYWJyaWMpXG4gICAgICovXG4gICAgcmVzb2x2ZU5hbWVzcGFjZTogZnVuY3Rpb24obmFtZXNwYWNlKSB7XG4gICAgICBpZiAoIW5hbWVzcGFjZSkge1xuICAgICAgICByZXR1cm4gZmFicmljO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFydHMgPSBuYW1lc3BhY2Uuc3BsaXQoJy4nKSxcbiAgICAgICAgICBsZW4gPSBwYXJ0cy5sZW5ndGgsIGksXG4gICAgICAgICAgb2JqID0gZ2xvYmFsIHx8IGZhYnJpYy53aW5kb3c7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBvYmogPSBvYmpbcGFydHNbaV1dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBpbWFnZSBlbGVtZW50IGZyb20gZ2l2ZW4gdXJsIGFuZCBwYXNzZXMgaXQgdG8gYSBjYWxsYmFja1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIHJlcHJlc2VudGluZyBhbiBpbWFnZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrOyBpbnZva2VkIHdpdGggbG9hZGVkIGltYWdlXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF0gQ29udGV4dCB0byBpbnZva2UgY2FsbGJhY2sgaW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2Nyb3NzT3JpZ2luXSBjcm9zc09yaWdpbiB2YWx1ZSB0byBzZXQgaW1hZ2UgZWxlbWVudCB0b1xuICAgICAqL1xuICAgIGxvYWRJbWFnZTogZnVuY3Rpb24odXJsLCBjYWxsYmFjaywgY29udGV4dCwgY3Jvc3NPcmlnaW4pIHtcbiAgICAgIGlmICghdXJsKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgdXJsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW1nID0gZmFicmljLnV0aWwuY3JlYXRlSW1hZ2UoKTtcblxuICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgIHZhciBvbkxvYWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChjb250ZXh0LCBpbWcpO1xuICAgICAgICBpbWcgPSBpbWcub25sb2FkID0gaW1nLm9uZXJyb3IgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgaW1nLm9ubG9hZCA9IG9uTG9hZENhbGxiYWNrO1xuICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZhYnJpYy5sb2coJ0Vycm9yIGxvYWRpbmcgJyArIGltZy5zcmMpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG51bGwsIHRydWUpO1xuICAgICAgICBpbWcgPSBpbWcub25sb2FkID0gaW1nLm9uZXJyb3IgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgLy8gZGF0YS11cmxzIGFwcGVhciB0byBiZSBidWdneSB3aXRoIGNyb3NzT3JpZ2luXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20va2FuZ2F4L2ZhYnJpYy5qcy9jb21taXQvZDBhYmI5MGYxY2Q1YzVlZjlkMmE5NGQzZmIyMWEyMjMzMGRhM2UwYSNjb21taXRjb21tZW50LTQ1MTM3NjdcbiAgICAgIC8vIHNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzE1MTUyXG4gICAgICAvLyAgICAgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTM1MDY5XG4gICAgICBpZiAodXJsLmluZGV4T2YoJ2RhdGEnKSAhPT0gMCAmJiBjcm9zc09yaWdpbikge1xuICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgICAgIH1cblxuICAgICAgLy8gSUUxMCAvIElFMTEtRml4OiBTVkcgY29udGVudHMgZnJvbSBkYXRhOiBVUklcbiAgICAgIC8vIHdpbGwgb25seSBiZSBhdmFpbGFibGUgaWYgdGhlIElNRyBpcyBwcmVzZW50XG4gICAgICAvLyBpbiB0aGUgRE9NIChhbmQgdmlzaWJsZSlcbiAgICAgIGlmICh1cmwuc3Vic3RyaW5nKDAsMTQpID09PSAnZGF0YTppbWFnZS9zdmcnKSB7XG4gICAgICAgIGltZy5vbmxvYWQgPSBudWxsO1xuICAgICAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2VJbkRvbShpbWcsIG9uTG9hZENhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgU1ZHIGltYWdlIHdpdGggZGF0YTogVVJMIHRvIHRoZSBkb21cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1nIEltYWdlIG9iamVjdCB3aXRoIGRhdGE6aW1hZ2Uvc3ZnIHNyY1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrOyBpbnZva2VkIHdpdGggbG9hZGVkIGltYWdlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBET00gZWxlbWVudCAoZGl2IGNvbnRhaW5pbmcgdGhlIFNWRyBpbWFnZSlcbiAgICAgKi9cbiAgICBsb2FkSW1hZ2VJbkRvbTogZnVuY3Rpb24oaW1nLCBvbkxvYWRDYWxsYmFjaykge1xuICAgICAgdmFyIGRpdiA9IGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpdi5zdHlsZS53aWR0aCA9IGRpdi5zdHlsZS5oZWlnaHQgPSAnMXB4JztcbiAgICAgIGRpdi5zdHlsZS5sZWZ0ID0gZGl2LnN0eWxlLnRvcCA9ICctMTAwJSc7XG4gICAgICBkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgZGl2LmFwcGVuZENoaWxkKGltZyk7XG4gICAgICBmYWJyaWMuZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpLmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAvKipcbiAgICAgICAqIFdyYXAgaW4gZnVuY3Rpb24gdG86XG4gICAgICAgKiAgIDEuIENhbGwgZXhpc3RpbmcgY2FsbGJhY2tcbiAgICAgICAqICAgMi4gQ2xlYW51cCBET01cbiAgICAgICAqL1xuICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb25Mb2FkQ2FsbGJhY2soKTtcbiAgICAgICAgZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgICAgZGl2ID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgY29ycmVzcG9uZGluZyBmYWJyaWMgaW5zdGFuY2VzIGZyb20gdGhlaXIgb2JqZWN0IHJlcHJlc2VudGF0aW9uc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzIE9iamVjdHMgdG8gZW5saXZlblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFsbCBvYmplY3RzIGFyZSBjcmVhdGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBOYW1lc3BhY2UgdG8gZ2V0IGtsYXNzIFwiQ2xhc3NcIiBvYmplY3QgZnJvbVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJldml2ZXIgTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygb2JqZWN0IGVsZW1lbnRzLFxuICAgICAqIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBlbmxpdmVuT2JqZWN0czogZnVuY3Rpb24ob2JqZWN0cywgY2FsbGJhY2ssIG5hbWVzcGFjZSwgcmV2aXZlcikge1xuICAgICAgb2JqZWN0cyA9IG9iamVjdHMgfHwgW107XG5cbiAgICAgIGZ1bmN0aW9uIG9uTG9hZGVkKCkge1xuICAgICAgICBpZiAoKytudW1Mb2FkZWRPYmplY3RzID09PSBudW1Ub3RhbE9iamVjdHMpIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZW5saXZlbmVkT2JqZWN0cyA9IFtdLFxuICAgICAgICAgIG51bUxvYWRlZE9iamVjdHMgPSAwLFxuICAgICAgICAgIG51bVRvdGFsT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoO1xuXG4gICAgICBpZiAoIW51bVRvdGFsT2JqZWN0cykge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24gKG8sIGluZGV4KSB7XG4gICAgICAgIC8vIGlmIHNwYXJzZSBhcnJheVxuICAgICAgICBpZiAoIW8gfHwgIW8udHlwZSkge1xuICAgICAgICAgIG9uTG9hZGVkKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrbGFzcyA9IGZhYnJpYy51dGlsLmdldEtsYXNzKG8udHlwZSwgbmFtZXNwYWNlKTtcbiAgICAgICAga2xhc3MuZnJvbU9iamVjdChvLCBmdW5jdGlvbiAob2JqLCBlcnJvcikge1xuICAgICAgICAgIGVycm9yIHx8IChlbmxpdmVuZWRPYmplY3RzW2luZGV4XSA9IG9iaik7XG4gICAgICAgICAgcmV2aXZlciAmJiByZXZpdmVyKG8sIG9iaiwgZXJyb3IpO1xuICAgICAgICAgIG9uTG9hZGVkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgd2FpdCBmb3IgbG9hZGluZyBvZiBwYXR0ZXJuc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXR0ZXJucyBPYmplY3RzIHRvIGVubGl2ZW5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbGwgb2JqZWN0cyBhcmUgY3JlYXRlZFxuICAgICAqIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBlbmxpdmVuUGF0dGVybnM6IGZ1bmN0aW9uKHBhdHRlcm5zLCBjYWxsYmFjaykge1xuICAgICAgcGF0dGVybnMgPSBwYXR0ZXJucyB8fCBbXTtcblxuICAgICAgZnVuY3Rpb24gb25Mb2FkZWQoKSB7XG4gICAgICAgIGlmICgrK251bUxvYWRlZFBhdHRlcm5zID09PSBudW1QYXR0ZXJucykge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZFBhdHRlcm5zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZW5saXZlbmVkUGF0dGVybnMgPSBbXSxcbiAgICAgICAgICBudW1Mb2FkZWRQYXR0ZXJucyA9IDAsXG4gICAgICAgICAgbnVtUGF0dGVybnMgPSBwYXR0ZXJucy5sZW5ndGg7XG5cbiAgICAgIGlmICghbnVtUGF0dGVybnMpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW5saXZlbmVkUGF0dGVybnMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHBhdHRlcm5zLmZvckVhY2goZnVuY3Rpb24gKHAsIGluZGV4KSB7XG4gICAgICAgIGlmIChwICYmIHAuc291cmNlKSB7XG4gICAgICAgICAgbmV3IGZhYnJpYy5QYXR0ZXJuKHAsIGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICAgICAgICAgIGVubGl2ZW5lZFBhdHRlcm5zW2luZGV4XSA9IHBhdHRlcm47XG4gICAgICAgICAgICBvbkxvYWRlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGVubGl2ZW5lZFBhdHRlcm5zW2luZGV4XSA9IHA7XG4gICAgICAgICAgb25Mb2FkZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdyb3VwcyBTVkcgZWxlbWVudHMgKHVzdWFsbHkgdGhvc2UgcmV0cmlldmVkIGZyb20gU1ZHIGRvY3VtZW50KVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBlbGVtZW50cyBTVkcgZWxlbWVudHMgdG8gZ3JvdXBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVmFsdWUgdG8gc2V0IHNvdXJjZVBhdGggdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fGZhYnJpYy5Hcm91cH1cbiAgICAgKi9cbiAgICBncm91cFNWR0VsZW1lbnRzOiBmdW5jdGlvbihlbGVtZW50cywgb3B0aW9ucywgcGF0aCkge1xuICAgICAgdmFyIG9iamVjdDtcbiAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzWzBdO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggJiYgb3B0aW9ucy5oZWlnaHQpIHtcbiAgICAgICAgICBvcHRpb25zLmNlbnRlclBvaW50ID0ge1xuICAgICAgICAgICAgeDogb3B0aW9ucy53aWR0aCAvIDIsXG4gICAgICAgICAgICB5OiBvcHRpb25zLmhlaWdodCAvIDJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLndpZHRoO1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb2JqZWN0ID0gbmV3IGZhYnJpYy5Hcm91cChlbGVtZW50cywgb3B0aW9ucyk7XG4gICAgICBpZiAodHlwZW9mIHBhdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9iamVjdC5zb3VyY2VQYXRoID0gcGF0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBvcHVsYXRlcyBhbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIG9mIGFub3RoZXIgb2JqZWN0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgU291cmNlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gcHJvcGVydGllcyBQcm9wZXJ0aWVzIG5hbWVzIHRvIGluY2x1ZGVcbiAgICAgKi9cbiAgICBwb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzOiBmdW5jdGlvbihzb3VyY2UsIGRlc3RpbmF0aW9uLCBwcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAocHJvcGVydGllcyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvcGVydGllcykgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllc1tpXSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnRpZXNbaV1dID0gc291cmNlW3Byb3BlcnRpZXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIGRhc2hlZCBsaW5lIGJldHdlZW4gdHdvIHBvaW50c1xuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBkcmF3IGRhc2hlZCBsaW5lIGFyb3VuZCBzZWxlY3Rpb24gYXJlYS5cbiAgICAgKiBTZWUgPGEgaHJlZj1cImh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDU3NjcyNC9kb3R0ZWQtc3Ryb2tlLWluLWNhbnZhc1wiPmRvdHRlZCBzdHJva2UgaW4gY2FudmFzPC9hPlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggIHN0YXJ0IHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHN0YXJ0IHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4MiBlbmQgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkyIGVuZCB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYSBkYXNoIGFycmF5IHBhdHRlcm5cbiAgICAgKi9cbiAgICBkcmF3RGFzaGVkTGluZTogZnVuY3Rpb24oY3R4LCB4LCB5LCB4MiwgeTIsIGRhKSB7XG4gICAgICB2YXIgZHggPSB4MiAtIHgsXG4gICAgICAgICAgZHkgPSB5MiAtIHksXG4gICAgICAgICAgbGVuID0gc3FydChkeCAqIGR4ICsgZHkgKiBkeSksXG4gICAgICAgICAgcm90ID0gYXRhbjIoZHksIGR4KSxcbiAgICAgICAgICBkYyA9IGRhLmxlbmd0aCxcbiAgICAgICAgICBkaSA9IDAsXG4gICAgICAgICAgZHJhdyA9IHRydWU7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgICAgIGN0eC5yb3RhdGUocm90KTtcblxuICAgICAgeCA9IDA7XG4gICAgICB3aGlsZSAobGVuID4geCkge1xuICAgICAgICB4ICs9IGRhW2RpKysgJSBkY107XG4gICAgICAgIGlmICh4ID4gbGVuKSB7XG4gICAgICAgICAgeCA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBjdHhbZHJhdyA/ICdsaW5lVG8nIDogJ21vdmVUbyddKHgsIDApO1xuICAgICAgICBkcmF3ID0gIWRyYXc7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHJldHVybiB7Q2FudmFzRWxlbWVudH0gaW5pdGlhbGl6ZWQgY2FudmFzIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjcmVhdGVDYW52YXNFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgaW1hZ2UgZWxlbWVudCAod29ya3Mgb24gY2xpZW50IGFuZCBub2RlKVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBIVE1MIGltYWdlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjcmVhdGVJbWFnZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgMi4wLjBcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHJlY2VpdmVyIE9iamVjdCBpbXBsZW1lbnRpbmcgYGNsaXBUb2AgbWV0aG9kXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGNsaXBcbiAgICAgKi9cbiAgICBjbGlwQ29udGV4dDogZnVuY3Rpb24ocmVjZWl2ZXIsIGN0eCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHJlY2VpdmVyLmNsaXBUbyhjdHgpO1xuICAgICAgY3R4LmNsaXAoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgbWF0cml4IEEgYnkgbWF0cml4IEIgdG8gbmVzdCB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGEgRmlyc3QgdHJhbnNmb3JtTWF0cml4XG4gICAgICogQHBhcmFtICB7QXJyYXl9IGIgU2Vjb25kIHRyYW5zZm9ybU1hdHJpeFxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGlzMngyIGZsYWcgdG8gbXVsdGlwbHkgbWF0cmljZXMgYXMgMngyIG1hdHJpY2VzXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBwcm9kdWN0IG9mIHRoZSB0d28gdHJhbnNmb3JtIG1hdHJpY2VzXG4gICAgICovXG4gICAgbXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlczogZnVuY3Rpb24oYSwgYiwgaXMyeDIpIHtcbiAgICAgIC8vIE1hdHJpeCBtdWx0aXBseSBhICogYlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYVswXSAqIGJbMF0gKyBhWzJdICogYlsxXSxcbiAgICAgICAgYVsxXSAqIGJbMF0gKyBhWzNdICogYlsxXSxcbiAgICAgICAgYVswXSAqIGJbMl0gKyBhWzJdICogYlszXSxcbiAgICAgICAgYVsxXSAqIGJbMl0gKyBhWzNdICogYlszXSxcbiAgICAgICAgaXMyeDIgPyAwIDogYVswXSAqIGJbNF0gKyBhWzJdICogYls1XSArIGFbNF0sXG4gICAgICAgIGlzMngyID8gMCA6IGFbMV0gKiBiWzRdICsgYVszXSAqIGJbNV0gKyBhWzVdXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNvbXBvc2VzIHN0YW5kYXJkIDJ4MiBtYXRyaXggaW50byB0cmFuc2Zvcm0gY29tcG9uZW50ZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGEgdHJhbnNmb3JtTWF0cml4XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDb21wb25lbnRzIG9mIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIHFyRGVjb21wb3NlOiBmdW5jdGlvbihhKSB7XG4gICAgICB2YXIgYW5nbGUgPSBhdGFuMihhWzFdLCBhWzBdKSxcbiAgICAgICAgICBkZW5vbSA9IHBvdyhhWzBdLCAyKSArIHBvdyhhWzFdLCAyKSxcbiAgICAgICAgICBzY2FsZVggPSBzcXJ0KGRlbm9tKSxcbiAgICAgICAgICBzY2FsZVkgPSAoYVswXSAqIGFbM10gLSBhWzJdICogYSBbMV0pIC8gc2NhbGVYLFxuICAgICAgICAgIHNrZXdYID0gYXRhbjIoYVswXSAqIGFbMl0gKyBhWzFdICogYSBbM10sIGRlbm9tKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFuZ2xlOiBhbmdsZSAgLyBQaUJ5MTgwLFxuICAgICAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiBzY2FsZVksXG4gICAgICAgIHNrZXdYOiBza2V3WCAvIFBpQnkxODAsXG4gICAgICAgIHNrZXdZOiAwLFxuICAgICAgICB0cmFuc2xhdGVYOiBhWzRdLFxuICAgICAgICB0cmFuc2xhdGVZOiBhWzVdXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBjdXN0b21UcmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uKHNjYWxlWCwgc2NhbGVZLCBza2V3WCkge1xuICAgICAgdmFyIHNrZXdNYXRyaXhYID0gWzEsIDAsIGFicyhNYXRoLnRhbihza2V3WCAqIFBpQnkxODApKSwgMV0sXG4gICAgICAgICAgc2NhbGVNYXRyaXggPSBbYWJzKHNjYWxlWCksIDAsIDAsIGFicyhzY2FsZVkpXTtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKHNjYWxlTWF0cml4LCBza2V3TWF0cml4WCwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIHJlc2V0T2JqZWN0VHJhbnNmb3JtOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICB0YXJnZXQuc2NhbGVYID0gMTtcbiAgICAgIHRhcmdldC5zY2FsZVkgPSAxO1xuICAgICAgdGFyZ2V0LnNrZXdYID0gMDtcbiAgICAgIHRhcmdldC5za2V3WSA9IDA7XG4gICAgICB0YXJnZXQuZmxpcFggPSBmYWxzZTtcbiAgICAgIHRhcmdldC5mbGlwWSA9IGZhbHNlO1xuICAgICAgdGFyZ2V0LnJvdGF0ZSgwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZnVuY3Rpb24gYm9keVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGdldCBib2R5IG9mXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBGdW5jdGlvbiBib2R5XG4gICAgICovXG4gICAgZ2V0RnVuY3Rpb25Cb2R5OiBmdW5jdGlvbihmbikge1xuICAgICAgcmV0dXJuIChTdHJpbmcoZm4pLm1hdGNoKC9mdW5jdGlvbltee10qXFx7KFtcXHNcXFNdKilcXH0vKSB8fCB7fSlbMV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBjb250ZXh0IGhhcyB0cmFuc3BhcmVudCBwaXhlbFxuICAgICAqIGF0IHNwZWNpZmllZCBsb2NhdGlvbiAodGFraW5nIHRvbGVyYW5jZSBpbnRvIGFjY291bnQpXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgeSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvbGVyYW5jZSBUb2xlcmFuY2VcbiAgICAgKi9cbiAgICBpc1RyYW5zcGFyZW50OiBmdW5jdGlvbihjdHgsIHgsIHksIHRvbGVyYW5jZSkge1xuXG4gICAgICAvLyBJZiB0b2xlcmFuY2UgaXMgPiAwIGFkanVzdCBzdGFydCBjb29yZHMgdG8gdGFrZSBpbnRvIGFjY291bnQuXG4gICAgICAvLyBJZiBtb3ZlcyBvZmYgQ2FudmFzIGZpeCB0byAwXG4gICAgICBpZiAodG9sZXJhbmNlID4gMCkge1xuICAgICAgICBpZiAoeCA+IHRvbGVyYW5jZSkge1xuICAgICAgICAgIHggLT0gdG9sZXJhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ID4gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgeSAtPSB0b2xlcmFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgeSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIF9pc1RyYW5zcGFyZW50ID0gdHJ1ZSwgaSwgdGVtcCxcbiAgICAgICAgICBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKHgsIHksICh0b2xlcmFuY2UgKiAyKSB8fCAxLCAodG9sZXJhbmNlICogMikgfHwgMSksXG4gICAgICAgICAgbCA9IGltYWdlRGF0YS5kYXRhLmxlbmd0aDtcblxuICAgICAgLy8gU3BsaXQgaW1hZ2UgZGF0YSAtIGZvciB0b2xlcmFuY2UgPiAxLCBwaXhlbERhdGFTaXplID0gNDtcbiAgICAgIGZvciAoaSA9IDM7IGkgPCBsOyBpICs9IDQpIHtcbiAgICAgICAgdGVtcCA9IGltYWdlRGF0YS5kYXRhW2ldO1xuICAgICAgICBfaXNUcmFuc3BhcmVudCA9IHRlbXAgPD0gMDtcbiAgICAgICAgaWYgKF9pc1RyYW5zcGFyZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrOyAvLyBTdG9wIGlmIGNvbG91ciBmb3VuZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGltYWdlRGF0YSA9IG51bGw7XG5cbiAgICAgIHJldHVybiBfaXNUcmFuc3BhcmVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgcHJlc2VydmVBc3BlY3RSYXRpbyBhdHRyaWJ1dGUgZnJvbSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSB0byBiZSBwYXJzZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGFuIG9iamVjdCBjb250YWluaW5nIGFsaWduIGFuZCBtZWV0T3JTbGljZSBhdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBwYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGU6IGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIG1lZXRPclNsaWNlID0gJ21lZXQnLCBhbGlnblggPSAnTWlkJywgYWxpZ25ZID0gJ01pZCcsXG4gICAgICAgICAgYXNwZWN0UmF0aW9BdHRycyA9IGF0dHJpYnV0ZS5zcGxpdCgnICcpLCBhbGlnbjtcblxuICAgICAgaWYgKGFzcGVjdFJhdGlvQXR0cnMgJiYgYXNwZWN0UmF0aW9BdHRycy5sZW5ndGgpIHtcbiAgICAgICAgbWVldE9yU2xpY2UgPSBhc3BlY3RSYXRpb0F0dHJzLnBvcCgpO1xuICAgICAgICBpZiAobWVldE9yU2xpY2UgIT09ICdtZWV0JyAmJiBtZWV0T3JTbGljZSAhPT0gJ3NsaWNlJykge1xuICAgICAgICAgIGFsaWduID0gbWVldE9yU2xpY2U7XG4gICAgICAgICAgbWVldE9yU2xpY2UgPSAnbWVldCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXNwZWN0UmF0aW9BdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICBhbGlnbiA9IGFzcGVjdFJhdGlvQXR0cnMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vZGl2aWRlIGFsaWduIGluIGFsaWduWCBhbmQgYWxpZ25ZXG4gICAgICBhbGlnblggPSBhbGlnbiAhPT0gJ25vbmUnID8gYWxpZ24uc2xpY2UoMSwgNCkgOiAnbm9uZSc7XG4gICAgICBhbGlnblkgPSBhbGlnbiAhPT0gJ25vbmUnID8gYWxpZ24uc2xpY2UoNSwgOCkgOiAnbm9uZSc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZWV0T3JTbGljZTogbWVldE9yU2xpY2UsXG4gICAgICAgIGFsaWduWDogYWxpZ25YLFxuICAgICAgICBhbGlnblk6IGFsaWduWVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgY2hhciB3aWR0aHMgY2FjaGUgZm9yIHRoZSBnaXZlbiBmb250IGZhbWlseSBvciBhbGwgdGhlIGNhY2hlIGlmIG5vXG4gICAgICogZm9udEZhbWlseSBpcyBzcGVjaWZpZWQuXG4gICAgICogVXNlIGl0IGlmIHlvdSBrbm93IHlvdSBhcmUgbG9hZGluZyBmb250cyBpbiBhIGxhenkgd2F5IGFuZCB5b3UgYXJlIG5vdCB3YWl0aW5nXG4gICAgICogZm9yIGN1c3RvbSBmb250cyB0byBsb2FkIHByb3Blcmx5IHdoZW4gYWRkaW5nIHRleHQgb2JqZWN0cyB0byB0aGUgY2FudmFzLlxuICAgICAqIElmIGEgdGV4dCBvYmplY3QgaXMgYWRkZWQgd2hlbiBpdHMgb3duIGZvbnQgaXMgbm90IGxvYWRlZCB5ZXQsIHlvdSB3aWxsIGdldCB3cm9uZ1xuICAgICAqIG1lYXN1cmVtZW50IGFuZCBzbyB3cm9uZyBib3VuZGluZyBib3hlcy5cbiAgICAgKiBBZnRlciB0aGUgZm9udCBjYWNoZSBpcyBjbGVhcmVkLCBlaXRoZXIgY2hhbmdlIHRoZSB0ZXh0T2JqZWN0IHRleHQgY29udGVudCBvciBjYWxsXG4gICAgICogaW5pdERpbWVuc2lvbnMoKSB0byB0cmlnZ2VyIGEgcmVjYWxjdWxhdGlvblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZm9udEZhbWlseV0gZm9udCBmYW1pbHkgdG8gY2xlYXJcbiAgICAgKi9cbiAgICBjbGVhckZhYnJpY0ZvbnRDYWNoZTogZnVuY3Rpb24oZm9udEZhbWlseSkge1xuICAgICAgZm9udEZhbWlseSA9IChmb250RmFtaWx5IHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKCFmb250RmFtaWx5KSB7XG4gICAgICAgIGZhYnJpYy5jaGFyV2lkdGhzQ2FjaGUgPSB7IH07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmYWJyaWMuY2hhcldpZHRoc0NhY2hlW2ZvbnRGYW1pbHldKSB7XG4gICAgICAgIGRlbGV0ZSBmYWJyaWMuY2hhcldpZHRoc0NhY2hlW2ZvbnRGYW1pbHldO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBjdXJyZW50IGFzcGVjdCByYXRpbywgZGV0ZXJtaW5lcyB0aGUgbWF4IHdpZHRoIGFuZCBoZWlnaHQgdGhhdCBjYW5cbiAgICAgKiByZXNwZWN0IHRoZSB0b3RhbCBhbGxvd2VkIGFyZWEgZm9yIHRoZSBjYWNoZS5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXIgYXNwZWN0IHJhdGlvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heGltdW1BcmVhIE1heGltdW0gYXJlYSB5b3Ugd2FudCB0byBhY2hpZXZlXG4gICAgICogQHJldHVybiB7T2JqZWN0Lnh9IExpbWl0ZWQgZGltZW5zaW9ucyBieSBYXG4gICAgICogQHJldHVybiB7T2JqZWN0Lnl9IExpbWl0ZWQgZGltZW5zaW9ucyBieSBZXG4gICAgICovXG4gICAgbGltaXREaW1zQnlBcmVhOiBmdW5jdGlvbihhciwgbWF4aW11bUFyZWEpIHtcbiAgICAgIHZhciByb3VnaFdpZHRoID0gTWF0aC5zcXJ0KG1heGltdW1BcmVhICogYXIpLFxuICAgICAgICAgIHBlcmZMaW1pdFNpemVZID0gTWF0aC5mbG9vcihtYXhpbXVtQXJlYSAvIHJvdWdoV2lkdGgpO1xuICAgICAgcmV0dXJuIHsgeDogTWF0aC5mbG9vcihyb3VnaFdpZHRoKSwgeTogcGVyZkxpbWl0U2l6ZVkgfTtcbiAgICB9LFxuXG4gICAgY2FwVmFsdWU6IGZ1bmN0aW9uKG1pbiwgdmFsdWUsIG1heCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4odmFsdWUsIG1heCkpO1xuICAgIH0sXG5cbiAgICBmaW5kU2NhbGVUb0ZpdDogZnVuY3Rpb24oc291cmNlLCBkZXN0aW5hdGlvbikge1xuICAgICAgcmV0dXJuIE1hdGgubWluKGRlc3RpbmF0aW9uLndpZHRoIC8gc291cmNlLndpZHRoLCBkZXN0aW5hdGlvbi5oZWlnaHQgLyBzb3VyY2UuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgZmluZFNjYWxlVG9Db3ZlcjogZnVuY3Rpb24oc291cmNlLCBkZXN0aW5hdGlvbikge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KGRlc3RpbmF0aW9uLndpZHRoIC8gc291cmNlLndpZHRoLCBkZXN0aW5hdGlvbi5oZWlnaHQgLyBzb3VyY2UuaGVpZ2h0KTtcbiAgICB9XG4gIH07XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBhcmNUb1NlZ21lbnRzQ2FjaGUgPSB7IH0sXG4gICAgICBzZWdtZW50VG9CZXppZXJDYWNoZSA9IHsgfSxcbiAgICAgIGJvdW5kc09mQ3VydmVDYWNoZSA9IHsgfSxcbiAgICAgIF9qb2luID0gQXJyYXkucHJvdG90eXBlLmpvaW47XG5cbiAgLyogQWRhcHRlZCBmcm9tIGh0dHA6Ly9keHIubW96aWxsYS5vcmcvbW96aWxsYS1jZW50cmFsL3NvdXJjZS9jb250ZW50L3N2Zy9jb250ZW50L3NyYy9uc1NWR1BhdGhEYXRhUGFyc2VyLmNwcFxuICAgKiBieSBBbmRyZWEgQm9nYXp6aSBjb2RlIGlzIHVuZGVyIE1QTC4gaWYgeW91IGRvbid0IGhhdmUgYSBjb3B5IG9mIHRoZSBsaWNlbnNlIHlvdSBjYW4gdGFrZSBpdCBoZXJlXG4gICAqIGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wL1xuICAgKi9cbiAgZnVuY3Rpb24gYXJjVG9TZWdtZW50cyh0b1gsIHRvWSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdGF0ZVgpIHtcbiAgICB2YXIgYXJnc1N0cmluZyA9IF9qb2luLmNhbGwoYXJndW1lbnRzKTtcbiAgICBpZiAoYXJjVG9TZWdtZW50c0NhY2hlW2FyZ3NTdHJpbmddKSB7XG4gICAgICByZXR1cm4gYXJjVG9TZWdtZW50c0NhY2hlW2FyZ3NTdHJpbmddO1xuICAgIH1cblxuICAgIHZhciBQSSA9IE1hdGguUEksIHRoID0gcm90YXRlWCAqIFBJIC8gMTgwLFxuICAgICAgICBzaW5UaCA9IGZhYnJpYy51dGlsLnNpbih0aCksXG4gICAgICAgIGNvc1RoID0gZmFicmljLnV0aWwuY29zKHRoKSxcbiAgICAgICAgZnJvbVggPSAwLCBmcm9tWSA9IDA7XG5cbiAgICByeCA9IE1hdGguYWJzKHJ4KTtcbiAgICByeSA9IE1hdGguYWJzKHJ5KTtcblxuICAgIHZhciBweCA9IC1jb3NUaCAqIHRvWCAqIDAuNSAtIHNpblRoICogdG9ZICogMC41LFxuICAgICAgICBweSA9IC1jb3NUaCAqIHRvWSAqIDAuNSArIHNpblRoICogdG9YICogMC41LFxuICAgICAgICByeDIgPSByeCAqIHJ4LCByeTIgPSByeSAqIHJ5LCBweTIgPSBweSAqIHB5LCBweDIgPSBweCAqIHB4LFxuICAgICAgICBwbCA9IHJ4MiAqIHJ5MiAtIHJ4MiAqIHB5MiAtIHJ5MiAqIHB4MixcbiAgICAgICAgcm9vdCA9IDA7XG5cbiAgICBpZiAocGwgPCAwKSB7XG4gICAgICB2YXIgcyA9IE1hdGguc3FydCgxIC0gcGwgLyAocngyICogcnkyKSk7XG4gICAgICByeCAqPSBzO1xuICAgICAgcnkgKj0gcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByb290ID0gKGxhcmdlID09PSBzd2VlcCA/IC0xLjAgOiAxLjApICpcbiAgICAgICAgICAgICAgTWF0aC5zcXJ0KCBwbCAvIChyeDIgKiBweTIgKyByeTIgKiBweDIpKTtcbiAgICB9XG5cbiAgICB2YXIgY3ggPSByb290ICogcnggKiBweSAvIHJ5LFxuICAgICAgICBjeSA9IC1yb290ICogcnkgKiBweCAvIHJ4LFxuICAgICAgICBjeDEgPSBjb3NUaCAqIGN4IC0gc2luVGggKiBjeSArIHRvWCAqIDAuNSxcbiAgICAgICAgY3kxID0gc2luVGggKiBjeCArIGNvc1RoICogY3kgKyB0b1kgKiAwLjUsXG4gICAgICAgIG1UaGV0YSA9IGNhbGNWZWN0b3JBbmdsZSgxLCAwLCAocHggLSBjeCkgLyByeCwgKHB5IC0gY3kpIC8gcnkpLFxuICAgICAgICBkdGhldGEgPSBjYWxjVmVjdG9yQW5nbGUoKHB4IC0gY3gpIC8gcngsIChweSAtIGN5KSAvIHJ5LCAoLXB4IC0gY3gpIC8gcngsICgtcHkgLSBjeSkgLyByeSk7XG5cbiAgICBpZiAoc3dlZXAgPT09IDAgJiYgZHRoZXRhID4gMCkge1xuICAgICAgZHRoZXRhIC09IDIgKiBQSTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3dlZXAgPT09IDEgJiYgZHRoZXRhIDwgMCkge1xuICAgICAgZHRoZXRhICs9IDIgKiBQSTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGludG8gY3ViaWMgYmV6aWVyIHNlZ21lbnRzIDw9IDkwZGVnXG4gICAgdmFyIHNlZ21lbnRzID0gTWF0aC5jZWlsKE1hdGguYWJzKGR0aGV0YSAvIFBJICogMikpLFxuICAgICAgICByZXN1bHQgPSBbXSwgbURlbHRhID0gZHRoZXRhIC8gc2VnbWVudHMsXG4gICAgICAgIG1UID0gOCAvIDMgKiBNYXRoLnNpbihtRGVsdGEgLyA0KSAqIE1hdGguc2luKG1EZWx0YSAvIDQpIC8gTWF0aC5zaW4obURlbHRhIC8gMiksXG4gICAgICAgIHRoMyA9IG1UaGV0YSArIG1EZWx0YTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHM7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gc2VnbWVudFRvQmV6aWVyKG1UaGV0YSwgdGgzLCBjb3NUaCwgc2luVGgsIHJ4LCByeSwgY3gxLCBjeTEsIG1ULCBmcm9tWCwgZnJvbVkpO1xuICAgICAgZnJvbVggPSByZXN1bHRbaV1bNF07XG4gICAgICBmcm9tWSA9IHJlc3VsdFtpXVs1XTtcbiAgICAgIG1UaGV0YSA9IHRoMztcbiAgICAgIHRoMyArPSBtRGVsdGE7XG4gICAgfVxuICAgIGFyY1RvU2VnbWVudHNDYWNoZVthcmdzU3RyaW5nXSA9IHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gc2VnbWVudFRvQmV6aWVyKHRoMiwgdGgzLCBjb3NUaCwgc2luVGgsIHJ4LCByeSwgY3gxLCBjeTEsIG1ULCBmcm9tWCwgZnJvbVkpIHtcbiAgICB2YXIgYXJnc1N0cmluZzIgPSBfam9pbi5jYWxsKGFyZ3VtZW50cyk7XG4gICAgaWYgKHNlZ21lbnRUb0JlemllckNhY2hlW2FyZ3NTdHJpbmcyXSkge1xuICAgICAgcmV0dXJuIHNlZ21lbnRUb0JlemllckNhY2hlW2FyZ3NTdHJpbmcyXTtcbiAgICB9XG5cbiAgICB2YXIgY29zdGgyID0gZmFicmljLnV0aWwuY29zKHRoMiksXG4gICAgICAgIHNpbnRoMiA9IGZhYnJpYy51dGlsLnNpbih0aDIpLFxuICAgICAgICBjb3N0aDMgPSBmYWJyaWMudXRpbC5jb3ModGgzKSxcbiAgICAgICAgc2ludGgzID0gZmFicmljLnV0aWwuc2luKHRoMyksXG4gICAgICAgIHRvWCA9IGNvc1RoICogcnggKiBjb3N0aDMgLSBzaW5UaCAqIHJ5ICogc2ludGgzICsgY3gxLFxuICAgICAgICB0b1kgPSBzaW5UaCAqIHJ4ICogY29zdGgzICsgY29zVGggKiByeSAqIHNpbnRoMyArIGN5MSxcbiAgICAgICAgY3AxWCA9IGZyb21YICsgbVQgKiAoIC1jb3NUaCAqIHJ4ICogc2ludGgyIC0gc2luVGggKiByeSAqIGNvc3RoMiksXG4gICAgICAgIGNwMVkgPSBmcm9tWSArIG1UICogKCAtc2luVGggKiByeCAqIHNpbnRoMiArIGNvc1RoICogcnkgKiBjb3N0aDIpLFxuICAgICAgICBjcDJYID0gdG9YICsgbVQgKiAoIGNvc1RoICogcnggKiBzaW50aDMgKyBzaW5UaCAqIHJ5ICogY29zdGgzKSxcbiAgICAgICAgY3AyWSA9IHRvWSArIG1UICogKCBzaW5UaCAqIHJ4ICogc2ludGgzIC0gY29zVGggKiByeSAqIGNvc3RoMyk7XG5cbiAgICBzZWdtZW50VG9CZXppZXJDYWNoZVthcmdzU3RyaW5nMl0gPSBbXG4gICAgICBjcDFYLCBjcDFZLFxuICAgICAgY3AyWCwgY3AyWSxcbiAgICAgIHRvWCwgdG9ZXG4gICAgXTtcbiAgICByZXR1cm4gc2VnbWVudFRvQmV6aWVyQ2FjaGVbYXJnc1N0cmluZzJdO1xuICB9XG5cbiAgLypcbiAgICogUHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY2FsY1ZlY3RvckFuZ2xlKHV4LCB1eSwgdngsIHZ5KSB7XG4gICAgdmFyIHRhID0gTWF0aC5hdGFuMih1eSwgdXgpLFxuICAgICAgICB0YiA9IE1hdGguYXRhbjIodnksIHZ4KTtcbiAgICBpZiAodGIgPj0gdGEpIHtcbiAgICAgIHJldHVybiB0YiAtIHRhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAyICogTWF0aC5QSSAtICh0YSAtIHRiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRHJhd3MgYXJjXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZ4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmeVxuICAgKiBAcGFyYW0ge0FycmF5fSBjb29yZHNcbiAgICovXG4gIGZhYnJpYy51dGlsLmRyYXdBcmMgPSBmdW5jdGlvbihjdHgsIGZ4LCBmeSwgY29vcmRzKSB7XG4gICAgdmFyIHJ4ID0gY29vcmRzWzBdLFxuICAgICAgICByeSA9IGNvb3Jkc1sxXSxcbiAgICAgICAgcm90ID0gY29vcmRzWzJdLFxuICAgICAgICBsYXJnZSA9IGNvb3Jkc1szXSxcbiAgICAgICAgc3dlZXAgPSBjb29yZHNbNF0sXG4gICAgICAgIHR4ID0gY29vcmRzWzVdLFxuICAgICAgICB0eSA9IGNvb3Jkc1s2XSxcbiAgICAgICAgc2VncyA9IFtbXSwgW10sIFtdLCBbXV0sXG4gICAgICAgIHNlZ3NOb3JtID0gYXJjVG9TZWdtZW50cyh0eCAtIGZ4LCB0eSAtIGZ5LCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWdzTm9ybS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2Vnc1tpXVswXSA9IHNlZ3NOb3JtW2ldWzBdICsgZng7XG4gICAgICBzZWdzW2ldWzFdID0gc2Vnc05vcm1baV1bMV0gKyBmeTtcbiAgICAgIHNlZ3NbaV1bMl0gPSBzZWdzTm9ybVtpXVsyXSArIGZ4O1xuICAgICAgc2Vnc1tpXVszXSA9IHNlZ3NOb3JtW2ldWzNdICsgZnk7XG4gICAgICBzZWdzW2ldWzRdID0gc2Vnc05vcm1baV1bNF0gKyBmeDtcbiAgICAgIHNlZ3NbaV1bNV0gPSBzZWdzTm9ybVtpXVs1XSArIGZ5O1xuICAgICAgY3R4LmJlemllckN1cnZlVG8uYXBwbHkoY3R4LCBzZWdzW2ldKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBib3VuZGluZyBib3ggb2YgYSBlbGxpcHRpYy1hcmNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZ4IHN0YXJ0IHBvaW50IG9mIGFyY1xuICAgKiBAcGFyYW0ge051bWJlcn0gZnlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJ4IGhvcml6b250YWwgcmFkaXVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByeSB2ZXJ0aWNhbCByYWRpdXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvdCBhbmdsZSBvZiBob3Jpem9udGFsIGF4ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gbGFyZ2UgMSBvciAwLCB3aGF0ZXZlciB0aGUgYXJjIGlzIHRoZSBiaWcgb3IgdGhlIHNtYWxsIG9uIHRoZSAyIHBvaW50c1xuICAgKiBAcGFyYW0ge051bWJlcn0gc3dlZXAgMSBvciAwLCAxIGNsb2Nrd2lzZSBvciBjb3VudGVyY2xvY2t3aXNlIGRpcmVjdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gdHggZW5kIHBvaW50IG9mIGFyY1xuICAgKiBAcGFyYW0ge051bWJlcn0gdHlcbiAgICovXG4gIGZhYnJpYy51dGlsLmdldEJvdW5kc09mQXJjID0gZnVuY3Rpb24oZngsIGZ5LCByeCwgcnksIHJvdCwgbGFyZ2UsIHN3ZWVwLCB0eCwgdHkpIHtcblxuICAgIHZhciBmcm9tWCA9IDAsIGZyb21ZID0gMCwgYm91bmQsIGJvdW5kcyA9IFtdLFxuICAgICAgICBzZWdzID0gYXJjVG9TZWdtZW50cyh0eCAtIGZ4LCB0eSAtIGZ5LCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBib3VuZCA9IGdldEJvdW5kc09mQ3VydmUoZnJvbVgsIGZyb21ZLCBzZWdzW2ldWzBdLCBzZWdzW2ldWzFdLCBzZWdzW2ldWzJdLCBzZWdzW2ldWzNdLCBzZWdzW2ldWzRdLCBzZWdzW2ldWzVdKTtcbiAgICAgIGJvdW5kcy5wdXNoKHsgeDogYm91bmRbMF0ueCArIGZ4LCB5OiBib3VuZFswXS55ICsgZnkgfSk7XG4gICAgICBib3VuZHMucHVzaCh7IHg6IGJvdW5kWzFdLnggKyBmeCwgeTogYm91bmRbMV0ueSArIGZ5IH0pO1xuICAgICAgZnJvbVggPSBzZWdzW2ldWzRdO1xuICAgICAgZnJvbVkgPSBzZWdzW2ldWzVdO1xuICAgIH1cbiAgICByZXR1cm4gYm91bmRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgYm91bmRpbmcgYm94IG9mIGEgYmV6aWVyY3VydmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgwIHN0YXJ0aW5nIHBvaW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MFxuICAgKiBAcGFyYW0ge051bWJlcn0geDEgZmlyc3QgY29udHJvbCBwb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0geTFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgyIHNlY29uZG8gY29udHJvbCBwb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0geTJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgzIGVuZCBvZiBiZWl6ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkzXG4gICAqL1xuICAvLyB0YWtlbiBmcm9tIGh0dHA6Ly9qc2Jpbi5jb20vaXZvbWlxLzU2L2VkaXQgIG5vIGNyZWRpdHMgYXZhaWxhYmxlIGZvciB0aGF0LlxuICBmdW5jdGlvbiBnZXRCb3VuZHNPZkN1cnZlKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIHZhciBhcmdzU3RyaW5nID0gX2pvaW4uY2FsbChhcmd1bWVudHMpO1xuICAgIGlmIChib3VuZHNPZkN1cnZlQ2FjaGVbYXJnc1N0cmluZ10pIHtcbiAgICAgIHJldHVybiBib3VuZHNPZkN1cnZlQ2FjaGVbYXJnc1N0cmluZ107XG4gICAgfVxuXG4gICAgdmFyIHNxcnQgPSBNYXRoLnNxcnQsXG4gICAgICAgIG1pbiA9IE1hdGgubWluLCBtYXggPSBNYXRoLm1heCxcbiAgICAgICAgYWJzID0gTWF0aC5hYnMsIHR2YWx1ZXMgPSBbXSxcbiAgICAgICAgYm91bmRzID0gW1tdLCBbXV0sXG4gICAgICAgIGEsIGIsIGMsIHQsIHQxLCB0MiwgYjJhYywgc3FydGIyYWM7XG5cbiAgICBiID0gNiAqIHgwIC0gMTIgKiB4MSArIDYgKiB4MjtcbiAgICBhID0gLTMgKiB4MCArIDkgKiB4MSAtIDkgKiB4MiArIDMgKiB4MztcbiAgICBjID0gMyAqIHgxIC0gMyAqIHgwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBiID0gNiAqIHkwIC0gMTIgKiB5MSArIDYgKiB5MjtcbiAgICAgICAgYSA9IC0zICogeTAgKyA5ICogeTEgLSA5ICogeTIgKyAzICogeTM7XG4gICAgICAgIGMgPSAzICogeTEgLSAzICogeTA7XG4gICAgICB9XG5cbiAgICAgIGlmIChhYnMoYSkgPCAxZS0xMikge1xuICAgICAgICBpZiAoYWJzKGIpIDwgMWUtMTIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0ID0gLWMgLyBiO1xuICAgICAgICBpZiAoMCA8IHQgJiYgdCA8IDEpIHtcbiAgICAgICAgICB0dmFsdWVzLnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBiMmFjID0gYiAqIGIgLSA0ICogYyAqIGE7XG4gICAgICBpZiAoYjJhYyA8IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzcXJ0YjJhYyA9IHNxcnQoYjJhYyk7XG4gICAgICB0MSA9ICgtYiArIHNxcnRiMmFjKSAvICgyICogYSk7XG4gICAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xuICAgICAgICB0dmFsdWVzLnB1c2godDEpO1xuICAgICAgfVxuICAgICAgdDIgPSAoLWIgLSBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcbiAgICAgICAgdHZhbHVlcy5wdXNoKHQyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgeCwgeSwgaiA9IHR2YWx1ZXMubGVuZ3RoLCBqbGVuID0gaiwgbXQ7XG4gICAgd2hpbGUgKGotLSkge1xuICAgICAgdCA9IHR2YWx1ZXNbal07XG4gICAgICBtdCA9IDEgLSB0O1xuICAgICAgeCA9IChtdCAqIG10ICogbXQgKiB4MCkgKyAoMyAqIG10ICogbXQgKiB0ICogeDEpICsgKDMgKiBtdCAqIHQgKiB0ICogeDIpICsgKHQgKiB0ICogdCAqIHgzKTtcbiAgICAgIGJvdW5kc1swXVtqXSA9IHg7XG5cbiAgICAgIHkgPSAobXQgKiBtdCAqIG10ICogeTApICsgKDMgKiBtdCAqIG10ICogdCAqIHkxKSArICgzICogbXQgKiB0ICogdCAqIHkyKSArICh0ICogdCAqIHQgKiB5Myk7XG4gICAgICBib3VuZHNbMV1bal0gPSB5O1xuICAgIH1cblxuICAgIGJvdW5kc1swXVtqbGVuXSA9IHgwO1xuICAgIGJvdW5kc1sxXVtqbGVuXSA9IHkwO1xuICAgIGJvdW5kc1swXVtqbGVuICsgMV0gPSB4MztcbiAgICBib3VuZHNbMV1bamxlbiArIDFdID0geTM7XG4gICAgdmFyIHJlc3VsdCA9IFtcbiAgICAgIHtcbiAgICAgICAgeDogbWluLmFwcGx5KG51bGwsIGJvdW5kc1swXSksXG4gICAgICAgIHk6IG1pbi5hcHBseShudWxsLCBib3VuZHNbMV0pXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB4OiBtYXguYXBwbHkobnVsbCwgYm91bmRzWzBdKSxcbiAgICAgICAgeTogbWF4LmFwcGx5KG51bGwsIGJvdW5kc1sxXSlcbiAgICAgIH1cbiAgICBdO1xuICAgIGJvdW5kc09mQ3VydmVDYWNoZVthcmdzU3RyaW5nXSA9IHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSA9IGdldEJvdW5kc09mQ3VydmU7XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAvKipcbiAgICogSW52b2tlcyBtZXRob2Qgb24gYWxsIGl0ZW1zIGluIGEgZ2l2ZW4gYXJyYXlcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE5hbWUgb2YgYSBtZXRob2QgdG8gaW52b2tlXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZnVuY3Rpb24gaW52b2tlKGFycmF5LCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSwgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBhcmdzLmxlbmd0aCA/IGFycmF5W2ldW21ldGhvZF0uYXBwbHkoYXJyYXlbaV0sIGFyZ3MpIDogYXJyYXlbaV1bbWV0aG9kXS5jYWxsKGFycmF5W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBtYXhpbXVtIHZhbHVlIGluIGFycmF5IChub3QgbmVjZXNzYXJpbHkgXCJmaXJzdFwiIG9uZSlcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnlQcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZnVuY3Rpb24gbWF4KGFycmF5LCBieVByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGZpbmQoYXJyYXksIGJ5UHJvcGVydHksIGZ1bmN0aW9uKHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgICByZXR1cm4gdmFsdWUxID49IHZhbHVlMjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBtaW5pbXVtIHZhbHVlIGluIGFycmF5IChub3QgbmVjZXNzYXJpbHkgXCJmaXJzdFwiIG9uZSlcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnlQcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZnVuY3Rpb24gbWluKGFycmF5LCBieVByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGZpbmQoYXJyYXksIGJ5UHJvcGVydHksIGZ1bmN0aW9uKHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgICByZXR1cm4gdmFsdWUxIDwgdmFsdWUyO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaWxsKGFycmF5LCB2YWx1ZSkge1xuICAgIHZhciBrID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChrLS0pIHtcbiAgICAgIGFycmF5W2tdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluZChhcnJheSwgYnlQcm9wZXJ0eSwgY29uZGl0aW9uKSB7XG4gICAgaWYgKCFhcnJheSB8fCBhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDEsXG4gICAgICAgIHJlc3VsdCA9IGJ5UHJvcGVydHkgPyBhcnJheVtpXVtieVByb3BlcnR5XSA6IGFycmF5W2ldO1xuICAgIGlmIChieVByb3BlcnR5KSB7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24oYXJyYXlbaV1bYnlQcm9wZXJ0eV0sIHJlc3VsdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBhcnJheVtpXVtieVByb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbihhcnJheVtpXSwgcmVzdWx0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBmYWJyaWMudXRpbC5hcnJheVxuICAgKi9cbiAgZmFicmljLnV0aWwuYXJyYXkgPSB7XG4gICAgZmlsbDogZmlsbCxcbiAgICBpbnZva2U6IGludm9rZSxcbiAgICBtaW46IG1pbixcbiAgICBtYXg6IG1heFxuICB9O1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIENvcGllcyBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIG9uZSBqcyBvYmplY3QgdG8gYW5vdGhlclxuICAgKiBEb2VzIG5vdCBjbG9uZSBvciBleHRlbmQgZmFicmljLk9iamVjdCBzdWJjbGFzc2VzLlxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwub2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0aW5hdGlvbiBXaGVyZSB0byBjb3B5IHRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgV2hlcmUgdG8gY29weSBmcm9tXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cbiAgZnVuY3Rpb24gZXh0ZW5kKGRlc3RpbmF0aW9uLCBzb3VyY2UsIGRlZXApIHtcbiAgICAvLyBKU2NyaXB0IERvbnRFbnVtIGJ1ZyBpcyBub3QgdGFrZW4gY2FyZSBvZlxuICAgIC8vIHRoZSBkZWVwIGNsb25lIGlzIGZvciBpbnRlcm5hbCB1c2UsIGlzIG5vdCBtZWFudCB0byBhdm9pZFxuICAgIC8vIGphdmFzY3JpcHQgdHJhcHMgb3IgY2xvbmluZyBodG1sIGVsZW1lbnQgb3Igc2VsZiByZWZlcmVuY2VkIG9iamVjdHMuXG4gICAgaWYgKGRlZXApIHtcbiAgICAgIGlmICghZmFicmljLmlzTGlrZWx5Tm9kZSAmJiBzb3VyY2UgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgIC8vIGF2b2lkIGNsb25pbmcgZGVlcCBpbWFnZXMsIGNhbnZhc2VzLFxuICAgICAgICBkZXN0aW5hdGlvbiA9IHNvdXJjZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGRlc3RpbmF0aW9uID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBkZXN0aW5hdGlvbltpXSA9IGV4dGVuZCh7IH0sIHNvdXJjZVtpXSwgZGVlcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNvdXJjZSAmJiB0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydHldID0gZXh0ZW5kKHsgfSwgc291cmNlW3Byb3BlcnR5XSwgZGVlcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyBzb3VuZHMgb2RkIGZvciBhbiBleHRlbmQgYnV0IGlzIG9rIGZvciByZWN1cnNpdmUgdXNlXG4gICAgICAgIGRlc3RpbmF0aW9uID0gc291cmNlO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSkge1xuICAgICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdGluYXRpb247XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBlbXB0eSBvYmplY3QgYW5kIGNvcGllcyBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFub3RoZXIgb2JqZWN0IHRvIGl0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5vYmplY3RcbiAgICogVE9ETzogdGhpcyBmdW5jdGlvbiByZXR1cm4gYW4gZW1wdHkgb2JqZWN0IGlmIHlvdSB0cnkgdG8gY2xvbmUgbnVsbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjbG9uZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBmdW5jdGlvbiBjbG9uZShvYmplY3QsIGRlZXApIHtcbiAgICByZXR1cm4gZXh0ZW5kKHsgfSwgb2JqZWN0LCBkZWVwKTtcbiAgfVxuXG4gIC8qKiBAbmFtZXNwYWNlIGZhYnJpYy51dGlsLm9iamVjdCAqL1xuICBmYWJyaWMudXRpbC5vYmplY3QgPSB7XG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgY2xvbmU6IGNsb25lXG4gIH07XG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLnV0aWwsIGZhYnJpYy5PYnNlcnZhYmxlKTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBDYW1lbGl6ZXMgYSBzdHJpbmdcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFN0cmluZyB0byBjYW1lbGl6ZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IENhbWVsaXplZCB2ZXJzaW9uIG9mIGEgc3RyaW5nXG4gICAqL1xuICBmdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLy0rKC4pPy9nLCBmdW5jdGlvbihtYXRjaCwgY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gY2hhcmFjdGVyID8gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXBpdGFsaXplcyBhIHN0cmluZ1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIGNhcGl0YWxpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZmlyc3RMZXR0ZXJPbmx5XSBJZiB0cnVlIG9ubHkgZmlyc3QgbGV0dGVyIGlzIGNhcGl0YWxpemVkXG4gICAqIGFuZCBvdGhlciBsZXR0ZXJzIHN0YXkgdW50b3VjaGVkLCBpZiBmYWxzZSBmaXJzdCBsZXR0ZXIgaXMgY2FwaXRhbGl6ZWRcbiAgICogYW5kIG90aGVyIGxldHRlcnMgYXJlIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gQ2FwaXRhbGl6ZWQgdmVyc2lvbiBvZiBhIHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcsIGZpcnN0TGV0dGVyT25seSkge1xuICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgK1xuICAgICAgKGZpcnN0TGV0dGVyT25seSA/IHN0cmluZy5zbGljZSgxKSA6IHN0cmluZy5zbGljZSgxKS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFc2NhcGVzIFhNTCBpbiBhIHN0cmluZ1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIGVzY2FwZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEVzY2FwZWQgdmVyc2lvbiBvZiBhIHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlWG1sKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgICAgLnJlcGxhY2UoLycvZywgJyZhcG9zOycpXG4gICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpdmlkZSBhIHN0cmluZyBpbiB0aGUgdXNlciBwZXJjZWl2ZWQgc2luZ2xlIHVuaXRzXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5zdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRzdHJpbmcgU3RyaW5nIHRvIGVzY2FwZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgY29udGFpbmluZyB0aGUgZ3JhcGhlbWVzXG4gICAqL1xuICBmdW5jdGlvbiBncmFwaGVtZVNwbGl0KHRleHRzdHJpbmcpIHtcbiAgICB2YXIgaSA9IDAsIGNociwgZ3JhcGhlbWVzID0gW107XG4gICAgZm9yIChpID0gMCwgY2hyOyBpIDwgdGV4dHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKChjaHIgPSBnZXRXaG9sZUNoYXIodGV4dHN0cmluZywgaSkpID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGdyYXBoZW1lcy5wdXNoKGNocik7XG4gICAgfVxuICAgIHJldHVybiBncmFwaGVtZXM7XG4gIH1cblxuICAvLyB0YWtlbiBmcm9tIG1kbiBpbiB0aGUgY2hhckF0IGRvYyBwYWdlLlxuICBmdW5jdGlvbiBnZXRXaG9sZUNoYXIoc3RyLCBpKSB7XG4gICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgIGlmIChpc05hTihjb2RlKSkge1xuICAgICAgcmV0dXJuICcnOyAvLyBQb3NpdGlvbiBub3QgZm91bmRcbiAgICB9XG4gICAgaWYgKGNvZGUgPCAweEQ4MDAgfHwgY29kZSA+IDB4REZGRikge1xuICAgICAgcmV0dXJuIHN0ci5jaGFyQXQoaSk7XG4gICAgfVxuXG4gICAgLy8gSGlnaCBzdXJyb2dhdGUgKGNvdWxkIGNoYW5nZSBsYXN0IGhleCB0byAweERCN0YgdG8gdHJlYXQgaGlnaCBwcml2YXRlXG4gICAgLy8gc3Vycm9nYXRlcyBhcyBzaW5nbGUgY2hhcmFjdGVycylcbiAgICBpZiAoMHhEODAwIDw9IGNvZGUgJiYgY29kZSA8PSAweERCRkYpIHtcbiAgICAgIGlmIChzdHIubGVuZ3RoIDw9IChpICsgMSkpIHtcbiAgICAgICAgdGhyb3cgJ0hpZ2ggc3Vycm9nYXRlIHdpdGhvdXQgZm9sbG93aW5nIGxvdyBzdXJyb2dhdGUnO1xuICAgICAgfVxuICAgICAgdmFyIG5leHQgPSBzdHIuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICBpZiAoMHhEQzAwID4gbmV4dCB8fCBuZXh0ID4gMHhERkZGKSB7XG4gICAgICAgIHRocm93ICdIaWdoIHN1cnJvZ2F0ZSB3aXRob3V0IGZvbGxvd2luZyBsb3cgc3Vycm9nYXRlJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHIuY2hhckF0KGkpICsgc3RyLmNoYXJBdChpICsgMSk7XG4gICAgfVxuICAgIC8vIExvdyBzdXJyb2dhdGUgKDB4REMwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHhERkZGKVxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICB0aHJvdyAnTG93IHN1cnJvZ2F0ZSB3aXRob3V0IHByZWNlZGluZyBoaWdoIHN1cnJvZ2F0ZSc7XG4gICAgfVxuICAgIHZhciBwcmV2ID0gc3RyLmNoYXJDb2RlQXQoaSAtIDEpO1xuXG4gICAgLy8gKGNvdWxkIGNoYW5nZSBsYXN0IGhleCB0byAweERCN0YgdG8gdHJlYXQgaGlnaCBwcml2YXRlXG4gICAgLy8gc3Vycm9nYXRlcyBhcyBzaW5nbGUgY2hhcmFjdGVycylcbiAgICBpZiAoMHhEODAwID4gcHJldiB8fCBwcmV2ID4gMHhEQkZGKSB7XG4gICAgICB0aHJvdyAnTG93IHN1cnJvZ2F0ZSB3aXRob3V0IHByZWNlZGluZyBoaWdoIHN1cnJvZ2F0ZSc7XG4gICAgfVxuICAgIC8vIFdlIGNhbiBwYXNzIG92ZXIgbG93IHN1cnJvZ2F0ZXMgbm93IGFzIHRoZSBzZWNvbmQgY29tcG9uZW50XG4gICAgLy8gaW4gYSBwYWlyIHdoaWNoIHdlIGhhdmUgYWxyZWFkeSBwcm9jZXNzZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTdHJpbmcgdXRpbGl0aWVzXG4gICAqIEBuYW1lc3BhY2UgZmFicmljLnV0aWwuc3RyaW5nXG4gICAqL1xuICBmYWJyaWMudXRpbC5zdHJpbmcgPSB7XG4gICAgY2FtZWxpemU6IGNhbWVsaXplLFxuICAgIGNhcGl0YWxpemU6IGNhcGl0YWxpemUsXG4gICAgZXNjYXBlWG1sOiBlc2NhcGVYbWwsXG4gICAgZ3JhcGhlbWVTcGxpdDogZ3JhcGhlbWVTcGxpdFxuICB9O1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLCBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAgIElTX0RPTlRFTlVNX0JVR0dZID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBwIGluIHsgdG9TdHJpbmc6IDEgfSkge1xuICAgICAgICAgIGlmIChwID09PSAndG9TdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSkoKSxcblxuICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgIGFkZE1ldGhvZHMgPSBmdW5jdGlvbihrbGFzcywgc291cmNlLCBwYXJlbnQpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc291cmNlKSB7XG5cbiAgICAgICAgICBpZiAocHJvcGVydHkgaW4ga2xhc3MucHJvdG90eXBlICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBrbGFzcy5wcm90b3R5cGVbcHJvcGVydHldID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgIChzb3VyY2VbcHJvcGVydHldICsgJycpLmluZGV4T2YoJ2NhbGxTdXBlcicpID4gLTEpIHtcblxuICAgICAgICAgICAga2xhc3MucHJvdG90eXBlW3Byb3BlcnR5XSA9IChmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3VwZXJjbGFzcyA9IHRoaXMuY29uc3RydWN0b3Iuc3VwZXJjbGFzcztcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3MgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gc291cmNlW3Byb3BlcnR5XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3Iuc3VwZXJjbGFzcyA9IHN1cGVyY2xhc3M7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkgIT09ICdpbml0aWFsaXplJykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBrbGFzcy5wcm90b3R5cGVbcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSVNfRE9OVEVOVU1fQlVHR1kpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHtcbiAgICAgICAgICAgICAga2xhc3MucHJvdG90eXBlLnRvU3RyaW5nID0gc291cmNlLnRvU3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvdXJjZS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHtcbiAgICAgICAgICAgICAga2xhc3MucHJvdG90eXBlLnZhbHVlT2YgPSBzb3VyY2UudmFsdWVPZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgZnVuY3Rpb24gU3ViY2xhc3MoKSB7IH1cblxuICBmdW5jdGlvbiBjYWxsU3VwZXIobWV0aG9kTmFtZSkge1xuICAgIHZhciBwYXJlbnRNZXRob2QgPSBudWxsLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyBjbGltYiBwcm90b3R5cGUgY2hhaW4gdG8gZmluZCBtZXRob2Qgbm90IGVxdWFsIHRvIGNhbGxlZSdzIG1ldGhvZFxuICAgIHdoaWxlIChfdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzKSB7XG4gICAgICB2YXIgc3VwZXJDbGFzc01ldGhvZCA9IF90aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdO1xuICAgICAgaWYgKF90aGlzW21ldGhvZE5hbWVdICE9PSBzdXBlckNsYXNzTWV0aG9kKSB7XG4gICAgICAgIHBhcmVudE1ldGhvZCA9IHN1cGVyQ2xhc3NNZXRob2Q7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBfdGhpcyA9IF90aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3MucHJvdG90eXBlO1xuICAgIH1cblxuICAgIGlmICghcGFyZW50TWV0aG9kKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5sb2coJ3RyaWVkIHRvIGNhbGxTdXBlciAnICsgbWV0aG9kTmFtZSArICcsIG1ldGhvZCBub3QgZm91bmQgaW4gcHJvdG90eXBlIGNoYWluJywgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChhcmd1bWVudHMubGVuZ3RoID4gMSlcbiAgICAgID8gcGFyZW50TWV0aG9kLmFwcGx5KHRoaXMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSlcbiAgICAgIDogcGFyZW50TWV0aG9kLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZvciBjcmVhdGlvbiBvZiBcImNsYXNzZXNcIi5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJlbnRdIG9wdGlvbmFsIFwiQ2xhc3NcIiB0byBpbmhlcml0IGZyb21cbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHNoYXJlZCBieSBhbGwgaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3NcbiAgICogICAgICAgICAgICAgICAgICAoYmUgY2FyZWZ1bCBtb2RpZnlpbmcgb2JqZWN0cyBkZWZpbmVkIGhlcmUgYXMgdGhpcyB3b3VsZCBhZmZlY3QgYWxsIGluc3RhbmNlcylcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzKCkge1xuICAgIHZhciBwYXJlbnQgPSBudWxsLFxuICAgICAgICBwcm9wZXJ0aWVzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0aWVzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwYXJlbnQgPSBwcm9wZXJ0aWVzLnNoaWZ0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGtsYXNzKCkge1xuICAgICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAga2xhc3Muc3VwZXJjbGFzcyA9IHBhcmVudDtcbiAgICBrbGFzcy5zdWJjbGFzc2VzID0gW107XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBTdWJjbGFzcy5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgICAga2xhc3MucHJvdG90eXBlID0gbmV3IFN1YmNsYXNzKCk7XG4gICAgICBwYXJlbnQuc3ViY2xhc3Nlcy5wdXNoKGtsYXNzKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGFkZE1ldGhvZHMoa2xhc3MsIHByb3BlcnRpZXNbaV0sIHBhcmVudCk7XG4gICAgfVxuICAgIGlmICgha2xhc3MucHJvdG90eXBlLmluaXRpYWxpemUpIHtcbiAgICAgIGtsYXNzLnByb3RvdHlwZS5pbml0aWFsaXplID0gZW1wdHlGdW5jdGlvbjtcbiAgICB9XG4gICAga2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0ga2xhc3M7XG4gICAga2xhc3MucHJvdG90eXBlLmNhbGxTdXBlciA9IGNhbGxTdXBlcjtcbiAgICByZXR1cm4ga2xhc3M7XG4gIH1cblxuICBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyA9IGNyZWF0ZUNsYXNzO1xufSkoKTtcblxuXG4oZnVuY3Rpb24gKCkge1xuXG4gIHZhciB1bmtub3duID0gJ3Vua25vd24nO1xuXG4gIC8qIEVWRU5UIEhBTkRMSU5HICovXG5cbiAgZnVuY3Rpb24gYXJlSG9zdE1ldGhvZHMob2JqZWN0KSB7XG4gICAgdmFyIG1ldGhvZE5hbWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgdCwgaSwgbGVuID0gbWV0aG9kTmFtZXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdCA9IHR5cGVvZiBvYmplY3RbbWV0aG9kTmFtZXNbaV1dO1xuICAgICAgaWYgKCEoL14oPzpmdW5jdGlvbnxvYmplY3R8dW5rbm93bikkLykudGVzdCh0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIEBpZ25vcmUgKi9cbiAgdmFyIGdldEVsZW1lbnQsXG4gICAgICBzZXRFbGVtZW50LFxuICAgICAgZ2V0VW5pcXVlSWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdWlkID0gMDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuX191bmlxdWVJRCB8fCAoZWxlbWVudC5fX3VuaXF1ZUlEID0gJ3VuaXF1ZUlEX18nICsgdWlkKyspO1xuICAgICAgICB9O1xuICAgICAgfSkoKTtcblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGVtZW50cyA9IHsgfTtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIGdldEVsZW1lbnQgPSBmdW5jdGlvbiAodWlkKSB7XG4gICAgICByZXR1cm4gZWxlbWVudHNbdWlkXTtcbiAgICB9O1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgc2V0RWxlbWVudCA9IGZ1bmN0aW9uICh1aWQsIGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnRzW3VpZF0gPSBlbGVtZW50O1xuICAgIH07XG4gIH0pKCk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXIodWlkLCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICB3cmFwcGVkSGFuZGxlcjogY3JlYXRlV3JhcHBlZEhhbmRsZXIodWlkLCBoYW5kbGVyKVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVXcmFwcGVkSGFuZGxlcih1aWQsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGhhbmRsZXIuY2FsbChnZXRFbGVtZW50KHVpZCksIGUgfHwgZmFicmljLndpbmRvdy5ldmVudCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZURpc3BhdGNoZXIodWlkLCBldmVudE5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChoYW5kbGVyc1t1aWRdICYmIGhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXSkge1xuICAgICAgICB2YXIgaGFuZGxlcnNGb3JFdmVudCA9IGhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhhbmRsZXJzRm9yRXZlbnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBoYW5kbGVyc0ZvckV2ZW50W2ldLmNhbGwodGhpcywgZSB8fCBmYWJyaWMud2luZG93LmV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgc2hvdWxkVXNlQWRkTGlzdGVuZXJSZW1vdmVMaXN0ZW5lciA9IChcbiAgICAgICAgYXJlSG9zdE1ldGhvZHMoZmFicmljLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ2FkZEV2ZW50TGlzdGVuZXInLCAncmVtb3ZlRXZlbnRMaXN0ZW5lcicpICYmXG4gICAgICAgIGFyZUhvc3RNZXRob2RzKGZhYnJpYy53aW5kb3csICdhZGRFdmVudExpc3RlbmVyJywgJ3JlbW92ZUV2ZW50TGlzdGVuZXInKSksXG5cbiAgICAgIHNob3VsZFVzZUF0dGFjaEV2ZW50RGV0YWNoRXZlbnQgPSAoXG4gICAgICAgIGFyZUhvc3RNZXRob2RzKGZhYnJpYy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICdhdHRhY2hFdmVudCcsICdkZXRhY2hFdmVudCcpICYmXG4gICAgICAgIGFyZUhvc3RNZXRob2RzKGZhYnJpYy53aW5kb3csICdhdHRhY2hFdmVudCcsICdkZXRhY2hFdmVudCcpKSxcblxuICAgICAgLy8gSUUgYnJhbmNoXG4gICAgICBsaXN0ZW5lcnMgPSB7IH0sXG5cbiAgICAgIC8vIERPTSBMMCBicmFuY2hcbiAgICAgIGhhbmRsZXJzID0geyB9LFxuXG4gICAgICBhZGRMaXN0ZW5lciwgcmVtb3ZlTGlzdGVuZXI7XG5cbiAgaWYgKHNob3VsZFVzZUFkZExpc3RlbmVyUmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIGFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgLy8gc2luY2UgaWUxMCBvciBpZTkgY2FuIHVzZSBhZGRFdmVudExpc3RlbmVyIGJ1dCB0aGV5IGRvIG5vdCBzdXBwb3J0IG9wdGlvbnMsIGkgbmVlZCB0byBjaGVja1xuICAgICAgZWxlbWVudCAmJiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBzaG91bGRVc2VBdHRhY2hFdmVudERldGFjaEV2ZW50ID8gZmFsc2UgOiBvcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgICBlbGVtZW50ICYmIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIHNob3VsZFVzZUF0dGFjaEV2ZW50RGV0YWNoRXZlbnQgPyBmYWxzZSA6IG9wdGlvbnMpO1xuICAgIH07XG4gIH1cblxuICBlbHNlIGlmIChzaG91bGRVc2VBdHRhY2hFdmVudERldGFjaEV2ZW50KSB7XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBhZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdWlkID0gZ2V0VW5pcXVlSWQoZWxlbWVudCk7XG4gICAgICBzZXRFbGVtZW50KHVpZCwgZWxlbWVudCk7XG4gICAgICBpZiAoIWxpc3RlbmVyc1t1aWRdKSB7XG4gICAgICAgIGxpc3RlbmVyc1t1aWRdID0geyB9O1xuICAgICAgfVxuICAgICAgaWYgKCFsaXN0ZW5lcnNbdWlkXVtldmVudE5hbWVdKSB7XG4gICAgICAgIGxpc3RlbmVyc1t1aWRdW2V2ZW50TmFtZV0gPSBbXTtcblxuICAgICAgfVxuICAgICAgdmFyIGxpc3RlbmVyID0gY3JlYXRlTGlzdGVuZXIodWlkLCBoYW5kbGVyKTtcbiAgICAgIGxpc3RlbmVyc1t1aWRdW2V2ZW50TmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICBlbGVtZW50LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudE5hbWUsIGxpc3RlbmVyLndyYXBwZWRIYW5kbGVyKTtcbiAgICB9O1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHVpZCA9IGdldFVuaXF1ZUlkKGVsZW1lbnQpLCBsaXN0ZW5lcjtcbiAgICAgIGlmIChsaXN0ZW5lcnNbdWlkXSAmJiBsaXN0ZW5lcnNbdWlkXVtldmVudE5hbWVdKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnNbdWlkXVtldmVudE5hbWVdLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbdWlkXVtldmVudE5hbWVdW2ldO1xuICAgICAgICAgIGlmIChsaXN0ZW5lciAmJiBsaXN0ZW5lci5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICAgICAgICBlbGVtZW50LmRldGFjaEV2ZW50KCdvbicgKyBldmVudE5hbWUsIGxpc3RlbmVyLndyYXBwZWRIYW5kbGVyKTtcbiAgICAgICAgICAgIGxpc3RlbmVyc1t1aWRdW2V2ZW50TmFtZV1baV0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZWxzZSB7XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBhZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdWlkID0gZ2V0VW5pcXVlSWQoZWxlbWVudCk7XG4gICAgICBpZiAoIWhhbmRsZXJzW3VpZF0pIHtcbiAgICAgICAgaGFuZGxlcnNbdWlkXSA9IHsgfTtcbiAgICAgIH1cbiAgICAgIGlmICghaGFuZGxlcnNbdWlkXVtldmVudE5hbWVdKSB7XG4gICAgICAgIGhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXSA9IFtdO1xuICAgICAgICB2YXIgZXhpc3RpbmdIYW5kbGVyID0gZWxlbWVudFsnb24nICsgZXZlbnROYW1lXTtcbiAgICAgICAgaWYgKGV4aXN0aW5nSGFuZGxlcikge1xuICAgICAgICAgIGhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXS5wdXNoKGV4aXN0aW5nSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudFsnb24nICsgZXZlbnROYW1lXSA9IGNyZWF0ZURpc3BhdGNoZXIodWlkLCBldmVudE5hbWUpO1xuICAgICAgfVxuICAgICAgaGFuZGxlcnNbdWlkXVtldmVudE5hbWVdLnB1c2goaGFuZGxlcik7XG4gICAgfTtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB1aWQgPSBnZXRVbmlxdWVJZChlbGVtZW50KTtcbiAgICAgIGlmIChoYW5kbGVyc1t1aWRdICYmIGhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXSkge1xuICAgICAgICB2YXIgaGFuZGxlcnNGb3JFdmVudCA9IGhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhhbmRsZXJzRm9yRXZlbnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoaGFuZGxlcnNGb3JFdmVudFtpXSA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcnNGb3JFdmVudC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGFuIGVsZW1lbnRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIgPSBhZGRMaXN0ZW5lcjtcblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGFuIGVsZW1lbnRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZmFicmljLnV0aWwucmVtb3ZlTGlzdGVuZXIgPSByZW1vdmVMaXN0ZW5lcjtcblxuICAvKipcbiAgICogQ3Jvc3MtYnJvd3NlciB3cmFwcGVyIGZvciBnZXR0aW5nIGV2ZW50J3MgY29vcmRpbmF0ZXNcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEV2ZW50IG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UG9pbnRlcihldmVudCkge1xuICAgIGV2ZW50IHx8IChldmVudCA9IGZhYnJpYy53aW5kb3cuZXZlbnQpO1xuXG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC50YXJnZXQgfHxcbiAgICAgICAgICAgICAgICAgICh0eXBlb2YgZXZlbnQuc3JjRWxlbWVudCAhPT0gdW5rbm93biA/IGV2ZW50LnNyY0VsZW1lbnQgOiBudWxsKSxcblxuICAgICAgICBzY3JvbGwgPSBmYWJyaWMudXRpbC5nZXRTY3JvbGxMZWZ0VG9wKGVsZW1lbnQpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBwb2ludGVyWChldmVudCkgKyBzY3JvbGwubGVmdCxcbiAgICAgIHk6IHBvaW50ZXJZKGV2ZW50KSArIHNjcm9sbC50b3BcbiAgICB9O1xuICB9XG5cbiAgdmFyIHBvaW50ZXJYID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50LmNsaWVudFg7XG4gICAgICB9LFxuXG4gICAgICBwb2ludGVyWSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC5jbGllbnRZO1xuICAgICAgfTtcblxuICBmdW5jdGlvbiBfZ2V0UG9pbnRlcihldmVudCwgcGFnZVByb3AsIGNsaWVudFByb3ApIHtcbiAgICB2YXIgdG91Y2hQcm9wID0gZXZlbnQudHlwZSA9PT0gJ3RvdWNoZW5kJyA/ICdjaGFuZ2VkVG91Y2hlcycgOiAndG91Y2hlcyc7XG4gICAgdmFyIHBvaW50ZXIsIGV2ZW50VG91Y2hQcm9wID0gZXZlbnRbdG91Y2hQcm9wXTtcblxuICAgIGlmIChldmVudFRvdWNoUHJvcCAmJiBldmVudFRvdWNoUHJvcFswXSkge1xuICAgICAgcG9pbnRlciA9IGV2ZW50VG91Y2hQcm9wWzBdW2NsaWVudFByb3BdO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcG9pbnRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHBvaW50ZXIgPSBldmVudFtjbGllbnRQcm9wXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRlcjtcbiAgfVxuXG4gIGlmIChmYWJyaWMuaXNUb3VjaFN1cHBvcnRlZCkge1xuICAgIHBvaW50ZXJYID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHJldHVybiBfZ2V0UG9pbnRlcihldmVudCwgJ3BhZ2VYJywgJ2NsaWVudFgnKTtcbiAgICB9O1xuICAgIHBvaW50ZXJZID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHJldHVybiBfZ2V0UG9pbnRlcihldmVudCwgJ3BhZ2VZJywgJ2NsaWVudFknKTtcbiAgICB9O1xuICB9XG5cbiAgZmFicmljLnV0aWwuZ2V0UG9pbnRlciA9IGdldFBvaW50ZXI7XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQ3Jvc3MtYnJvd3NlciB3cmFwcGVyIGZvciBzZXR0aW5nIGVsZW1lbnQncyBzdHlsZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBFbGVtZW50IHRoYXQgd2FzIHBhc3NlZCBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAqL1xuICBmdW5jdGlvbiBzZXRTdHlsZShlbGVtZW50LCBzdHlsZXMpIHtcbiAgICB2YXIgZWxlbWVudFN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICBpZiAoIWVsZW1lbnRTdHlsZSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ICs9ICc7JyArIHN0eWxlcztcbiAgICAgIHJldHVybiBzdHlsZXMuaW5kZXhPZignb3BhY2l0eScpID4gLTFcbiAgICAgICAgPyBzZXRPcGFjaXR5KGVsZW1lbnQsIHN0eWxlcy5tYXRjaCgvb3BhY2l0eTpcXHMqKFxcZD9cXC4/XFxkKikvKVsxXSlcbiAgICAgICAgOiBlbGVtZW50O1xuICAgIH1cbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ29wYWNpdHknKSB7XG4gICAgICAgIHNldE9wYWNpdHkoZWxlbWVudCwgc3R5bGVzW3Byb3BlcnR5XSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRQcm9wZXJ0eSA9IChwcm9wZXJ0eSA9PT0gJ2Zsb2F0JyB8fCBwcm9wZXJ0eSA9PT0gJ2Nzc0Zsb2F0JylcbiAgICAgICAgICA/ICh0eXBlb2YgZWxlbWVudFN0eWxlLnN0eWxlRmxvYXQgPT09ICd1bmRlZmluZWQnID8gJ2Nzc0Zsb2F0JyA6ICdzdHlsZUZsb2F0JylcbiAgICAgICAgICA6IHByb3BlcnR5O1xuICAgICAgICBlbGVtZW50U3R5bGVbbm9ybWFsaXplZFByb3BlcnR5XSA9IHN0eWxlc1twcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgdmFyIHBhcnNlRWwgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICBzdXBwb3J0c09wYWNpdHkgPSB0eXBlb2YgcGFyc2VFbC5zdHlsZS5vcGFjaXR5ID09PSAnc3RyaW5nJyxcbiAgICAgIHN1cHBvcnRzRmlsdGVycyA9IHR5cGVvZiBwYXJzZUVsLnN0eWxlLmZpbHRlciA9PT0gJ3N0cmluZycsXG4gICAgICByZU9wYWNpdHkgPSAvYWxwaGFcXHMqXFwoXFxzKm9wYWNpdHlcXHMqPVxccyooW15cXCldKylcXCkvLFxuXG4gICAgICAvKiogQGlnbm9yZSAqL1xuICAgICAgc2V0T3BhY2l0eSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50OyB9O1xuXG4gIGlmIChzdXBwb3J0c09wYWNpdHkpIHtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHNldE9wYWNpdHkgPSBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZSkge1xuICAgICAgZWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gdmFsdWU7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9O1xuICB9XG4gIGVsc2UgaWYgKHN1cHBvcnRzRmlsdGVycykge1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgc2V0T3BhY2l0eSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgICB2YXIgZXMgPSBlbGVtZW50LnN0eWxlO1xuICAgICAgaWYgKGVsZW1lbnQuY3VycmVudFN0eWxlICYmICFlbGVtZW50LmN1cnJlbnRTdHlsZS5oYXNMYXlvdXQpIHtcbiAgICAgICAgZXMuem9vbSA9IDE7XG4gICAgICB9XG4gICAgICBpZiAocmVPcGFjaXR5LnRlc3QoZXMuZmlsdGVyKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID49IDAuOTk5OSA/ICcnIDogKCdhbHBoYShvcGFjaXR5PScgKyAodmFsdWUgKiAxMDApICsgJyknKTtcbiAgICAgICAgZXMuZmlsdGVyID0gZXMuZmlsdGVyLnJlcGxhY2UocmVPcGFjaXR5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZXMuZmlsdGVyICs9ICcgYWxwaGEob3BhY2l0eT0nICsgKHZhbHVlICogMTAwKSArICcpJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG4gIH1cblxuICBmYWJyaWMudXRpbC5zZXRTdHlsZSA9IHNldFN0eWxlO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgX3NsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIC8qKlxuICAgKiBUYWtlcyBpZCBhbmQgcmV0dXJucyBhbiBlbGVtZW50IHdpdGggdGhhdCBpZCAoaWYgb25lIGV4aXN0cyBpbiBhIGRvY3VtZW50KVxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGlkXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBmYWJyaWMuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogaWQ7XG4gIH1cblxuICB2YXIgc2xpY2VDYW5Db252ZXJ0Tm9kZWxpc3RzLFxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0cyBhbiBhcnJheS1saWtlIG9iamVjdCAoZS5nLiBhcmd1bWVudHMgb3IgTm9kZUxpc3QpIHRvIGFuIGFycmF5XG4gICAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcnJheUxpa2VcbiAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgICovXG4gICAgICB0b0FycmF5ID0gZnVuY3Rpb24oYXJyYXlMaWtlKSB7XG4gICAgICAgIHJldHVybiBfc2xpY2UuY2FsbChhcnJheUxpa2UsIDApO1xuICAgICAgfTtcblxuICB0cnkge1xuICAgIHNsaWNlQ2FuQ29udmVydE5vZGVsaXN0cyA9IHRvQXJyYXkoZmFicmljLmRvY3VtZW50LmNoaWxkTm9kZXMpIGluc3RhbmNlb2YgQXJyYXk7XG4gIH1cbiAgY2F0Y2ggKGVycikgeyB9XG5cbiAgaWYgKCFzbGljZUNhbkNvbnZlcnROb2RlbGlzdHMpIHtcbiAgICB0b0FycmF5ID0gZnVuY3Rpb24oYXJyYXlMaWtlKSB7XG4gICAgICB2YXIgYXJyID0gbmV3IEFycmF5KGFycmF5TGlrZS5sZW5ndGgpLCBpID0gYXJyYXlMaWtlLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgYXJyW2ldID0gYXJyYXlMaWtlW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgc3BlY2lmaWVkIGVsZW1lbnQgd2l0aCBzcGVjaWZpZWQgYXR0cmlidXRlc1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRhZ05hbWUgVHlwZSBvZiBhbiBlbGVtZW50IHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdIEF0dHJpYnV0ZXMgdG8gc2V0IG9uIGFuIGVsZW1lbnRcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IE5ld2x5IGNyZWF0ZWQgZWxlbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZUVsZW1lbnQodGFnTmFtZSwgYXR0cmlidXRlcykge1xuICAgIHZhciBlbCA9IGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIGZvciAodmFyIHByb3AgaW4gYXR0cmlidXRlcykge1xuICAgICAgaWYgKHByb3AgPT09ICdjbGFzcycpIHtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHByb3AgPT09ICdmb3InKSB7XG4gICAgICAgIGVsLmh0bWxGb3IgPSBhdHRyaWJ1dGVzW3Byb3BdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgY2xhc3MgdG8gYW4gZWxlbWVudFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGFkZCBjbGFzcyB0b1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lIENsYXNzIHRvIGFkZCB0byBhbiBlbGVtZW50XG4gICAqL1xuICBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICBpZiAoZWxlbWVudCAmJiAoJyAnICsgZWxlbWVudC5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgY2xhc3NOYW1lICsgJyAnKSA9PT0gLTEpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9IChlbGVtZW50LmNsYXNzTmFtZSA/ICcgJyA6ICcnKSArIGNsYXNzTmFtZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgZWxlbWVudCB3aXRoIGFub3RoZXIgZWxlbWVudFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHdyYXBcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxTdHJpbmd9IHdyYXBwZXIgRWxlbWVudCB0byB3cmFwIHdpdGhcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXSBBdHRyaWJ1dGVzIHRvIHNldCBvbiBhIHdyYXBwZXJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IHdyYXBwZXJcbiAgICovXG4gIGZ1bmN0aW9uIHdyYXBFbGVtZW50KGVsZW1lbnQsIHdyYXBwZXIsIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAodHlwZW9mIHdyYXBwZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICB3cmFwcGVyID0gbWFrZUVsZW1lbnQod3JhcHBlciwgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQod3JhcHBlciwgZWxlbWVudCk7XG4gICAgfVxuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBlbGVtZW50IHNjcm9sbCBvZmZzZXRzXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gb3BlcmF0ZSBvblxuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIGxlZnQvdG9wIHZhbHVlc1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U2Nyb2xsTGVmdFRvcChlbGVtZW50KSB7XG5cbiAgICB2YXIgbGVmdCA9IDAsXG4gICAgICAgIHRvcCA9IDAsXG4gICAgICAgIGRvY0VsZW1lbnQgPSBmYWJyaWMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICBib2R5ID0gZmFicmljLmRvY3VtZW50LmJvZHkgfHwge1xuICAgICAgICAgIHNjcm9sbExlZnQ6IDAsIHNjcm9sbFRvcDogMFxuICAgICAgICB9O1xuXG4gICAgLy8gV2hpbGUgbG9vcCBjaGVja3MgKGFuZCB0aGVuIHNldHMgZWxlbWVudCB0bykgLnBhcmVudE5vZGUgT1IgLmhvc3RcbiAgICAvLyAgdG8gYWNjb3VudCBmb3IgU2hhZG93RE9NLiBXZSBzdGlsbCB3YW50IHRvIHRyYXZlcnNlIHVwIG91dCBvZiBTaGFkb3dET00sXG4gICAgLy8gIGJ1dCB0aGUgLnBhcmVudE5vZGUgb2YgYSByb290IFNoYWRvd0RPTSBub2RlIHdpbGwgYWx3YXlzIGJlIG51bGwsIGluc3RlYWRcbiAgICAvLyAgaXQgc2hvdWxkIGJlIGFjY2Vzc2VkIHRocm91Z2ggLmhvc3QuIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNDc2NTUyOC80MzgzOTM4XG4gICAgd2hpbGUgKGVsZW1lbnQgJiYgKGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3QpKSB7XG5cbiAgICAgIC8vIFNldCBlbGVtZW50IHRvIGVsZW1lbnQgcGFyZW50LCBvciAnaG9zdCcgaW4gY2FzZSBvZiBTaGFkb3dET01cbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudC5ob3N0O1xuXG4gICAgICBpZiAoZWxlbWVudCA9PT0gZmFicmljLmRvY3VtZW50KSB7XG4gICAgICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWxlbWVudC5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgICAgIHRvcCA9IGJvZHkuc2Nyb2xsVG9wIHx8ICBkb2NFbGVtZW50LnNjcm9sbFRvcCB8fCAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxlZnQgKz0gZWxlbWVudC5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgICAgIHRvcCArPSBlbGVtZW50LnNjcm9sbFRvcCB8fCAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gMSAmJiBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGxlZnQ6IGxlZnQsIHRvcDogdG9wIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBvZmZzZXQgZm9yIGEgZ2l2ZW4gZWxlbWVudFxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBnZXQgb2Zmc2V0IGZvclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIFwibGVmdFwiIGFuZCBcInRvcFwiIHByb3BlcnRpZXNcbiAgICovXG4gIGZ1bmN0aW9uIGdldEVsZW1lbnRPZmZzZXQoZWxlbWVudCkge1xuICAgIHZhciBkb2NFbGVtLFxuICAgICAgICBkb2MgPSBlbGVtZW50ICYmIGVsZW1lbnQub3duZXJEb2N1bWVudCxcbiAgICAgICAgYm94ID0geyBsZWZ0OiAwLCB0b3A6IDAgfSxcbiAgICAgICAgb2Zmc2V0ID0geyBsZWZ0OiAwLCB0b3A6IDAgfSxcbiAgICAgICAgc2Nyb2xsTGVmdFRvcCxcbiAgICAgICAgb2Zmc2V0QXR0cmlidXRlcyA9IHtcbiAgICAgICAgICBib3JkZXJMZWZ0V2lkdGg6ICdsZWZ0JyxcbiAgICAgICAgICBib3JkZXJUb3BXaWR0aDogICd0b3AnLFxuICAgICAgICAgIHBhZGRpbmdMZWZ0OiAgICAgJ2xlZnQnLFxuICAgICAgICAgIHBhZGRpbmdUb3A6ICAgICAgJ3RvcCdcbiAgICAgICAgfTtcblxuICAgIGlmICghZG9jKSB7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIGZvciAodmFyIGF0dHIgaW4gb2Zmc2V0QXR0cmlidXRlcykge1xuICAgICAgb2Zmc2V0W29mZnNldEF0dHJpYnV0ZXNbYXR0cl1dICs9IHBhcnNlSW50KGdldEVsZW1lbnRTdHlsZShlbGVtZW50LCBhdHRyKSwgMTApIHx8IDA7XG4gICAgfVxuXG4gICAgZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgaWYgKCB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgYm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG5cbiAgICBzY3JvbGxMZWZ0VG9wID0gZ2V0U2Nyb2xsTGVmdFRvcChlbGVtZW50KTtcblxuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBib3gubGVmdCArIHNjcm9sbExlZnRUb3AubGVmdCAtIChkb2NFbGVtLmNsaWVudExlZnQgfHwgMCkgKyBvZmZzZXQubGVmdCxcbiAgICAgIHRvcDogYm94LnRvcCArIHNjcm9sbExlZnRUb3AudG9wIC0gKGRvY0VsZW0uY2xpZW50VG9wIHx8IDApICArIG9mZnNldC50b3BcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3R5bGUgYXR0cmlidXRlIHZhbHVlIG9mIGEgZ2l2ZW4gZWxlbWVudFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGdldCBzdHlsZSBhdHRyaWJ1dGUgZm9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIFN0eWxlIGF0dHJpYnV0ZSB0byBnZXQgZm9yIGVsZW1lbnRcbiAgICogQHJldHVybiB7U3RyaW5nfSBTdHlsZSBhdHRyaWJ1dGUgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAqL1xuICB2YXIgZ2V0RWxlbWVudFN0eWxlO1xuICBpZiAoZmFicmljLmRvY3VtZW50LmRlZmF1bHRWaWV3ICYmIGZhYnJpYy5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgZ2V0RWxlbWVudFN0eWxlID0gZnVuY3Rpb24oZWxlbWVudCwgYXR0cikge1xuICAgICAgdmFyIHN0eWxlID0gZmFicmljLmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gICAgICByZXR1cm4gc3R5bGUgPyBzdHlsZVthdHRyXSA6IHVuZGVmaW5lZDtcbiAgICB9O1xuICB9XG4gIGVsc2Uge1xuICAgIGdldEVsZW1lbnRTdHlsZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHIpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGVsZW1lbnQuc3R5bGVbYXR0cl07XG4gICAgICBpZiAoIXZhbHVlICYmIGVsZW1lbnQuY3VycmVudFN0eWxlKSB7XG4gICAgICAgIHZhbHVlID0gZWxlbWVudC5jdXJyZW50U3R5bGVbYXR0cl07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0eWxlID0gZmFicmljLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSxcbiAgICAgICAgc2VsZWN0UHJvcCA9ICd1c2VyU2VsZWN0JyBpbiBzdHlsZVxuICAgICAgICAgID8gJ3VzZXJTZWxlY3QnXG4gICAgICAgICAgOiAnTW96VXNlclNlbGVjdCcgaW4gc3R5bGVcbiAgICAgICAgICAgID8gJ01velVzZXJTZWxlY3QnXG4gICAgICAgICAgICA6ICdXZWJraXRVc2VyU2VsZWN0JyBpbiBzdHlsZVxuICAgICAgICAgICAgICA/ICdXZWJraXRVc2VyU2VsZWN0J1xuICAgICAgICAgICAgICA6ICdLaHRtbFVzZXJTZWxlY3QnIGluIHN0eWxlXG4gICAgICAgICAgICAgICAgPyAnS2h0bWxVc2VyU2VsZWN0J1xuICAgICAgICAgICAgICAgIDogJyc7XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBlbGVtZW50IHVuc2VsZWN0YWJsZVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBtYWtlIHVuc2VsZWN0YWJsZVxuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBFbGVtZW50IHRoYXQgd2FzIHBhc3NlZCBpblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VFbGVtZW50VW5zZWxlY3RhYmxlKGVsZW1lbnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5vbnNlbGVjdHN0YXJ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgPSBmYWJyaWMudXRpbC5mYWxzZUZ1bmN0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdFByb3ApIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZVtzZWxlY3RQcm9wXSA9ICdub25lJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnVuc2VsZWN0YWJsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZWxlbWVudC51bnNlbGVjdGFibGUgPSAnb24nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgZWxlbWVudCBzZWxlY3RhYmxlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIG1ha2Ugc2VsZWN0YWJsZVxuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBFbGVtZW50IHRoYXQgd2FzIHBhc3NlZCBpblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VFbGVtZW50U2VsZWN0YWJsZShlbGVtZW50KSB7XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQub25zZWxlY3RzdGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZWxlbWVudC5vbnNlbGVjdHN0YXJ0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RQcm9wKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbc2VsZWN0UHJvcF0gPSAnJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnVuc2VsZWN0YWJsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZWxlbWVudC51bnNlbGVjdGFibGUgPSAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50VW5zZWxlY3RhYmxlID0gbWFrZUVsZW1lbnRVbnNlbGVjdGFibGU7XG4gICAgZmFicmljLnV0aWwubWFrZUVsZW1lbnRTZWxlY3RhYmxlID0gbWFrZUVsZW1lbnRTZWxlY3RhYmxlO1xuICB9KSgpO1xuXG4gIChmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBzY3JpcHQgZWxlbWVudCB3aXRoIGEgZ2l2ZW4gdXJsIGludG8gYSBkb2N1bWVudDsgaW52b2tlcyBjYWxsYmFjaywgd2hlbiB0aGF0IHNjcmlwdCBpcyBmaW5pc2hlZCBsb2FkaW5nXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgb2YgYSBzY3JpcHQgdG8gbG9hZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBzY3JpcHQgaXMgZmluaXNoZWQgbG9hZGluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNjcmlwdCh1cmwsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaGVhZEVsID0gZmFicmljLmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0sXG4gICAgICAgICAgc2NyaXB0RWwgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JyksXG4gICAgICAgICAgbG9hZGluZyA9IHRydWU7XG5cbiAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICBzY3JpcHRFbC5vbmxvYWQgPSAvKiogQGlnbm9yZSAqLyBzY3JpcHRFbC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChsb2FkaW5nKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnJlYWR5U3RhdGUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSAhPT0gJ2xvYWRlZCcgJiZcbiAgICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlICE9PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBjYWxsYmFjayhlIHx8IGZhYnJpYy53aW5kb3cuZXZlbnQpO1xuICAgICAgICAgIHNjcmlwdEVsID0gc2NyaXB0RWwub25sb2FkID0gc2NyaXB0RWwub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNjcmlwdEVsLnNyYyA9IHVybDtcbiAgICAgIGhlYWRFbC5hcHBlbmRDaGlsZChzY3JpcHRFbCk7XG4gICAgICAvLyBjYXVzZXMgaXNzdWUgaW4gT3BlcmFcbiAgICAgIC8vIGhlYWRFbC5yZW1vdmVDaGlsZChzY3JpcHRFbCk7XG4gICAgfVxuXG4gICAgZmFicmljLnV0aWwuZ2V0U2NyaXB0ID0gZ2V0U2NyaXB0O1xuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIGdldE5vZGVDYW52YXMoZWxlbWVudCkge1xuICAgIHZhciBpbXBsID0gZmFicmljLmpzZG9tSW1wbEZvcldyYXBwZXIoZWxlbWVudCk7XG4gICAgcmV0dXJuIGltcGwuX2NhbnZhcyB8fCBpbXBsLl9pbWFnZTtcbiAgfTtcblxuICBmYWJyaWMudXRpbC5nZXRCeUlkID0gZ2V0QnlJZDtcbiAgZmFicmljLnV0aWwudG9BcnJheSA9IHRvQXJyYXk7XG4gIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50ID0gbWFrZUVsZW1lbnQ7XG4gIGZhYnJpYy51dGlsLmFkZENsYXNzID0gYWRkQ2xhc3M7XG4gIGZhYnJpYy51dGlsLndyYXBFbGVtZW50ID0gd3JhcEVsZW1lbnQ7XG4gIGZhYnJpYy51dGlsLmdldFNjcm9sbExlZnRUb3AgPSBnZXRTY3JvbGxMZWZ0VG9wO1xuICBmYWJyaWMudXRpbC5nZXRFbGVtZW50T2Zmc2V0ID0gZ2V0RWxlbWVudE9mZnNldDtcbiAgZmFicmljLnV0aWwuZ2V0RWxlbWVudFN0eWxlID0gZ2V0RWxlbWVudFN0eWxlO1xuICBmYWJyaWMudXRpbC5nZXROb2RlQ2FudmFzID0gZ2V0Tm9kZUNhbnZhcztcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgZnVuY3Rpb24gYWRkUGFyYW1Ub1VybCh1cmwsIHBhcmFtKSB7XG4gICAgcmV0dXJuIHVybCArICgvXFw/Ly50ZXN0KHVybCkgPyAnJicgOiAnPycpICsgcGFyYW07XG4gIH1cblxuICB2YXIgbWFrZVhIUiA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgZmFjdG9yaWVzID0gW1xuICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTsgfSxcbiAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7IH0sXG4gICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC4zLjAnKTsgfSxcbiAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7IH1cbiAgICBdO1xuICAgIGZvciAodmFyIGkgPSBmYWN0b3JpZXMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlcSA9IGZhY3Rvcmllc1tpXSgpO1xuICAgICAgICBpZiAocmVxKSB7XG4gICAgICAgICAgcmV0dXJuIGZhY3Rvcmllc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2F0Y2ggKGVycikgeyB9XG4gICAgfVxuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIGVtcHR5Rm4oKSB7IH1cblxuICAvKipcbiAgICogQ3Jvc3MtYnJvd3NlciBhYnN0cmFjdGlvbiBmb3Igc2VuZGluZyBYTUxIdHRwUmVxdWVzdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgdG8gc2VuZCBYTUxIdHRwUmVxdWVzdCB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXRob2Q9XCJHRVRcIl1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhcmFtZXRlcnNdIHBhcmFtZXRlcnMgdG8gYXBwZW5kIHRvIHVybCBpbiBHRVQgb3IgaW4gYm9keVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYm9keV0gYm9keSB0byBzZW5kIHdpdGggUE9TVCBvciBQVVQgcmVxdWVzdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uQ29tcGxldGUgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gcmVxdWVzdCBpcyBjb21wbGV0ZWRcbiAgICogQHJldHVybiB7WE1MSHR0cFJlcXVlc3R9IHJlcXVlc3RcbiAgICovXG4gIGZ1bmN0aW9uIHJlcXVlc3QodXJsLCBvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgIHZhciBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCA/IG9wdGlvbnMubWV0aG9kLnRvVXBwZXJDYXNlKCkgOiAnR0VUJyxcbiAgICAgICAgb25Db21wbGV0ZSA9IG9wdGlvbnMub25Db21wbGV0ZSB8fCBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgeGhyID0gbWFrZVhIUigpLFxuICAgICAgICBib2R5ID0gb3B0aW9ucy5ib2R5IHx8IG9wdGlvbnMucGFyYW1ldGVycztcblxuICAgIC8qKiBAaWdub3JlICovXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgIG9uQ29tcGxldGUoeGhyKTtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5Rm47XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICBib2R5ID0gbnVsbDtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wYXJhbWV0ZXJzID09PSAnc3RyaW5nJykge1xuICAgICAgICB1cmwgPSBhZGRQYXJhbVRvVXJsKHVybCwgb3B0aW9ucy5wYXJhbWV0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG5cbiAgICBpZiAobWV0aG9kID09PSAnUE9TVCcgfHwgbWV0aG9kID09PSAnUFVUJykge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICB9XG5cbiAgICB4aHIuc2VuZChib2R5KTtcbiAgICByZXR1cm4geGhyO1xuICB9XG5cbiAgZmFicmljLnV0aWwucmVxdWVzdCA9IHJlcXVlc3Q7XG59KSgpO1xuXG5cbi8qKlxuICogV3JhcHBlciBhcm91bmQgYGNvbnNvbGUubG9nYCAod2hlbiBhdmFpbGFibGUpXG4gKiBAcGFyYW0geyp9IFt2YWx1ZXNdIFZhbHVlcyB0byBsb2dcbiAqL1xuZmFicmljLmxvZyA9IGZ1bmN0aW9uKCkgeyB9O1xuXG4vKipcbiAqIFdyYXBwZXIgYXJvdW5kIGBjb25zb2xlLndhcm5gICh3aGVuIGF2YWlsYWJsZSlcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlc10gVmFsdWVzIHRvIGxvZyBhcyBhIHdhcm5pbmdcbiAqL1xuZmFicmljLndhcm4gPSBmdW5jdGlvbigpIHsgfTtcblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblxuICBbJ2xvZycsICd3YXJuJ10uZm9yRWFjaChmdW5jdGlvbihtZXRob2ROYW1lKSB7XG5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBjb25zb2xlW21ldGhvZE5hbWVdLmFwcGx5ID09PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgIGZhYnJpY1ttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29uc29sZVttZXRob2ROYW1lXS5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBub29wKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHZhbHVlIGZyb20gb25lIHRvIGFub3RoZXIgd2l0aGluIGNlcnRhaW4gcGVyaW9kIG9mIHRpbWUsIGludm9raW5nIGNhbGxiYWNrcyBhcyB2YWx1ZSBpcyBiZWluZyBjaGFuZ2VkLlxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbmltYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkNoYW5nZV0gQ2FsbGJhY2s7IGludm9rZWQgb24gZXZlcnkgdmFsdWUgY2hhbmdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uQ29tcGxldGVdIENhbGxiYWNrOyBpbnZva2VkIHdoZW4gdmFsdWUgY2hhbmdlIGlzIGNvbXBsZXRlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3RhcnRWYWx1ZT0wXSBTdGFydGluZyB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZW5kVmFsdWU9MTAwXSBFbmRpbmcgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJ5VmFsdWU9MTAwXSBWYWx1ZSB0byBtb2RpZnkgdGhlIHByb3BlcnR5IGJ5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmVhc2luZ10gRWFzaW5nIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvbj01MDBdIER1cmF0aW9uIG9mIGNoYW5nZSAoaW4gbXMpXG4gICAqL1xuICBmdW5jdGlvbiBhbmltYXRlKG9wdGlvbnMpIHtcblxuICAgIHJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24odGltZXN0YW1wKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdmFyIHN0YXJ0ID0gdGltZXN0YW1wIHx8ICtuZXcgRGF0ZSgpLFxuICAgICAgICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiB8fCA1MDAsXG4gICAgICAgICAgZmluaXNoID0gc3RhcnQgKyBkdXJhdGlvbiwgdGltZSxcbiAgICAgICAgICBvbkNoYW5nZSA9IG9wdGlvbnMub25DaGFuZ2UgfHwgbm9vcCxcbiAgICAgICAgICBhYm9ydCA9IG9wdGlvbnMuYWJvcnQgfHwgbm9vcCxcbiAgICAgICAgICBvbkNvbXBsZXRlID0gb3B0aW9ucy5vbkNvbXBsZXRlIHx8IG5vb3AsXG4gICAgICAgICAgZWFzaW5nID0gb3B0aW9ucy5lYXNpbmcgfHwgZnVuY3Rpb24odCwgYiwgYywgZCkge3JldHVybiAtYyAqIE1hdGguY29zKHQgLyBkICogKE1hdGguUEkgLyAyKSkgKyBjICsgYjt9LFxuICAgICAgICAgIHN0YXJ0VmFsdWUgPSAnc3RhcnRWYWx1ZScgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhcnRWYWx1ZSA6IDAsXG4gICAgICAgICAgZW5kVmFsdWUgPSAnZW5kVmFsdWUnIGluIG9wdGlvbnMgPyBvcHRpb25zLmVuZFZhbHVlIDogMTAwLFxuICAgICAgICAgIGJ5VmFsdWUgPSBvcHRpb25zLmJ5VmFsdWUgfHwgZW5kVmFsdWUgLSBzdGFydFZhbHVlO1xuXG4gICAgICBvcHRpb25zLm9uU3RhcnQgJiYgb3B0aW9ucy5vblN0YXJ0KCk7XG5cbiAgICAgIChmdW5jdGlvbiB0aWNrKHRpY2t0aW1lKSB7XG4gICAgICAgIGlmIChhYm9ydCgpKSB7XG4gICAgICAgICAgb25Db21wbGV0ZShlbmRWYWx1ZSwgMSwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRpbWUgPSB0aWNrdGltZSB8fCArbmV3IERhdGUoKTtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdGltZSA+IGZpbmlzaCA/IGR1cmF0aW9uIDogKHRpbWUgLSBzdGFydCksXG4gICAgICAgICAgICB0aW1lUGVyYyA9IGN1cnJlbnRUaW1lIC8gZHVyYXRpb24sXG4gICAgICAgICAgICBjdXJyZW50ID0gZWFzaW5nKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBieVZhbHVlLCBkdXJhdGlvbiksXG4gICAgICAgICAgICB2YWx1ZVBlcmMgPSBNYXRoLmFicygoY3VycmVudCAtIHN0YXJ0VmFsdWUpIC8gYnlWYWx1ZSk7XG4gICAgICAgIG9uQ2hhbmdlKGN1cnJlbnQsIHZhbHVlUGVyYywgdGltZVBlcmMpO1xuICAgICAgICBpZiAodGltZSA+IGZpbmlzaCkge1xuICAgICAgICAgIG9wdGlvbnMub25Db21wbGV0ZSAmJiBvcHRpb25zLm9uQ29tcGxldGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1GcmFtZSh0aWNrKTtcbiAgICAgIH0pKHN0YXJ0KTtcbiAgICB9KTtcblxuICB9XG5cbiAgdmFyIF9yZXF1ZXN0QW5pbUZyYW1lID0gZmFicmljLndpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFicmljLndpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFicmljLndpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFicmljLndpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFicmljLndpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFicmljLndpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gIHZhciBfY2FuY2VsQW5pbUZyYW1lID0gZmFicmljLndpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCBmYWJyaWMud2luZG93LmNsZWFyVGltZW91dDtcblxuICAvKipcbiAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHBvbHlmaWxsIGJhc2VkIG9uIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG4gICAqIEluIG9yZGVyIHRvIGdldCBhIHByZWNpc2Ugc3RhcnQgdGltZSwgYHJlcXVlc3RBbmltRnJhbWVgIHNob3VsZCBiZSBjYWxsZWQgYXMgYW4gZW50cnkgaW50byB0aGUgbWV0aG9kXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2VcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IG9wdGlvbmFsIEVsZW1lbnQgdG8gYXNzb2NpYXRlIHdpdGggYW5pbWF0aW9uXG4gICAqL1xuICBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKCkge1xuICAgIHJldHVybiBfcmVxdWVzdEFuaW1GcmFtZS5hcHBseShmYWJyaWMud2luZG93LCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKCkge1xuICAgIHJldHVybiBfY2FuY2VsQW5pbUZyYW1lLmFwcGx5KGZhYnJpYy53aW5kb3csIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmYWJyaWMudXRpbC5hbmltYXRlID0gYW5pbWF0ZTtcbiAgZmFicmljLnV0aWwucmVxdWVzdEFuaW1GcmFtZSA9IHJlcXVlc3RBbmltRnJhbWU7XG4gIGZhYnJpYy51dGlsLmNhbmNlbEFuaW1GcmFtZSA9IGNhbmNlbEFuaW1GcmFtZTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICAvLyBDYWxjdWxhdGUgYW4gaW4tYmV0d2VlbiBjb2xvci4gUmV0dXJucyBhIFwicmdiYSgpXCIgc3RyaW5nLlxuICAvLyBDcmVkaXQ6IEVkd2luIE1hcnRpbiA8ZWR3aW5AYml0c3Rvcm0ub3JnPlxuICAvLyAgICAgICAgIGh0dHA6Ly93d3cuYml0c3Rvcm0ub3JnL2pxdWVyeS9jb2xvci1hbmltYXRpb24vanF1ZXJ5LmFuaW1hdGUtY29sb3JzLmpzXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZUNvbG9yKGJlZ2luLCBlbmQsIHBvcykge1xuICAgIHZhciBjb2xvciA9ICdyZ2JhKCdcbiAgICAgICAgKyBwYXJzZUludCgoYmVnaW5bMF0gKyBwb3MgKiAoZW5kWzBdIC0gYmVnaW5bMF0pKSwgMTApICsgJywnXG4gICAgICAgICsgcGFyc2VJbnQoKGJlZ2luWzFdICsgcG9zICogKGVuZFsxXSAtIGJlZ2luWzFdKSksIDEwKSArICcsJ1xuICAgICAgICArIHBhcnNlSW50KChiZWdpblsyXSArIHBvcyAqIChlbmRbMl0gLSBiZWdpblsyXSkpLCAxMCk7XG5cbiAgICBjb2xvciArPSAnLCcgKyAoYmVnaW4gJiYgZW5kID8gcGFyc2VGbG9hdChiZWdpblszXSArIHBvcyAqIChlbmRbM10gLSBiZWdpblszXSkpIDogMSk7XG4gICAgY29sb3IgKz0gJyknO1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRoZSBjb2xvciBmcm9tIG9uZSB0byBhbm90aGVyIHdpdGhpbiBjZXJ0YWluIHBlcmlvZCBvZiB0aW1lLCBpbnZva2luZyBjYWxsYmFja3MgYXMgdmFsdWUgaXMgYmVpbmcgY2hhbmdlZC5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tQ29sb3IgVGhlIHN0YXJ0aW5nIGNvbG9yIGluIGhleCBvciByZ2IoYSkgZm9ybWF0LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdG9Db2xvciBUaGUgc3RhcnRpbmcgY29sb3IgaW4gaGV4IG9yIHJnYihhKSBmb3JtYXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZHVyYXRpb25dIER1cmF0aW9uIG9mIGNoYW5nZSAoaW4gbXMpLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuaW1hdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uQ2hhbmdlXSBDYWxsYmFjazsgaW52b2tlZCBvbiBldmVyeSB2YWx1ZSBjaGFuZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25Db21wbGV0ZV0gQ2FsbGJhY2s7IGludm9rZWQgd2hlbiB2YWx1ZSBjaGFuZ2UgaXMgY29tcGxldGVkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNvbG9yRWFzaW5nXSBFYXNpbmcgZnVuY3Rpb24uIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG9ubHkgdGFrZSB0d28gYXJndW1lbnRzIChjdXJyZW50VGltZSwgZHVyYXRpb24pLiBUaHVzIHRoZSByZWd1bGFyIGFuaW1hdGlvbiBlYXNpbmcgZnVuY3Rpb25zIGNhbm5vdCBiZSB1c2VkLlxuICAgKi9cbiAgZnVuY3Rpb24gYW5pbWF0ZUNvbG9yKGZyb21Db2xvciwgdG9Db2xvciwgZHVyYXRpb24sIG9wdGlvbnMpIHtcbiAgICB2YXIgc3RhcnRDb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoZnJvbUNvbG9yKS5nZXRTb3VyY2UoKSxcbiAgICAgICAgZW5kQ29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHRvQ29sb3IpLmdldFNvdXJjZSgpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBmYWJyaWMudXRpbC5hbmltYXRlKGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQob3B0aW9ucywge1xuICAgICAgZHVyYXRpb246IGR1cmF0aW9uIHx8IDUwMCxcbiAgICAgIHN0YXJ0VmFsdWU6IHN0YXJ0Q29sb3IsXG4gICAgICBlbmRWYWx1ZTogZW5kQ29sb3IsXG4gICAgICBieVZhbHVlOiBlbmRDb2xvcixcbiAgICAgIGVhc2luZzogZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBieVZhbHVlLCBkdXJhdGlvbikge1xuICAgICAgICB2YXIgcG9zVmFsdWUgPSBvcHRpb25zLmNvbG9yRWFzaW5nXG4gICAgICAgICAgPyBvcHRpb25zLmNvbG9yRWFzaW5nKGN1cnJlbnRUaW1lLCBkdXJhdGlvbilcbiAgICAgICAgICA6IDEgLSBNYXRoLmNvcyhjdXJyZW50VGltZSAvIGR1cmF0aW9uICogKE1hdGguUEkgLyAyKSk7XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGVDb2xvcihzdGFydFZhbHVlLCBieVZhbHVlLCBwb3NWYWx1ZSk7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG5cbiAgZmFicmljLnV0aWwuYW5pbWF0ZUNvbG9yID0gYW5pbWF0ZUNvbG9yO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBub3JtYWxpemUoYSwgYywgcCwgcykge1xuICAgIGlmIChhIDwgTWF0aC5hYnMoYykpIHtcbiAgICAgIGEgPSBjO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vaGFuZGxlIHRoZSAwLzAgY2FzZTpcbiAgICAgIGlmIChjID09PSAwICYmIGEgPT09IDApIHtcbiAgICAgICAgcyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKDEpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbihjIC8gYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGE6IGEsIGM6IGMsIHA6IHAsIHM6IHMgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVsYXN0aWMob3B0cywgdCwgZCkge1xuICAgIHJldHVybiBvcHRzLmEgKlxuICAgICAgTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKlxuICAgICAgTWF0aC5zaW4oICh0ICogZCAtIG9wdHMucykgKiAoMiAqIE1hdGguUEkpIC8gb3B0cy5wICk7XG4gIH1cblxuICAvKipcbiAgICogQ3ViaWMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEN1YmljKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogdCArIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdWJpYyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0Q3ViaWModCwgYiwgYywgZCkge1xuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiB0ICogdCAqIHQgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWFydGljIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluUXVhcnQodCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCAqIHQgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1YXJ0aWMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dFF1YXJ0KHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gLWMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKiB0IC0gMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1YXJ0aWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dFF1YXJ0KHQsIGIsIGMsIGQpIHtcbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKiB0ICogdCArIGI7XG4gICAgfVxuICAgIHJldHVybiAtYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVpbnRpYyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJblF1aW50KHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKiB0ICogdCArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVpbnRpYyBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0UXVpbnQodCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVpbnRpYyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0UXVpbnQodCwgYiwgYywgZCkge1xuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiB0ICogdCAqIHQgKiB0ICogdCArIGI7XG4gICAgfVxuICAgIHJldHVybiBjIC8gMiAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogU2ludXNvaWRhbCBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJblNpbmUodCwgYiwgYywgZCkge1xuICAgIHJldHVybiAtYyAqIE1hdGguY29zKHQgLyBkICogKE1hdGguUEkgLyAyKSkgKyBjICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW51c29pZGFsIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRTaW5lKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqIE1hdGguc2luKHQgLyBkICogKE1hdGguUEkgLyAyKSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbnVzb2lkYWwgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dFNpbmUodCwgYiwgYywgZCkge1xuICAgIHJldHVybiAtYyAvIDIgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIHQgLyBkKSAtIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvbmVudGlhbCBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkV4cG8odCwgYiwgYywgZCkge1xuICAgIHJldHVybiAodCA9PT0gMCkgPyBiIDogYyAqIE1hdGgucG93KDIsIDEwICogKHQgLyBkIC0gMSkpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvbmVudGlhbCBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0RXhwbyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuICh0ID09PSBkKSA/IGIgKyBjIDogYyAqICgtTWF0aC5wb3coMiwgLTEwICogdCAvIGQpICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9uZW50aWFsIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRFeHBvKHQsIGIsIGMsIGQpIHtcbiAgICBpZiAodCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIGlmICh0ID09PSBkKSB7XG4gICAgICByZXR1cm4gYiArIGM7XG4gICAgfVxuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGMgLyAyICogKC1NYXRoLnBvdygyLCAtMTAgKiAtLXQpICsgMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIENpcmN1bGFyIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluQ2lyYyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIC1jICogKE1hdGguc3FydCgxIC0gKHQgLz0gZCkgKiB0KSAtIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaXJjdWxhciBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0Q2lyYyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiBNYXRoLnNxcnQoMSAtICh0ID0gdCAvIGQgLSAxKSAqIHQpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaXJjdWxhciBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0Q2lyYyh0LCBiLCBjLCBkKSB7XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiAtYyAvIDIgKiAoTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKSArIGI7XG4gICAgfVxuICAgIHJldHVybiBjIC8gMiAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRWxhc3RpYyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkVsYXN0aWModCwgYiwgYywgZCkge1xuICAgIHZhciBzID0gMS43MDE1OCwgcCA9IDAsIGEgPSBjO1xuICAgIGlmICh0ID09PSAwKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgdCAvPSBkO1xuICAgIGlmICh0ID09PSAxKSB7XG4gICAgICByZXR1cm4gYiArIGM7XG4gICAgfVxuICAgIGlmICghcCkge1xuICAgICAgcCA9IGQgKiAwLjM7XG4gICAgfVxuICAgIHZhciBvcHRzID0gbm9ybWFsaXplKGEsIGMsIHAsIHMpO1xuICAgIHJldHVybiAtZWxhc3RpYyhvcHRzLCB0LCBkKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRWxhc3RpYyBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0RWxhc3RpYyh0LCBiLCBjLCBkKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4LCBwID0gMCwgYSA9IGM7XG4gICAgaWYgKHQgPT09IDApIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICB0IC89IGQ7XG4gICAgaWYgKHQgPT09IDEpIHtcbiAgICAgIHJldHVybiBiICsgYztcbiAgICB9XG4gICAgaWYgKCFwKSB7XG4gICAgICBwID0gZCAqIDAuMztcbiAgICB9XG4gICAgdmFyIG9wdHMgPSBub3JtYWxpemUoYSwgYywgcCwgcyk7XG4gICAgcmV0dXJuIG9wdHMuYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgKiBkIC0gb3B0cy5zKSAqICgyICogTWF0aC5QSSkgLyBvcHRzLnAgKSArIG9wdHMuYyArIGI7XG4gIH1cblxuICAvKipcbiAgICogRWxhc3RpYyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0RWxhc3RpYyh0LCBiLCBjLCBkKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4LCBwID0gMCwgYSA9IGM7XG4gICAgaWYgKHQgPT09IDApIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0ID09PSAyKSB7XG4gICAgICByZXR1cm4gYiArIGM7XG4gICAgfVxuICAgIGlmICghcCkge1xuICAgICAgcCA9IGQgKiAoMC4zICogMS41KTtcbiAgICB9XG4gICAgdmFyIG9wdHMgPSBub3JtYWxpemUoYSwgYywgcCwgcyk7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gLTAuNSAqIGVsYXN0aWMob3B0cywgdCwgZCkgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gb3B0cy5hICogTWF0aC5wb3coMiwgLTEwICogKHQgLT0gMSkpICpcbiAgICAgIE1hdGguc2luKCh0ICogZCAtIG9wdHMucykgKiAoMiAqIE1hdGguUEkpIC8gb3B0cy5wICkgKiAwLjUgKyBvcHRzLmMgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhY2t3YXJkcyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkJhY2sodCwgYiwgYywgZCwgcykge1xuICAgIGlmIChzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHMgPSAxLjcwMTU4O1xuICAgIH1cbiAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqICgocyArIDEpICogdCAtIHMpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYWNrd2FyZHMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEJhY2sodCwgYiwgYywgZCwgcykge1xuICAgIGlmIChzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHMgPSAxLjcwMTU4O1xuICAgIH1cbiAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQmFja3dhcmRzIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRCYWNrKHQsIGIsIGMsIGQsIHMpIHtcbiAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzID0gMS43MDE1ODtcbiAgICB9XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiBjIC8gMiAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSkgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCArIHMpICsgMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJvdW5jaW5nIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluQm91bmNlKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAtIGVhc2VPdXRCb3VuY2UgKGQgLSB0LCAwLCBjLCBkKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQm91bmNpbmcgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEJvdW5jZSh0LCBiLCBjLCBkKSB7XG4gICAgaWYgKCh0IC89IGQpIDwgKDEgLyAyLjc1KSkge1xuICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogdCAqIHQpICsgYjtcbiAgICB9XG4gICAgZWxzZSBpZiAodCA8ICgyIC8gMi43NSkpIHtcbiAgICAgIHJldHVybiBjICogKDcuNTYyNSAqICh0IC09ICgxLjUgLyAyLjc1KSkgKiB0ICsgMC43NSkgKyBiO1xuICAgIH1cbiAgICBlbHNlIGlmICh0IDwgKDIuNSAvIDIuNzUpKSB7XG4gICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAoMi4yNSAvIDIuNzUpKSAqIHQgKyAwLjkzNzUpICsgYjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAoMi42MjUgLyAyLjc1KSkgKiB0ICsgMC45ODQzNzUpICsgYjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQm91bmNpbmcgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dEJvdW5jZSh0LCBiLCBjLCBkKSB7XG4gICAgaWYgKHQgPCBkIC8gMikge1xuICAgICAgcmV0dXJuIGVhc2VJbkJvdW5jZSAodCAqIDIsIDAsIGMsIGQpICogMC41ICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGVhc2VPdXRCb3VuY2UodCAqIDIgLSBkLCAwLCBjLCBkKSAqIDAuNSArIGMgKiAwLjUgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVhc2luZyBmdW5jdGlvbnNcbiAgICogU2VlIDxhIGhyZWY9XCJodHRwOi8vZ2l6bWEuY29tL2Vhc2luZy9cIj5FYXNpbmcgRXF1YXRpb25zIGJ5IFJvYmVydCBQZW5uZXI8L2E+XG4gICAqIEBuYW1lc3BhY2UgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZmFicmljLnV0aWwuZWFzZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFF1YWRyYXRpYyBlYXNpbmcgaW5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgICAqL1xuICAgIGVhc2VJblF1YWQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUXVhZHJhdGljIGVhc2luZyBvdXRcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgICAqL1xuICAgIGVhc2VPdXRRdWFkOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICByZXR1cm4gLWMgKiAodCAvPSBkKSAqICh0IC0gMikgKyBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBRdWFkcmF0aWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgICAqL1xuICAgIGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHQgLz0gKGQgLyAyKTtcbiAgICAgIGlmICh0IDwgMSkge1xuICAgICAgICByZXR1cm4gYyAvIDIgKiB0ICogdCArIGI7XG4gICAgICB9XG4gICAgICByZXR1cm4gLWMgLyAyICogKCgtLXQpICogKHQgLSAyKSAtIDEpICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3ViaWMgZWFzaW5nIGluXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlSW5DdWJpYzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiB0ICsgYjtcbiAgICB9LFxuXG4gICAgZWFzZU91dEN1YmljOiBlYXNlT3V0Q3ViaWMsXG4gICAgZWFzZUluT3V0Q3ViaWM6IGVhc2VJbk91dEN1YmljLFxuICAgIGVhc2VJblF1YXJ0OiBlYXNlSW5RdWFydCxcbiAgICBlYXNlT3V0UXVhcnQ6IGVhc2VPdXRRdWFydCxcbiAgICBlYXNlSW5PdXRRdWFydDogZWFzZUluT3V0UXVhcnQsXG4gICAgZWFzZUluUXVpbnQ6IGVhc2VJblF1aW50LFxuICAgIGVhc2VPdXRRdWludDogZWFzZU91dFF1aW50LFxuICAgIGVhc2VJbk91dFF1aW50OiBlYXNlSW5PdXRRdWludCxcbiAgICBlYXNlSW5TaW5lOiBlYXNlSW5TaW5lLFxuICAgIGVhc2VPdXRTaW5lOiBlYXNlT3V0U2luZSxcbiAgICBlYXNlSW5PdXRTaW5lOiBlYXNlSW5PdXRTaW5lLFxuICAgIGVhc2VJbkV4cG86IGVhc2VJbkV4cG8sXG4gICAgZWFzZU91dEV4cG86IGVhc2VPdXRFeHBvLFxuICAgIGVhc2VJbk91dEV4cG86IGVhc2VJbk91dEV4cG8sXG4gICAgZWFzZUluQ2lyYzogZWFzZUluQ2lyYyxcbiAgICBlYXNlT3V0Q2lyYzogZWFzZU91dENpcmMsXG4gICAgZWFzZUluT3V0Q2lyYzogZWFzZUluT3V0Q2lyYyxcbiAgICBlYXNlSW5FbGFzdGljOiBlYXNlSW5FbGFzdGljLFxuICAgIGVhc2VPdXRFbGFzdGljOiBlYXNlT3V0RWxhc3RpYyxcbiAgICBlYXNlSW5PdXRFbGFzdGljOiBlYXNlSW5PdXRFbGFzdGljLFxuICAgIGVhc2VJbkJhY2s6IGVhc2VJbkJhY2ssXG4gICAgZWFzZU91dEJhY2s6IGVhc2VPdXRCYWNrLFxuICAgIGVhc2VJbk91dEJhY2s6IGVhc2VJbk91dEJhY2ssXG4gICAgZWFzZUluQm91bmNlOiBlYXNlSW5Cb3VuY2UsXG4gICAgZWFzZU91dEJvdW5jZTogZWFzZU91dEJvdW5jZSxcbiAgICBlYXNlSW5PdXRCb3VuY2U6IGVhc2VJbk91dEJvdW5jZVxuICB9O1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIEBuYW1lIGZhYnJpY1xuICAgKiBAbmFtZXNwYWNlXG4gICAqL1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZSxcbiAgICAgIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkLFxuICAgICAgcGFyc2VVbml0ID0gZmFicmljLnV0aWwucGFyc2VVbml0LFxuICAgICAgbXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyA9IGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMsXG5cbiAgICAgIHN2Z1ZhbGlkVGFnTmFtZXMgPSBbJ3BhdGgnLCAnY2lyY2xlJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAnZWxsaXBzZScsICdyZWN0JywgJ2xpbmUnLFxuICAgICAgICAnaW1hZ2UnLCAndGV4dCcsICdsaW5lYXJHcmFkaWVudCcsICdyYWRpYWxHcmFkaWVudCcsICdzdG9wJ10sXG4gICAgICBzdmdWaWV3Qm94RWxlbWVudHMgPSBbJ3N5bWJvbCcsICdpbWFnZScsICdtYXJrZXInLCAncGF0dGVybicsICd2aWV3JywgJ3N2ZyddLFxuICAgICAgc3ZnSW52YWxpZEFuY2VzdG9ycyA9IFsncGF0dGVybicsICdkZWZzJywgJ3N5bWJvbCcsICdtZXRhZGF0YScsICdjbGlwUGF0aCcsICdtYXNrJywgJ2Rlc2MnXSxcbiAgICAgIHN2Z1ZhbGlkUGFyZW50cyA9IFsnc3ltYm9sJywgJ2cnLCAnYScsICdzdmcnXSxcblxuICAgICAgYXR0cmlidXRlc01hcCA9IHtcbiAgICAgICAgY3g6ICAgICAgICAgICAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgeDogICAgICAgICAgICAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgcjogICAgICAgICAgICAgICAgICAgICdyYWRpdXMnLFxuICAgICAgICBjeTogICAgICAgICAgICAgICAgICAgJ3RvcCcsXG4gICAgICAgIHk6ICAgICAgICAgICAgICAgICAgICAndG9wJyxcbiAgICAgICAgZGlzcGxheTogICAgICAgICAgICAgICd2aXNpYmxlJyxcbiAgICAgICAgdmlzaWJpbGl0eTogICAgICAgICAgICd2aXNpYmxlJyxcbiAgICAgICAgdHJhbnNmb3JtOiAgICAgICAgICAgICd0cmFuc2Zvcm1NYXRyaXgnLFxuICAgICAgICAnZmlsbC1vcGFjaXR5JzogICAgICAgJ2ZpbGxPcGFjaXR5JyxcbiAgICAgICAgJ2ZpbGwtcnVsZSc6ICAgICAgICAgICdmaWxsUnVsZScsXG4gICAgICAgICdmb250LWZhbWlseSc6ICAgICAgICAnZm9udEZhbWlseScsXG4gICAgICAgICdmb250LXNpemUnOiAgICAgICAgICAnZm9udFNpemUnLFxuICAgICAgICAnZm9udC1zdHlsZSc6ICAgICAgICAgJ2ZvbnRTdHlsZScsXG4gICAgICAgICdmb250LXdlaWdodCc6ICAgICAgICAnZm9udFdlaWdodCcsXG4gICAgICAgICdsZXR0ZXItc3BhY2luZyc6ICAgICAnY2hhclNwYWNpbmcnLFxuICAgICAgICAncGFpbnQtb3JkZXInOiAgICAgICAgJ3BhaW50Rmlyc3QnLFxuICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICAgJ3N0cm9rZURhc2hBcnJheScsXG4gICAgICAgICdzdHJva2UtbGluZWNhcCc6ICAgICAnc3Ryb2tlTGluZUNhcCcsXG4gICAgICAgICdzdHJva2UtbGluZWpvaW4nOiAgICAnc3Ryb2tlTGluZUpvaW4nLFxuICAgICAgICAnc3Ryb2tlLW1pdGVybGltaXQnOiAgJ3N0cm9rZU1pdGVyTGltaXQnLFxuICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAgICAgJ3N0cm9rZU9wYWNpdHknLFxuICAgICAgICAnc3Ryb2tlLXdpZHRoJzogICAgICAgJ3N0cm9rZVdpZHRoJyxcbiAgICAgICAgJ3RleHQtZGVjb3JhdGlvbic6ICAgICd0ZXh0RGVjb3JhdGlvbicsXG4gICAgICAgICd0ZXh0LWFuY2hvcic6ICAgICAgICAndGV4dEFuY2hvcicsXG4gICAgICAgIG9wYWNpdHk6ICAgICAgICAgICAgICAnb3BhY2l0eSdcbiAgICAgIH0sXG5cbiAgICAgIGNvbG9yQXR0cmlidXRlcyA9IHtcbiAgICAgICAgc3Ryb2tlOiAnc3Ryb2tlT3BhY2l0eScsXG4gICAgICAgIGZpbGw6ICAgJ2ZpbGxPcGFjaXR5J1xuICAgICAgfTtcblxuICBmYWJyaWMuc3ZnVmFsaWRUYWdOYW1lc1JlZ0V4ID0gZ2V0U3ZnUmVnZXgoc3ZnVmFsaWRUYWdOYW1lcyk7XG4gIGZhYnJpYy5zdmdWaWV3Qm94RWxlbWVudHNSZWdFeCA9IGdldFN2Z1JlZ2V4KHN2Z1ZpZXdCb3hFbGVtZW50cyk7XG4gIGZhYnJpYy5zdmdJbnZhbGlkQW5jZXN0b3JzUmVnRXggPSBnZXRTdmdSZWdleChzdmdJbnZhbGlkQW5jZXN0b3JzKTtcbiAgZmFicmljLnN2Z1ZhbGlkUGFyZW50c1JlZ0V4ID0gZ2V0U3ZnUmVnZXgoc3ZnVmFsaWRQYXJlbnRzKTtcblxuICBmYWJyaWMuY3NzUnVsZXMgPSB7IH07XG4gIGZhYnJpYy5ncmFkaWVudERlZnMgPSB7IH07XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplQXR0cihhdHRyKSB7XG4gICAgLy8gdHJhbnNmb3JtIGF0dHJpYnV0ZSBuYW1lc1xuICAgIGlmIChhdHRyIGluIGF0dHJpYnV0ZXNNYXApIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzTWFwW2F0dHJdO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKGF0dHIsIHZhbHVlLCBwYXJlbnRBdHRyaWJ1dGVzLCBmb250U2l6ZSkge1xuICAgIHZhciBpc0FycmF5ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgICAgcGFyc2VkO1xuXG4gICAgaWYgKChhdHRyID09PSAnZmlsbCcgfHwgYXR0ciA9PT0gJ3N0cm9rZScpICYmIHZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdzdHJva2VEYXNoQXJyYXknKSB7XG4gICAgICBpZiAodmFsdWUgPT09ICdub25lJykge1xuICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8sL2csICcgJykuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG4pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ3RyYW5zZm9ybU1hdHJpeCcpIHtcbiAgICAgIGlmIChwYXJlbnRBdHRyaWJ1dGVzICYmIHBhcmVudEF0dHJpYnV0ZXMudHJhbnNmb3JtTWF0cml4KSB7XG4gICAgICAgIHZhbHVlID0gbXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyhcbiAgICAgICAgICBwYXJlbnRBdHRyaWJ1dGVzLnRyYW5zZm9ybU1hdHJpeCwgZmFicmljLnBhcnNlVHJhbnNmb3JtQXR0cmlidXRlKHZhbHVlKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBmYWJyaWMucGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAndmlzaWJsZScpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgIT09ICdub25lJyAmJiB2YWx1ZSAhPT0gJ2hpZGRlbic7XG4gICAgICAvLyBkaXNwbGF5PW5vbmUgb24gcGFyZW50IGVsZW1lbnQgYWx3YXlzIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBjaGlsZCBlbGVtZW50XG4gICAgICBpZiAocGFyZW50QXR0cmlidXRlcyAmJiBwYXJlbnRBdHRyaWJ1dGVzLnZpc2libGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdvcGFjaXR5Jykge1xuICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIGlmIChwYXJlbnRBdHRyaWJ1dGVzICYmIHR5cGVvZiBwYXJlbnRBdHRyaWJ1dGVzLm9wYWNpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhbHVlICo9IHBhcmVudEF0dHJpYnV0ZXMub3BhY2l0eTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ3RleHRBbmNob3InIC8qIHRleHQtYW5jaG9yICovKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlID09PSAnc3RhcnQnID8gJ2xlZnQnIDogdmFsdWUgPT09ICdlbmQnID8gJ3JpZ2h0JyA6ICdjZW50ZXInO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAnY2hhclNwYWNpbmcnKSB7XG4gICAgICAvLyBwYXJzZVVuaXQgcmV0dXJucyBweCBhbmQgd2UgY29udmVydCBpdCB0byBlbVxuICAgICAgcGFyc2VkID0gcGFyc2VVbml0KHZhbHVlLCBmb250U2l6ZSkgLyBmb250U2l6ZSAqIDEwMDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdwYWludEZpcnN0Jykge1xuICAgICAgdmFyIGZpbGxJbmRleCA9IHZhbHVlLmluZGV4T2YoJ2ZpbGwnKTtcbiAgICAgIHZhciBzdHJva2VJbmRleCA9IHZhbHVlLmluZGV4T2YoJ3N0cm9rZScpO1xuICAgICAgdmFyIHZhbHVlID0gJ2ZpbGwnO1xuICAgICAgaWYgKGZpbGxJbmRleCA+IC0xICYmIHN0cm9rZUluZGV4ID4gLTEgJiYgc3Ryb2tlSW5kZXggPCBmaWxsSW5kZXgpIHtcbiAgICAgICAgdmFsdWUgPSAnc3Ryb2tlJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZpbGxJbmRleCA9PT0gLTEgJiYgc3Ryb2tlSW5kZXggPiAtMSkge1xuICAgICAgICB2YWx1ZSA9ICdzdHJva2UnO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHBhcnNlZCA9IGlzQXJyYXkgPyB2YWx1ZS5tYXAocGFyc2VVbml0KSA6IHBhcnNlVW5pdCh2YWx1ZSwgZm9udFNpemUpO1xuICAgIH1cblxuICAgIHJldHVybiAoIWlzQXJyYXkgJiYgaXNOYU4ocGFyc2VkKSA/IHZhbHVlIDogcGFyc2VkKTtcbiAgfVxuXG4gIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICBmdW5jdGlvbiBnZXRTdmdSZWdleChhcnIpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXignICsgYXJyLmpvaW4oJ3wnKSArICcpXFxcXGInLCAnaScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIEFycmF5IG9mIGF0dHJpYnV0ZXMgdG8gcGFyc2VcbiAgICovXG4gIGZ1bmN0aW9uIF9zZXRTdHJva2VGaWxsT3BhY2l0eShhdHRyaWJ1dGVzKSB7XG4gICAgZm9yICh2YXIgYXR0ciBpbiBjb2xvckF0dHJpYnV0ZXMpIHtcblxuICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzW2NvbG9yQXR0cmlidXRlc1thdHRyXV0gPT09ICd1bmRlZmluZWQnIHx8IGF0dHJpYnV0ZXNbYXR0cl0gPT09ICcnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXNbYXR0cl0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICghZmFicmljLk9iamVjdC5wcm90b3R5cGVbYXR0cl0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBhdHRyaWJ1dGVzW2F0dHJdID0gZmFicmljLk9iamVjdC5wcm90b3R5cGVbYXR0cl07XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzW2F0dHJdLmluZGV4T2YoJ3VybCgnKSA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihhdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgIGF0dHJpYnV0ZXNbYXR0cl0gPSBjb2xvci5zZXRBbHBoYSh0b0ZpeGVkKGNvbG9yLmdldEFscGhhKCkgKiBhdHRyaWJ1dGVzW2NvbG9yQXR0cmlidXRlc1thdHRyXV0sIDIpKS50b1JnYmEoKTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRNdWx0aXBsZU5vZGVzKGRvYywgbm9kZU5hbWVzKSB7XG4gICAgdmFyIG5vZGVOYW1lLCBub2RlQXJyYXkgPSBbXSwgbm9kZUxpc3QsIGksIGxlbjtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlTmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG5vZGVOYW1lID0gbm9kZU5hbWVzW2ldO1xuICAgICAgbm9kZUxpc3QgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUobm9kZU5hbWUpO1xuICAgICAgbm9kZUFycmF5ID0gbm9kZUFycmF5LmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChub2RlTGlzdCkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZUFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZSwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHZhbHVlc1xuICAgKiBAc3RhdGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVWYWx1ZSBTdHJpbmcgY29udGFpbmluZyBhdHRyaWJ1dGUgdmFsdWVcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIDYgZWxlbWVudHMgcmVwcmVzZW50aW5nIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgKi9cbiAgZmFicmljLnBhcnNlVHJhbnNmb3JtQXR0cmlidXRlID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIHJvdGF0ZU1hdHJpeChtYXRyaXgsIGFyZ3MpIHtcbiAgICAgIHZhciBjb3MgPSBmYWJyaWMudXRpbC5jb3MoYXJnc1swXSksIHNpbiA9IGZhYnJpYy51dGlsLnNpbihhcmdzWzBdKSxcbiAgICAgICAgICB4ID0gMCwgeSA9IDA7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgeCA9IGFyZ3NbMV07XG4gICAgICAgIHkgPSBhcmdzWzJdO1xuICAgICAgfVxuXG4gICAgICBtYXRyaXhbMF0gPSBjb3M7XG4gICAgICBtYXRyaXhbMV0gPSBzaW47XG4gICAgICBtYXRyaXhbMl0gPSAtc2luO1xuICAgICAgbWF0cml4WzNdID0gY29zO1xuICAgICAgbWF0cml4WzRdID0geCAtIChjb3MgKiB4IC0gc2luICogeSk7XG4gICAgICBtYXRyaXhbNV0gPSB5IC0gKHNpbiAqIHggKyBjb3MgKiB5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FsZU1hdHJpeChtYXRyaXgsIGFyZ3MpIHtcbiAgICAgIHZhciBtdWx0aXBsaWVyWCA9IGFyZ3NbMF0sXG4gICAgICAgICAgbXVsdGlwbGllclkgPSAoYXJncy5sZW5ndGggPT09IDIpID8gYXJnc1sxXSA6IGFyZ3NbMF07XG5cbiAgICAgIG1hdHJpeFswXSA9IG11bHRpcGxpZXJYO1xuICAgICAgbWF0cml4WzNdID0gbXVsdGlwbGllclk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2tld01hdHJpeChtYXRyaXgsIGFyZ3MsIHBvcykge1xuICAgICAgbWF0cml4W3Bvc10gPSBNYXRoLnRhbihmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKGFyZ3NbMF0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGVNYXRyaXgobWF0cml4LCBhcmdzKSB7XG4gICAgICBtYXRyaXhbNF0gPSBhcmdzWzBdO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIG1hdHJpeFs1XSA9IGFyZ3NbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWRlbnRpdHkgbWF0cml4XG4gICAgdmFyIGlNYXRyaXggPSBbXG4gICAgICAgICAgMSwgLy8gYVxuICAgICAgICAgIDAsIC8vIGJcbiAgICAgICAgICAwLCAvLyBjXG4gICAgICAgICAgMSwgLy8gZFxuICAgICAgICAgIDAsIC8vIGVcbiAgICAgICAgICAwICAvLyBmXG4gICAgICAgIF0sXG5cbiAgICAgICAgLy8gPT0gYmVnaW4gdHJhbnNmb3JtIHJlZ2V4cFxuICAgICAgICBudW1iZXIgPSBmYWJyaWMucmVOdW0sXG5cbiAgICAgICAgY29tbWFXc3AgPSAnKD86XFxcXHMrLD9cXFxccyp8LFxcXFxzKiknLFxuXG4gICAgICAgIHNrZXdYID0gJyg/Oihza2V3WClcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccypcXFxcKSknLFxuXG4gICAgICAgIHNrZXdZID0gJyg/Oihza2V3WSlcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccypcXFxcKSknLFxuXG4gICAgICAgIHJvdGF0ZSA9ICcoPzoocm90YXRlKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKSg/OicgK1xuICAgICAgICAgICAgICAgICAgICBjb21tYVdzcCArICcoJyArIG51bWJlciArICcpJyArXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hV3NwICsgJygnICsgbnVtYmVyICsgJykpP1xcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgc2NhbGUgPSAnKD86KHNjYWxlKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKSg/OicgK1xuICAgICAgICAgICAgICAgICAgICBjb21tYVdzcCArICcoJyArIG51bWJlciArICcpKT9cXFxccypcXFxcKSknLFxuXG4gICAgICAgIHRyYW5zbGF0ZSA9ICcoPzoodHJhbnNsYXRlKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKSg/OicgK1xuICAgICAgICAgICAgICAgICAgICBjb21tYVdzcCArICcoJyArIG51bWJlciArICcpKT9cXFxccypcXFxcKSknLFxuXG4gICAgICAgIG1hdHJpeCA9ICcoPzoobWF0cml4KVxcXFxzKlxcXFwoXFxcXHMqJyArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgK1xuICAgICAgICAgICAgICAgICAgJ1xcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgdHJhbnNmb3JtID0gJyg/OicgK1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXggKyAnfCcgK1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGUgKyAnfCcgK1xuICAgICAgICAgICAgICAgICAgICBzY2FsZSArICd8JyArXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZSArICd8JyArXG4gICAgICAgICAgICAgICAgICAgIHNrZXdYICsgJ3wnICtcbiAgICAgICAgICAgICAgICAgICAgc2tld1kgK1xuICAgICAgICAgICAgICAgICAgICAnKScsXG5cbiAgICAgICAgdHJhbnNmb3JtcyA9ICcoPzonICsgdHJhbnNmb3JtICsgJyg/OicgKyBjb21tYVdzcCArICcqJyArIHRyYW5zZm9ybSArICcpKicgKyAnKScsXG5cbiAgICAgICAgdHJhbnNmb3JtTGlzdCA9ICdeXFxcXHMqKD86JyArIHRyYW5zZm9ybXMgKyAnPylcXFxccyokJyxcblxuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvY29vcmRzLmh0bWwjVHJhbnNmb3JtQXR0cmlidXRlXG4gICAgICAgIHJlVHJhbnNmb3JtTGlzdCA9IG5ldyBSZWdFeHAodHJhbnNmb3JtTGlzdCksXG4gICAgICAgIC8vID09IGVuZCB0cmFuc2Zvcm0gcmVnZXhwXG5cbiAgICAgICAgcmVUcmFuc2Zvcm0gPSBuZXcgUmVnRXhwKHRyYW5zZm9ybSwgJ2cnKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhdHRyaWJ1dGVWYWx1ZSkge1xuXG4gICAgICAvLyBzdGFydCB3aXRoIGlkZW50aXR5IG1hdHJpeFxuICAgICAgdmFyIG1hdHJpeCA9IGlNYXRyaXguY29uY2F0KCksXG4gICAgICAgICAgbWF0cmljZXMgPSBbXTtcblxuICAgICAgLy8gcmV0dXJuIGlmIG5vIGFyZ3VtZW50IHdhcyBnaXZlbiBvclxuICAgICAgLy8gYW4gYXJndW1lbnQgZG9lcyBub3QgbWF0Y2ggdHJhbnNmb3JtIGF0dHJpYnV0ZSByZWdleHBcbiAgICAgIGlmICghYXR0cmlidXRlVmFsdWUgfHwgKGF0dHJpYnV0ZVZhbHVlICYmICFyZVRyYW5zZm9ybUxpc3QudGVzdChhdHRyaWJ1dGVWYWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICB9XG5cbiAgICAgIGF0dHJpYnV0ZVZhbHVlLnJlcGxhY2UocmVUcmFuc2Zvcm0sIGZ1bmN0aW9uKG1hdGNoKSB7XG5cbiAgICAgICAgdmFyIG0gPSBuZXcgUmVnRXhwKHRyYW5zZm9ybSkuZXhlYyhtYXRjaCkuZmlsdGVyKGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAvLyBtYXRjaCAhPT0gJycgJiYgbWF0Y2ggIT0gbnVsbFxuICAgICAgICAgICAgICByZXR1cm4gKCEhbWF0Y2gpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvcGVyYXRpb24gPSBtWzFdLFxuICAgICAgICAgICAgYXJncyA9IG0uc2xpY2UoMikubWFwKHBhcnNlRmxvYXQpO1xuXG4gICAgICAgIHN3aXRjaCAob3BlcmF0aW9uKSB7XG4gICAgICAgICAgY2FzZSAndHJhbnNsYXRlJzpcbiAgICAgICAgICAgIHRyYW5zbGF0ZU1hdHJpeChtYXRyaXgsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncm90YXRlJzpcbiAgICAgICAgICAgIGFyZ3NbMF0gPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKGFyZ3NbMF0pO1xuICAgICAgICAgICAgcm90YXRlTWF0cml4KG1hdHJpeCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzY2FsZSc6XG4gICAgICAgICAgICBzY2FsZU1hdHJpeChtYXRyaXgsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2tld1gnOlxuICAgICAgICAgICAgc2tld01hdHJpeChtYXRyaXgsIGFyZ3MsIDIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2tld1knOlxuICAgICAgICAgICAgc2tld01hdHJpeChtYXRyaXgsIGFyZ3MsIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWF0cml4JzpcbiAgICAgICAgICAgIG1hdHJpeCA9IGFyZ3M7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNuYXBzaG90IGN1cnJlbnQgbWF0cml4IGludG8gbWF0cmljZXMgYXJyYXlcbiAgICAgICAgbWF0cmljZXMucHVzaChtYXRyaXguY29uY2F0KCkpO1xuICAgICAgICAvLyByZXNldFxuICAgICAgICBtYXRyaXggPSBpTWF0cml4LmNvbmNhdCgpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjb21iaW5lZE1hdHJpeCA9IG1hdHJpY2VzWzBdO1xuICAgICAgd2hpbGUgKG1hdHJpY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbWF0cmljZXMuc2hpZnQoKTtcbiAgICAgICAgY29tYmluZWRNYXRyaXggPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKGNvbWJpbmVkTWF0cml4LCBtYXRyaWNlc1swXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tYmluZWRNYXRyaXg7XG4gICAgfTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlU3R5bGVTdHJpbmcoc3R5bGUsIG9TdHlsZSkge1xuICAgIHZhciBhdHRyLCB2YWx1ZTtcbiAgICBzdHlsZS5yZXBsYWNlKC87XFxzKiQvLCAnJykuc3BsaXQoJzsnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgdmFyIHBhaXIgPSBjaHVuay5zcGxpdCgnOicpO1xuXG4gICAgICBhdHRyID0gcGFpclswXS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhbHVlID0gIHBhaXJbMV0udHJpbSgpO1xuXG4gICAgICBvU3R5bGVbYXR0cl0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VTdHlsZU9iamVjdChzdHlsZSwgb1N0eWxlKSB7XG4gICAgdmFyIGF0dHIsIHZhbHVlO1xuICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3R5bGVbcHJvcF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBhdHRyID0gcHJvcC50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFsdWUgPSBzdHlsZVtwcm9wXTtcblxuICAgICAgb1N0eWxlW2F0dHJdID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBnZXRHbG9iYWxTdHlsZXNGb3JFbGVtZW50KGVsZW1lbnQsIHN2Z1VpZCkge1xuICAgIHZhciBzdHlsZXMgPSB7IH07XG4gICAgZm9yICh2YXIgcnVsZSBpbiBmYWJyaWMuY3NzUnVsZXNbc3ZnVWlkXSkge1xuICAgICAgaWYgKGVsZW1lbnRNYXRjaGVzUnVsZShlbGVtZW50LCBydWxlLnNwbGl0KCcgJykpKSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIGZhYnJpYy5jc3NSdWxlc1tzdmdVaWRdW3J1bGVdKSB7XG4gICAgICAgICAgc3R5bGVzW3Byb3BlcnR5XSA9IGZhYnJpYy5jc3NSdWxlc1tzdmdVaWRdW3J1bGVdW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBlbGVtZW50TWF0Y2hlc1J1bGUoZWxlbWVudCwgc2VsZWN0b3JzKSB7XG4gICAgdmFyIGZpcnN0TWF0Y2hpbmcsIHBhcmVudE1hdGNoaW5nID0gdHJ1ZTtcbiAgICAvL3N0YXJ0IGZyb20gcmlnaHRtb3N0IHNlbGVjdG9yLlxuICAgIGZpcnN0TWF0Y2hpbmcgPSBzZWxlY3Rvck1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3JzLnBvcCgpKTtcbiAgICBpZiAoZmlyc3RNYXRjaGluZyAmJiBzZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICBwYXJlbnRNYXRjaGluZyA9IGRvZXNTb21lUGFyZW50TWF0Y2goZWxlbWVudCwgc2VsZWN0b3JzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0TWF0Y2hpbmcgJiYgcGFyZW50TWF0Y2hpbmcgJiYgKHNlbGVjdG9ycy5sZW5ndGggPT09IDApO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9lc1NvbWVQYXJlbnRNYXRjaChlbGVtZW50LCBzZWxlY3RvcnMpIHtcbiAgICB2YXIgc2VsZWN0b3IsIHBhcmVudE1hdGNoaW5nID0gdHJ1ZTtcbiAgICB3aGlsZSAoZWxlbWVudC5wYXJlbnROb2RlICYmIGVsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBzZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICBpZiAocGFyZW50TWF0Y2hpbmcpIHtcbiAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvcnMucG9wKCk7XG4gICAgICB9XG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgcGFyZW50TWF0Y2hpbmcgPSBzZWxlY3Rvck1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0b3JzLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gc2VsZWN0b3JNYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZSxcbiAgICAgICAgY2xhc3NOYW1lcyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpLFxuICAgICAgICBpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpLCBtYXRjaGVyLCBpO1xuICAgIC8vIGkgY2hlY2sgaWYgYSBzZWxlY3RvciBtYXRjaGVzIHNsaWNpbmcgYXdheSBwYXJ0IGZyb20gaXQuXG4gICAgLy8gaWYgaSBnZXQgZW1wdHkgc3RyaW5nIGkgc2hvdWxkIG1hdGNoXG4gICAgbWF0Y2hlciA9IG5ldyBSZWdFeHAoJ14nICsgbm9kZU5hbWUsICdpJyk7XG4gICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKG1hdGNoZXIsICcnKTtcbiAgICBpZiAoaWQgJiYgc2VsZWN0b3IubGVuZ3RoKSB7XG4gICAgICBtYXRjaGVyID0gbmV3IFJlZ0V4cCgnIycgKyBpZCArICcoPyFbYS16QS1aXFxcXC1dKyknLCAnaScpO1xuICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKG1hdGNoZXIsICcnKTtcbiAgICB9XG4gICAgaWYgKGNsYXNzTmFtZXMgJiYgc2VsZWN0b3IubGVuZ3RoKSB7XG4gICAgICBjbGFzc05hbWVzID0gY2xhc3NOYW1lcy5zcGxpdCgnICcpO1xuICAgICAgZm9yIChpID0gY2xhc3NOYW1lcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgbWF0Y2hlciA9IG5ldyBSZWdFeHAoJ1xcXFwuJyArIGNsYXNzTmFtZXNbaV0gKyAnKD8hW2EtekEtWlxcXFwtXSspJywgJ2knKTtcbiAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKG1hdGNoZXIsICcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdG9yLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiB0byBzdXBwb3J0IElFOCBtaXNzaW5nIGdldEVsZW1lbnRCeUlkIG9uIFNWR2RvY3VtZW50XG4gICAqL1xuICBmdW5jdGlvbiBlbGVtZW50QnlJZChkb2MsIGlkKSB7XG4gICAgdmFyIGVsO1xuICAgIGRvYy5nZXRFbGVtZW50QnlJZCAmJiAoZWwgPSBkb2MuZ2V0RWxlbWVudEJ5SWQoaWQpKTtcbiAgICBpZiAoZWwpIHtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gICAgdmFyIG5vZGUsIGksIGxlbiwgbm9kZWxpc3QgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlbGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbm9kZSA9IG5vZGVsaXN0W2ldO1xuICAgICAgaWYgKGlkID09PSBub2RlLmdldEF0dHJpYnV0ZSgnaWQnKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlVXNlRGlyZWN0aXZlcyhkb2MpIHtcbiAgICB2YXIgbm9kZWxpc3QgPSBfZ2V0TXVsdGlwbGVOb2Rlcyhkb2MsIFsndXNlJywgJ3N2Zzp1c2UnXSksIGkgPSAwO1xuXG4gICAgd2hpbGUgKG5vZGVsaXN0Lmxlbmd0aCAmJiBpIDwgbm9kZWxpc3QubGVuZ3RoKSB7XG4gICAgICB2YXIgZWwgPSBub2RlbGlzdFtpXSxcbiAgICAgICAgICB4bGluayA9IGVsLmdldEF0dHJpYnV0ZSgneGxpbms6aHJlZicpLnN1YnN0cigxKSxcbiAgICAgICAgICB4ID0gZWwuZ2V0QXR0cmlidXRlKCd4JykgfHwgMCxcbiAgICAgICAgICB5ID0gZWwuZ2V0QXR0cmlidXRlKCd5JykgfHwgMCxcbiAgICAgICAgICBlbDIgPSBlbGVtZW50QnlJZChkb2MsIHhsaW5rKS5jbG9uZU5vZGUodHJ1ZSksXG4gICAgICAgICAgY3VycmVudFRyYW5zID0gKGVsMi5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpIHx8ICcnKSArICcgdHJhbnNsYXRlKCcgKyB4ICsgJywgJyArIHkgKyAnKScsXG4gICAgICAgICAgcGFyZW50Tm9kZSwgb2xkTGVuZ3RoID0gbm9kZWxpc3QubGVuZ3RoLCBhdHRyLCBqLCBhdHRycywgbGVuO1xuXG4gICAgICBhcHBseVZpZXdib3hUcmFuc2Zvcm0oZWwyKTtcbiAgICAgIGlmICgvXnN2ZyQvaS50ZXN0KGVsMi5ub2RlTmFtZSkpIHtcbiAgICAgICAgdmFyIGVsMyA9IGVsMi5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2cnKTtcbiAgICAgICAgZm9yIChqID0gMCwgYXR0cnMgPSBlbDIuYXR0cmlidXRlcywgbGVuID0gYXR0cnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICBhdHRyID0gYXR0cnMuaXRlbShqKTtcbiAgICAgICAgICBlbDMuc2V0QXR0cmlidXRlKGF0dHIubm9kZU5hbWUsIGF0dHIubm9kZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbDIuZmlyc3RDaGlsZCAhPSBudWxsXG4gICAgICAgIHdoaWxlIChlbDIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGVsMy5hcHBlbmRDaGlsZChlbDIuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWwyID0gZWwzO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGogPSAwLCBhdHRycyA9IGVsLmF0dHJpYnV0ZXMsIGxlbiA9IGF0dHJzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIGF0dHIgPSBhdHRycy5pdGVtKGopO1xuICAgICAgICBpZiAoYXR0ci5ub2RlTmFtZSA9PT0gJ3gnIHx8IGF0dHIubm9kZU5hbWUgPT09ICd5JyB8fCBhdHRyLm5vZGVOYW1lID09PSAneGxpbms6aHJlZicpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdHRyLm5vZGVOYW1lID09PSAndHJhbnNmb3JtJykge1xuICAgICAgICAgIGN1cnJlbnRUcmFucyA9IGF0dHIubm9kZVZhbHVlICsgJyAnICsgY3VycmVudFRyYW5zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGVsMi5zZXRBdHRyaWJ1dGUoYXR0ci5ub2RlTmFtZSwgYXR0ci5ub2RlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsMi5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIGN1cnJlbnRUcmFucyk7XG4gICAgICBlbDIuc2V0QXR0cmlidXRlKCdpbnN0YW50aWF0ZWRfYnlfdXNlJywgJzEnKTtcbiAgICAgIGVsMi5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICBwYXJlbnROb2RlID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGVsMiwgZWwpO1xuICAgICAgLy8gc29tZSBicm93c2VycyBkbyBub3Qgc2hvcnRlbiBub2RlbGlzdCBhZnRlciByZXBsYWNlQ2hpbGQgKElFOClcbiAgICAgIGlmIChub2RlbGlzdC5sZW5ndGggPT09IG9sZExlbmd0aCkge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2Nvb3Jkcy5odG1sI1ZpZXdCb3hBdHRyaWJ1dGVcbiAgLy8gbWF0Y2hlcywgZS5nLjogKzE0LjU2ZS0xMiwgZXRjLlxuICB2YXIgcmVWaWV3Qm94QXR0clZhbHVlID0gbmV3IFJlZ0V4cChcbiAgICAnXicgK1xuICAgICdcXFxccyooJyArIGZhYnJpYy5yZU51bSArICcrKVxcXFxzKiw/JyArXG4gICAgJ1xcXFxzKignICsgZmFicmljLnJlTnVtICsgJyspXFxcXHMqLD8nICtcbiAgICAnXFxcXHMqKCcgKyBmYWJyaWMucmVOdW0gKyAnKylcXFxccyosPycgK1xuICAgICdcXFxccyooJyArIGZhYnJpYy5yZU51bSArICcrKVxcXFxzKicgK1xuICAgICckJ1xuICApO1xuXG4gIC8qKlxuICAgKiBBZGQgYSA8Zz4gZWxlbWVudCB0aGF0IGVudmVsb3AgYWxsIGNoaWxkIGVsZW1lbnRzIGFuZCBtYWtlcyB0aGUgdmlld2JveCB0cmFuc2Zvcm1NYXRyaXggZGVzY2VuZCBvbiBhbGwgZWxlbWVudHNcbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5Vmlld2JveFRyYW5zZm9ybShlbGVtZW50KSB7XG5cbiAgICB2YXIgdmlld0JveEF0dHIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndmlld0JveCcpLFxuICAgICAgICBzY2FsZVggPSAxLFxuICAgICAgICBzY2FsZVkgPSAxLFxuICAgICAgICBtaW5YID0gMCxcbiAgICAgICAgbWluWSA9IDAsXG4gICAgICAgIHZpZXdCb3hXaWR0aCwgdmlld0JveEhlaWdodCwgbWF0cml4LCBlbCxcbiAgICAgICAgd2lkdGhBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksXG4gICAgICAgIGhlaWdodEF0dHIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaGVpZ2h0JyksXG4gICAgICAgIHggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgneCcpIHx8IDAsXG4gICAgICAgIHkgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgneScpIHx8IDAsXG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpIHx8ICcnLFxuICAgICAgICBtaXNzaW5nVmlld0JveCA9ICghdmlld0JveEF0dHIgfHwgIWZhYnJpYy5zdmdWaWV3Qm94RWxlbWVudHNSZWdFeC50ZXN0KGVsZW1lbnQubm9kZU5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAhKHZpZXdCb3hBdHRyID0gdmlld0JveEF0dHIubWF0Y2gocmVWaWV3Qm94QXR0clZhbHVlKSkpLFxuICAgICAgICBtaXNzaW5nRGltQXR0ciA9ICghd2lkdGhBdHRyIHx8ICFoZWlnaHRBdHRyIHx8IHdpZHRoQXR0ciA9PT0gJzEwMCUnIHx8IGhlaWdodEF0dHIgPT09ICcxMDAlJyksXG4gICAgICAgIHRvQmVQYXJzZWQgPSBtaXNzaW5nVmlld0JveCAmJiBtaXNzaW5nRGltQXR0cixcbiAgICAgICAgcGFyc2VkRGltID0geyB9LCB0cmFuc2xhdGVNYXRyaXggPSAnJywgd2lkdGhEaWZmID0gMCwgaGVpZ2h0RGlmZiA9IDA7XG5cbiAgICBwYXJzZWREaW0ud2lkdGggPSAwO1xuICAgIHBhcnNlZERpbS5oZWlnaHQgPSAwO1xuICAgIHBhcnNlZERpbS50b0JlUGFyc2VkID0gdG9CZVBhcnNlZDtcblxuICAgIGlmICh0b0JlUGFyc2VkKSB7XG4gICAgICByZXR1cm4gcGFyc2VkRGltO1xuICAgIH1cblxuICAgIGlmIChtaXNzaW5nVmlld0JveCkge1xuICAgICAgcGFyc2VkRGltLndpZHRoID0gcGFyc2VVbml0KHdpZHRoQXR0cik7XG4gICAgICBwYXJzZWREaW0uaGVpZ2h0ID0gcGFyc2VVbml0KGhlaWdodEF0dHIpO1xuICAgICAgcmV0dXJuIHBhcnNlZERpbTtcbiAgICB9XG5cbiAgICBtaW5YID0gLXBhcnNlRmxvYXQodmlld0JveEF0dHJbMV0pO1xuICAgIG1pblkgPSAtcGFyc2VGbG9hdCh2aWV3Qm94QXR0clsyXSk7XG4gICAgdmlld0JveFdpZHRoID0gcGFyc2VGbG9hdCh2aWV3Qm94QXR0clszXSk7XG4gICAgdmlld0JveEhlaWdodCA9IHBhcnNlRmxvYXQodmlld0JveEF0dHJbNF0pO1xuXG4gICAgaWYgKCFtaXNzaW5nRGltQXR0cikge1xuICAgICAgcGFyc2VkRGltLndpZHRoID0gcGFyc2VVbml0KHdpZHRoQXR0cik7XG4gICAgICBwYXJzZWREaW0uaGVpZ2h0ID0gcGFyc2VVbml0KGhlaWdodEF0dHIpO1xuICAgICAgc2NhbGVYID0gcGFyc2VkRGltLndpZHRoIC8gdmlld0JveFdpZHRoO1xuICAgICAgc2NhbGVZID0gcGFyc2VkRGltLmhlaWdodCAvIHZpZXdCb3hIZWlnaHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcGFyc2VkRGltLndpZHRoID0gdmlld0JveFdpZHRoO1xuICAgICAgcGFyc2VkRGltLmhlaWdodCA9IHZpZXdCb3hIZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gZGVmYXVsdCBpcyB0byBwcmVzZXJ2ZSBhc3BlY3QgcmF0aW9cbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gZmFicmljLnV0aWwucGFyc2VQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlKHByZXNlcnZlQXNwZWN0UmF0aW8pO1xuICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLmFsaWduWCAhPT0gJ25vbmUnKSB7XG4gICAgICAvL3RyYW5zbGF0ZSBhbGwgY29udGFpbmVyIGZvciB0aGUgZWZmZWN0IG9mIE1pZCwgTWluLCBNYXhcbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLm1lZXRPclNsaWNlID09PSAnbWVldCcpIHtcbiAgICAgICAgc2NhbGVZID0gc2NhbGVYID0gKHNjYWxlWCA+IHNjYWxlWSA/IHNjYWxlWSA6IHNjYWxlWCk7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBhZGRpdGlvbmFsIHRyYW5zbGF0aW9uIHRvIG1vdmUgdGhlIHZpZXdib3hcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLm1lZXRPclNsaWNlID09PSAnc2xpY2UnKSB7XG4gICAgICAgIHNjYWxlWSA9IHNjYWxlWCA9IChzY2FsZVggPiBzY2FsZVkgPyBzY2FsZVggOiBzY2FsZVkpO1xuICAgICAgICAvLyBjYWxjdWxhdGUgYWRkaXRpb25hbCB0cmFuc2xhdGlvbiB0byBtb3ZlIHRoZSB2aWV3Ym94XG4gICAgICB9XG4gICAgICB3aWR0aERpZmYgPSBwYXJzZWREaW0ud2lkdGggLSB2aWV3Qm94V2lkdGggKiBzY2FsZVg7XG4gICAgICBoZWlnaHREaWZmID0gcGFyc2VkRGltLmhlaWdodCAtIHZpZXdCb3hIZWlnaHQgKiBzY2FsZVg7XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblggPT09ICdNaWQnKSB7XG4gICAgICAgIHdpZHRoRGlmZiAvPSAyO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8uYWxpZ25ZID09PSAnTWlkJykge1xuICAgICAgICBoZWlnaHREaWZmIC89IDI7XG4gICAgICB9XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblggPT09ICdNaW4nKSB7XG4gICAgICAgIHdpZHRoRGlmZiA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblkgPT09ICdNaW4nKSB7XG4gICAgICAgIGhlaWdodERpZmYgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzY2FsZVggPT09IDEgJiYgc2NhbGVZID09PSAxICYmIG1pblggPT09IDAgJiYgbWluWSA9PT0gMCAmJiB4ID09PSAwICYmIHkgPT09IDApIHtcbiAgICAgIHJldHVybiBwYXJzZWREaW07XG4gICAgfVxuXG4gICAgaWYgKHggfHwgeSkge1xuICAgICAgdHJhbnNsYXRlTWF0cml4ID0gJyB0cmFuc2xhdGUoJyArIHBhcnNlVW5pdCh4KSArICcgJyArIHBhcnNlVW5pdCh5KSArICcpICc7XG4gICAgfVxuXG4gICAgbWF0cml4ID0gdHJhbnNsYXRlTWF0cml4ICsgJyBtYXRyaXgoJyArIHNjYWxlWCArXG4gICAgICAgICAgICAgICAgICAnIDAnICtcbiAgICAgICAgICAgICAgICAgICcgMCAnICtcbiAgICAgICAgICAgICAgICAgIHNjYWxlWSArICcgJyArXG4gICAgICAgICAgICAgICAgICAobWluWCAqIHNjYWxlWCArIHdpZHRoRGlmZikgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgKG1pblkgKiBzY2FsZVkgKyBoZWlnaHREaWZmKSArICcpICc7XG5cbiAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ3N2ZycpIHtcbiAgICAgIGVsID0gZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2cnKTtcbiAgICAgIC8vIGVsZW1lbnQuZmlyc3RDaGlsZCAhPSBudWxsXG4gICAgICB3aGlsZSAoZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKGVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBlbCA9IGVsZW1lbnQ7XG4gICAgICBtYXRyaXggPSBlbC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpICsgbWF0cml4O1xuICAgIH1cblxuICAgIGVsLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgbWF0cml4KTtcbiAgICByZXR1cm4gcGFyc2VkRGltO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQW5jZXN0b3JXaXRoTm9kZU5hbWUoZWxlbWVudCwgbm9kZU5hbWUpIHtcbiAgICB3aGlsZSAoZWxlbWVudCAmJiAoZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSkpIHtcbiAgICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lICYmIG5vZGVOYW1lLnRlc3QoZWxlbWVudC5ub2RlTmFtZS5yZXBsYWNlKCdzdmc6JywgJycpKVxuICAgICAgICAmJiAhZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2luc3RhbnRpYXRlZF9ieV91c2UnKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBTVkcgZG9jdW1lbnQsIGNvbnZlcnRzIGl0IHRvIGFuIGFycmF5IG9mIGNvcnJlc3BvbmRpbmcgZmFicmljLiogaW5zdGFuY2VzIGFuZCBwYXNzZXMgdGhlbSB0byBhIGNhbGxiYWNrXG4gICAqIEBzdGF0aWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICogQHBhcmFtIHtTVkdEb2N1bWVudH0gZG9jIFNWRyBkb2N1bWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBjYWxsIHdoZW4gcGFyc2luZyBpcyBmaW5pc2hlZDtcbiAgICogSXQncyBiZWluZyBwYXNzZWQgYW4gYXJyYXkgb2YgZWxlbWVudHMgKHBhcnNlZCBmcm9tIGEgZG9jdW1lbnQpLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgU1ZHIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyc2luZ09wdGlvbnNdIG9wdGlvbnMgZm9yIHBhcnNpbmcgZG9jdW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJzaW5nT3B0aW9ucy5jcm9zc09yaWdpbl0gY3Jvc3NPcmlnaW4gc2V0dGluZ3NcbiAgICovXG4gIGZhYnJpYy5wYXJzZVNWR0RvY3VtZW50ID0gZnVuY3Rpb24oZG9jLCBjYWxsYmFjaywgcmV2aXZlciwgcGFyc2luZ09wdGlvbnMpIHtcbiAgICBpZiAoIWRvYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBhcnNlVXNlRGlyZWN0aXZlcyhkb2MpO1xuXG4gICAgdmFyIHN2Z1VpZCA9ICBmYWJyaWMuT2JqZWN0Ll9fdWlkKyssIGksIGxlbixcbiAgICAgICAgb3B0aW9ucyA9IGFwcGx5Vmlld2JveFRyYW5zZm9ybShkb2MpLFxuICAgICAgICBkZXNjZW5kYW50cyA9IGZhYnJpYy51dGlsLnRvQXJyYXkoZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykpO1xuICAgIG9wdGlvbnMuY3Jvc3NPcmlnaW4gPSBwYXJzaW5nT3B0aW9ucyAmJiBwYXJzaW5nT3B0aW9ucy5jcm9zc09yaWdpbjtcbiAgICBvcHRpb25zLnN2Z1VpZCA9IHN2Z1VpZDtcblxuICAgIGlmIChkZXNjZW5kYW50cy5sZW5ndGggPT09IDAgJiYgZmFicmljLmlzTGlrZWx5Tm9kZSkge1xuICAgICAgLy8gd2UncmUgbGlrZWx5IGluIG5vZGUsIHdoZXJlIFwibzMteG1sXCIgbGlicmFyeSBmYWlscyB0byBnRUJUTihcIipcIilcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hamF4b3JnL25vZGUtbzMteG1sL2lzc3Vlcy8yMVxuICAgICAgZGVzY2VuZGFudHMgPSBkb2Muc2VsZWN0Tm9kZXMoJy8vKltuYW1lKC4pIT1cInN2Z1wiXScpO1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gZGVzY2VuZGFudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gZGVzY2VuZGFudHNbaV07XG4gICAgICB9XG4gICAgICBkZXNjZW5kYW50cyA9IGFycjtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHMgPSBkZXNjZW5kYW50cy5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcbiAgICAgIGFwcGx5Vmlld2JveFRyYW5zZm9ybShlbCk7XG4gICAgICByZXR1cm4gZmFicmljLnN2Z1ZhbGlkVGFnTmFtZXNSZWdFeC50ZXN0KGVsLm5vZGVOYW1lLnJlcGxhY2UoJ3N2ZzonLCAnJykpICYmXG4gICAgICAgICAgICAhaGFzQW5jZXN0b3JXaXRoTm9kZU5hbWUoZWwsIGZhYnJpYy5zdmdJbnZhbGlkQW5jZXN0b3JzUmVnRXgpOyAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3RydWN0Lmh0bWwjRGVmc0VsZW1lbnRcbiAgICB9KTtcblxuICAgIGlmICghZWxlbWVudHMgfHwgKGVsZW1lbnRzICYmICFlbGVtZW50cy5sZW5ndGgpKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhbXSwge30pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZhYnJpYy5ncmFkaWVudERlZnNbc3ZnVWlkXSA9IGZhYnJpYy5nZXRHcmFkaWVudERlZnMoZG9jKTtcbiAgICBmYWJyaWMuY3NzUnVsZXNbc3ZnVWlkXSA9IGZhYnJpYy5nZXRDU1NSdWxlcyhkb2MpO1xuICAgIC8vIFByZWNlZGVuY2Ugb2YgcnVsZXM6ICAgc3R5bGUgPiBjbGFzcyA+IGF0dHJpYnV0ZVxuICAgIGZhYnJpYy5wYXJzZUVsZW1lbnRzKGVsZW1lbnRzLCBmdW5jdGlvbihpbnN0YW5jZXMsIGVsZW1lbnRzKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soaW5zdGFuY2VzLCBvcHRpb25zLCBlbGVtZW50cywgZGVzY2VuZGFudHMpO1xuICAgICAgfVxuICAgIH0sIGNsb25lKG9wdGlvbnMpLCByZXZpdmVyLCBwYXJzaW5nT3B0aW9ucyk7XG4gIH07XG5cbiAgdmFyIHJlRm9udERlY2xhcmF0aW9uID0gbmV3IFJlZ0V4cChcbiAgICAnKG5vcm1hbHxpdGFsaWMpP1xcXFxzKihub3JtYWx8c21hbGwtY2Fwcyk/XFxcXHMqJyArXG4gICAgJyhub3JtYWx8Ym9sZHxib2xkZXJ8bGlnaHRlcnwxMDB8MjAwfDMwMHw0MDB8NTAwfDYwMHw3MDB8ODAwfDkwMCk/XFxcXHMqKCcgK1xuICAgICAgZmFicmljLnJlTnVtICtcbiAgICAnKD86cHh8Y218bW18ZW18cHR8cGN8aW4pKikoPzpcXFxcLyhub3JtYWx8JyArIGZhYnJpYy5yZU51bSArICcpKT9cXFxccysoLiopJyk7XG5cbiAgZXh0ZW5kKGZhYnJpYywge1xuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHNob3J0IGZvbnQgZGVjbGFyYXRpb24sIGJ1aWxkaW5nIGFkZGluZyBpdHMgcHJvcGVydGllcyB0byBhIHN0eWxlIG9iamVjdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIGZvbnQgZGVjbGFyYXRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb1N0eWxlIGRlZmluaXRpb25cbiAgICAgKi9cbiAgICBwYXJzZUZvbnREZWNsYXJhdGlvbjogZnVuY3Rpb24odmFsdWUsIG9TdHlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2gocmVGb250RGVjbGFyYXRpb24pO1xuXG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBmb250U3R5bGUgPSBtYXRjaFsxXSxcbiAgICAgICAgICAvLyBmb250IHZhcmlhbnQgaXMgbm90IHVzZWRcbiAgICAgICAgICAvLyBmb250VmFyaWFudCA9IG1hdGNoWzJdLFxuICAgICAgICAgIGZvbnRXZWlnaHQgPSBtYXRjaFszXSxcbiAgICAgICAgICBmb250U2l6ZSA9IG1hdGNoWzRdLFxuICAgICAgICAgIGxpbmVIZWlnaHQgPSBtYXRjaFs1XSxcbiAgICAgICAgICBmb250RmFtaWx5ID0gbWF0Y2hbNl07XG5cbiAgICAgIGlmIChmb250U3R5bGUpIHtcbiAgICAgICAgb1N0eWxlLmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICAgIH1cbiAgICAgIGlmIChmb250V2VpZ2h0KSB7XG4gICAgICAgIG9TdHlsZS5mb250V2VpZ2h0ID0gaXNOYU4ocGFyc2VGbG9hdChmb250V2VpZ2h0KSkgPyBmb250V2VpZ2h0IDogcGFyc2VGbG9hdChmb250V2VpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGlmIChmb250U2l6ZSkge1xuICAgICAgICBvU3R5bGUuZm9udFNpemUgPSBwYXJzZVVuaXQoZm9udFNpemUpO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnRGYW1pbHkpIHtcbiAgICAgICAgb1N0eWxlLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVIZWlnaHQpIHtcbiAgICAgICAgb1N0eWxlLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0ID09PSAnbm9ybWFsJyA/IDEgOiBsaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYW4gU1ZHIGRvY3VtZW50LCByZXR1cm5pbmcgYWxsIG9mIHRoZSBncmFkaWVudCBkZWNsYXJhdGlvbnMgZm91bmQgaW4gaXRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U1ZHRG9jdW1lbnR9IGRvYyBTVkcgZG9jdW1lbnQgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEdyYWRpZW50IGRlZmluaXRpb25zOyBrZXkgY29ycmVzcG9uZHMgdG8gZWxlbWVudCBpZCwgdmFsdWUgLS0gdG8gZ3JhZGllbnQgZGVmaW5pdGlvbiBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0R3JhZGllbnREZWZzOiBmdW5jdGlvbihkb2MpIHtcbiAgICAgIHZhciB0YWdBcnJheSA9IFtcbiAgICAgICAgICAgICdsaW5lYXJHcmFkaWVudCcsXG4gICAgICAgICAgICAncmFkaWFsR3JhZGllbnQnLFxuICAgICAgICAgICAgJ3N2ZzpsaW5lYXJHcmFkaWVudCcsXG4gICAgICAgICAgICAnc3ZnOnJhZGlhbEdyYWRpZW50J10sXG4gICAgICAgICAgZWxMaXN0ID0gX2dldE11bHRpcGxlTm9kZXMoZG9jLCB0YWdBcnJheSksXG4gICAgICAgICAgZWwsIGogPSAwLCBpZCwgeGxpbmssXG4gICAgICAgICAgZ3JhZGllbnREZWZzID0geyB9LCBpZHNUb1hsaW5rTWFwID0geyB9O1xuICAgICAgaiA9IGVsTGlzdC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgZWwgPSBlbExpc3Rbal07XG4gICAgICAgIHhsaW5rID0gZWwuZ2V0QXR0cmlidXRlKCd4bGluazpocmVmJyk7XG4gICAgICAgIGlkID0gZWwuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICBpZiAoeGxpbmspIHtcbiAgICAgICAgICBpZHNUb1hsaW5rTWFwW2lkXSA9IHhsaW5rLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgICBncmFkaWVudERlZnNbaWRdID0gZWw7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaWQgaW4gaWRzVG9YbGlua01hcCkge1xuICAgICAgICB2YXIgZWwyID0gZ3JhZGllbnREZWZzW2lkc1RvWGxpbmtNYXBbaWRdXS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIGVsID0gZ3JhZGllbnREZWZzW2lkXTtcbiAgICAgICAgd2hpbGUgKGVsMi5maXJzdENoaWxkKSB7XG4gICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZWwyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JhZGllbnREZWZzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzJyBuYW1lL3ZhbHVlLCBnaXZlbiBlbGVtZW50IGFuZCBhbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXM7XG4gICAgICogUGFyc2VzIHBhcmVudCBcImdcIiBub2RlcyByZWN1cnNpdmVseSB1cHdhcmRzLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhdHRyaWJ1dGVzIEFycmF5IG9mIGF0dHJpYnV0ZXMgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCBjb250YWluaW5nIHBhcnNlZCBhdHRyaWJ1dGVzJyBuYW1lcy92YWx1ZXNcbiAgICAgKi9cbiAgICBwYXJzZUF0dHJpYnV0ZXM6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJpYnV0ZXMsIHN2Z1VpZCkge1xuXG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUsXG4gICAgICAgICAgcGFyZW50QXR0cmlidXRlcyA9IHsgfSxcbiAgICAgICAgICBmb250U2l6ZTtcblxuICAgICAgaWYgKHR5cGVvZiBzdmdVaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHN2Z1VpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdmdVaWQnKTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHRoZXJlJ3MgYSBwYXJlbnQgY29udGFpbmVyIChgZ2Agb3IgYGFgIG9yIGBzeW1ib2xgIG5vZGUpLCBwYXJzZSBpdHMgYXR0cmlidXRlcyByZWN1cnNpdmVseSB1cHdhcmRzXG4gICAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlICYmIGZhYnJpYy5zdmdWYWxpZFBhcmVudHNSZWdFeC50ZXN0KGVsZW1lbnQucGFyZW50Tm9kZS5ub2RlTmFtZSkpIHtcbiAgICAgICAgcGFyZW50QXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudC5wYXJlbnROb2RlLCBhdHRyaWJ1dGVzLCBzdmdVaWQpO1xuICAgICAgfVxuICAgICAgZm9udFNpemUgPSAocGFyZW50QXR0cmlidXRlcyAmJiBwYXJlbnRBdHRyaWJ1dGVzLmZvbnRTaXplICkgfHxcbiAgICAgICAgICAgICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2ZvbnQtc2l6ZScpIHx8IGZhYnJpYy5UZXh0LkRFRkFVTFRfU1ZHX0ZPTlRfU0laRTtcblxuICAgICAgdmFyIG93bkF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLnJlZHVjZShmdW5jdGlvbihtZW1vLCBhdHRyKSB7XG4gICAgICAgIHZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIGlmICh2YWx1ZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgbWVtb1thdHRyXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgfSwgeyB9KTtcbiAgICAgIC8vIGFkZCB2YWx1ZXMgcGFyc2VkIGZyb20gc3R5bGUsIHdoaWNoIHRha2UgcHJlY2VkZW5jZSBvdmVyIGF0dHJpYnV0ZXNcbiAgICAgIC8vIChzZWU6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zdHlsaW5nLmh0bWwjVXNpbmdQcmVzZW50YXRpb25BdHRyaWJ1dGVzKVxuICAgICAgb3duQXR0cmlidXRlcyA9IGV4dGVuZChvd25BdHRyaWJ1dGVzLFxuICAgICAgICBleHRlbmQoZ2V0R2xvYmFsU3R5bGVzRm9yRWxlbWVudChlbGVtZW50LCBzdmdVaWQpLCBmYWJyaWMucGFyc2VTdHlsZUF0dHJpYnV0ZShlbGVtZW50KSkpO1xuXG4gICAgICB2YXIgbm9ybWFsaXplZEF0dHIsIG5vcm1hbGl6ZWRWYWx1ZSwgbm9ybWFsaXplZFN0eWxlID0ge307XG4gICAgICBmb3IgKHZhciBhdHRyIGluIG93bkF0dHJpYnV0ZXMpIHtcbiAgICAgICAgbm9ybWFsaXplZEF0dHIgPSBub3JtYWxpemVBdHRyKGF0dHIpO1xuICAgICAgICBub3JtYWxpemVkVmFsdWUgPSBub3JtYWxpemVWYWx1ZShub3JtYWxpemVkQXR0ciwgb3duQXR0cmlidXRlc1thdHRyXSwgcGFyZW50QXR0cmlidXRlcywgZm9udFNpemUpO1xuICAgICAgICBub3JtYWxpemVkU3R5bGVbbm9ybWFsaXplZEF0dHJdID0gbm9ybWFsaXplZFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vcm1hbGl6ZWRTdHlsZSAmJiBub3JtYWxpemVkU3R5bGUuZm9udCkge1xuICAgICAgICBmYWJyaWMucGFyc2VGb250RGVjbGFyYXRpb24obm9ybWFsaXplZFN0eWxlLmZvbnQsIG5vcm1hbGl6ZWRTdHlsZSk7XG4gICAgICB9XG4gICAgICB2YXIgbWVyZ2VkQXR0cnMgPSBleHRlbmQocGFyZW50QXR0cmlidXRlcywgbm9ybWFsaXplZFN0eWxlKTtcbiAgICAgIHJldHVybiBmYWJyaWMuc3ZnVmFsaWRQYXJlbnRzUmVnRXgudGVzdChlbGVtZW50Lm5vZGVOYW1lKSA/IG1lcmdlZEF0dHJzIDogX3NldFN0cm9rZUZpbGxPcGFjaXR5KG1lcmdlZEF0dHJzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhbiBhcnJheSBvZiBzdmcgZWxlbWVudHMgdG8gY29ycmVzcG9uZGluZyBmYWJyaWMuKiBpbnN0YW5jZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGVsZW1lbnRzIEFycmF5IG9mIGVsZW1lbnRzIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQmVpbmcgcGFzc2VkIGFuIGFycmF5IG9mIGZhYnJpYyBpbnN0YW5jZXMgKHRyYW5zZm9ybWVkIGZyb20gU1ZHIGVsZW1lbnRzKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgU1ZHIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICovXG4gICAgcGFyc2VFbGVtZW50czogZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrLCBvcHRpb25zLCByZXZpdmVyLCBwYXJzaW5nT3B0aW9ucykge1xuICAgICAgbmV3IGZhYnJpYy5FbGVtZW50c1BhcnNlcihlbGVtZW50cywgY2FsbGJhY2ssIG9wdGlvbnMsIHJldml2ZXIsIHBhcnNpbmdPcHRpb25zKS5wYXJzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgXCJzdHlsZVwiIGF0dHJpYnV0ZSwgcmV0dW5pbmcgYW4gb2JqZWN0IHdpdGggdmFsdWVzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0cyB3aXRoIHZhbHVlcyBwYXJzZWQgZnJvbSBzdHlsZSBhdHRyaWJ1dGUgb2YgYW4gZWxlbWVudFxuICAgICAqL1xuICAgIHBhcnNlU3R5bGVBdHRyaWJ1dGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvU3R5bGUgPSB7IH0sXG4gICAgICAgICAgc3R5bGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcblxuICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICByZXR1cm4gb1N0eWxlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJzZVN0eWxlU3RyaW5nKHN0eWxlLCBvU3R5bGUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHBhcnNlU3R5bGVPYmplY3Qoc3R5bGUsIG9TdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvU3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBcInBvaW50c1wiIGF0dHJpYnV0ZSwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHZhbHVlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBvaW50cyBwb2ludHMgYXR0cmlidXRlIHN0cmluZ1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiBwb2ludHNcbiAgICAgKi9cbiAgICBwYXJzZVBvaW50c0F0dHJpYnV0ZTogZnVuY3Rpb24ocG9pbnRzKSB7XG5cbiAgICAgIC8vIHBvaW50cyBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgYW5kIG11c3Qgbm90IGJlIGVtcHR5XG4gICAgICBpZiAoIXBvaW50cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gcmVwbGFjZSBjb21tYXMgd2l0aCB3aGl0ZXNwYWNlIGFuZCByZW1vdmUgYm9va2VuZGluZyB3aGl0ZXNwYWNlXG4gICAgICBwb2ludHMgPSBwb2ludHMucmVwbGFjZSgvLC9nLCAnICcpLnRyaW0oKTtcblxuICAgICAgcG9pbnRzID0gcG9pbnRzLnNwbGl0KC9cXHMrLyk7XG4gICAgICB2YXIgcGFyc2VkUG9pbnRzID0gW10sIGksIGxlbjtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgIHBhcnNlZFBvaW50cy5wdXNoKHtcbiAgICAgICAgICB4OiBwYXJzZUZsb2F0KHBvaW50c1tpXSksXG4gICAgICAgICAgeTogcGFyc2VGbG9hdChwb2ludHNbaSArIDFdKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gb2RkIG51bWJlciBvZiBwb2ludHMgaXMgYW4gZXJyb3JcbiAgICAgIC8vIGlmIChwYXJzZWRQb2ludHMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgLy8gICByZXR1cm4gbnVsbDtcbiAgICAgIC8vIH1cblxuICAgICAgcmV0dXJuIHBhcnNlZFBvaW50cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBDU1MgcnVsZXMgZm9yIGEgZ2l2ZW4gU1ZHIGRvY3VtZW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1NWR0RvY3VtZW50fSBkb2MgU1ZHIGRvY3VtZW50IHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDU1MgcnVsZXMgb2YgdGhpcyBkb2N1bWVudFxuICAgICAqL1xuICAgIGdldENTU1J1bGVzOiBmdW5jdGlvbihkb2MpIHtcbiAgICAgIHZhciBzdHlsZXMgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N0eWxlJyksIGksIGxlbixcbiAgICAgICAgICBhbGxSdWxlcyA9IHsgfSwgcnVsZXM7XG5cbiAgICAgIC8vIHZlcnkgY3J1ZGUgcGFyc2luZyBvZiBzdHlsZSBjb250ZW50c1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gc3R5bGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIElFOSBkb2Vzbid0IHN1cHBvcnQgdGV4dENvbnRlbnQsIGJ1dCBwcm92aWRlcyB0ZXh0IGluc3RlYWQuXG4gICAgICAgIHZhciBzdHlsZUNvbnRlbnRzID0gc3R5bGVzW2ldLnRleHRDb250ZW50IHx8IHN0eWxlc1tpXS50ZXh0O1xuXG4gICAgICAgIC8vIHJlbW92ZSBjb21tZW50c1xuICAgICAgICBzdHlsZUNvbnRlbnRzID0gc3R5bGVDb250ZW50cy5yZXBsYWNlKC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvL2csICcnKTtcbiAgICAgICAgaWYgKHN0eWxlQ29udGVudHMudHJpbSgpID09PSAnJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJ1bGVzID0gc3R5bGVDb250ZW50cy5tYXRjaCgvW157XSpcXHtbXFxzXFxTXSo/XFx9L2cpO1xuICAgICAgICBydWxlcyA9IHJ1bGVzLm1hcChmdW5jdGlvbihydWxlKSB7IHJldHVybiBydWxlLnRyaW0oKTsgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgICAgcnVsZXMuZm9yRWFjaChmdW5jdGlvbihydWxlKSB7XG5cbiAgICAgICAgICB2YXIgbWF0Y2ggPSBydWxlLm1hdGNoKC8oW1xcc1xcU10qPylcXHMqXFx7KFtefV0qKVxcfS8pLFxuICAgICAgICAgICAgICBydWxlT2JqID0geyB9LCBkZWNsYXJhdGlvbiA9IG1hdGNoWzJdLnRyaW0oKSxcbiAgICAgICAgICAgICAgcHJvcGVydHlWYWx1ZVBhaXJzID0gZGVjbGFyYXRpb24ucmVwbGFjZSgvOyQvLCAnJykuc3BsaXQoL1xccyo7XFxzKi8pO1xuXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcHJvcGVydHlWYWx1ZVBhaXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFpciA9IHByb3BlcnR5VmFsdWVQYWlyc1tpXS5zcGxpdCgvXFxzKjpcXHMqLyksXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYWlyWzBdLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFpclsxXTtcbiAgICAgICAgICAgIHJ1bGVPYmpbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJ1bGUgPSBtYXRjaFsxXTtcbiAgICAgICAgICBydWxlLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbihfcnVsZSkge1xuICAgICAgICAgICAgX3J1bGUgPSBfcnVsZS5yZXBsYWNlKC9ec3ZnL2ksICcnKS50cmltKCk7XG4gICAgICAgICAgICBpZiAoX3J1bGUgPT09ICcnKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGxSdWxlc1tfcnVsZV0pIHtcbiAgICAgICAgICAgICAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChhbGxSdWxlc1tfcnVsZV0sIHJ1bGVPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGFsbFJ1bGVzW19ydWxlXSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShydWxlT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxsUnVsZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRha2VzIHVybCBjb3JyZXNwb25kaW5nIHRvIGFuIFNWRyBkb2N1bWVudCwgYW5kIHBhcnNlcyBpdCBpbnRvIGEgc2V0IG9mIGZhYnJpYyBvYmplY3RzLlxuICAgICAqIE5vdGUgdGhhdCBTVkcgaXMgZmV0Y2hlZCB2aWEgWE1MSHR0cFJlcXVlc3QsIHNvIGl0IG5lZWRzIHRvIGNvbmZvcm0gdG8gU09QIChTYW1lIE9yaWdpbiBQb2xpY3kpXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBTVkcgZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9iamVjdCBjb250YWluaW5nIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY3Jvc3NPcmlnaW5dIGNyb3NzT3JpZ2luIGNyb3NzT3JpZ2luIHNldHRpbmcgdG8gdXNlIGZvciBleHRlcm5hbCByZXNvdXJjZXNcbiAgICAgKi9cbiAgICBsb2FkU1ZHRnJvbVVSTDogZnVuY3Rpb24odXJsLCBjYWxsYmFjaywgcmV2aXZlciwgb3B0aW9ucykge1xuXG4gICAgICB1cmwgPSB1cmwucmVwbGFjZSgvXlxcblxccyovLCAnJykudHJpbSgpO1xuICAgICAgbmV3IGZhYnJpYy51dGlsLnJlcXVlc3QodXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ2dldCcsXG4gICAgICAgIG9uQ29tcGxldGU6IG9uQ29tcGxldGVcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBvbkNvbXBsZXRlKHIpIHtcblxuICAgICAgICB2YXIgeG1sID0gci5yZXNwb25zZVhNTDtcbiAgICAgICAgaWYgKHhtbCAmJiAheG1sLmRvY3VtZW50RWxlbWVudCAmJiBmYWJyaWMud2luZG93LkFjdGl2ZVhPYmplY3QgJiYgci5yZXNwb25zZVRleHQpIHtcbiAgICAgICAgICB4bWwgPSBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTERPTScpO1xuICAgICAgICAgIHhtbC5hc3luYyA9ICdmYWxzZSc7XG4gICAgICAgICAgLy9JRSBjaG9rZXMgb24gRE9DVFlQRVxuICAgICAgICAgIHhtbC5sb2FkWE1MKHIucmVzcG9uc2VUZXh0LnJlcGxhY2UoLzwhRE9DVFlQRVtcXHNcXFNdKj8oXFxbW1xcc1xcU10qXFxdKSo/Pi9pLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgheG1sIHx8ICF4bWwuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBmYWJyaWMucGFyc2VTVkdEb2N1bWVudCh4bWwuZG9jdW1lbnRFbGVtZW50LCBmdW5jdGlvbiAocmVzdWx0cywgX29wdGlvbnMsIGVsZW1lbnRzLCBhbGxFbGVtZW50cykge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3VsdHMsIF9vcHRpb25zLCBlbGVtZW50cywgYWxsRWxlbWVudHMpO1xuICAgICAgICB9LCByZXZpdmVyLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGFrZXMgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gYW4gU1ZHIGRvY3VtZW50LCBhbmQgcGFyc2VzIGl0IGludG8gYSBzZXQgb2YgZmFicmljIG9iamVjdHNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIFNWRyBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jcm9zc09yaWdpbl0gY3Jvc3NPcmlnaW4gY3Jvc3NPcmlnaW4gc2V0dGluZyB0byB1c2UgZm9yIGV4dGVybmFsIHJlc291cmNlc1xuICAgICAqL1xuICAgIGxvYWRTVkdGcm9tU3RyaW5nOiBmdW5jdGlvbihzdHJpbmcsIGNhbGxiYWNrLCByZXZpdmVyLCBvcHRpb25zKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcudHJpbSgpO1xuICAgICAgdmFyIGRvYztcbiAgICAgIGlmICh0eXBlb2YgRE9NUGFyc2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICBpZiAocGFyc2VyICYmIHBhcnNlci5wYXJzZUZyb21TdHJpbmcpIHtcbiAgICAgICAgICBkb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHN0cmluZywgJ3RleHQveG1sJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZhYnJpYy53aW5kb3cuQWN0aXZlWE9iamVjdCkge1xuICAgICAgICBkb2MgPSBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTERPTScpO1xuICAgICAgICBkb2MuYXN5bmMgPSAnZmFsc2UnO1xuICAgICAgICAvLyBJRSBjaG9rZXMgb24gRE9DVFlQRVxuICAgICAgICBkb2MubG9hZFhNTChzdHJpbmcucmVwbGFjZSgvPCFET0NUWVBFW1xcc1xcU10qPyhcXFtbXFxzXFxTXSpcXF0pKj8+L2ksICcnKSk7XG4gICAgICB9XG5cbiAgICAgIGZhYnJpYy5wYXJzZVNWR0RvY3VtZW50KGRvYy5kb2N1bWVudEVsZW1lbnQsIGZ1bmN0aW9uIChyZXN1bHRzLCBfb3B0aW9ucywgZWxlbWVudHMsIGFsbEVsZW1lbnRzKSB7XG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdHMsIF9vcHRpb25zLCBlbGVtZW50cywgYWxsRWxlbWVudHMpO1xuICAgICAgfSwgcmV2aXZlciwgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbmZhYnJpYy5FbGVtZW50c1BhcnNlciA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBjYWxsYmFjaywgb3B0aW9ucywgcmV2aXZlciwgcGFyc2luZ09wdGlvbnMpIHtcbiAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMucmV2aXZlciA9IHJldml2ZXI7XG4gIHRoaXMuc3ZnVWlkID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5zdmdVaWQpIHx8IDA7XG4gIHRoaXMucGFyc2luZ09wdGlvbnMgPSBwYXJzaW5nT3B0aW9ucztcbiAgdGhpcy5yZWdleFVybCA9IC9edXJsXFwoWydcIl0/IyhbXidcIl0rKVsnXCJdP1xcKS9nO1xufTtcblxuZmFicmljLkVsZW1lbnRzUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmluc3RhbmNlcyA9IG5ldyBBcnJheSh0aGlzLmVsZW1lbnRzLmxlbmd0aCk7XG4gIHRoaXMubnVtRWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcblxuICB0aGlzLmNyZWF0ZU9iamVjdHMoKTtcbn07XG5cbmZhYnJpYy5FbGVtZW50c1BhcnNlci5wcm90b3R5cGUuY3JlYXRlT2JqZWN0cyA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHRoaXMuZWxlbWVudHNbaV0uc2V0QXR0cmlidXRlKCdzdmdVaWQnLCB0aGlzLnN2Z1VpZCk7XG4gICAgKGZ1bmN0aW9uKF9vYmosIGkpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIF9vYmouY3JlYXRlT2JqZWN0KF9vYmouZWxlbWVudHNbaV0sIGkpO1xuICAgICAgfSwgMCk7XG4gICAgfSkodGhpcywgaSk7XG4gIH1cbn07XG5cbmZhYnJpYy5FbGVtZW50c1BhcnNlci5wcm90b3R5cGUuY3JlYXRlT2JqZWN0ID0gZnVuY3Rpb24oZWwsIGluZGV4KSB7XG4gIHZhciBrbGFzcyA9IGZhYnJpY1tmYWJyaWMudXRpbC5zdHJpbmcuY2FwaXRhbGl6ZShlbC50YWdOYW1lLnJlcGxhY2UoJ3N2ZzonLCAnJykpXTtcbiAgaWYgKGtsYXNzICYmIGtsYXNzLmZyb21FbGVtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2NyZWF0ZU9iamVjdChrbGFzcywgZWwsIGluZGV4KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgZmFicmljLmxvZyhlcnIpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmNoZWNrSWZEb25lKCk7XG4gIH1cbn07XG5cbmZhYnJpYy5FbGVtZW50c1BhcnNlci5wcm90b3R5cGUuX2NyZWF0ZU9iamVjdCA9IGZ1bmN0aW9uKGtsYXNzLCBlbCwgaW5kZXgpIHtcbiAga2xhc3MuZnJvbUVsZW1lbnQoZWwsIHRoaXMuY3JlYXRlQ2FsbGJhY2soaW5kZXgsIGVsKSwgdGhpcy5vcHRpb25zKTtcbn07XG5cbmZhYnJpYy5FbGVtZW50c1BhcnNlci5wcm90b3R5cGUuY3JlYXRlQ2FsbGJhY2sgPSBmdW5jdGlvbihpbmRleCwgZWwpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBfb3B0aW9ucztcbiAgICBfdGhpcy5yZXNvbHZlR3JhZGllbnQob2JqLCAnZmlsbCcpO1xuICAgIF90aGlzLnJlc29sdmVHcmFkaWVudChvYmosICdzdHJva2UnKTtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgZmFicmljLkltYWdlKSB7XG4gICAgICBfb3B0aW9ucyA9IG9iai5wYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGUoZWwpO1xuICAgIH1cbiAgICBvYmouX3JlbW92ZVRyYW5zZm9ybU1hdHJpeChfb3B0aW9ucyk7XG4gICAgX3RoaXMucmV2aXZlciAmJiBfdGhpcy5yZXZpdmVyKGVsLCBvYmopO1xuICAgIF90aGlzLmluc3RhbmNlc1tpbmRleF0gPSBvYmo7XG4gICAgX3RoaXMuY2hlY2tJZkRvbmUoKTtcbiAgfTtcbn07XG5cbmZhYnJpYy5FbGVtZW50c1BhcnNlci5wcm90b3R5cGUucmVzb2x2ZUdyYWRpZW50ID0gZnVuY3Rpb24ob2JqLCBwcm9wZXJ0eSkge1xuXG4gIHZhciBpbnN0YW5jZUZpbGxWYWx1ZSA9IG9ialtwcm9wZXJ0eV07XG4gIGlmICghKC9edXJsXFwoLykudGVzdChpbnN0YW5jZUZpbGxWYWx1ZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGdyYWRpZW50SWQgPSB0aGlzLnJlZ2V4VXJsLmV4ZWMoaW5zdGFuY2VGaWxsVmFsdWUpWzFdO1xuICB0aGlzLnJlZ2V4VXJsLmxhc3RJbmRleCA9IDA7XG4gIGlmIChmYWJyaWMuZ3JhZGllbnREZWZzW3RoaXMuc3ZnVWlkXVtncmFkaWVudElkXSkge1xuICAgIG9iai5zZXQocHJvcGVydHksXG4gICAgICBmYWJyaWMuR3JhZGllbnQuZnJvbUVsZW1lbnQoZmFicmljLmdyYWRpZW50RGVmc1t0aGlzLnN2Z1VpZF1bZ3JhZGllbnRJZF0sIG9iaikpO1xuICB9XG59O1xuXG5mYWJyaWMuRWxlbWVudHNQYXJzZXIucHJvdG90eXBlLmNoZWNrSWZEb25lID0gZnVuY3Rpb24oKSB7XG4gIGlmICgtLXRoaXMubnVtRWxlbWVudHMgPT09IDApIHtcbiAgICB0aGlzLmluc3RhbmNlcyA9IHRoaXMuaW5zdGFuY2VzLmZpbHRlcihmdW5jdGlvbihlbCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsIGVxZXFlcVxuICAgICAgcmV0dXJuIGVsICE9IG51bGw7XG4gICAgfSk7XG4gICAgdGhpcy5jYWxsYmFjayh0aGlzLmluc3RhbmNlcywgdGhpcy5lbGVtZW50cyk7XG4gIH1cbn07XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiBBZGFwdGF0aW9uIG9mIHdvcmsgb2YgS2V2aW4gTGluZHNleSAoa2V2aW5Aa2V2bGluZGV2LmNvbSkgKi9cblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSk7XG5cbiAgaWYgKGZhYnJpYy5Qb2ludCkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuUG9pbnQgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZmFicmljLlBvaW50ID0gUG9pbnQ7XG5cbiAgLyoqXG4gICAqIFBvaW50IGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUG9pbnRcbiAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAqL1xuICBmdW5jdGlvbiBQb2ludCh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG5cbiAgUG9pbnQucHJvdG90eXBlID0gLyoqIEBsZW5kcyBmYWJyaWMuUG9pbnQucHJvdG90eXBlICovIHtcblxuICAgIHR5cGU6ICdwb2ludCcsXG5cbiAgICBjb25zdHJ1Y3RvcjogUG9pbnQsXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFub3RoZXIgcG9pbnQgdG8gdGhpcyBvbmUgYW5kIHJldHVybnMgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gbmV3IFBvaW50IGluc3RhbmNlIHdpdGggYWRkZWQgdmFsdWVzXG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyB0aGF0LngsIHRoaXMueSArIHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW5vdGhlciBwb2ludCB0byB0aGlzIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFkZEVxdWFsczogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHRoaXMueCArPSB0aGF0Lng7XG4gICAgICB0aGlzLnkgKz0gdGhhdC55O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdmFsdWUgdG8gdGhpcyBwb2ludCBhbmQgcmV0dXJucyBhIG5ldyBvbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBuZXcgUG9pbnQgd2l0aCBhZGRlZCB2YWx1ZVxuICAgICAqL1xuICAgIHNjYWxhckFkZDogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyBzY2FsYXIsIHRoaXMueSArIHNjYWxhcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdmFsdWUgdG8gdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2NhbGFyQWRkRXF1YWxzOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICB0aGlzLnggKz0gc2NhbGFyO1xuICAgICAgdGhpcy55ICs9IHNjYWxhcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgYW5vdGhlciBwb2ludCBmcm9tIHRoaXMgcG9pbnQgYW5kIHJldHVybnMgYSBuZXcgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IG5ldyBQb2ludCBvYmplY3Qgd2l0aCBzdWJ0cmFjdGVkIHZhbHVlc1xuICAgICAqL1xuICAgIHN1YnRyYWN0OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLSB0aGF0LngsIHRoaXMueSAtIHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyBhbm90aGVyIHBvaW50IGZyb20gdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHN1YnRyYWN0RXF1YWxzOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdGhpcy54IC09IHRoYXQueDtcbiAgICAgIHRoaXMueSAtPSB0aGF0Lnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHZhbHVlIGZyb20gdGhpcyBwb2ludCBhbmQgcmV0dXJucyBhIG5ldyBvbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHNjYWxhclN1YnRyYWN0OiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIHNjYWxhciwgdGhpcy55IC0gc2NhbGFyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHZhbHVlIGZyb20gdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2NhbGFyU3VidHJhY3RFcXVhbHM6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHRoaXMueCAtPSBzY2FsYXI7XG4gICAgICB0aGlzLnkgLT0gc2NhbGFyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdGhpcyBwb2ludCBieSBhIHZhbHVlIGFuZCByZXR1cm5zIGEgbmV3IG9uZVxuICAgICAqIFRPRE86IHJlbmFtZSBpbiBzY2FsYXJNdWx0aXBseSBpbiAyLjBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIG11bHRpcGx5OiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHNjYWxhciwgdGhpcy55ICogc2NhbGFyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGlzIHBvaW50IGJ5IGEgdmFsdWVcbiAgICAgKiBUT0RPOiByZW5hbWUgaW4gc2NhbGFyTXVsdGlwbHlFcXVhbHMgaW4gMi4wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBtdWx0aXBseUVxdWFsczogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgdGhpcy54ICo9IHNjYWxhcjtcbiAgICAgIHRoaXMueSAqPSBzY2FsYXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyB0aGlzIHBvaW50IGJ5IGEgdmFsdWUgYW5kIHJldHVybnMgYSBuZXcgb25lXG4gICAgICogVE9ETzogcmVuYW1lIGluIHNjYWxhckRpdmlkZSBpbiAyLjBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIGRpdmlkZTogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLyBzY2FsYXIsIHRoaXMueSAvIHNjYWxhcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgdGhpcyBwb2ludCBieSBhIHZhbHVlXG4gICAgICogVE9ETzogcmVuYW1lIGluIHNjYWxhckRpdmlkZUVxdWFscyBpbiAyLjBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRpdmlkZUVxdWFsczogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgdGhpcy54IC89IHNjYWxhcjtcbiAgICAgIHRoaXMueSAvPSBzY2FsYXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgZXF1YWwgdG8gYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZXE6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gKHRoaXMueCA9PT0gdGhhdC54ICYmIHRoaXMueSA9PT0gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgbGVzcyB0aGFuIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGx0OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggPCB0aGF0LnggJiYgdGhpcy55IDwgdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGx0ZTogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiAodGhpcy54IDw9IHRoYXQueCAmJiB0aGlzLnkgPD0gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG5cbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyBncmVhdGVyIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGd0OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggPiB0aGF0LnggJiYgdGhpcy55ID4gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGd0ZTogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiAodGhpcy54ID49IHRoYXQueCAmJiB0aGlzLnkgPj0gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBuZXcgcG9pbnQgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3aXRoIHRoaXMgb25lIGFuZCBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHQgLCBwb3NpdGlvbiBvZiBpbnRlcnBvbGF0aW9uLCBiZXR3ZWVuIDAgYW5kIDEgZGVmYXVsdCAwLjVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgbGVycDogZnVuY3Rpb24gKHRoYXQsIHQpIHtcbiAgICAgIGlmICh0eXBlb2YgdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdCA9IDAuNTtcbiAgICAgIH1cbiAgICAgIHQgPSBNYXRoLm1heChNYXRoLm1pbigxLCB0KSwgMCk7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArICh0aGF0LnggLSB0aGlzLngpICogdCwgdGhpcy55ICsgKHRoYXQueSAtIHRoaXMueSkgKiB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkaXN0YW5jZSBmcm9tIHRoaXMgcG9pbnQgYW5kIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZGlzdGFuY2VGcm9tOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdmFyIGR4ID0gdGhpcy54IC0gdGhhdC54LFxuICAgICAgICAgIGR5ID0gdGhpcy55IC0gdGhhdC55O1xuICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IGJldHdlZW4gdGhpcyBwb2ludCBhbmQgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBtaWRQb2ludEZyb206IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gdGhpcy5sZXJwKHRoYXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHBvaW50IHdoaWNoIGlzIHRoZSBtaW4gb2YgdGhpcyBhbmQgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBtaW46IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KE1hdGgubWluKHRoaXMueCwgdGhhdC54KSwgTWF0aC5taW4odGhpcy55LCB0aGF0LnkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBwb2ludCB3aGljaCBpcyB0aGUgbWF4IG9mIHRoaXMgYW5kIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgbWF4OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludChNYXRoLm1heCh0aGlzLngsIHRoYXQueCksIE1hdGgubWF4KHRoaXMueSwgdGhhdC55KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnggKyAnLCcgKyB0aGlzLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgeC95IG9mIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFhZOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB4IG9mIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRYOiBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHkgb2YgdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFk6IGZ1bmN0aW9uICh5KSB7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgeC95IG9mIHRoaXMgcG9pbnQgZnJvbSBhbm90aGVyIHBvaW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0RnJvbVBvaW50OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdGhpcy54ID0gdGhhdC54O1xuICAgICAgdGhpcy55ID0gdGhhdC55O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN3YXBzIHgveSBvZiB0aGlzIHBvaW50IGFuZCBhbm90aGVyIHBvaW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKi9cbiAgICBzd2FwOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdmFyIHggPSB0aGlzLngsXG4gICAgICAgICAgeSA9IHRoaXMueTtcbiAgICAgIHRoaXMueCA9IHRoYXQueDtcbiAgICAgIHRoaXMueSA9IHRoYXQueTtcbiAgICAgIHRoYXQueCA9IHg7XG4gICAgICB0aGF0LnkgPSB5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gYSBjbG9uZWQgaW5zdGFuY2Ugb2YgdGhlIHBvaW50XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIEFkYXB0YXRpb24gb2Ygd29yayBvZiBLZXZpbiBMaW5kc2V5IChrZXZpbkBrZXZsaW5kZXYuY29tKSAqL1xuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSk7XG5cbiAgaWYgKGZhYnJpYy5JbnRlcnNlY3Rpb24pIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkludGVyc2VjdGlvbiBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJzZWN0aW9uIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW50ZXJzZWN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBJbnRlcnNlY3Rpb24oc3RhdHVzKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgfVxuXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24gPSBJbnRlcnNlY3Rpb247XG5cbiAgZmFicmljLkludGVyc2VjdGlvbi5wcm90b3R5cGUgPSAvKiogQGxlbmRzIGZhYnJpYy5JbnRlcnNlY3Rpb24ucHJvdG90eXBlICovIHtcblxuICAgIGNvbnN0cnVjdG9yOiBJbnRlcnNlY3Rpb24sXG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGEgcG9pbnQgdG8gaW50ZXJzZWN0aW9uXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50XG4gICAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBhcHBlbmRQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICB0aGlzLnBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIHBvaW50cyB0byBpbnRlcnNlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFwcGVuZFBvaW50czogZnVuY3Rpb24gKHBvaW50cykge1xuICAgICAgdGhpcy5wb2ludHMgPSB0aGlzLnBvaW50cy5jb25jYXQocG9pbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIG9uZSBsaW5lIGludGVyc2VjdHMgYW5vdGhlclxuICAgKiBUT0RPOiByZW5hbWUgaW4gaW50ZXJzZWN0U2VnbWVudFNlZ21lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYTFcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGEyXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBiMVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYjJcbiAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn1cbiAgICovXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZUxpbmUgPSBmdW5jdGlvbiAoYTEsIGEyLCBiMSwgYjIpIHtcbiAgICB2YXIgcmVzdWx0LFxuICAgICAgICB1YVQgPSAoYjIueCAtIGIxLngpICogKGExLnkgLSBiMS55KSAtIChiMi55IC0gYjEueSkgKiAoYTEueCAtIGIxLngpLFxuICAgICAgICB1YlQgPSAoYTIueCAtIGExLngpICogKGExLnkgLSBiMS55KSAtIChhMi55IC0gYTEueSkgKiAoYTEueCAtIGIxLngpLFxuICAgICAgICB1QiA9IChiMi55IC0gYjEueSkgKiAoYTIueCAtIGExLngpIC0gKGIyLnggLSBiMS54KSAqIChhMi55IC0gYTEueSk7XG4gICAgaWYgKHVCICE9PSAwKSB7XG4gICAgICB2YXIgdWEgPSB1YVQgLyB1QixcbiAgICAgICAgICB1YiA9IHViVCAvIHVCO1xuICAgICAgaWYgKDAgPD0gdWEgJiYgdWEgPD0gMSAmJiAwIDw9IHViICYmIHViIDw9IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbignSW50ZXJzZWN0aW9uJyk7XG4gICAgICAgIHJlc3VsdC5hcHBlbmRQb2ludChuZXcgZmFicmljLlBvaW50KGExLnggKyB1YSAqIChhMi54IC0gYTEueCksIGExLnkgKyB1YSAqIChhMi55IC0gYTEueSkpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKHVhVCA9PT0gMCB8fCB1YlQgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbignQ29pbmNpZGVudCcpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oJ1BhcmFsbGVsJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBsaW5lIGludGVyc2VjdHMgcG9seWdvblxuICAgKiBUT0RPOiByZW5hbWUgaW4gaW50ZXJzZWN0U2VnbWVudFBvbHlnb25cbiAgICogZml4IGRldGVjdGlvbiBvZiBjb2luY2lkZW50XG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGExXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBhMlxuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHNcbiAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn1cbiAgICovXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24gPSBmdW5jdGlvbihhMSwgYTIsIHBvaW50cykge1xuICAgIHZhciByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCksXG4gICAgICAgIGxlbmd0aCA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIGIxLCBiMiwgaW50ZXIsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGIxID0gcG9pbnRzW2ldO1xuICAgICAgYjIgPSBwb2ludHNbKGkgKyAxKSAlIGxlbmd0aF07XG4gICAgICBpbnRlciA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lTGluZShhMSwgYTIsIGIxLCBiMik7XG5cbiAgICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIucG9pbnRzKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5wb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnN0YXR1cyA9ICdJbnRlcnNlY3Rpb24nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcG9seWdvbiBpbnRlcnNlY3RzIGFub3RoZXIgcG9seWdvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50czFcbiAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzMlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufVxuICAgKi9cbiAgZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RQb2x5Z29uUG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMxLCBwb2ludHMyKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oKSxcbiAgICAgICAgbGVuZ3RoID0gcG9pbnRzMS5sZW5ndGgsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhMSA9IHBvaW50czFbaV0sXG4gICAgICAgICAgYTIgPSBwb2ludHMxWyhpICsgMSkgJSBsZW5ndGhdLFxuICAgICAgICAgIGludGVyID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKGExLCBhMiwgcG9pbnRzMik7XG5cbiAgICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIucG9pbnRzKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5wb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnN0YXR1cyA9ICdJbnRlcnNlY3Rpb24nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcG9seWdvbiBpbnRlcnNlY3RzIHJlY3RhbmdsZVxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50c1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcjFcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHIyXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259XG4gICAqL1xuICBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdFBvbHlnb25SZWN0YW5nbGUgPSBmdW5jdGlvbiAocG9pbnRzLCByMSwgcjIpIHtcbiAgICB2YXIgbWluID0gcjEubWluKHIyKSxcbiAgICAgICAgbWF4ID0gcjEubWF4KHIyKSxcbiAgICAgICAgdG9wUmlnaHQgPSBuZXcgZmFicmljLlBvaW50KG1heC54LCBtaW4ueSksXG4gICAgICAgIGJvdHRvbUxlZnQgPSBuZXcgZmFicmljLlBvaW50KG1pbi54LCBtYXgueSksXG4gICAgICAgIGludGVyMSA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbihtaW4sIHRvcFJpZ2h0LCBwb2ludHMpLFxuICAgICAgICBpbnRlcjIgPSBJbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24odG9wUmlnaHQsIG1heCwgcG9pbnRzKSxcbiAgICAgICAgaW50ZXIzID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKG1heCwgYm90dG9tTGVmdCwgcG9pbnRzKSxcbiAgICAgICAgaW50ZXI0ID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKGJvdHRvbUxlZnQsIG1pbiwgcG9pbnRzKSxcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbigpO1xuXG4gICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlcjEucG9pbnRzKTtcbiAgICByZXN1bHQuYXBwZW5kUG9pbnRzKGludGVyMi5wb2ludHMpO1xuICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIzLnBvaW50cyk7XG4gICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlcjQucG9pbnRzKTtcblxuICAgIGlmIChyZXN1bHQucG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdC5zdGF0dXMgPSAnSW50ZXJzZWN0aW9uJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuQ29sb3IpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkNvbG9yIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogQ29sb3IgY2xhc3NcbiAgICogVGhlIHB1cnBvc2Ugb2Yge0BsaW5rIGZhYnJpYy5Db2xvcn0gaXMgdG8gYWJzdHJhY3QgYW5kIGVuY2Fwc3VsYXRlIGNvbW1vbiBjb2xvciBvcGVyYXRpb25zO1xuICAgKiB7QGxpbmsgZmFicmljLkNvbG9yfSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBjcmVhdGVzIGluc3RhbmNlcyBvZiB7QGxpbmsgZmFicmljLkNvbG9yfSBvYmplY3RzLlxuICAgKlxuICAgKiBAY2xhc3MgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBvcHRpb25hbCBpbiBoZXggb3IgcmdiKGEpIG9yIGhzbCBmb3JtYXQgb3IgZnJvbSBrbm93biBjb2xvciBsaXN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn0gdGhpc0FyZ1xuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMi8jY29sb3JzfVxuICAgKi9cbiAgZnVuY3Rpb24gQ29sb3IoY29sb3IpIHtcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICB0aGlzLnNldFNvdXJjZShbMCwgMCwgMCwgMV0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3RyeVBhcnNpbmdDb2xvcihjb2xvcik7XG4gICAgfVxuICB9XG5cbiAgZmFicmljLkNvbG9yID0gQ29sb3I7XG5cbiAgZmFicmljLkNvbG9yLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLkNvbG9yLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBjb2xvciBDb2xvciB2YWx1ZSB0byBwYXJzZVxuICAgICAqL1xuICAgIF90cnlQYXJzaW5nQ29sb3I6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICB2YXIgc291cmNlO1xuXG4gICAgICBpZiAoY29sb3IgaW4gQ29sb3IuY29sb3JOYW1lTWFwKSB7XG4gICAgICAgIGNvbG9yID0gQ29sb3IuY29sb3JOYW1lTWFwW2NvbG9yXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgIHNvdXJjZSA9IFsyNTUsIDI1NSwgMjU1LCAwXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgc291cmNlID0gQ29sb3Iuc291cmNlRnJvbUhleChjb2xvcik7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBzb3VyY2UgPSBDb2xvci5zb3VyY2VGcm9tUmdiKGNvbG9yKTtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHNvdXJjZSA9IENvbG9yLnNvdXJjZUZyb21Ic2woY29sb3IpO1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgLy9pZiBjb2xvciBpcyBub3QgcmVjb2duaXplIGxldCdzIG1ha2UgYmxhY2sgYXMgY2FudmFzIGRvZXNcbiAgICAgICAgc291cmNlID0gWzAsIDAsIDAsIDFdO1xuICAgICAgfVxuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICB0aGlzLnNldFNvdXJjZShzb3VyY2UpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGFwdGVkIGZyb20gPGEgaHJlZj1cImh0dHBzOi8vcmF3Z2l0aHViLmNvbS9tamlqYWNrc29uL21qaWphY2tzb24uZ2l0aHViLmNvbS9tYXN0ZXIvMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0Lmh0bWxcIj5odHRwczovL2dpdGh1Yi5jb20vbWppamFja3NvbjwvYT5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByIFJlZCBjb2xvciB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBnIEdyZWVuIGNvbG9yIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgQmx1ZSBjb2xvciB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBIc2wgY29sb3JcbiAgICAgKi9cbiAgICBfcmdiVG9Ic2w6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcbiAgICAgIHIgLz0gMjU1OyBnIC89IDI1NTsgYiAvPSAyNTU7XG5cbiAgICAgIHZhciBoLCBzLCBsLFxuICAgICAgICAgIG1heCA9IGZhYnJpYy51dGlsLmFycmF5Lm1heChbciwgZywgYl0pLFxuICAgICAgICAgIG1pbiA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbihbciwgZywgYl0pO1xuXG4gICAgICBsID0gKG1heCArIG1pbikgLyAyO1xuXG4gICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgaCA9IHMgPSAwOyAvLyBhY2hyb21hdGljXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGc6XG4gICAgICAgICAgICBoID0gKGIgLSByKSAvIGQgKyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBiOlxuICAgICAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGggLz0gNjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgTWF0aC5yb3VuZChoICogMzYwKSxcbiAgICAgICAgTWF0aC5yb3VuZChzICogMTAwKSxcbiAgICAgICAgTWF0aC5yb3VuZChsICogMTAwKVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzb3VyY2Ugb2YgdGhpcyBjb2xvciAod2hlcmUgc291cmNlIGlzIGFuIGFycmF5IHJlcHJlc2VudGF0aW9uOyBleDogWzIwMCwgMjAwLCAxMDAsIDFdKVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGdldFNvdXJjZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc291cmNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNvdXJjZSBvZiB0aGlzIGNvbG9yICh3aGVyZSBzb3VyY2UgaXMgYW4gYXJyYXkgcmVwcmVzZW50YXRpb247IGV4OiBbMjAwLCAyMDAsIDEwMCwgMV0pXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlXG4gICAgICovXG4gICAgc2V0U291cmNlOiBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBSR0IgZm9ybWF0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBleDogcmdiKDAtMjU1LDAtMjU1LDAtMjU1KVxuICAgICAqL1xuICAgIHRvUmdiOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgICAgcmV0dXJuICdyZ2IoJyArIHNvdXJjZVswXSArICcsJyArIHNvdXJjZVsxXSArICcsJyArIHNvdXJjZVsyXSArICcpJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBSR0JBIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IHJnYmEoMC0yNTUsMC0yNTUsMC0yNTUsMC0xKVxuICAgICAqL1xuICAgIHRvUmdiYTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKTtcbiAgICAgIHJldHVybiAncmdiYSgnICsgc291cmNlWzBdICsgJywnICsgc291cmNlWzFdICsgJywnICsgc291cmNlWzJdICsgJywnICsgc291cmNlWzNdICsgJyknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VudGF0aW9uIGluIEhTTCBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiBoc2woMC0zNjAsMCUtMTAwJSwwJS0xMDAlKVxuICAgICAqL1xuICAgIHRvSHNsOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGhzbCA9IHRoaXMuX3JnYlRvSHNsKHNvdXJjZVswXSwgc291cmNlWzFdLCBzb3VyY2VbMl0pO1xuXG4gICAgICByZXR1cm4gJ2hzbCgnICsgaHNsWzBdICsgJywnICsgaHNsWzFdICsgJyUsJyArIGhzbFsyXSArICclKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgcmVwcmVzZW50YXRpb24gaW4gSFNMQSBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiBoc2xhKDAtMzYwLDAlLTEwMCUsMCUtMTAwJSwwLTEpXG4gICAgICovXG4gICAgdG9Ic2xhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGhzbCA9IHRoaXMuX3JnYlRvSHNsKHNvdXJjZVswXSwgc291cmNlWzFdLCBzb3VyY2VbMl0pO1xuXG4gICAgICByZXR1cm4gJ2hzbGEoJyArIGhzbFswXSArICcsJyArIGhzbFsxXSArICclLCcgKyBoc2xbMl0gKyAnJSwnICsgc291cmNlWzNdICsgJyknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VudGF0aW9uIGluIEhFWCBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiBGRjU1NTVcbiAgICAgKi9cbiAgICB0b0hleDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSwgciwgZywgYjtcblxuICAgICAgciA9IHNvdXJjZVswXS50b1N0cmluZygxNik7XG4gICAgICByID0gKHIubGVuZ3RoID09PSAxKSA/ICgnMCcgKyByKSA6IHI7XG5cbiAgICAgIGcgPSBzb3VyY2VbMV0udG9TdHJpbmcoMTYpO1xuICAgICAgZyA9IChnLmxlbmd0aCA9PT0gMSkgPyAoJzAnICsgZykgOiBnO1xuXG4gICAgICBiID0gc291cmNlWzJdLnRvU3RyaW5nKDE2KTtcbiAgICAgIGIgPSAoYi5sZW5ndGggPT09IDEpID8gKCcwJyArIGIpIDogYjtcblxuICAgICAgcmV0dXJuIHIudG9VcHBlckNhc2UoKSArIGcudG9VcHBlckNhc2UoKSArIGIudG9VcHBlckNhc2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBIRVhBIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IEZGNTU1NUNDXG4gICAgICovXG4gICAgdG9IZXhhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLCBhO1xuXG4gICAgICBhID0gTWF0aC5yb3VuZChzb3VyY2VbM10gKiAyNTUpO1xuICAgICAgYSA9IGEudG9TdHJpbmcoMTYpO1xuICAgICAgYSA9IChhLmxlbmd0aCA9PT0gMSkgPyAoJzAnICsgYSkgOiBhO1xuXG4gICAgICByZXR1cm4gdGhpcy50b0hleCgpICsgYS50b1VwcGVyQ2FzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHZhbHVlIG9mIGFscGhhIGNoYW5uZWwgZm9yIHRoaXMgY29sb3JcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IDAtMVxuICAgICAqL1xuICAgIGdldEFscGhhOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFNvdXJjZSgpWzNdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHZhbHVlIG9mIGFscGhhIGNoYW5uZWwgZm9yIHRoaXMgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYWxwaGEgQWxwaGEgdmFsdWUgMC0xXG4gICAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfSB0aGlzQXJnXG4gICAgICovXG4gICAgc2V0QWxwaGE6IGZ1bmN0aW9uKGFscGhhKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKTtcbiAgICAgIHNvdXJjZVszXSA9IGFscGhhO1xuICAgICAgdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGNvbG9yIHRvIGl0cyBncmF5c2NhbGUgcmVwcmVzZW50YXRpb25cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICB0b0dyYXlzY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBhdmVyYWdlID0gcGFyc2VJbnQoKHNvdXJjZVswXSAqIDAuMyArIHNvdXJjZVsxXSAqIDAuNTkgKyBzb3VyY2VbMl0gKiAwLjExKS50b0ZpeGVkKDApLCAxMCksXG4gICAgICAgICAgY3VycmVudEFscGhhID0gc291cmNlWzNdO1xuICAgICAgdGhpcy5zZXRTb3VyY2UoW2F2ZXJhZ2UsIGF2ZXJhZ2UsIGF2ZXJhZ2UsIGN1cnJlbnRBbHBoYV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgY29sb3IgdG8gaXRzIGJsYWNrIGFuZCB3aGl0ZSByZXByZXNlbnRhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICB0b0JsYWNrV2hpdGU6IGZ1bmN0aW9uKHRocmVzaG9sZCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksXG4gICAgICAgICAgYXZlcmFnZSA9IChzb3VyY2VbMF0gKiAwLjMgKyBzb3VyY2VbMV0gKiAwLjU5ICsgc291cmNlWzJdICogMC4xMSkudG9GaXhlZCgwKSxcbiAgICAgICAgICBjdXJyZW50QWxwaGEgPSBzb3VyY2VbM107XG5cbiAgICAgIHRocmVzaG9sZCA9IHRocmVzaG9sZCB8fCAxMjc7XG5cbiAgICAgIGF2ZXJhZ2UgPSAoTnVtYmVyKGF2ZXJhZ2UpIDwgTnVtYmVyKHRocmVzaG9sZCkpID8gMCA6IDI1NTtcbiAgICAgIHRoaXMuc2V0U291cmNlKFthdmVyYWdlLCBhdmVyYWdlLCBhdmVyYWdlLCBjdXJyZW50QWxwaGFdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPdmVybGF5cyBjb2xvciB3aXRoIGFub3RoZXIgY29sb3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xmYWJyaWMuQ29sb3J9IG90aGVyQ29sb3JcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBvdmVybGF5V2l0aDogZnVuY3Rpb24ob3RoZXJDb2xvcikge1xuICAgICAgaWYgKCEob3RoZXJDb2xvciBpbnN0YW5jZW9mIENvbG9yKSkge1xuICAgICAgICBvdGhlckNvbG9yID0gbmV3IENvbG9yKG90aGVyQ29sb3IpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgYWxwaGEgPSB0aGlzLmdldEFscGhhKCksXG4gICAgICAgICAgb3RoZXJBbHBoYSA9IDAuNSxcbiAgICAgICAgICBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIG90aGVyU291cmNlID0gb3RoZXJDb2xvci5nZXRTb3VyY2UoKSwgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChNYXRoLnJvdW5kKChzb3VyY2VbaV0gKiAoMSAtIG90aGVyQWxwaGEpKSArIChvdGhlclNvdXJjZVtpXSAqIG90aGVyQWxwaGEpKSk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdFszXSA9IGFscGhhO1xuICAgICAgdGhpcy5zZXRTb3VyY2UocmVzdWx0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVnZXggbWF0Y2hpbmcgY29sb3IgaW4gUkdCIG9yIFJHQkEgZm9ybWF0cyAoZXg6IHJnYigwLCAwLCAwKSwgcmdiYSgyNTUsIDEwMCwgMTAsIDAuNSksIHJnYmEoIDI1NSAsIDEwMCAsIDEwICwgMC41ICksIHJnYigxLDEsMSksIHJnYmEoMTAwJSwgNjAlLCAxMCUsIDAuNSkpXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gIGZhYnJpYy5Db2xvci5yZVJHQmEgPSAvXnJnYmE/XFwoXFxzKihcXGR7MSwzfSg/OlxcLlxcZCspP1xcJT8pXFxzKixcXHMqKFxcZHsxLDN9KD86XFwuXFxkKyk/XFwlPylcXHMqLFxccyooXFxkezEsM30oPzpcXC5cXGQrKT9cXCU/KVxccyooPzpcXHMqLFxccyooKD86XFxkKlxcLj9cXGQrKT8pXFxzKik/XFwpJC9pO1xuXG4gIC8qKlxuICAgKiBSZWdleCBtYXRjaGluZyBjb2xvciBpbiBIU0wgb3IgSFNMQSBmb3JtYXRzIChleDogaHNsKDIwMCwgODAlLCAxMCUpLCBoc2xhKDMwMCwgNTAlLCA4MCUsIDAuNSksIGhzbGEoIDMwMCAsIDUwJSAsIDgwJSAsIDAuNSApKVxuICAgKiBAc3RhdGljXG4gICAqIEBmaWVsZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqL1xuICBmYWJyaWMuQ29sb3IucmVIU0xhID0gL15oc2xhP1xcKFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9XFwlKVxccyosXFxzKihcXGR7MSwzfVxcJSlcXHMqKD86XFxzKixcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFxzKik/XFwpJC9pO1xuXG4gIC8qKlxuICAgKiBSZWdleCBtYXRjaGluZyBjb2xvciBpbiBIRVggZm9ybWF0IChleDogI0ZGNTU0NENDLCAjRkY1NTU1LCAwMTAxNTUsIGFmZilcbiAgICogQHN0YXRpY1xuICAgKiBAZmllbGRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKi9cbiAgZmFicmljLkNvbG9yLnJlSGV4ID0gL14jPyhbMC05YS1mXXs4fXxbMC05YS1mXXs2fXxbMC05YS1mXXs0fXxbMC05YS1mXXszfSkkL2k7XG5cbiAgLyoqXG4gICAqIE1hcCBvZiB0aGUgMTQ4IGNvbG9yIG5hbWVzIHdpdGggSEVYIGNvZGVcbiAgICogQHN0YXRpY1xuICAgKiBAZmllbGRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAc2VlOiBodHRwczovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jc3ZnLWNvbG9yXG4gICAqL1xuICBmYWJyaWMuQ29sb3IuY29sb3JOYW1lTWFwID0ge1xuICAgIGFsaWNlYmx1ZTogICAgICAgICAgICAnI0YwRjhGRicsXG4gICAgYW50aXF1ZXdoaXRlOiAgICAgICAgICcjRkFFQkQ3JyxcbiAgICBhcXVhOiAgICAgICAgICAgICAgICAgJyMwMEZGRkYnLFxuICAgIGFxdWFtYXJpbmU6ICAgICAgICAgICAnIzdGRkZENCcsXG4gICAgYXp1cmU6ICAgICAgICAgICAgICAgICcjRjBGRkZGJyxcbiAgICBiZWlnZTogICAgICAgICAgICAgICAgJyNGNUY1REMnLFxuICAgIGJpc3F1ZTogICAgICAgICAgICAgICAnI0ZGRTRDNCcsXG4gICAgYmxhY2s6ICAgICAgICAgICAgICAgICcjMDAwMDAwJyxcbiAgICBibGFuY2hlZGFsbW9uZDogICAgICAgJyNGRkVCQ0QnLFxuICAgIGJsdWU6ICAgICAgICAgICAgICAgICAnIzAwMDBGRicsXG4gICAgYmx1ZXZpb2xldDogICAgICAgICAgICcjOEEyQkUyJyxcbiAgICBicm93bjogICAgICAgICAgICAgICAgJyNBNTJBMkEnLFxuICAgIGJ1cmx5d29vZDogICAgICAgICAgICAnI0RFQjg4NycsXG4gICAgY2FkZXRibHVlOiAgICAgICAgICAgICcjNUY5RUEwJyxcbiAgICBjaGFydHJldXNlOiAgICAgICAgICAgJyM3RkZGMDAnLFxuICAgIGNob2NvbGF0ZTogICAgICAgICAgICAnI0QyNjkxRScsXG4gICAgY29yYWw6ICAgICAgICAgICAgICAgICcjRkY3RjUwJyxcbiAgICBjb3JuZmxvd2VyYmx1ZTogICAgICAgJyM2NDk1RUQnLFxuICAgIGNvcm5zaWxrOiAgICAgICAgICAgICAnI0ZGRjhEQycsXG4gICAgY3JpbXNvbjogICAgICAgICAgICAgICcjREMxNDNDJyxcbiAgICBjeWFuOiAgICAgICAgICAgICAgICAgJyMwMEZGRkYnLFxuICAgIGRhcmtibHVlOiAgICAgICAgICAgICAnIzAwMDA4QicsXG4gICAgZGFya2N5YW46ICAgICAgICAgICAgICcjMDA4QjhCJyxcbiAgICBkYXJrZ29sZGVucm9kOiAgICAgICAgJyNCODg2MEInLFxuICAgIGRhcmtncmF5OiAgICAgICAgICAgICAnI0E5QTlBOScsXG4gICAgZGFya2dyZXk6ICAgICAgICAgICAgICcjQTlBOUE5JyxcbiAgICBkYXJrZ3JlZW46ICAgICAgICAgICAgJyMwMDY0MDAnLFxuICAgIGRhcmtraGFraTogICAgICAgICAgICAnI0JEQjc2QicsXG4gICAgZGFya21hZ2VudGE6ICAgICAgICAgICcjOEIwMDhCJyxcbiAgICBkYXJrb2xpdmVncmVlbjogICAgICAgJyM1NTZCMkYnLFxuICAgIGRhcmtvcmFuZ2U6ICAgICAgICAgICAnI0ZGOEMwMCcsXG4gICAgZGFya29yY2hpZDogICAgICAgICAgICcjOTkzMkNDJyxcbiAgICBkYXJrcmVkOiAgICAgICAgICAgICAgJyM4QjAwMDAnLFxuICAgIGRhcmtzYWxtb246ICAgICAgICAgICAnI0U5OTY3QScsXG4gICAgZGFya3NlYWdyZWVuOiAgICAgICAgICcjOEZCQzhGJyxcbiAgICBkYXJrc2xhdGVibHVlOiAgICAgICAgJyM0ODNEOEInLFxuICAgIGRhcmtzbGF0ZWdyYXk6ICAgICAgICAnIzJGNEY0RicsXG4gICAgZGFya3NsYXRlZ3JleTogICAgICAgICcjMkY0RjRGJyxcbiAgICBkYXJrdHVycXVvaXNlOiAgICAgICAgJyMwMENFRDEnLFxuICAgIGRhcmt2aW9sZXQ6ICAgICAgICAgICAnIzk0MDBEMycsXG4gICAgZGVlcHBpbms6ICAgICAgICAgICAgICcjRkYxNDkzJyxcbiAgICBkZWVwc2t5Ymx1ZTogICAgICAgICAgJyMwMEJGRkYnLFxuICAgIGRpbWdyYXk6ICAgICAgICAgICAgICAnIzY5Njk2OScsXG4gICAgZGltZ3JleTogICAgICAgICAgICAgICcjNjk2OTY5JyxcbiAgICBkb2RnZXJibHVlOiAgICAgICAgICAgJyMxRTkwRkYnLFxuICAgIGZpcmVicmljazogICAgICAgICAgICAnI0IyMjIyMicsXG4gICAgZmxvcmFsd2hpdGU6ICAgICAgICAgICcjRkZGQUYwJyxcbiAgICBmb3Jlc3RncmVlbjogICAgICAgICAgJyMyMjhCMjInLFxuICAgIGZ1Y2hzaWE6ICAgICAgICAgICAgICAnI0ZGMDBGRicsXG4gICAgZ2FpbnNib3JvOiAgICAgICAgICAgICcjRENEQ0RDJyxcbiAgICBnaG9zdHdoaXRlOiAgICAgICAgICAgJyNGOEY4RkYnLFxuICAgIGdvbGQ6ICAgICAgICAgICAgICAgICAnI0ZGRDcwMCcsXG4gICAgZ29sZGVucm9kOiAgICAgICAgICAgICcjREFBNTIwJyxcbiAgICBncmF5OiAgICAgICAgICAgICAgICAgJyM4MDgwODAnLFxuICAgIGdyZXk6ICAgICAgICAgICAgICAgICAnIzgwODA4MCcsXG4gICAgZ3JlZW46ICAgICAgICAgICAgICAgICcjMDA4MDAwJyxcbiAgICBncmVlbnllbGxvdzogICAgICAgICAgJyNBREZGMkYnLFxuICAgIGhvbmV5ZGV3OiAgICAgICAgICAgICAnI0YwRkZGMCcsXG4gICAgaG90cGluazogICAgICAgICAgICAgICcjRkY2OUI0JyxcbiAgICBpbmRpYW5yZWQ6ICAgICAgICAgICAgJyNDRDVDNUMnLFxuICAgIGluZGlnbzogICAgICAgICAgICAgICAnIzRCMDA4MicsXG4gICAgaXZvcnk6ICAgICAgICAgICAgICAgICcjRkZGRkYwJyxcbiAgICBraGFraTogICAgICAgICAgICAgICAgJyNGMEU2OEMnLFxuICAgIGxhdmVuZGVyOiAgICAgICAgICAgICAnI0U2RTZGQScsXG4gICAgbGF2ZW5kZXJibHVzaDogICAgICAgICcjRkZGMEY1JyxcbiAgICBsYXduZ3JlZW46ICAgICAgICAgICAgJyM3Q0ZDMDAnLFxuICAgIGxlbW9uY2hpZmZvbjogICAgICAgICAnI0ZGRkFDRCcsXG4gICAgbGlnaHRibHVlOiAgICAgICAgICAgICcjQUREOEU2JyxcbiAgICBsaWdodGNvcmFsOiAgICAgICAgICAgJyNGMDgwODAnLFxuICAgIGxpZ2h0Y3lhbjogICAgICAgICAgICAnI0UwRkZGRicsXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ICcjRkFGQUQyJyxcbiAgICBsaWdodGdyYXk6ICAgICAgICAgICAgJyNEM0QzRDMnLFxuICAgIGxpZ2h0Z3JleTogICAgICAgICAgICAnI0QzRDNEMycsXG4gICAgbGlnaHRncmVlbjogICAgICAgICAgICcjOTBFRTkwJyxcbiAgICBsaWdodHBpbms6ICAgICAgICAgICAgJyNGRkI2QzEnLFxuICAgIGxpZ2h0c2FsbW9uOiAgICAgICAgICAnI0ZGQTA3QScsXG4gICAgbGlnaHRzZWFncmVlbjogICAgICAgICcjMjBCMkFBJyxcbiAgICBsaWdodHNreWJsdWU6ICAgICAgICAgJyM4N0NFRkEnLFxuICAgIGxpZ2h0c2xhdGVncmF5OiAgICAgICAnIzc3ODg5OScsXG4gICAgbGlnaHRzbGF0ZWdyZXk6ICAgICAgICcjNzc4ODk5JyxcbiAgICBsaWdodHN0ZWVsYmx1ZTogICAgICAgJyNCMEM0REUnLFxuICAgIGxpZ2h0eWVsbG93OiAgICAgICAgICAnI0ZGRkZFMCcsXG4gICAgbGltZTogICAgICAgICAgICAgICAgICcjMDBGRjAwJyxcbiAgICBsaW1lZ3JlZW46ICAgICAgICAgICAgJyMzMkNEMzInLFxuICAgIGxpbmVuOiAgICAgICAgICAgICAgICAnI0ZBRjBFNicsXG4gICAgbWFnZW50YTogICAgICAgICAgICAgICcjRkYwMEZGJyxcbiAgICBtYXJvb246ICAgICAgICAgICAgICAgJyM4MDAwMDAnLFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6ICAgICAnIzY2Q0RBQScsXG4gICAgbWVkaXVtYmx1ZTogICAgICAgICAgICcjMDAwMENEJyxcbiAgICBtZWRpdW1vcmNoaWQ6ICAgICAgICAgJyNCQTU1RDMnLFxuICAgIG1lZGl1bXB1cnBsZTogICAgICAgICAnIzkzNzBEQicsXG4gICAgbWVkaXVtc2VhZ3JlZW46ICAgICAgICcjM0NCMzcxJyxcbiAgICBtZWRpdW1zbGF0ZWJsdWU6ICAgICAgJyM3QjY4RUUnLFxuICAgIG1lZGl1bXNwcmluZ2dyZWVuOiAgICAnIzAwRkE5QScsXG4gICAgbWVkaXVtdHVycXVvaXNlOiAgICAgICcjNDhEMUNDJyxcbiAgICBtZWRpdW12aW9sZXRyZWQ6ICAgICAgJyNDNzE1ODUnLFxuICAgIG1pZG5pZ2h0Ymx1ZTogICAgICAgICAnIzE5MTk3MCcsXG4gICAgbWludGNyZWFtOiAgICAgICAgICAgICcjRjVGRkZBJyxcbiAgICBtaXN0eXJvc2U6ICAgICAgICAgICAgJyNGRkU0RTEnLFxuICAgIG1vY2Nhc2luOiAgICAgICAgICAgICAnI0ZGRTRCNScsXG4gICAgbmF2YWpvd2hpdGU6ICAgICAgICAgICcjRkZERUFEJyxcbiAgICBuYXZ5OiAgICAgICAgICAgICAgICAgJyMwMDAwODAnLFxuICAgIG9sZGxhY2U6ICAgICAgICAgICAgICAnI0ZERjVFNicsXG4gICAgb2xpdmU6ICAgICAgICAgICAgICAgICcjODA4MDAwJyxcbiAgICBvbGl2ZWRyYWI6ICAgICAgICAgICAgJyM2QjhFMjMnLFxuICAgIG9yYW5nZTogICAgICAgICAgICAgICAnI0ZGQTUwMCcsXG4gICAgb3JhbmdlcmVkOiAgICAgICAgICAgICcjRkY0NTAwJyxcbiAgICBvcmNoaWQ6ICAgICAgICAgICAgICAgJyNEQTcwRDYnLFxuICAgIHBhbGVnb2xkZW5yb2Q6ICAgICAgICAnI0VFRThBQScsXG4gICAgcGFsZWdyZWVuOiAgICAgICAgICAgICcjOThGQjk4JyxcbiAgICBwYWxldHVycXVvaXNlOiAgICAgICAgJyNBRkVFRUUnLFxuICAgIHBhbGV2aW9sZXRyZWQ6ICAgICAgICAnI0RCNzA5MycsXG4gICAgcGFwYXlhd2hpcDogICAgICAgICAgICcjRkZFRkQ1JyxcbiAgICBwZWFjaHB1ZmY6ICAgICAgICAgICAgJyNGRkRBQjknLFxuICAgIHBlcnU6ICAgICAgICAgICAgICAgICAnI0NEODUzRicsXG4gICAgcGluazogICAgICAgICAgICAgICAgICcjRkZDMENCJyxcbiAgICBwbHVtOiAgICAgICAgICAgICAgICAgJyNEREEwREQnLFxuICAgIHBvd2RlcmJsdWU6ICAgICAgICAgICAnI0IwRTBFNicsXG4gICAgcHVycGxlOiAgICAgICAgICAgICAgICcjODAwMDgwJyxcbiAgICByZWJlY2NhcHVycGxlOiAgICAgICAgJyM2NjMzOTknLFxuICAgIHJlZDogICAgICAgICAgICAgICAgICAnI0ZGMDAwMCcsXG4gICAgcm9zeWJyb3duOiAgICAgICAgICAgICcjQkM4RjhGJyxcbiAgICByb3lhbGJsdWU6ICAgICAgICAgICAgJyM0MTY5RTEnLFxuICAgIHNhZGRsZWJyb3duOiAgICAgICAgICAnIzhCNDUxMycsXG4gICAgc2FsbW9uOiAgICAgICAgICAgICAgICcjRkE4MDcyJyxcbiAgICBzYW5keWJyb3duOiAgICAgICAgICAgJyNGNEE0NjAnLFxuICAgIHNlYWdyZWVuOiAgICAgICAgICAgICAnIzJFOEI1NycsXG4gICAgc2Vhc2hlbGw6ICAgICAgICAgICAgICcjRkZGNUVFJyxcbiAgICBzaWVubmE6ICAgICAgICAgICAgICAgJyNBMDUyMkQnLFxuICAgIHNpbHZlcjogICAgICAgICAgICAgICAnI0MwQzBDMCcsXG4gICAgc2t5Ymx1ZTogICAgICAgICAgICAgICcjODdDRUVCJyxcbiAgICBzbGF0ZWJsdWU6ICAgICAgICAgICAgJyM2QTVBQ0QnLFxuICAgIHNsYXRlZ3JheTogICAgICAgICAgICAnIzcwODA5MCcsXG4gICAgc2xhdGVncmV5OiAgICAgICAgICAgICcjNzA4MDkwJyxcbiAgICBzbm93OiAgICAgICAgICAgICAgICAgJyNGRkZBRkEnLFxuICAgIHNwcmluZ2dyZWVuOiAgICAgICAgICAnIzAwRkY3RicsXG4gICAgc3RlZWxibHVlOiAgICAgICAgICAgICcjNDY4MkI0JyxcbiAgICB0YW46ICAgICAgICAgICAgICAgICAgJyNEMkI0OEMnLFxuICAgIHRlYWw6ICAgICAgICAgICAgICAgICAnIzAwODA4MCcsXG4gICAgdGhpc3RsZTogICAgICAgICAgICAgICcjRDhCRkQ4JyxcbiAgICB0b21hdG86ICAgICAgICAgICAgICAgJyNGRjYzNDcnLFxuICAgIHR1cnF1b2lzZTogICAgICAgICAgICAnIzQwRTBEMCcsXG4gICAgdmlvbGV0OiAgICAgICAgICAgICAgICcjRUU4MkVFJyxcbiAgICB3aGVhdDogICAgICAgICAgICAgICAgJyNGNURFQjMnLFxuICAgIHdoaXRlOiAgICAgICAgICAgICAgICAnI0ZGRkZGRicsXG4gICAgd2hpdGVzbW9rZTogICAgICAgICAgICcjRjVGNUY1JyxcbiAgICB5ZWxsb3c6ICAgICAgICAgICAgICAgJyNGRkZGMDAnLFxuICAgIHllbGxvd2dyZWVuOiAgICAgICAgICAnIzlBQ0QzMidcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gICAgaWYgKHQgPCAwKSB7XG4gICAgICB0ICs9IDE7XG4gICAgfVxuICAgIGlmICh0ID4gMSkge1xuICAgICAgdCAtPSAxO1xuICAgIH1cbiAgICBpZiAodCA8IDEgLyA2KSB7XG4gICAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICB9XG4gICAgaWYgKHQgPCAxIC8gMikge1xuICAgICAgcmV0dXJuIHE7XG4gICAgfVxuICAgIGlmICh0IDwgMiAvIDMpIHtcbiAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gUkdCIGZvcm1hdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogcmdiKDAtMjU1LDAtMjU1LDAtMjU1KVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbVJnYiA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIENvbG9yLmZyb21Tb3VyY2UoQ29sb3Iuc291cmNlRnJvbVJnYihjb2xvcikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzEwMCwgMTAwLCAyMDAsIDFdKSBvZiBhIGNvbG9yIHRoYXQncyBpbiBSR0Igb3IgUkdCQSBmb3JtYXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IHJnYigwLTI1NSwwLTI1NSwwLTI1NSksIHJnYigwJS0xMDAlLDAlLTEwMCUsMCUtMTAwJSlcbiAgICogQHJldHVybiB7QXJyYXl9IHNvdXJjZVxuICAgKi9cbiAgZmFicmljLkNvbG9yLnNvdXJjZUZyb21SZ2IgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHZhciBtYXRjaCA9IGNvbG9yLm1hdGNoKENvbG9yLnJlUkdCYSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCkgLyAoLyUkLy50ZXN0KG1hdGNoWzFdKSA/IDEwMCA6IDEpICogKC8lJC8udGVzdChtYXRjaFsxXSkgPyAyNTUgOiAxKSxcbiAgICAgICAgICBnID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKSAvICgvJSQvLnRlc3QobWF0Y2hbMl0pID8gMTAwIDogMSkgKiAoLyUkLy50ZXN0KG1hdGNoWzJdKSA/IDI1NSA6IDEpLFxuICAgICAgICAgIGIgPSBwYXJzZUludChtYXRjaFszXSwgMTApIC8gKC8lJC8udGVzdChtYXRjaFszXSkgPyAxMDAgOiAxKSAqICgvJSQvLnRlc3QobWF0Y2hbM10pID8gMjU1IDogMSk7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHBhcnNlSW50KHIsIDEwKSxcbiAgICAgICAgcGFyc2VJbnQoZywgMTApLFxuICAgICAgICBwYXJzZUludChiLCAxMCksXG4gICAgICAgIG1hdGNoWzRdID8gcGFyc2VGbG9hdChtYXRjaFs0XSkgOiAxXG4gICAgICBdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gUkdCQSBmb3JtYXRcbiAgICogQHN0YXRpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3JcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21SZ2JhID0gQ29sb3IuZnJvbVJnYjtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gSFNMIGZvcm1hdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IGhzbCgwLTI2MCwwJS0xMDAlLDAlLTEwMCUpXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21Ic2wgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHJldHVybiBDb2xvci5mcm9tU291cmNlKENvbG9yLnNvdXJjZUZyb21Ic2woY29sb3IpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhcnJheSByZXByZXNlbnRhdGlvbiAoZXg6IFsxMDAsIDEwMCwgMjAwLCAxXSkgb2YgYSBjb2xvciB0aGF0J3MgaW4gSFNMIG9yIEhTTEEgZm9ybWF0LlxuICAgKiBBZGFwdGVkIGZyb20gPGEgaHJlZj1cImh0dHBzOi8vcmF3Z2l0aHViLmNvbS9tamlqYWNrc29uL21qaWphY2tzb24uZ2l0aHViLmNvbS9tYXN0ZXIvMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0Lmh0bWxcIj5odHRwczovL2dpdGh1Yi5jb20vbWppamFja3NvbjwvYT5cbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IGhzbCgwLTM2MCwwJS0xMDAlLDAlLTEwMCUpIG9yIGhzbGEoMC0zNjAsMCUtMTAwJSwwJS0xMDAlLCAwLTEpXG4gICAqIEByZXR1cm4ge0FycmF5fSBzb3VyY2VcbiAgICogQHNlZSBodHRwOi8vaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jaHNsLWNvbG9yXG4gICAqL1xuICBmYWJyaWMuQ29sb3Iuc291cmNlRnJvbUhzbCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgdmFyIG1hdGNoID0gY29sb3IubWF0Y2goQ29sb3IucmVIU0xhKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGggPSAoKChwYXJzZUZsb2F0KG1hdGNoWzFdKSAlIDM2MCkgKyAzNjApICUgMzYwKSAvIDM2MCxcbiAgICAgICAgcyA9IHBhcnNlRmxvYXQobWF0Y2hbMl0pIC8gKC8lJC8udGVzdChtYXRjaFsyXSkgPyAxMDAgOiAxKSxcbiAgICAgICAgbCA9IHBhcnNlRmxvYXQobWF0Y2hbM10pIC8gKC8lJC8udGVzdChtYXRjaFszXSkgPyAxMDAgOiAxKSxcbiAgICAgICAgciwgZywgYjtcblxuICAgIGlmIChzID09PSAwKSB7XG4gICAgICByID0gZyA9IGIgPSBsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBxID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHMsXG4gICAgICAgICAgcCA9IGwgKiAyIC0gcTtcblxuICAgICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKTtcbiAgICAgIGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICAgICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgTWF0aC5yb3VuZChyICogMjU1KSxcbiAgICAgIE1hdGgucm91bmQoZyAqIDI1NSksXG4gICAgICBNYXRoLnJvdW5kKGIgKiAyNTUpLFxuICAgICAgbWF0Y2hbNF0gPyBwYXJzZUZsb2F0KG1hdGNoWzRdKSA6IDFcbiAgICBdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBIU0xBIGZvcm1hdFxuICAgKiBAc3RhdGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbUhzbGEgPSBDb2xvci5mcm9tSHNsO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBIRVggZm9ybWF0XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IEZGNTU1NVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbUhleCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIENvbG9yLmZyb21Tb3VyY2UoQ29sb3Iuc291cmNlRnJvbUhleChjb2xvcikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzEwMCwgMTAwLCAyMDAsIDFdKSBvZiBhIGNvbG9yIHRoYXQncyBpbiBIRVggZm9ybWF0XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgZXg6IEZGNTU1NSBvciBGRjU1NDRDQyAoUkdCYSlcbiAgICogQHJldHVybiB7QXJyYXl9IHNvdXJjZVxuICAgKi9cbiAgZmFicmljLkNvbG9yLnNvdXJjZUZyb21IZXggPSBmdW5jdGlvbihjb2xvcikge1xuICAgIGlmIChjb2xvci5tYXRjaChDb2xvci5yZUhleCkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGNvbG9yLnNsaWNlKGNvbG9yLmluZGV4T2YoJyMnKSArIDEpLFxuICAgICAgICAgIGlzU2hvcnROb3RhdGlvbiA9ICh2YWx1ZS5sZW5ndGggPT09IDMgfHwgdmFsdWUubGVuZ3RoID09PSA0KSxcbiAgICAgICAgICBpc1JHQmEgPSAodmFsdWUubGVuZ3RoID09PSA4IHx8IHZhbHVlLmxlbmd0aCA9PT0gNCksXG4gICAgICAgICAgciA9IGlzU2hvcnROb3RhdGlvbiA/ICh2YWx1ZS5jaGFyQXQoMCkgKyB2YWx1ZS5jaGFyQXQoMCkpIDogdmFsdWUuc3Vic3RyaW5nKDAsIDIpLFxuICAgICAgICAgIGcgPSBpc1Nob3J0Tm90YXRpb24gPyAodmFsdWUuY2hhckF0KDEpICsgdmFsdWUuY2hhckF0KDEpKSA6IHZhbHVlLnN1YnN0cmluZygyLCA0KSxcbiAgICAgICAgICBiID0gaXNTaG9ydE5vdGF0aW9uID8gKHZhbHVlLmNoYXJBdCgyKSArIHZhbHVlLmNoYXJBdCgyKSkgOiB2YWx1ZS5zdWJzdHJpbmcoNCwgNiksXG4gICAgICAgICAgYSA9IGlzUkdCYSA/IChpc1Nob3J0Tm90YXRpb24gPyAodmFsdWUuY2hhckF0KDMpICsgdmFsdWUuY2hhckF0KDMpKSA6IHZhbHVlLnN1YnN0cmluZyg2LCA4KSkgOiAnRkYnO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBwYXJzZUludChyLCAxNiksXG4gICAgICAgIHBhcnNlSW50KGcsIDE2KSxcbiAgICAgICAgcGFyc2VJbnQoYiwgMTYpLFxuICAgICAgICBwYXJzZUZsb2F0KChwYXJzZUludChhLCAxNikgLyAyNTUpLnRvRml4ZWQoMikpXG4gICAgICBdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGNvbG9yIGluIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzIwMCwgMTAwLCAxMDAsIDAuNV0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21Tb3VyY2UgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICB2YXIgb0NvbG9yID0gbmV3IENvbG9yKCk7XG4gICAgb0NvbG9yLnNldFNvdXJjZShzb3VyY2UpO1xuICAgIHJldHVybiBvQ29sb3I7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICBmdW5jdGlvbiBnZXRDb2xvclN0b3AoZWwpIHtcbiAgICB2YXIgc3R5bGUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyksXG4gICAgICAgIG9mZnNldCA9IGVsLmdldEF0dHJpYnV0ZSgnb2Zmc2V0JykgfHwgMCxcbiAgICAgICAgY29sb3IsIGNvbG9yQWxwaGEsIG9wYWNpdHksIGk7XG5cbiAgICAvLyBjb252ZXJ0IHBlcmNlbnRzIHRvIGFic29sdXRlIHZhbHVlc1xuICAgIG9mZnNldCA9IHBhcnNlRmxvYXQob2Zmc2V0KSAvICgvJSQvLnRlc3Qob2Zmc2V0KSA/IDEwMCA6IDEpO1xuICAgIG9mZnNldCA9IG9mZnNldCA8IDAgPyAwIDogb2Zmc2V0ID4gMSA/IDEgOiBvZmZzZXQ7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICB2YXIga2V5VmFsdWVQYWlycyA9IHN0eWxlLnNwbGl0KC9cXHMqO1xccyovKTtcblxuICAgICAgaWYgKGtleVZhbHVlUGFpcnNba2V5VmFsdWVQYWlycy5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgICAga2V5VmFsdWVQYWlycy5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0ga2V5VmFsdWVQYWlycy5sZW5ndGg7IGktLTsgKSB7XG5cbiAgICAgICAgdmFyIHNwbGl0ID0ga2V5VmFsdWVQYWlyc1tpXS5zcGxpdCgvXFxzKjpcXHMqLyksXG4gICAgICAgICAgICBrZXkgPSBzcGxpdFswXS50cmltKCksXG4gICAgICAgICAgICB2YWx1ZSA9IHNwbGl0WzFdLnRyaW0oKTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnc3RvcC1jb2xvcicpIHtcbiAgICAgICAgICBjb2xvciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0b3Atb3BhY2l0eScpIHtcbiAgICAgICAgICBvcGFjaXR5ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICBjb2xvciA9IGVsLmdldEF0dHJpYnV0ZSgnc3RvcC1jb2xvcicpIHx8ICdyZ2IoMCwwLDApJztcbiAgICB9XG4gICAgaWYgKCFvcGFjaXR5KSB7XG4gICAgICBvcGFjaXR5ID0gZWwuZ2V0QXR0cmlidXRlKCdzdG9wLW9wYWNpdHknKTtcbiAgICB9XG5cbiAgICBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoY29sb3IpO1xuICAgIGNvbG9yQWxwaGEgPSBjb2xvci5nZXRBbHBoYSgpO1xuICAgIG9wYWNpdHkgPSBpc05hTihwYXJzZUZsb2F0KG9wYWNpdHkpKSA/IDEgOiBwYXJzZUZsb2F0KG9wYWNpdHkpO1xuICAgIG9wYWNpdHkgKj0gY29sb3JBbHBoYTtcblxuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgIGNvbG9yOiBjb2xvci50b1JnYigpLFxuICAgICAgb3BhY2l0eTogb3BhY2l0eVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMaW5lYXJDb29yZHMoZWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IGVsLmdldEF0dHJpYnV0ZSgneDEnKSB8fCAwLFxuICAgICAgeTE6IGVsLmdldEF0dHJpYnV0ZSgneTEnKSB8fCAwLFxuICAgICAgeDI6IGVsLmdldEF0dHJpYnV0ZSgneDInKSB8fCAnMTAwJScsXG4gICAgICB5MjogZWwuZ2V0QXR0cmlidXRlKCd5MicpIHx8IDBcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UmFkaWFsQ29vcmRzKGVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiBlbC5nZXRBdHRyaWJ1dGUoJ2Z4JykgfHwgZWwuZ2V0QXR0cmlidXRlKCdjeCcpIHx8ICc1MCUnLFxuICAgICAgeTE6IGVsLmdldEF0dHJpYnV0ZSgnZnknKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ2N5JykgfHwgJzUwJScsXG4gICAgICByMTogMCxcbiAgICAgIHgyOiBlbC5nZXRBdHRyaWJ1dGUoJ2N4JykgfHwgJzUwJScsXG4gICAgICB5MjogZWwuZ2V0QXR0cmlidXRlKCdjeScpIHx8ICc1MCUnLFxuICAgICAgcjI6IGVsLmdldEF0dHJpYnV0ZSgncicpIHx8ICc1MCUnXG4gICAgfTtcbiAgfVxuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIHZhciBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZTtcblxuICAvKipcbiAgICogR3JhZGllbnQgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5HcmFkaWVudFxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMiNncmFkaWVudHN9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5HcmFkaWVudCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkdyYWRpZW50ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoLyoqIEBsZW5kcyBmYWJyaWMuR3JhZGllbnQucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgb2Zmc2V0IGZvciBhbGlnbmluZyBncmFkaWVudHMgY29taW5nIGZyb20gU1ZHIHdoZW4gb3V0c2lkZSBwYXRoZ3JvdXBzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIG9mZnNldFg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBvZmZzZXQgZm9yIGFsaWduaW5nIGdyYWRpZW50cyBjb21pbmcgZnJvbSBTVkcgd2hlbiBvdXRzaWRlIHBhdGhncm91cHNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgb2Zmc2V0WTogMCxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCB3aXRoIHR5cGUsIGNvb3JkcywgZ3JhZGllbnRVbml0cyBhbmQgY29sb3JTdG9wc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5HcmFkaWVudH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB2YXIgY29vcmRzID0geyB9O1xuXG4gICAgICB0aGlzLmlkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlIHx8ICdsaW5lYXInO1xuXG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHgxOiBvcHRpb25zLmNvb3Jkcy54MSB8fCAwLFxuICAgICAgICB5MTogb3B0aW9ucy5jb29yZHMueTEgfHwgMCxcbiAgICAgICAgeDI6IG9wdGlvbnMuY29vcmRzLngyIHx8IDAsXG4gICAgICAgIHkyOiBvcHRpb25zLmNvb3Jkcy55MiB8fCAwXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAncmFkaWFsJykge1xuICAgICAgICBjb29yZHMucjEgPSBvcHRpb25zLmNvb3Jkcy5yMSB8fCAwO1xuICAgICAgICBjb29yZHMucjIgPSBvcHRpb25zLmNvb3Jkcy5yMiB8fCAwO1xuICAgICAgfVxuICAgICAgdGhpcy5jb29yZHMgPSBjb29yZHM7XG4gICAgICB0aGlzLmNvbG9yU3RvcHMgPSBvcHRpb25zLmNvbG9yU3RvcHMuc2xpY2UoKTtcbiAgICAgIGlmIChvcHRpb25zLmdyYWRpZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0gPSBvcHRpb25zLmdyYWRpZW50VHJhbnNmb3JtO1xuICAgICAgfVxuICAgICAgdGhpcy5vZmZzZXRYID0gb3B0aW9ucy5vZmZzZXRYIHx8IHRoaXMub2Zmc2V0WDtcbiAgICAgIHRoaXMub2Zmc2V0WSA9IG9wdGlvbnMub2Zmc2V0WSB8fCB0aGlzLm9mZnNldFk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW5vdGhlciBjb2xvclN0b3BcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29sb3JTdG9wIE9iamVjdCB3aXRoIG9mZnNldCBhbmQgY29sb3JcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JhZGllbnR9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBhZGRDb2xvclN0b3A6IGZ1bmN0aW9uKGNvbG9yU3RvcHMpIHtcbiAgICAgIGZvciAodmFyIHBvc2l0aW9uIGluIGNvbG9yU3RvcHMpIHtcbiAgICAgICAgdmFyIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihjb2xvclN0b3BzW3Bvc2l0aW9uXSk7XG4gICAgICAgIHRoaXMuY29sb3JTdG9wcy5wdXNoKHtcbiAgICAgICAgICBvZmZzZXQ6IHBhcnNlRmxvYXQocG9zaXRpb24pLFxuICAgICAgICAgIGNvbG9yOiBjb2xvci50b1JnYigpLFxuICAgICAgICAgIG9wYWNpdHk6IGNvbG9yLmdldEFscGhhKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBncmFkaWVudFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBvYmplY3QgPSB7XG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgY29vcmRzOiB0aGlzLmNvb3JkcyxcbiAgICAgICAgY29sb3JTdG9wczogdGhpcy5jb2xvclN0b3BzLFxuICAgICAgICBvZmZzZXRYOiB0aGlzLm9mZnNldFgsXG4gICAgICAgIG9mZnNldFk6IHRoaXMub2Zmc2V0WSxcbiAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm06IHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0gPyB0aGlzLmdyYWRpZW50VHJhbnNmb3JtLmNvbmNhdCgpIDogdGhpcy5ncmFkaWVudFRyYW5zZm9ybVxuICAgICAgfTtcbiAgICAgIGZhYnJpYy51dGlsLnBvcHVsYXRlV2l0aFByb3BlcnRpZXModGhpcywgb2JqZWN0LCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhbiBncmFkaWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhIGdyYWRpZW50IGZvclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGFuIGdyYWRpZW50IChsaW5lYXIvcmFkaWFsKVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBjb29yZHMgPSBjbG9uZSh0aGlzLmNvb3JkcywgdHJ1ZSksIGksIGxlbixcbiAgICAgICAgICBtYXJrdXAsIGNvbW1vbkF0dHJpYnV0ZXMsIGNvbG9yU3RvcHMgPSBjbG9uZSh0aGlzLmNvbG9yU3RvcHMsIHRydWUpLFxuICAgICAgICAgIG5lZWRzU3dhcCA9IGNvb3Jkcy5yMSA+IGNvb3Jkcy5yMixcbiAgICAgICAgICBvZmZzZXRYID0gb2JqZWN0LndpZHRoIC8gMiwgb2Zmc2V0WSA9IG9iamVjdC5oZWlnaHQgLyAyO1xuICAgICAgLy8gY29sb3JTdG9wcyBtdXN0IGJlIHNvcnRlZCBhc2NlbmRpbmdcbiAgICAgIGNvbG9yU3RvcHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLm9mZnNldCAtIGIub2Zmc2V0O1xuICAgICAgfSk7XG4gICAgICBpZiAob2JqZWN0LnR5cGUgPT09ICdwYXRoJykge1xuICAgICAgICBvZmZzZXRYIC09IG9iamVjdC5wYXRoT2Zmc2V0Lng7XG4gICAgICAgIG9mZnNldFkgLT0gb2JqZWN0LnBhdGhPZmZzZXQueTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHByb3AgaW4gY29vcmRzKSB7XG4gICAgICAgIGlmIChwcm9wID09PSAneDEnIHx8IHByb3AgPT09ICd4MicpIHtcbiAgICAgICAgICBjb29yZHNbcHJvcF0gKz0gdGhpcy5vZmZzZXRYIC0gb2Zmc2V0WDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9wID09PSAneTEnIHx8IHByb3AgPT09ICd5MicpIHtcbiAgICAgICAgICBjb29yZHNbcHJvcF0gKz0gdGhpcy5vZmZzZXRZIC0gb2Zmc2V0WTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb21tb25BdHRyaWJ1dGVzID0gJ2lkPVwiU1ZHSURfJyArIHRoaXMuaWQgK1xuICAgICAgICAgICAgICAgICAgICAgJ1wiIGdyYWRpZW50VW5pdHM9XCJ1c2VyU3BhY2VPblVzZVwiJztcbiAgICAgIGlmICh0aGlzLmdyYWRpZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbW1vbkF0dHJpYnV0ZXMgKz0gJyBncmFkaWVudFRyYW5zZm9ybT1cIm1hdHJpeCgnICsgdGhpcy5ncmFkaWVudFRyYW5zZm9ybS5qb2luKCcgJykgKyAnKVwiICc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50eXBlID09PSAnbGluZWFyJykge1xuICAgICAgICBtYXJrdXAgPSBbXG4gICAgICAgICAgJzxsaW5lYXJHcmFkaWVudCAnLFxuICAgICAgICAgIGNvbW1vbkF0dHJpYnV0ZXMsXG4gICAgICAgICAgJyB4MT1cIicsIGNvb3Jkcy54MSxcbiAgICAgICAgICAnXCIgeTE9XCInLCBjb29yZHMueTEsXG4gICAgICAgICAgJ1wiIHgyPVwiJywgY29vcmRzLngyLFxuICAgICAgICAgICdcIiB5Mj1cIicsIGNvb3Jkcy55MixcbiAgICAgICAgICAnXCI+XFxuJ1xuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSAncmFkaWFsJykge1xuICAgICAgICAvLyBzdmcgcmFkaWFsIGdyYWRpZW50IGhhcyBqdXN0IDEgcmFkaXVzLiB0aGUgYmlnZ2VzdC5cbiAgICAgICAgbWFya3VwID0gW1xuICAgICAgICAgICc8cmFkaWFsR3JhZGllbnQgJyxcbiAgICAgICAgICBjb21tb25BdHRyaWJ1dGVzLFxuICAgICAgICAgICcgY3g9XCInLCBuZWVkc1N3YXAgPyBjb29yZHMueDEgOiBjb29yZHMueDIsXG4gICAgICAgICAgJ1wiIGN5PVwiJywgbmVlZHNTd2FwID8gY29vcmRzLnkxIDogY29vcmRzLnkyLFxuICAgICAgICAgICdcIiByPVwiJywgbmVlZHNTd2FwID8gY29vcmRzLnIxIDogY29vcmRzLnIyLFxuICAgICAgICAgICdcIiBmeD1cIicsIG5lZWRzU3dhcCA/IGNvb3Jkcy54MiA6IGNvb3Jkcy54MSxcbiAgICAgICAgICAnXCIgZnk9XCInLCBuZWVkc1N3YXAgPyBjb29yZHMueTIgOiBjb29yZHMueTEsXG4gICAgICAgICAgJ1wiPlxcbidcbiAgICAgICAgXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgaWYgKG5lZWRzU3dhcCkge1xuICAgICAgICAgIC8vIHN2ZyBnb2VzIGZyb20gaW50ZXJuYWwgdG8gZXh0ZXJuYWwgcmFkaXVzLiBpZiByYWRpdXMgYXJlIGludmVydGVkLCBzd2FwIGNvbG9yIHN0b3BzLlxuICAgICAgICAgIGNvbG9yU3RvcHMgPSBjb2xvclN0b3BzLmNvbmNhdCgpO1xuICAgICAgICAgIGNvbG9yU3RvcHMucmV2ZXJzZSgpO1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvbG9yU3RvcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbG9yU3RvcHNbaV0ub2Zmc2V0ID0gMSAtIGNvbG9yU3RvcHNbaV0ub2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluUmFkaXVzID0gTWF0aC5taW4oY29vcmRzLnIxLCBjb29yZHMucjIpO1xuICAgICAgICBpZiAobWluUmFkaXVzID4gMCkge1xuICAgICAgICAgIC8vIGkgaGF2ZSB0byBzaGlmdCBhbGwgY29sb3JTdG9wcyBhbmQgYWRkIG5ldyBvbmUgaW4gMC5cbiAgICAgICAgICB2YXIgbWF4UmFkaXVzID0gTWF0aC5tYXgoY29vcmRzLnIxLCBjb29yZHMucjIpLFxuICAgICAgICAgICAgICBwZXJjZW50YWdlU2hpZnQgPSBtaW5SYWRpdXMgLyBtYXhSYWRpdXM7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY29sb3JTdG9wcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29sb3JTdG9wc1tpXS5vZmZzZXQgKz0gcGVyY2VudGFnZVNoaWZ0ICogKDEgLSBjb2xvclN0b3BzW2ldLm9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvbG9yU3RvcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbG9yU3RvcCA9IGNvbG9yU3RvcHNbaV07XG4gICAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAgICc8c3RvcCAnLFxuICAgICAgICAgICdvZmZzZXQ9XCInLCAoY29sb3JTdG9wLm9mZnNldCAqIDEwMCkgKyAnJScsXG4gICAgICAgICAgJ1wiIHN0eWxlPVwic3RvcC1jb2xvcjonLCBjb2xvclN0b3AuY29sb3IsXG4gICAgICAgICAgKHR5cGVvZiBjb2xvclN0b3Aub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcgPyAnO3N0b3Atb3BhY2l0eTogJyArIGNvbG9yU3RvcC5vcGFjaXR5IDogJzsnKSxcbiAgICAgICAgICAnXCIvPlxcbidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgbWFya3VwLnB1c2goKHRoaXMudHlwZSA9PT0gJ2xpbmVhcicgPyAnPC9saW5lYXJHcmFkaWVudD5cXG4nIDogJzwvcmFkaWFsR3JhZGllbnQ+XFxuJykpO1xuXG4gICAgICByZXR1cm4gbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIENhbnZhc0dyYWRpZW50XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEByZXR1cm4ge0NhbnZhc0dyYWRpZW50fVxuICAgICAqL1xuICAgIHRvTGl2ZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgZ3JhZGllbnQsIGNvb3JkcyA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZSh0aGlzLmNvb3JkcyksIGksIGxlbjtcblxuICAgICAgaWYgKCF0aGlzLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAnbGluZWFyJykge1xuICAgICAgICBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChcbiAgICAgICAgICBjb29yZHMueDEsIGNvb3Jkcy55MSwgY29vcmRzLngyLCBjb29yZHMueTIpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSAncmFkaWFsJykge1xuICAgICAgICBncmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChcbiAgICAgICAgICBjb29yZHMueDEsIGNvb3Jkcy55MSwgY29vcmRzLnIxLCBjb29yZHMueDIsIGNvb3Jkcy55MiwgY29vcmRzLnIyKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5jb2xvclN0b3BzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjb2xvciA9IHRoaXMuY29sb3JTdG9wc1tpXS5jb2xvcixcbiAgICAgICAgICAgIG9wYWNpdHkgPSB0aGlzLmNvbG9yU3RvcHNbaV0ub3BhY2l0eSxcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuY29sb3JTdG9wc1tpXS5vZmZzZXQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcGFjaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihjb2xvcikuc2V0QWxwaGEob3BhY2l0eSkudG9SZ2JhKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKG9mZnNldCwgY29sb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JhZGllbnQ7XG4gICAgfVxuICB9KTtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5HcmFkaWVudCwge1xuXG4gICAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5HcmFkaWVudH0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkdyYWRpZW50XG4gICAgICogQHBhcmFtIHtTVkdHcmFkaWVudEVsZW1lbnR9IGVsIFNWRyBncmFkaWVudCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5HcmFkaWVudH0gR3JhZGllbnQgaW5zdGFuY2VcbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wc2VydmVycy5odG1sI0xpbmVhckdyYWRpZW50RWxlbWVudFxuICAgICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BzZXJ2ZXJzLmh0bWwjUmFkaWFsR3JhZGllbnRFbGVtZW50XG4gICAgICovXG4gICAgZnJvbUVsZW1lbnQ6IGZ1bmN0aW9uKGVsLCBpbnN0YW5jZSkge1xuICAgICAgLyoqXG4gICAgICAgKiAgQGV4YW1wbGU6XG4gICAgICAgKlxuICAgICAgICogIDxsaW5lYXJHcmFkaWVudCBpZD1cImxpbmVhckdyYWQxXCI+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIwJVwiIHN0b3AtY29sb3I9XCJ3aGl0ZVwiLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjEwMCVcIiBzdG9wLWNvbG9yPVwiYmxhY2tcIi8+XG4gICAgICAgKiAgPC9saW5lYXJHcmFkaWVudD5cbiAgICAgICAqXG4gICAgICAgKiAgT1JcbiAgICAgICAqXG4gICAgICAgKiAgPGxpbmVhckdyYWRpZW50IGlkPVwibGluZWFyR3JhZDJcIj5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjBcIiBzdHlsZT1cInN0b3AtY29sb3I6cmdiKDI1NSwyNTUsMjU1KVwiLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjFcIiBzdHlsZT1cInN0b3AtY29sb3I6cmdiKDAsMCwwKVwiLz5cbiAgICAgICAqICA8L2xpbmVhckdyYWRpZW50PlxuICAgICAgICpcbiAgICAgICAqICBPUlxuICAgICAgICpcbiAgICAgICAqICA8cmFkaWFsR3JhZGllbnQgaWQ9XCJyYWRpYWxHcmFkMVwiPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMCVcIiBzdG9wLWNvbG9yPVwid2hpdGVcIiBzdG9wLW9wYWNpdHk9XCIxXCIgLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjUwJVwiIHN0b3AtY29sb3I9XCJibGFja1wiIHN0b3Atb3BhY2l0eT1cIjAuNVwiIC8+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIxMDAlXCIgc3RvcC1jb2xvcj1cIndoaXRlXCIgc3RvcC1vcGFjaXR5PVwiMVwiIC8+XG4gICAgICAgKiAgPC9yYWRpYWxHcmFkaWVudD5cbiAgICAgICAqXG4gICAgICAgKiAgT1JcbiAgICAgICAqXG4gICAgICAgKiAgPHJhZGlhbEdyYWRpZW50IGlkPVwicmFkaWFsR3JhZDJcIj5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjBcIiBzdG9wLWNvbG9yPVwicmdiKDI1NSwyNTUsMjU1KVwiIC8+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIwLjVcIiBzdG9wLWNvbG9yPVwicmdiKDAsMCwwKVwiIC8+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIxXCIgc3RvcC1jb2xvcj1cInJnYigyNTUsMjU1LDI1NSlcIiAvPlxuICAgICAgICogIDwvcmFkaWFsR3JhZGllbnQ+XG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHZhciBjb2xvclN0b3BFbHMgPSBlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3RvcCcpLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZ3JhZGllbnRVbml0cyA9IGVsLmdldEF0dHJpYnV0ZSgnZ3JhZGllbnRVbml0cycpIHx8ICdvYmplY3RCb3VuZGluZ0JveCcsXG4gICAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm0gPSBlbC5nZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VHJhbnNmb3JtJyksXG4gICAgICAgICAgY29sb3JTdG9wcyA9IFtdLFxuICAgICAgICAgIGNvb3JkcywgZWxsaXBzZU1hdHJpeCwgaTtcblxuICAgICAgaWYgKGVsLm5vZGVOYW1lID09PSAnbGluZWFyR3JhZGllbnQnIHx8IGVsLm5vZGVOYW1lID09PSAnTElORUFSR1JBRElFTlQnKSB7XG4gICAgICAgIHR5cGUgPSAnbGluZWFyJztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0eXBlID0gJ3JhZGlhbCc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSAnbGluZWFyJykge1xuICAgICAgICBjb29yZHMgPSBnZXRMaW5lYXJDb29yZHMoZWwpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgY29vcmRzID0gZ2V0UmFkaWFsQ29vcmRzKGVsKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gY29sb3JTdG9wRWxzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgY29sb3JTdG9wcy5wdXNoKGdldENvbG9yU3RvcChjb2xvclN0b3BFbHNbaV0pKTtcbiAgICAgIH1cblxuICAgICAgZWxsaXBzZU1hdHJpeCA9IF9jb252ZXJ0UGVyY2VudFVuaXRzVG9WYWx1ZXMoaW5zdGFuY2UsIGNvb3JkcywgZ3JhZGllbnRVbml0cyk7XG5cbiAgICAgIHZhciBncmFkaWVudCA9IG5ldyBmYWJyaWMuR3JhZGllbnQoe1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBjb29yZHM6IGNvb3JkcyxcbiAgICAgICAgY29sb3JTdG9wczogY29sb3JTdG9wcyxcbiAgICAgICAgb2Zmc2V0WDogLWluc3RhbmNlLmxlZnQsXG4gICAgICAgIG9mZnNldFk6IC1pbnN0YW5jZS50b3BcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZ3JhZGllbnRUcmFuc2Zvcm0gfHwgZWxsaXBzZU1hdHJpeCAhPT0gJycpIHtcbiAgICAgICAgZ3JhZGllbnQuZ3JhZGllbnRUcmFuc2Zvcm0gPSBmYWJyaWMucGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUoKGdyYWRpZW50VHJhbnNmb3JtIHx8ICcnKSArIGVsbGlwc2VNYXRyaXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JhZGllbnQ7XG4gICAgfSxcbiAgICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkdyYWRpZW50fSBpbnN0YW5jZSBmcm9tIGl0cyBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5HcmFkaWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZm9yT2JqZWN0OiBmdW5jdGlvbihvYmosIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgX2NvbnZlcnRQZXJjZW50VW5pdHNUb1ZhbHVlcyhvYmosIG9wdGlvbnMuY29vcmRzLCAndXNlclNwYWNlT25Vc2UnKTtcbiAgICAgIHJldHVybiBuZXcgZmFicmljLkdyYWRpZW50KG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfY29udmVydFBlcmNlbnRVbml0c1RvVmFsdWVzKG9iamVjdCwgb3B0aW9ucywgZ3JhZGllbnRVbml0cykge1xuICAgIHZhciBwcm9wVmFsdWUsIGFkZEZhY3RvciA9IDAsIG11bHRGYWN0b3IgPSAxLCBlbGxpcHNlTWF0cml4ID0gJyc7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9uc1twcm9wXSA9PT0gJ0luZmluaXR5Jykge1xuICAgICAgICBvcHRpb25zW3Byb3BdID0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wdGlvbnNbcHJvcF0gPT09ICctSW5maW5pdHknKSB7XG4gICAgICAgIG9wdGlvbnNbcHJvcF0gPSAwO1xuICAgICAgfVxuICAgICAgcHJvcFZhbHVlID0gcGFyc2VGbG9hdChvcHRpb25zW3Byb3BdLCAxMCk7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnNbcHJvcF0gPT09ICdzdHJpbmcnICYmIC9eKFxcZCtcXC5cXGQrKSV8KFxcZCspJSQvLnRlc3Qob3B0aW9uc1twcm9wXSkpIHtcbiAgICAgICAgbXVsdEZhY3RvciA9IDAuMDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbXVsdEZhY3RvciA9IDE7XG4gICAgICB9XG4gICAgICBpZiAocHJvcCA9PT0gJ3gxJyB8fCBwcm9wID09PSAneDInIHx8IHByb3AgPT09ICdyMicpIHtcbiAgICAgICAgbXVsdEZhY3RvciAqPSBncmFkaWVudFVuaXRzID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnID8gb2JqZWN0LndpZHRoIDogMTtcbiAgICAgICAgYWRkRmFjdG9yID0gZ3JhZGllbnRVbml0cyA9PT0gJ29iamVjdEJvdW5kaW5nQm94JyA/IG9iamVjdC5sZWZ0IHx8IDAgOiAwO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocHJvcCA9PT0gJ3kxJyB8fCBwcm9wID09PSAneTInKSB7XG4gICAgICAgIG11bHRGYWN0b3IgKj0gZ3JhZGllbnRVbml0cyA9PT0gJ29iamVjdEJvdW5kaW5nQm94JyA/IG9iamVjdC5oZWlnaHQgOiAxO1xuICAgICAgICBhZGRGYWN0b3IgPSBncmFkaWVudFVuaXRzID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnID8gb2JqZWN0LnRvcCB8fCAwIDogMDtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnNbcHJvcF0gPSBwcm9wVmFsdWUgKiBtdWx0RmFjdG9yICsgYWRkRmFjdG9yO1xuICAgIH1cbiAgICBpZiAob2JqZWN0LnR5cGUgPT09ICdlbGxpcHNlJyAmJlxuICAgICAgICBvcHRpb25zLnIyICE9PSBudWxsICYmXG4gICAgICAgIGdyYWRpZW50VW5pdHMgPT09ICdvYmplY3RCb3VuZGluZ0JveCcgJiZcbiAgICAgICAgb2JqZWN0LnJ4ICE9PSBvYmplY3QucnkpIHtcblxuICAgICAgdmFyIHNjYWxlRmFjdG9yID0gb2JqZWN0LnJ5IC8gb2JqZWN0LnJ4O1xuICAgICAgZWxsaXBzZU1hdHJpeCA9ICcgc2NhbGUoMSwgJyArIHNjYWxlRmFjdG9yICsgJyknO1xuICAgICAgaWYgKG9wdGlvbnMueTEpIHtcbiAgICAgICAgb3B0aW9ucy55MSAvPSBzY2FsZUZhY3RvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnkyKSB7XG4gICAgICAgIG9wdGlvbnMueTIgLz0gc2NhbGVGYWN0b3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGxpcHNlTWF0cml4O1xuICB9XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkO1xuXG4gIC8qKlxuICAgKiBQYXR0ZXJuIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUGF0dGVyblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL3BhdHRlcm5zfFBhdHRlcm4gZGVtb31cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9keW5hbWljLXBhdHRlcm5zfER5bmFtaWNQYXR0ZXJuIGRlbW99XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5QYXR0ZXJuI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuXG5cbiAgZmFicmljLlBhdHRlcm4gPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcygvKiogQGxlbmRzIGZhYnJpYy5QYXR0ZXJuLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBSZXBlYXQgcHJvcGVydHkgb2YgYSBwYXR0ZXJuIChvbmUgb2YgcmVwZWF0LCByZXBlYXQteCwgcmVwZWF0LXkgb3Igbm8tcmVwZWF0KVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcmVwZWF0OiAncmVwZWF0JyxcblxuICAgIC8qKlxuICAgICAqIFBhdHRlcm4gaG9yaXpvbnRhbCBvZmZzZXQgZnJvbSBvYmplY3QncyBsZWZ0L3RvcCBjb3JuZXJcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9mZnNldFg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBQYXR0ZXJuIHZlcnRpY2FsIG9mZnNldCBmcm9tIG9iamVjdCdzIGxlZnQvdG9wIGNvcm5lclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb2Zmc2V0WTogMCxcblxuICAgIC8qKlxuICAgICAqIGNyb3NzT3JpZ2luIHZhbHVlIChvbmUgb2YgXCJcIiwgXCJhbm9ueW1vdXNcIiwgXCJ1c2UtY3JlZGVudGlhbHNcIilcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNyb3NzT3JpZ2luOiAnJyxcblxuICAgIC8qKlxuICAgICAqIHRyYW5zZm9ybSBtYXRyaXggdG8gY2hhbmdlIHRoZSBwYXR0ZXJuLCBpbXBvcnRlZCBmcm9tIHN2Z3MuXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhdHRlcm5UcmFuc2Zvcm06IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIGZ1bmN0aW9uIHRvIGludm9rZSBhZnRlciBjYWxsYmFjayBpbml0LlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5QYXR0ZXJufSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB0aGlzLmlkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgaWYgKCFvcHRpb25zLnNvdXJjZSB8fCAob3B0aW9ucy5zb3VyY2UgJiYgdHlwZW9mIG9wdGlvbnMuc291cmNlICE9PSAnc3RyaW5nJykpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sodGhpcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGZ1bmN0aW9uIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBmYWJyaWMudXRpbC5nZXRGdW5jdGlvbkJvZHkob3B0aW9ucy5zb3VyY2UpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IG5ldyBGdW5jdGlvbihmYWJyaWMudXRpbC5nZXRGdW5jdGlvbkJvZHkob3B0aW9ucy5zb3VyY2UpKTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sodGhpcyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gaW1nIHNyYyBzdHJpbmdcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBmYWJyaWMudXRpbC5jcmVhdGVJbWFnZSgpO1xuICAgICAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2Uob3B0aW9ucy5zb3VyY2UsIGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgIF90aGlzLnNvdXJjZSA9IGltZztcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhfdGhpcyk7XG4gICAgICAgIH0sIG51bGwsIHRoaXMuY3Jvc3NPcmlnaW4pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHBhdHRlcm5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBwYXR0ZXJuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTLFxuICAgICAgICAgIHNvdXJjZSwgb2JqZWN0O1xuXG4gICAgICAvLyBjYWxsYmFja1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzb3VyY2UgPSBTdHJpbmcodGhpcy5zb3VyY2UpO1xuICAgICAgfVxuICAgICAgLy8gPGltZz4gZWxlbWVudFxuICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuc291cmNlLnNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc291cmNlID0gdGhpcy5zb3VyY2Uuc3JjO1xuICAgICAgfVxuICAgICAgLy8gPGNhbnZhcz4gZWxlbWVudFxuICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuc291cmNlID09PSAnb2JqZWN0JyAmJiB0aGlzLnNvdXJjZS50b0RhdGFVUkwpIHtcbiAgICAgICAgc291cmNlID0gdGhpcy5zb3VyY2UudG9EYXRhVVJMKCk7XG4gICAgICB9XG5cbiAgICAgIG9iamVjdCA9IHtcbiAgICAgICAgdHlwZTogJ3BhdHRlcm4nLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgcmVwZWF0OiB0aGlzLnJlcGVhdCxcbiAgICAgICAgY3Jvc3NPcmlnaW46IHRoaXMuY3Jvc3NPcmlnaW4sXG4gICAgICAgIG9mZnNldFg6IHRvRml4ZWQodGhpcy5vZmZzZXRYLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgb2Zmc2V0WTogdG9GaXhlZCh0aGlzLm9mZnNldFksIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICBwYXR0ZXJuVHJhbnNmb3JtOiB0aGlzLnBhdHRlcm5UcmFuc2Zvcm0gPyB0aGlzLnBhdHRlcm5UcmFuc2Zvcm0uY29uY2F0KCkgOiBudWxsXG4gICAgICB9O1xuICAgICAgZmFicmljLnV0aWwucG9wdWxhdGVXaXRoUHJvcGVydGllcyh0aGlzLCBvYmplY3QsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGEgcGF0dGVyblxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTVkcgcmVwcmVzZW50YXRpb24gb2YgYSBwYXR0ZXJuXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHBhdHRlcm5Tb3VyY2UgPSB0eXBlb2YgdGhpcy5zb3VyY2UgPT09ICdmdW5jdGlvbicgPyB0aGlzLnNvdXJjZSgpIDogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgcGF0dGVybldpZHRoID0gcGF0dGVyblNvdXJjZS53aWR0aCAvIG9iamVjdC53aWR0aCxcbiAgICAgICAgICBwYXR0ZXJuSGVpZ2h0ID0gcGF0dGVyblNvdXJjZS5oZWlnaHQgLyBvYmplY3QuaGVpZ2h0LFxuICAgICAgICAgIHBhdHRlcm5PZmZzZXRYID0gdGhpcy5vZmZzZXRYIC8gb2JqZWN0LndpZHRoLFxuICAgICAgICAgIHBhdHRlcm5PZmZzZXRZID0gdGhpcy5vZmZzZXRZIC8gb2JqZWN0LmhlaWdodCxcbiAgICAgICAgICBwYXR0ZXJuSW1nU3JjID0gJyc7XG4gICAgICBpZiAodGhpcy5yZXBlYXQgPT09ICdyZXBlYXQteCcgfHwgdGhpcy5yZXBlYXQgPT09ICduby1yZXBlYXQnKSB7XG4gICAgICAgIHBhdHRlcm5IZWlnaHQgPSAxO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVwZWF0ID09PSAncmVwZWF0LXknIHx8IHRoaXMucmVwZWF0ID09PSAnbm8tcmVwZWF0Jykge1xuICAgICAgICBwYXR0ZXJuV2lkdGggPSAxO1xuICAgICAgfVxuICAgICAgaWYgKHBhdHRlcm5Tb3VyY2Uuc3JjKSB7XG4gICAgICAgIHBhdHRlcm5JbWdTcmMgPSBwYXR0ZXJuU291cmNlLnNyYztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHBhdHRlcm5Tb3VyY2UudG9EYXRhVVJMKSB7XG4gICAgICAgIHBhdHRlcm5JbWdTcmMgPSBwYXR0ZXJuU291cmNlLnRvRGF0YVVSTCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJzxwYXR0ZXJuIGlkPVwiU1ZHSURfJyArIHRoaXMuaWQgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgeD1cIicgKyBwYXR0ZXJuT2Zmc2V0WCArXG4gICAgICAgICAgICAgICAgICAgICdcIiB5PVwiJyArIHBhdHRlcm5PZmZzZXRZICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIHdpZHRoPVwiJyArIHBhdHRlcm5XaWR0aCArXG4gICAgICAgICAgICAgICAgICAgICdcIiBoZWlnaHQ9XCInICsgcGF0dGVybkhlaWdodCArICdcIj5cXG4nICtcbiAgICAgICAgICAgICAgICc8aW1hZ2UgeD1cIjBcIiB5PVwiMFwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgJyB3aWR0aD1cIicgKyBwYXR0ZXJuU291cmNlLndpZHRoICtcbiAgICAgICAgICAgICAgICAgICAgICAnXCIgaGVpZ2h0PVwiJyArIHBhdHRlcm5Tb3VyY2UuaGVpZ2h0ICtcbiAgICAgICAgICAgICAgICAgICAgICAnXCIgeGxpbms6aHJlZj1cIicgKyBwYXR0ZXJuSW1nU3JjICtcbiAgICAgICAgICAgICAgICdcIj48L2ltYWdlPlxcbicgK1xuICAgICAgICAgICAgICc8L3BhdHRlcm4+XFxuJztcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgc2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXNbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIENhbnZhc1BhdHRlcm5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gY3JlYXRlIHBhdHRlcm5cbiAgICAgKiBAcmV0dXJuIHtDYW52YXNQYXR0ZXJufVxuICAgICAqL1xuICAgIHRvTGl2ZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgc291cmNlID0gdHlwZW9mIHRoaXMuc291cmNlID09PSAnZnVuY3Rpb24nID8gdGhpcy5zb3VyY2UoKSA6IHRoaXMuc291cmNlO1xuXG4gICAgICAvLyBpZiB0aGUgaW1hZ2UgZmFpbGVkIHRvIGxvYWQsIHJldHVybiwgYW5kIGFsbG93IHJlc3QgdG8gY29udGludWUgbG9hZGluZ1xuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBhbiBpbWFnZVxuICAgICAgaWYgKHR5cGVvZiBzb3VyY2Uuc3JjICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoIXNvdXJjZS5jb21wbGV0ZSkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlLm5hdHVyYWxXaWR0aCA9PT0gMCB8fCBzb3VyY2UubmF0dXJhbEhlaWdodCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHNvdXJjZSwgdGhpcy5yZXBlYXQpO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgaWYgKGZhYnJpYy5TaGFkb3cpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlNoYWRvdyBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFNoYWRvdyBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlNoYWRvd1xuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL3NoYWRvd3N8U2hhZG93IGRlbW99XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5TaGFkb3cjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5TaGFkb3cgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcygvKiogQGxlbmRzIGZhYnJpYy5TaGFkb3cucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBjb2xvclxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29sb3I6ICdyZ2IoMCwwLDApJyxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBibHVyXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgYmx1cjogMCxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBob3Jpem9udGFsIG9mZnNldFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb2Zmc2V0WDogMCxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyB2ZXJ0aWNhbCBvZmZzZXRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9mZnNldFk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBzaGFkb3cgc2hvdWxkIGFmZmVjdCBzdHJva2Ugb3BlcmF0aW9uc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFmZmVjdFN0cm9rZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0b09iamVjdCBzaG91bGQgaW5jbHVkZSBkZWZhdWx0IHZhbHVlc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGluY2x1ZGVEZWZhdWx0VmFsdWVzOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCB3aXRoIGFueSBvZiBjb2xvciwgYmx1ciwgb2Zmc2V0WCwgb2Zmc2V0WSBwcm9wZXJ0aWVzIG9yIHN0cmluZyAoZS5nLiBcInJnYmEoMCwwLDAsMC4yKSAycHggMnB4IDEwcHhcIilcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuU2hhZG93fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLl9wYXJzZVNoYWRvdyhvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXNbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaGFkb3cgU2hhZG93IHZhbHVlIHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBTaGFkb3cgb2JqZWN0IHdpdGggY29sb3IsIG9mZnNldFgsIG9mZnNldFkgYW5kIGJsdXJcbiAgICAgKi9cbiAgICBfcGFyc2VTaGFkb3c6IGZ1bmN0aW9uKHNoYWRvdykge1xuICAgICAgdmFyIHNoYWRvd1N0ciA9IHNoYWRvdy50cmltKCksXG4gICAgICAgICAgb2Zmc2V0c0FuZEJsdXIgPSBmYWJyaWMuU2hhZG93LnJlT2Zmc2V0c0FuZEJsdXIuZXhlYyhzaGFkb3dTdHIpIHx8IFtdLFxuICAgICAgICAgIGNvbG9yID0gc2hhZG93U3RyLnJlcGxhY2UoZmFicmljLlNoYWRvdy5yZU9mZnNldHNBbmRCbHVyLCAnJykgfHwgJ3JnYigwLDAsMCknO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2xvcjogY29sb3IudHJpbSgpLFxuICAgICAgICBvZmZzZXRYOiBwYXJzZUludChvZmZzZXRzQW5kQmx1clsxXSwgMTApIHx8IDAsXG4gICAgICAgIG9mZnNldFk6IHBhcnNlSW50KG9mZnNldHNBbmRCbHVyWzJdLCAxMCkgfHwgMCxcbiAgICAgICAgYmx1cjogcGFyc2VJbnQob2Zmc2V0c0FuZEJsdXJbM10sIDEwKSB8fCAwXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MtdGV4dC1kZWNvci0zLyN0ZXh0LXNoYWRvd1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBDU1MzIHRleHQtc2hhZG93IGRlY2xhcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLm9mZnNldFgsIHRoaXMub2Zmc2V0WSwgdGhpcy5ibHVyLCB0aGlzLmNvbG9yXS5qb2luKCdweCAnKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhIHNoYWRvd1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTVkcgcmVwcmVzZW50YXRpb24gb2YgYSBzaGFkb3dcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgZkJveFggPSA0MCwgZkJveFkgPSA0MCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyxcbiAgICAgICAgICBvZmZzZXQgPSBmYWJyaWMudXRpbC5yb3RhdGVWZWN0b3IoXG4gICAgICAgICAgICB7IHg6IHRoaXMub2Zmc2V0WCwgeTogdGhpcy5vZmZzZXRZIH0sXG4gICAgICAgICAgICBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKC1vYmplY3QuYW5nbGUpKSxcbiAgICAgICAgICBCTFVSX0JPWCA9IDIwLCBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcik7XG5cbiAgICAgIGlmIChvYmplY3Qud2lkdGggJiYgb2JqZWN0LmhlaWdodCkge1xuICAgICAgICAvL2h0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9maWx0ZXJzLmh0bWwjRmlsdGVyRWZmZWN0c1JlZ2lvblxuICAgICAgICAvLyB3ZSBhZGQgc29tZSBleHRyYSBzcGFjZSB0byBmaWx0ZXIgYm94IHRvIGNvbnRhaW4gdGhlIGJsdXIgKCAyMCApXG4gICAgICAgIGZCb3hYID0gdG9GaXhlZCgoTWF0aC5hYnMob2Zmc2V0LngpICsgdGhpcy5ibHVyKSAvIG9iamVjdC53aWR0aCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKiAxMDAgKyBCTFVSX0JPWDtcbiAgICAgICAgZkJveFkgPSB0b0ZpeGVkKChNYXRoLmFicyhvZmZzZXQueSkgKyB0aGlzLmJsdXIpIC8gb2JqZWN0LmhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKiAxMDAgKyBCTFVSX0JPWDtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuZmxpcFgpIHtcbiAgICAgICAgb2Zmc2V0LnggKj0gLTE7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmZsaXBZKSB7XG4gICAgICAgIG9mZnNldC55ICo9IC0xO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICAnPGZpbHRlciBpZD1cIlNWR0lEXycgKyB0aGlzLmlkICsgJ1wiIHk9XCItJyArIGZCb3hZICsgJyVcIiBoZWlnaHQ9XCInICsgKDEwMCArIDIgKiBmQm94WSkgKyAnJVwiICcgK1xuICAgICAgICAgICd4PVwiLScgKyBmQm94WCArICclXCIgd2lkdGg9XCInICsgKDEwMCArIDIgKiBmQm94WCkgKyAnJVwiICcgKyAnPlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVHYXVzc2lhbkJsdXIgaW49XCJTb3VyY2VBbHBoYVwiIHN0ZERldmlhdGlvbj1cIicgK1xuICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmJsdXIgPyB0aGlzLmJsdXIgLyAyIDogMCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnXCI+PC9mZUdhdXNzaWFuQmx1cj5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlT2Zmc2V0IGR4PVwiJyArIHRvRml4ZWQob2Zmc2V0LngsIE5VTV9GUkFDVElPTl9ESUdJVFMpICtcbiAgICAgICAgICAnXCIgZHk9XCInICsgdG9GaXhlZChvZmZzZXQueSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnXCIgcmVzdWx0PVwib0JsdXJcIiA+PC9mZU9mZnNldD5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlRmxvb2QgZmxvb2QtY29sb3I9XCInICsgY29sb3IudG9SZ2IoKSArICdcIiBmbG9vZC1vcGFjaXR5PVwiJyArIGNvbG9yLmdldEFscGhhKCkgKyAnXCIvPlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVDb21wb3NpdGUgaW4yPVwib0JsdXJcIiBvcGVyYXRvcj1cImluXCIgLz5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlTWVyZ2U+XFxuJyArXG4gICAgICAgICAgICAnXFx0XFx0PGZlTWVyZ2VOb2RlPjwvZmVNZXJnZU5vZGU+XFxuJyArXG4gICAgICAgICAgICAnXFx0XFx0PGZlTWVyZ2VOb2RlIGluPVwiU291cmNlR3JhcGhpY1wiPjwvZmVNZXJnZU5vZGU+XFxuJyArXG4gICAgICAgICAgJ1xcdDwvZmVNZXJnZT5cXG4nICtcbiAgICAgICAgJzwvZmlsdGVyPlxcbicpO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHNoYWRvd1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgc2hhZG93IGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgICBibHVyOiB0aGlzLmJsdXIsXG4gICAgICAgICAgb2Zmc2V0WDogdGhpcy5vZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFk6IHRoaXMub2Zmc2V0WSxcbiAgICAgICAgICBhZmZlY3RTdHJva2U6IHRoaXMuYWZmZWN0U3Ryb2tlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0geyB9LCBwcm90byA9IGZhYnJpYy5TaGFkb3cucHJvdG90eXBlO1xuXG4gICAgICBbJ2NvbG9yJywgJ2JsdXInLCAnb2Zmc2V0WCcsICdvZmZzZXRZJywgJ2FmZmVjdFN0cm9rZSddLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICBpZiAodGhpc1twcm9wXSAhPT0gcHJvdG9bcHJvcF0pIHtcbiAgICAgICAgICBvYmpbcHJvcF0gPSB0aGlzW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZWdleCBtYXRjaGluZyBzaGFkb3cgb2Zmc2V0WCwgb2Zmc2V0WSBhbmQgYmx1ciAoZXg6IFwiMnB4IDJweCAxMHB4IHJnYmEoMCwwLDAsMC4yKVwiLCBcInJnYigwLDI1NSwwKSAycHggMnB4XCIpXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuU2hhZG93XG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBmYWJyaWMuU2hhZG93LnJlT2Zmc2V0c0FuZEJsdXIgPSAvKD86XFxzfF4pKC0/XFxkKyg/OnB4KT8oPzpcXHM/fCQpKT8oLT9cXGQrKD86cHgpPyg/Olxccz98JCkpPyhcXGQrKD86cHgpPyk/KD86XFxzP3wkKSg/OiR8XFxzKS87XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24gKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAoZmFicmljLlN0YXRpY0NhbnZhcykge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuU3RhdGljQ2FudmFzIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBhbGlhc2VzIGZvciBmYXN0ZXIgcmVzb2x1dGlvblxuICB2YXIgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGdldEVsZW1lbnRPZmZzZXQgPSBmYWJyaWMudXRpbC5nZXRFbGVtZW50T2Zmc2V0LFxuICAgICAgcmVtb3ZlRnJvbUFycmF5ID0gZmFicmljLnV0aWwucmVtb3ZlRnJvbUFycmF5LFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQsXG4gICAgICB0cmFuc2Zvcm1Qb2ludCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50LFxuICAgICAgaW52ZXJ0VHJhbnNmb3JtID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtLFxuXG4gICAgICBDQU5WQVNfSU5JVF9FUlJPUiA9IG5ldyBFcnJvcignQ291bGQgbm90IGluaXRpYWxpemUgYGNhbnZhc2AgZWxlbWVudCcpO1xuXG4gIC8qKlxuICAgKiBTdGF0aWMgY2FudmFzIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuU3RhdGljQ2FudmFzXG4gICAqIEBtaXhlcyBmYWJyaWMuQ29sbGVjdGlvblxuICAgKiBAbWl4ZXMgZmFicmljLk9ic2VydmFibGVcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9zdGF0aWNfY2FudmFzfFN0YXRpY0NhbnZhcyBkZW1vfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBmaXJlcyBiZWZvcmU6cmVuZGVyXG4gICAqIEBmaXJlcyBhZnRlcjpyZW5kZXJcbiAgICogQGZpcmVzIGNhbnZhczpjbGVhcmVkXG4gICAqIEBmaXJlcyBvYmplY3Q6YWRkZWRcbiAgICogQGZpcmVzIG9iamVjdDpyZW1vdmVkXG4gICAqL1xuICBmYWJyaWMuU3RhdGljQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkNvbW1vbk1ldGhvZHMsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgU3RyaW5nfSBlbCAmbHQ7Y2FudmFzPiBlbGVtZW50IHRvIGluaXRpYWxpemUgaW5zdGFuY2Ugb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgdGhpcy5yZW5kZXJBbmRSZXNldEJvdW5kID0gdGhpcy5yZW5kZXJBbmRSZXNldC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsQm91bmQgPSB0aGlzLnJlcXVlc3RSZW5kZXJBbGwuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2luaXRTdGF0aWMoZWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIGNvbG9yIG9mIGNhbnZhcyBpbnN0YW5jZS5cbiAgICAgKiBTaG91bGQgYmUgc2V0IHZpYSB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNzZXRCYWNrZ3JvdW5kQ29sb3J9LlxuICAgICAqIEB0eXBlIHsoU3RyaW5nfGZhYnJpYy5QYXR0ZXJuKX1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJhY2tncm91bmRDb2xvcjogJycsXG5cbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIGltYWdlIG9mIGNhbnZhcyBpbnN0YW5jZS5cbiAgICAgKiBTaG91bGQgYmUgc2V0IHZpYSB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNzZXRCYWNrZ3JvdW5kSW1hZ2V9LlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoZSBcImJhY2tncm91bmRJbWFnZU9wYWNpdHlcIlxuICAgICAqIGFuZCBcImJhY2tncm91bmRJbWFnZVN0cmV0Y2hcIiBwcm9wZXJ0aWVzIGFyZSBkZXByZWNhdGVkIHNpbmNlIDEuMy45LlxuICAgICAqIFVzZSB7QGxpbmsgZmFicmljLkltYWdlI29wYWNpdHl9LCB7QGxpbmsgZmFicmljLkltYWdlI3dpZHRofSBhbmQge0BsaW5rIGZhYnJpYy5JbWFnZSNoZWlnaHR9LlxuICAgICAqIEB0eXBlIGZhYnJpYy5JbWFnZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYmFja2dyb3VuZEltYWdlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogT3ZlcmxheSBjb2xvciBvZiBjYW52YXMgaW5zdGFuY2UuXG4gICAgICogU2hvdWxkIGJlIHNldCB2aWEge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjc2V0T3ZlcmxheUNvbG9yfVxuICAgICAqIEBzaW5jZSAxLjMuOVxuICAgICAqIEB0eXBlIHsoU3RyaW5nfGZhYnJpYy5QYXR0ZXJuKX1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG92ZXJsYXlDb2xvcjogJycsXG5cbiAgICAvKipcbiAgICAgKiBPdmVybGF5IGltYWdlIG9mIGNhbnZhcyBpbnN0YW5jZS5cbiAgICAgKiBTaG91bGQgYmUgc2V0IHZpYSB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNzZXRPdmVybGF5SW1hZ2V9LlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoZSBcIm92ZXJsYXlJbWFnZUxlZnRcIlxuICAgICAqIGFuZCBcIm92ZXJsYXlJbWFnZVRvcFwiIHByb3BlcnRpZXMgYXJlIGRlcHJlY2F0ZWQgc2luY2UgMS4zLjkuXG4gICAgICogVXNlIHtAbGluayBmYWJyaWMuSW1hZ2UjbGVmdH0gYW5kIHtAbGluayBmYWJyaWMuSW1hZ2UjdG9wfS5cbiAgICAgKiBAdHlwZSBmYWJyaWMuSW1hZ2VcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG92ZXJsYXlJbWFnZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRvT2JqZWN0L3RvRGF0YWxlc3NPYmplY3Qgc2hvdWxkIGluY2x1ZGUgZGVmYXVsdCB2YWx1ZXNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbmNsdWRlRGVmYXVsdFZhbHVlczogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIG9iamVjdHMnIHN0YXRlIHNob3VsZCBiZSBzYXZlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0YXRlZnVsOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHtAbGluayBmYWJyaWMuQ29sbGVjdGlvbi5hZGR9LCB7QGxpbmsgZmFicmljLkNvbGxlY3Rpb24uaW5zZXJ0QXR9IGFuZCB7QGxpbmsgZmFicmljLkNvbGxlY3Rpb24ucmVtb3ZlfSxcbiAgICAgKiB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcy5tb3ZlVG99LCB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcy5jbGVhcn0gYW5kIG1hbnkgbW9yZSwgc2hvdWxkIGFsc28gcmUtcmVuZGVyIGNhbnZhcy5cbiAgICAgKiBEaXNhYmxpbmcgdGhpcyBvcHRpb24gd2lsbCBub3QgZ2l2ZSBhIHBlcmZvcm1hbmNlIGJvb3N0IHdoZW4gYWRkaW5nL3JlbW92aW5nIGEgbG90IG9mIG9iamVjdHMgdG8vZnJvbSBjYW52YXMgYXQgb25jZVxuICAgICAqIHNpbmNlIHRoZSByZW5kZXJzIGFyZSBxdWVxdWVkIGFuZCBleGVjdXRlZCBvbmUgcGVyIGZyYW1lLlxuICAgICAqIERpc2FibGluZyBpcyBzdWdnZXN0ZWQgYW55d2F5IGFuZCBtYW5hZ2luZyB0aGUgcmVuZGVycyBvZiB0aGUgYXBwIG1hbnVhbGx5IGlzIG5vdCBhIGJpZyBlZmZvcnQgKCBjYW52YXMucmVxdWVzdFJlbmRlckFsbCgpIClcbiAgICAgKiBMZWZ0IGRlZmF1bHQgdG8gdHJ1ZSB0byBkbyBub3QgYnJlYWsgZG9jdW1lbnRhdGlvbiBhbmQgb2xkIGFwcCwgZmlkZGxlcy5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByZW5kZXJPbkFkZFJlbW92ZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyBjbGlwcGluZyBvZiBlbnRpcmUgY2FudmFzIGFyZWFcbiAgICAgKiBCZWluZyBwYXNzZWQgY29udGV4dCBhcyBmaXJzdCBhcmd1bWVudC4gU2VlIGNsaXBwaW5nIGNhbnZhcyBhcmVhIGluIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20va2FuZ2F4L2ZhYnJpYy5qcy93aWtpL0ZBUX1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSAyLjAuMFxuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjbGlwVG86IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvYmplY3QgY29udHJvbHMgKGJvcmRlcnMvY29udHJvbHMpIGFyZSByZW5kZXJlZCBhYm92ZSBvdmVybGF5IGltYWdlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29udHJvbHNBYm92ZU92ZXJsYXk6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGJyb3dzZXIgY2FuIGJlIHNjcm9sbGVkIHdoZW4gdXNpbmcgYSB0b3VjaHNjcmVlbiBhbmQgZHJhZ2dpbmcgb24gdGhlIGNhbnZhc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFsbG93VG91Y2hTY3JvbGxpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBjYW52YXMgd2lsbCB1c2UgaW1hZ2Ugc21vb3RoaW5nLCB0aGlzIGlzIG9uIGJ5IGRlZmF1bHQgaW4gYnJvd3NlcnNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbWFnZVNtb290aGluZ0VuYWJsZWQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNmb3JtYXRpb24gKGluIHRoZSBmb3JtYXQgb2YgQ2FudmFzIHRyYW5zZm9ybSkgd2hpY2ggZm9jdXNlcyB0aGUgdmlld3BvcnRcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdmlld3BvcnRUcmFuc2Zvcm06IGZhYnJpYy5pTWF0cml4LmNvbmNhdCgpLFxuXG4gICAgLyoqXG4gICAgICogaWYgc2V0IHRvIGZhbHNlIGJhY2tncm91bmQgaW1hZ2UgaXMgbm90IGFmZmVjdGVkIGJ5IHZpZXdwb3J0IHRyYW5zZm9ybVxuICAgICAqIEBzaW5jZSAxLjYuM1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJhY2tncm91bmRWcHQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBpZiBzZXQgdG8gZmFsc2Ugb3Zlcmx5YSBpbWFnZSBpcyBub3QgYWZmZWN0ZWQgYnkgdmlld3BvcnQgdHJhbnNmb3JtXG4gICAgICogQHNpbmNlIDEuNi4zXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3ZlcmxheVZwdDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrOyBpbnZva2VkIHJpZ2h0IGJlZm9yZSBvYmplY3QgaXMgYWJvdXQgdG8gYmUgc2NhbGVkL3JvdGF0ZWRcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSAyLjMuMFxuICAgICAqIFVzZSBiZWZvcmU6dHJhbnNmb3JtIGV2ZW50XG4gICAgICovXG4gICAgb25CZWZvcmVTY2FsZVJvdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgLyogTk9PUCAqL1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGNhbnZhcyBpcyBzY2FsZWQgYnkgZGV2aWNlUGl4ZWxSYXRpbyBmb3IgYmV0dGVyIHJlbmRlcmluZyBvbiByZXRpbmEgc2NyZWVuc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGVuYWJsZVJldGluYVNjYWxpbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSBjYW52YXMgZWxlbWVudCBleHRlbnNpb24gb3ZlciBkZXNpZ25cbiAgICAgKiBwcm9wZXJ0aWVzIGFyZSB0bCx0cixibCxici5cbiAgICAgKiBpZiBjYW52YXMgaXMgbm90IHpvb21lZC9wYW5uZWQgdGhvc2UgcG9pbnRzIGFyZSB0aGUgZm91ciBjb3JuZXIgb2YgY2FudmFzXG4gICAgICogaWYgY2FudmFzIGlzIHZpZXdwb3J0VHJhbnNmb3JtZWQgeW91IHRob3NlIHBvaW50cyBpbmRpY2F0ZSB0aGUgZXh0ZW5zaW9uXG4gICAgICogb2YgY2FudmFzIGVsZW1lbnQgaW4gcGxhaW4gdW50cmFzZm9ybWVkIGNvb3JkaW5hdGVzXG4gICAgICogVGhlIGNvb3JkaW5hdGVzIGdldCB1cGRhdGVkIHdpdGggQG1ldGhvZCBjYWxjVmlld3BvcnRCb3VuZGFyaWVzLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHZwdENvb3JkczogeyB9LFxuXG4gICAgLyoqXG4gICAgICogQmFzZWQgb24gdnB0Q29vcmRzIGFuZCBvYmplY3QuYUNvb3Jkcywgc2tpcCByZW5kZXJpbmcgb2Ygb2JqZWN0cyB0aGF0XG4gICAgICogYXJlIG5vdCBpbmNsdWRlZCBpbiBjdXJyZW50IHZpZXdwb3J0LlxuICAgICAqIE1heSBncmVhdGx5IGhlbHAgaW4gYXBwbGljYXRpb25zIHdpdGggY3Jvd2RlZCBjYW52YXMgYW5kIHVzZSBvZiB6b29tL3BhblxuICAgICAqIElmIE9uZSBvZiB0aGUgY29ybmVyIG9mIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIG9iamVjdCBpcyBvbiB0aGUgY2FudmFzXG4gICAgICogdGhlIG9iamVjdHMgZ2V0IHJlbmRlcmVkLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNraXBPZmZzY3JlZW46IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTdHJpbmd9IGVsICZsdDtjYW52YXM+IGVsZW1lbnQgdG8gaW5pdGlhbGl6ZSBpbnN0YW5jZSBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBfaW5pdFN0YXRpYzogZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYiA9IHRoaXMucmVxdWVzdFJlbmRlckFsbEJvdW5kO1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgdGhpcy5fY3JlYXRlTG93ZXJDYW52YXMoZWwpO1xuICAgICAgdGhpcy5faW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLl9zZXRJbWFnZVNtb290aGluZygpO1xuICAgICAgLy8gb25seSBpbml0aWFsaXplIHJldGluYSBzY2FsaW5nIG9uY2VcbiAgICAgIGlmICghdGhpcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICB0aGlzLl9pbml0UmV0aW5hU2NhbGluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5vdmVybGF5SW1hZ2UpIHtcbiAgICAgICAgdGhpcy5zZXRPdmVybGF5SW1hZ2Uob3B0aW9ucy5vdmVybGF5SW1hZ2UsIGNiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmRJbWFnZSkge1xuICAgICAgICB0aGlzLnNldEJhY2tncm91bmRJbWFnZShvcHRpb25zLmJhY2tncm91bmRJbWFnZSwgY2IpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHRoaXMuc2V0QmFja2dyb3VuZENvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLCBjYik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5vdmVybGF5Q29sb3IpIHtcbiAgICAgICAgdGhpcy5zZXRPdmVybGF5Q29sb3Iob3B0aW9ucy5vdmVybGF5Q29sb3IsIGNiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc1JldGluYVNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbyAhPT0gMSAmJiB0aGlzLmVuYWJsZVJldGluYVNjYWxpbmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gcmV0aW5hU2NhbGluZyBpZiBhcHBsaWVkLCBvdGhlcndpc2UgMTtcbiAgICAgKi9cbiAgICBnZXRSZXRpbmFTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc1JldGluYVNjYWxpbmcoKSA/IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdFJldGluYVNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9pc1JldGluYVNjYWxpbmcoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMud2lkdGggKiBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmhlaWdodCAqIGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvKTtcblxuICAgICAgdGhpcy5jb250ZXh0Q29udGFpbmVyLnNjYWxlKGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvLCBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgY2FudmFzIGVsZW1lbnQgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGFsc28gYXR0YWNoZWQgYXMgXCJyZXNpemVcIiBldmVudCBoYW5kbGVyIG9mIHdpbmRvd1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNhbGNPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX29mZnNldCA9IGdldEVsZW1lbnRPZmZzZXQodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI292ZXJsYXlJbWFnZXxvdmVybGF5IGltYWdlfSBmb3IgdGhpcyBjYW52YXNcbiAgICAgKiBAcGFyYW0geyhmYWJyaWMuSW1hZ2V8U3RyaW5nKX0gaW1hZ2UgZmFicmljLkltYWdlIGluc3RhbmNlIG9yIFVSTCBvZiBhbiBpbWFnZSB0byBzZXQgb3ZlcmxheSB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIGltYWdlIGlzIGxvYWRlZCBhbmQgc2V0IGFzIGFuIG92ZXJsYXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnMgdG8gc2V0IGZvciB0aGUge0BsaW5rIGZhYnJpYy5JbWFnZXxvdmVybGF5IGltYWdlfS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvTW56SFQvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIG92ZXJsYXlJbWFnZSB3aXRoIGxlZnQvdG9wID0gMDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9qYWlsX2NlbGxfYmFycy5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgLy8gTmVlZGVkIHRvIHBvc2l0aW9uIG92ZXJsYXlJbWFnZSBhdCAwLzBcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+b3ZlcmxheUltYWdlIHdpdGggZGlmZmVyZW50IHByb3BlcnRpZXM8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIG9wYWNpdHk6IDAuNSxcbiAgICAgKiAgIGFuZ2xlOiA0NSxcbiAgICAgKiAgIGxlZnQ6IDQwMCxcbiAgICAgKiAgIHRvcDogNDAwLFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCdcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdHJldGNoZWQgb3ZlcmxheUltYWdlICMxIC0gd2lkdGgvaGVpZ2h0IGNvcnJlc3BvbmQgdG8gY2FudmFzIHdpZHRoL2hlaWdodDwvY2FwdGlvbj5cbiAgICAgKiBmYWJyaWMuSW1hZ2UuZnJvbVVSTCgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgZnVuY3Rpb24oaW1nKSB7XG4gICAgICogICAgaW1nLnNldCh7d2lkdGg6IGNhbnZhcy53aWR0aCwgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LCBvcmlnaW5YOiAnbGVmdCcsIG9yaWdpblk6ICd0b3AnfSk7XG4gICAgICogICAgY2FudmFzLnNldE92ZXJsYXlJbWFnZShpbWcsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdHJldGNoZWQgb3ZlcmxheUltYWdlICMyIC0gd2lkdGgvaGVpZ2h0IGNvcnJlc3BvbmQgdG8gY2FudmFzIHdpZHRoL2hlaWdodDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9qYWlsX2NlbGxfYmFycy5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgKiAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgKiAgIC8vIE5lZWRlZCB0byBwb3NpdGlvbiBvdmVybGF5SW1hZ2UgYXQgMC8wXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPm92ZXJsYXlJbWFnZSBsb2FkZWQgZnJvbSBjcm9zcy1vcmlnaW48L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIG9wYWNpdHk6IDAuNSxcbiAgICAgKiAgIGFuZ2xlOiA0NSxcbiAgICAgKiAgIGxlZnQ6IDQwMCxcbiAgICAgKiAgIHRvcDogNDAwLFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCcsXG4gICAgICogICBjcm9zc09yaWdpbjogJ2Fub255bW91cydcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXRPdmVybGF5SW1hZ2U6IGZ1bmN0aW9uIChpbWFnZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2V0QmdPdmVybGF5SW1hZ2UoJ292ZXJsYXlJbWFnZScsIGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjYmFja2dyb3VuZEltYWdlfGJhY2tncm91bmQgaW1hZ2V9IGZvciB0aGlzIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7KGZhYnJpYy5JbWFnZXxTdHJpbmcpfSBpbWFnZSBmYWJyaWMuSW1hZ2UgaW5zdGFuY2Ugb3IgVVJMIG9mIGFuIGltYWdlIHRvIHNldCBiYWNrZ3JvdW5kIHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gaW1hZ2UgaXMgbG9hZGVkIGFuZCBzZXQgYXMgYmFja2dyb3VuZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgb3B0aW9ucyB0byBzZXQgZm9yIHRoZSB7QGxpbmsgZmFicmljLkltYWdlfGJhY2tncm91bmQgaW1hZ2V9LlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9kam5yOG83YS8yOC98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ob3JtYWwgYmFja2dyb3VuZEltYWdlIHdpdGggbGVmdC90b3AgPSAwPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgLy8gTmVlZGVkIHRvIHBvc2l0aW9uIGJhY2tncm91bmRJbWFnZSBhdCAwLzBcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+YmFja2dyb3VuZEltYWdlIHdpdGggZGlmZmVyZW50IHByb3BlcnRpZXM8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvaG9uZXlfaW1fc3VidGxlLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICBvcGFjaXR5OiAwLjUsXG4gICAgICogICBhbmdsZTogNDUsXG4gICAgICogICBsZWZ0OiA0MDAsXG4gICAgICogICB0b3A6IDQwMCxcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U3RyZXRjaGVkIGJhY2tncm91bmRJbWFnZSAjMSAtIHdpZHRoL2hlaWdodCBjb3JyZXNwb25kIHRvIGNhbnZhcyB3aWR0aC9oZWlnaHQ8L2NhcHRpb24+XG4gICAgICogZmFicmljLkltYWdlLmZyb21VUkwoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgKiAgICBpbWcuc2V0KHt3aWR0aDogY2FudmFzLndpZHRoLCBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsIG9yaWdpblg6ICdsZWZ0Jywgb3JpZ2luWTogJ3RvcCd9KTtcbiAgICAgKiAgICBjYW52YXMuc2V0QmFja2dyb3VuZEltYWdlKGltZywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlN0cmV0Y2hlZCBiYWNrZ3JvdW5kSW1hZ2UgIzIgLSB3aWR0aC9oZWlnaHQgY29ycmVzcG9uZCB0byBjYW52YXMgd2lkdGgvaGVpZ2h0PC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgKiAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgKiAgIC8vIE5lZWRlZCB0byBwb3NpdGlvbiBiYWNrZ3JvdW5kSW1hZ2UgYXQgMC8wXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmJhY2tncm91bmRJbWFnZSBsb2FkZWQgZnJvbSBjcm9zcy1vcmlnaW48L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvaG9uZXlfaW1fc3VidGxlLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICBvcGFjaXR5OiAwLjUsXG4gICAgICogICBhbmdsZTogNDUsXG4gICAgICogICBsZWZ0OiA0MDAsXG4gICAgICogICB0b3A6IDQwMCxcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnLFxuICAgICAqICAgY3Jvc3NPcmlnaW46ICdhbm9ueW1vdXMnXG4gICAgICogfSk7XG4gICAgICovXG4gICAgc2V0QmFja2dyb3VuZEltYWdlOiBmdW5jdGlvbiAoaW1hZ2UsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3NldEJnT3ZlcmxheUltYWdlKCdiYWNrZ3JvdW5kSW1hZ2UnLCBpbWFnZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI292ZXJsYXlDb2xvcnxmb3JlZ3JvdW5kIGNvbG9yfSBmb3IgdGhpcyBjYW52YXNcbiAgICAgKiBAcGFyYW0geyhTdHJpbmd8ZmFicmljLlBhdHRlcm4pfSBvdmVybGF5Q29sb3IgQ29sb3Igb3IgcGF0dGVybiB0byBzZXQgZm9yZWdyb3VuZCBjb2xvciB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGZvcmVncm91bmQgY29sb3IgaXMgc2V0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL3BCNTVoL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk5vcm1hbCBvdmVybGF5Q29sb3IgLSBjb2xvciB2YWx1ZTwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUNvbG9yKCdyZ2JhKDI1NSwgNzMsIDY0LCAwLjYpJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmZhYnJpYy5QYXR0ZXJuIHVzZWQgYXMgb3ZlcmxheUNvbG9yPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5Q29sb3Ioe1xuICAgICAqICAgc291cmNlOiAnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvZXNjaGVyZXNxdWVfc3RlLnBuZydcbiAgICAgKiB9LCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+ZmFicmljLlBhdHRlcm4gdXNlZCBhcyBvdmVybGF5Q29sb3Igd2l0aCByZXBlYXQgYW5kIG9mZnNldDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUNvbG9yKHtcbiAgICAgKiAgIHNvdXJjZTogJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2VzY2hlcmVzcXVlX3N0ZS5wbmcnLFxuICAgICAqICAgcmVwZWF0OiAncmVwZWF0JyxcbiAgICAgKiAgIG9mZnNldFg6IDIwMCxcbiAgICAgKiAgIG9mZnNldFk6IDEwMFxuICAgICAqIH0sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKi9cbiAgICBzZXRPdmVybGF5Q29sb3I6IGZ1bmN0aW9uKG92ZXJsYXlDb2xvciwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2V0QmdPdmVybGF5Q29sb3IoJ292ZXJsYXlDb2xvcicsIG92ZXJsYXlDb2xvciwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI2JhY2tncm91bmRDb2xvcnxiYWNrZ3JvdW5kIGNvbG9yfSBmb3IgdGhpcyBjYW52YXNcbiAgICAgKiBAcGFyYW0geyhTdHJpbmd8ZmFicmljLlBhdHRlcm4pfSBiYWNrZ3JvdW5kQ29sb3IgQ29sb3Igb3IgcGF0dGVybiB0byBzZXQgYmFja2dyb3VuZCBjb2xvciB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGJhY2tncm91bmQgY29sb3IgaXMgc2V0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL2hYenZrL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk5vcm1hbCBiYWNrZ3JvdW5kQ29sb3IgLSBjb2xvciB2YWx1ZTwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZENvbG9yKCdyZ2JhKDI1NSwgNzMsIDY0LCAwLjYpJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmZhYnJpYy5QYXR0ZXJuIHVzZWQgYXMgYmFja2dyb3VuZENvbG9yPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kQ29sb3Ioe1xuICAgICAqICAgc291cmNlOiAnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvZXNjaGVyZXNxdWVfc3RlLnBuZydcbiAgICAgKiB9LCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+ZmFicmljLlBhdHRlcm4gdXNlZCBhcyBiYWNrZ3JvdW5kQ29sb3Igd2l0aCByZXBlYXQgYW5kIG9mZnNldDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZENvbG9yKHtcbiAgICAgKiAgIHNvdXJjZTogJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2VzY2hlcmVzcXVlX3N0ZS5wbmcnLFxuICAgICAqICAgcmVwZWF0OiAncmVwZWF0JyxcbiAgICAgKiAgIG9mZnNldFg6IDIwMCxcbiAgICAgKiAgIG9mZnNldFk6IDEwMFxuICAgICAqIH0sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKi9cbiAgICBzZXRCYWNrZ3JvdW5kQ29sb3I6IGZ1bmN0aW9uKGJhY2tncm91bmRDb2xvciwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2V0QmdPdmVybGF5Q29sb3IoJ2JhY2tncm91bmRDb2xvcicsIGJhY2tncm91bmRDb2xvciwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2RvbS1jb250ZXh0LTJkLWltYWdlc21vb3RoaW5nZW5hYmxlZHxXaGF0V0cgQ2FudmFzIFN0YW5kYXJkfVxuICAgICAqL1xuICAgIF9zZXRJbWFnZVNtb290aGluZzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5nZXRDb250ZXh0KCk7XG5cbiAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGN0eC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWRcbiAgICAgICAgfHwgY3R4Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCB8fCBjdHgubXNJbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgY3R4Lm9JbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdGhpcy5pbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIHNldCAoe0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjYmFja2dyb3VuZEltYWdlfGJhY2tncm91bmRJbWFnZX1cbiAgICAgKiBvciB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNvdmVybGF5SW1hZ2V8b3ZlcmxheUltYWdlfSlcbiAgICAgKiBAcGFyYW0geyhmYWJyaWMuSW1hZ2V8U3RyaW5nfG51bGwpfSBpbWFnZSBmYWJyaWMuSW1hZ2UgaW5zdGFuY2UsIFVSTCBvZiBhbiBpbWFnZSBvciBudWxsIHRvIHNldCBiYWNrZ3JvdW5kIG9yIG92ZXJsYXkgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBpbWFnZSBpcyBsb2FkZWQgYW5kIHNldCBhcyBiYWNrZ3JvdW5kIG9yIG92ZXJsYXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnMgdG8gc2V0IGZvciB0aGUge0BsaW5rIGZhYnJpYy5JbWFnZXxpbWFnZX0uXG4gICAgICovXG4gICAgX19zZXRCZ092ZXJsYXlJbWFnZTogZnVuY3Rpb24ocHJvcGVydHksIGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlKGltYWdlLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgICAgICBpbWcgJiYgKHRoaXNbcHJvcGVydHldID0gbmV3IGZhYnJpYy5JbWFnZShpbWcsIG9wdGlvbnMpKTtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhpbWcpO1xuICAgICAgICB9LCB0aGlzLCBvcHRpb25zICYmIG9wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgJiYgaW1hZ2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBpbWFnZTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soaW1hZ2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gc2V0ICh7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNiYWNrZ3JvdW5kQ29sb3J8YmFja2dyb3VuZENvbG9yfVxuICAgICAqIG9yIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI292ZXJsYXlDb2xvcnxvdmVybGF5Q29sb3J9KVxuICAgICAqIEBwYXJhbSB7KE9iamVjdHxTdHJpbmd8bnVsbCl9IGNvbG9yIE9iamVjdCB3aXRoIHBhdHRlcm4gaW5mb3JtYXRpb24sIGNvbG9yIHZhbHVlIG9yIG51bGxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIGlzIGludm9rZWQgd2hlbiBjb2xvciBpcyBzZXRcbiAgICAgKi9cbiAgICBfX3NldEJnT3ZlcmxheUNvbG9yOiBmdW5jdGlvbihwcm9wZXJ0eSwgY29sb3IsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzW3Byb3BlcnR5XSA9IGNvbG9yO1xuICAgICAgdGhpcy5faW5pdEdyYWRpZW50KGNvbG9yLCBwcm9wZXJ0eSk7XG4gICAgICB0aGlzLl9pbml0UGF0dGVybihjb2xvciwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVDYW52YXNFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHRocm93IENBTlZBU19JTklUX0VSUk9SO1xuICAgICAgfVxuICAgICAgaWYgKCFlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUgPSB7IH07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQuZ2V0Q29udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgQ0FOVkFTX0lOSVRfRVJST1I7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX2luaXRPcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdGhpcy5fc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgdGhpcy53aWR0aCA9IHRoaXMud2lkdGggfHwgcGFyc2VJbnQodGhpcy5sb3dlckNhbnZhc0VsLndpZHRoLCAxMCkgfHwgMDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgfHwgcGFyc2VJbnQodGhpcy5sb3dlckNhbnZhc0VsLmhlaWdodCwgMTApIHx8IDA7XG5cbiAgICAgIGlmICghdGhpcy5sb3dlckNhbnZhc0VsLnN0eWxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgIHRoaXMubG93ZXJDYW52YXNFbC5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArICdweCc7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyAncHgnO1xuXG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybS5zbGljZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYm90dG9tIGNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2NhbnZhc0VsXVxuICAgICAqL1xuICAgIF9jcmVhdGVMb3dlckNhbnZhczogZnVuY3Rpb24gKGNhbnZhc0VsKSB7XG4gICAgICAvLyBjYW52YXNFbCA9PT0gJ0hUTUxDYW52YXNFbGVtZW50JyBkb2VzIG5vdCB3b3JrIG9uIGpzZG9tL25vZGVcbiAgICAgIGlmIChjYW52YXNFbCAmJiBjYW52YXNFbC5nZXRDb250ZXh0KSB7XG4gICAgICAgIHRoaXMubG93ZXJDYW52YXNFbCA9IGNhbnZhc0VsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMubG93ZXJDYW52YXNFbCA9IGZhYnJpYy51dGlsLmdldEJ5SWQoY2FudmFzRWwpIHx8IHRoaXMuX2NyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIH1cblxuICAgICAgZmFicmljLnV0aWwuYWRkQ2xhc3ModGhpcy5sb3dlckNhbnZhc0VsLCAnbG93ZXItY2FudmFzJyk7XG5cbiAgICAgIGlmICh0aGlzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuX2FwcGx5Q2FudmFzU3R5bGUodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250ZXh0Q29udGFpbmVyID0gdGhpcy5sb3dlckNhbnZhc0VsLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY2FudmFzIHdpZHRoIChpbiBweClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNhbnZhcyBoZWlnaHQgKGluIHB4KVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aWR0aCBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWUgICAgICAgICAgICAgICAgICAgICAgICAgVmFsdWUgdG8gc2V0IHdpZHRoIHRvXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAgICBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuYmFja3N0b3JlT25seT1mYWxzZV0gU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY2FudmFzIGJhY2tzdG9yZSBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5jc3NPbmx5PWZhbHNlXSAgICAgICBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjc3MgZGltZW5zaW9uc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0RGltZW5zaW9ucyh7IHdpZHRoOiB2YWx1ZSB9LCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBoZWlnaHQgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlIHRvIHNldCBoZWlnaHQgdG9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIFtvcHRpb25zXSAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5iYWNrc3RvcmVPbmx5PWZhbHNlXSBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjYW52YXMgYmFja3N0b3JlIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmNzc09ubHk9ZmFsc2VdICAgICAgIFNldCB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBvbmx5IGFzIGNzcyBkaW1lbnNpb25zXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0RGltZW5zaW9ucyh7IGhlaWdodDogdmFsdWUgfSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgZGltZW5zaW9ucyAod2lkdGgsIGhlaWdodCkgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2UuIHdoZW4gb3B0aW9ucy5jc3NPbmx5IGZsYWcgYWN0aXZlIHlvdSBzaG91bGQgYWxzbyBzdXBwbHkgdGhlIHVuaXQgb2YgbWVhc3VyZSAocHgvJS9lbSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIGRpbWVuc2lvbnMgICAgICAgICAgICAgICAgICAgIE9iamVjdCB3aXRoIHdpZHRoL2hlaWdodCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbZGltZW5zaW9ucy53aWR0aF0gICAgICAgICAgICBXaWR0aCBvZiBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW2RpbWVuc2lvbnMuaGVpZ2h0XSAgICAgICAgICAgSGVpZ2h0IG9mIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAgICBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuYmFja3N0b3JlT25seT1mYWxzZV0gU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY2FudmFzIGJhY2tzdG9yZSBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5jc3NPbmx5PWZhbHNlXSAgICAgICBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjc3MgZGltZW5zaW9uc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0RGltZW5zaW9uczogZnVuY3Rpb24gKGRpbWVuc2lvbnMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjc3NWYWx1ZTtcblxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gZGltZW5zaW9ucykge1xuICAgICAgICBjc3NWYWx1ZSA9IGRpbWVuc2lvbnNbcHJvcF07XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmNzc09ubHkpIHtcbiAgICAgICAgICB0aGlzLl9zZXRCYWNrc3RvcmVEaW1lbnNpb24ocHJvcCwgZGltZW5zaW9uc1twcm9wXSk7XG4gICAgICAgICAgY3NzVmFsdWUgKz0gJ3B4JztcbiAgICAgICAgICB0aGlzLmhhc0xvc3RDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5iYWNrc3RvcmVPbmx5KSB7XG4gICAgICAgICAgdGhpcy5fc2V0Q3NzRGltZW5zaW9uKHByb3AsIGNzc1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZykge1xuICAgICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2ggJiYgdGhpcy5mcmVlRHJhd2luZ0JydXNoLl9zZXRCcnVzaFN0eWxlcygpO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5pdFJldGluYVNjYWxpbmcoKTtcbiAgICAgIHRoaXMuX3NldEltYWdlU21vb3RoaW5nKCk7XG4gICAgICB0aGlzLmNhbGNPZmZzZXQoKTtcblxuICAgICAgaWYgKCFvcHRpb25zLmNzc09ubHkpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZm9yIHNldHRpbmcgd2lkdGgvaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBwcm9wZXJ0eSAod2lkdGh8aGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSB2YWx1ZSB0byBzZXQgcHJvcGVydHkgdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIF9zZXRCYWNrc3RvcmVEaW1lbnNpb246IGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsW3Byb3BdID0gdmFsdWU7XG5cbiAgICAgIGlmICh0aGlzLnVwcGVyQ2FudmFzRWwpIHtcbiAgICAgICAgdGhpcy51cHBlckNhbnZhc0VsW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNhY2hlQ2FudmFzRWwpIHtcbiAgICAgICAgdGhpcy5jYWNoZUNhbnZhc0VsW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXNbcHJvcF0gPSB2YWx1ZTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmb3Igc2V0dGluZyBjc3Mgd2lkdGgvaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBwcm9wZXJ0eSAod2lkdGh8aGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSB2YWx1ZSB0byBzZXQgcHJvcGVydHkgdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIF9zZXRDc3NEaW1lbnNpb246IGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsLnN0eWxlW3Byb3BdID0gdmFsdWU7XG5cbiAgICAgIGlmICh0aGlzLnVwcGVyQ2FudmFzRWwpIHtcbiAgICAgICAgdGhpcy51cHBlckNhbnZhc0VsLnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLndyYXBwZXJFbCkge1xuICAgICAgICB0aGlzLndyYXBwZXJFbC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjYW52YXMgem9vbSBsZXZlbFxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRab29tOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy52aWV3cG9ydFRyYW5zZm9ybVswXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB2aWV3cG9ydCB0cmFuc2Zvcm0gb2YgdGhpcyBjYW52YXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2cHQgdGhlIHRyYW5zZm9ybSBpbiB0aGUgZm9ybSBvZiBjb250ZXh0LnRyYW5zZm9ybVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgc2V0Vmlld3BvcnRUcmFuc2Zvcm06IGZ1bmN0aW9uICh2cHQpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3QsIG9iamVjdCwgaWdub3JlVnB0ID0gZmFsc2UsIHNraXBBYnNvbHV0ZSA9IHRydWUsIGksIGxlbjtcbiAgICAgIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0gPSB2cHQ7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG9iamVjdCA9IHRoaXMuX29iamVjdHNbaV07XG4gICAgICAgIG9iamVjdC5ncm91cCB8fCBvYmplY3Quc2V0Q29vcmRzKGlnbm9yZVZwdCwgc2tpcEFic29sdXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChhY3RpdmVPYmplY3QgJiYgYWN0aXZlT2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICAgIGFjdGl2ZU9iamVjdC5zZXRDb29yZHMoaWdub3JlVnB0LCBza2lwQWJzb2x1dGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWxjVmlld3BvcnRCb3VuZGFyaWVzKCk7XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgem9vbSBsZXZlbCBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZSwgem9vbSBjZW50ZXJlZCBhcm91bmQgcG9pbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgdG8gem9vbSB3aXRoIHJlc3BlY3QgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdG8gc2V0IHpvb20gdG8sIGxlc3MgdGhhbiAxIHpvb21zIG91dFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgem9vbVRvUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCwgdmFsdWUpIHtcbiAgICAgIC8vIFRPRE86IGp1c3QgY2hhbmdlIHRoZSBzY2FsZSwgcHJlc2VydmUgb3RoZXIgdHJhbnNmb3JtYXRpb25zXG4gICAgICB2YXIgYmVmb3JlID0gcG9pbnQsIHZwdCA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0uc2xpY2UoMCk7XG4gICAgICBwb2ludCA9IHRyYW5zZm9ybVBvaW50KHBvaW50LCBpbnZlcnRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFRyYW5zZm9ybSkpO1xuICAgICAgdnB0WzBdID0gdmFsdWU7XG4gICAgICB2cHRbM10gPSB2YWx1ZTtcbiAgICAgIHZhciBhZnRlciA9IHRyYW5zZm9ybVBvaW50KHBvaW50LCB2cHQpO1xuICAgICAgdnB0WzRdICs9IGJlZm9yZS54IC0gYWZ0ZXIueDtcbiAgICAgIHZwdFs1XSArPSBiZWZvcmUueSAtIGFmdGVyLnk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydFRyYW5zZm9ybSh2cHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHpvb20gbGV2ZWwgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdG8gc2V0IHpvb20gdG8sIGxlc3MgdGhhbiAxIHpvb21zIG91dFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgc2V0Wm9vbTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLnpvb21Ub1BvaW50KG5ldyBmYWJyaWMuUG9pbnQoMCwgMCksIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYW4gdmlld3BvcnQgc28gYXMgdG8gcGxhY2UgcG9pbnQgYXQgdG9wIGxlZnQgY29ybmVyIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCB0byBtb3ZlIHRvXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBhYnNvbHV0ZVBhbjogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICB2YXIgdnB0ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybS5zbGljZSgwKTtcbiAgICAgIHZwdFs0XSA9IC1wb2ludC54O1xuICAgICAgdnB0WzVdID0gLXBvaW50Lnk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydFRyYW5zZm9ybSh2cHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYW5zIHZpZXdwb2ludCByZWxhdGl2ZWx5XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IChwb3NpdGlvbiB2ZWN0b3IpIHRvIG1vdmUgYnlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIHJlbGF0aXZlUGFuOiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFic29sdXRlUGFuKG5ldyBmYWJyaWMuUG9pbnQoXG4gICAgICAgIC1wb2ludC54IC0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybVs0XSxcbiAgICAgICAgLXBvaW50LnkgLSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtWzVdXG4gICAgICApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyAmbHQ7Y2FudmFzPiBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvd2VyQ2FudmFzRWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgd2FzIGFkZGVkXG4gICAgICovXG4gICAgX29uT2JqZWN0QWRkZWQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdGhpcy5zdGF0ZWZ1bCAmJiBvYmouc2V0dXBTdGF0ZSgpO1xuICAgICAgb2JqLl9zZXQoJ2NhbnZhcycsIHRoaXMpO1xuICAgICAgb2JqLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5maXJlKCdvYmplY3Q6YWRkZWQnLCB7IHRhcmdldDogb2JqIH0pO1xuICAgICAgb2JqLmZpcmUoJ2FkZGVkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgd2FzIHJlbW92ZWRcbiAgICAgKi9cbiAgICBfb25PYmplY3RSZW1vdmVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHRoaXMuZmlyZSgnb2JqZWN0OnJlbW92ZWQnLCB7IHRhcmdldDogb2JqIH0pO1xuICAgICAgb2JqLmZpcmUoJ3JlbW92ZWQnKTtcbiAgICAgIGRlbGV0ZSBvYmouY2FudmFzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgc3BlY2lmaWVkIGNvbnRleHQgb2YgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gY2xlYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNsZWFyQ29udGV4dDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRleHQgb2YgY2FudmFzIHdoZXJlIG9iamVjdHMgYXJlIGRyYXduXG4gICAgICogQHJldHVybiB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHRDb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY29udGV4dHMgKGJhY2tncm91bmQsIG1haW4sIHRvcCkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vYmplY3RzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLmJhY2tncm91bmRJbWFnZSA9IG51bGw7XG4gICAgICB0aGlzLm92ZXJsYXlJbWFnZSA9IG51bGw7XG4gICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9ICcnO1xuICAgICAgdGhpcy5vdmVybGF5Q29sb3IgPSAnJztcbiAgICAgIGlmICh0aGlzLl9oYXNJVGV4dEhhbmRsZXJzKSB7XG4gICAgICAgIHRoaXMub2ZmKCdtb3VzZTp1cCcsIHRoaXMuX21vdXNlVXBJVGV4dEhhbmRsZXIpO1xuICAgICAgICB0aGlzLl9pVGV4dEluc3RhbmNlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hhc0lUZXh0SGFuZGxlcnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KHRoaXMuY29udGV4dENvbnRhaW5lcik7XG4gICAgICB0aGlzLmZpcmUoJ2NhbnZhczpjbGVhcmVkJyk7XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbmRlckFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNhbnZhc1RvRHJhd09uID0gdGhpcy5jb250ZXh0Q29udGFpbmVyO1xuICAgICAgdGhpcy5yZW5kZXJDYW52YXMoY2FudmFzVG9EcmF3T24sIHRoaXMuX29iamVjdHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGNyZWF0ZWQgdG8gYmUgaW5zdGFuY2UgYm91bmQgYXQgaW5pdGlhbGl6YXRpb25cbiAgICAgKiB1c2VkIGluIHJlcXVlc3RBbmltYXRpb25GcmFtZSByZW5kZXJpbmdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW5kZXJBbmRSZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzUmVuZGVyaW5nID0gMDtcbiAgICAgIHRoaXMucmVuZGVyQWxsKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGVuZCBhIHJlbmRlckFsbCByZXF1ZXN0IHRvIG5leHQgYW5pbWF0aW9uIGZyYW1lLlxuICAgICAqIGEgYm9vbGVhbiBmbGFnIHdpbGwgYXZvaWQgYXBwZW5kaW5nIG1vcmUuXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVxdWVzdFJlbmRlckFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLmlzUmVuZGVyaW5nKSB7XG4gICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSBmYWJyaWMudXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMucmVuZGVyQW5kUmVzZXRCb3VuZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgNCBjb3JuZXIgb2YgY2FudmFzIHdpdGggY3VycmVudCB2aWV3cG9ydFRyYW5zZm9ybS5cbiAgICAgKiBoZWxwcyB0byBkZXRlcm1pbmF0ZSB3aGVuIGFuIG9iamVjdCBpcyBpbiB0aGUgY3VycmVudCByZW5kZXJpbmcgdmlld3BvcnQgdXNpbmdcbiAgICAgKiBvYmplY3QgYWJzb2x1dGUgY29vcmRpbmF0ZXMgKCBhQ29vcmRzIClcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHBvaW50cy50bFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjYWxjVmlld3BvcnRCb3VuZGFyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb2ludHMgPSB7IH0sIHdpZHRoID0gdGhpcy53aWR0aCwgaGVpZ2h0ID0gdGhpcy5oZWlnaHQsXG4gICAgICAgICAgaVZwdCA9IGludmVydFRyYW5zZm9ybSh0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKTtcbiAgICAgIHBvaW50cy50bCA9IHRyYW5zZm9ybVBvaW50KHsgeDogMCwgeTogMCB9LCBpVnB0KTtcbiAgICAgIHBvaW50cy5iciA9IHRyYW5zZm9ybVBvaW50KHsgeDogd2lkdGgsIHk6IGhlaWdodCB9LCBpVnB0KTtcbiAgICAgIHBvaW50cy50ciA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRzLmJyLngsIHBvaW50cy50bC55KTtcbiAgICAgIHBvaW50cy5ibCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRzLnRsLngsIHBvaW50cy5ici55KTtcbiAgICAgIHRoaXMudnB0Q29vcmRzID0gcG9pbnRzO1xuICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBiYWNrZ3JvdW5kLCBvYmplY3RzLCBvdmVybGF5IGFuZCBjb250cm9scy5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqZWN0cyB0byByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW5kZXJDYW52YXM6IGZ1bmN0aW9uKGN0eCwgb2JqZWN0cykge1xuICAgICAgdmFyIHYgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgaWYgKHRoaXMuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgZmFicmljLnV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuaXNSZW5kZXJpbmcpO1xuICAgICAgICB0aGlzLmlzUmVuZGVyaW5nID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsY1ZpZXdwb3J0Qm91bmRhcmllcygpO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcbiAgICAgIHRoaXMuZmlyZSgnYmVmb3JlOnJlbmRlcicpO1xuICAgICAgaWYgKHRoaXMuY2xpcFRvKSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmNsaXBDb250ZXh0KHRoaXMsIGN0eCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kKGN0eCk7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAvL2FwcGx5IHZpZXdwb3J0IHRyYW5zZm9ybSBvbmNlIGZvciBhbGwgcmVuZGVyaW5nIHByb2Nlc3NcbiAgICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gICAgICB0aGlzLl9yZW5kZXJPYmplY3RzKGN0eCwgb2JqZWN0cyk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgaWYgKCF0aGlzLmNvbnRyb2xzQWJvdmVPdmVybGF5ICYmIHRoaXMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5kcmF3Q29udHJvbHMoY3R4KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNsaXBUbykge1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyT3ZlcmxheShjdHgpO1xuICAgICAgaWYgKHRoaXMuY29udHJvbHNBYm92ZU92ZXJsYXkgJiYgdGhpcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICB0aGlzLmRyYXdDb250cm9scyhjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5maXJlKCdhZnRlcjpyZW5kZXInKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqZWN0cyB0byByZW5kZXJcbiAgICAgKi9cbiAgICBfcmVuZGVyT2JqZWN0czogZnVuY3Rpb24oY3R4LCBvYmplY3RzKSB7XG4gICAgICB2YXIgaSwgbGVuO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBvYmplY3RzW2ldICYmIG9iamVjdHNbaV0ucmVuZGVyKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAnYmFja2dyb3VuZCcgb3IgJ292ZXJsYXknXG4gICAgICovXG4gICAgX3JlbmRlckJhY2tncm91bmRPck92ZXJsYXk6IGZ1bmN0aW9uKGN0eCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBvYmplY3QgPSB0aGlzW3Byb3BlcnR5ICsgJ0NvbG9yJ10sIHY7XG4gICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvYmplY3QudG9MaXZlXG4gICAgICAgICAgPyBvYmplY3QudG9MaXZlKGN0eCwgdGhpcylcbiAgICAgICAgICA6IG9iamVjdDtcblxuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgb2JqZWN0Lm9mZnNldFggfHwgMCxcbiAgICAgICAgICBvYmplY3Qub2Zmc2V0WSB8fCAwLFxuICAgICAgICAgIHRoaXMud2lkdGgsXG4gICAgICAgICAgdGhpcy5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gdGhpc1twcm9wZXJ0eSArICdJbWFnZSddO1xuICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICBpZiAodGhpc1twcm9wZXJ0eSArICdWcHQnXSkge1xuICAgICAgICAgIHYgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QucmVuZGVyKGN0eCk7XG4gICAgICAgIHRoaXNbcHJvcGVydHkgKyAnVnB0J10gJiYgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckJhY2tncm91bmQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5fcmVuZGVyQmFja2dyb3VuZE9yT3ZlcmxheShjdHgsICdiYWNrZ3JvdW5kJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJPdmVybGF5OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmRPck92ZXJsYXkoY3R4LCAnb3ZlcmxheScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvb3JkaW5hdGVzIG9mIGEgY2VudGVyIG9mIGNhbnZhcy5cbiAgICAgKiBSZXR1cm5lZCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCB0b3AgYW5kIGxlZnQgcHJvcGVydGllc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggXCJ0b3BcIiBhbmQgXCJsZWZ0XCIgbnVtYmVyIHZhbHVlc1xuICAgICAqL1xuICAgIGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiB0aGlzLmhlaWdodCAvIDIsXG4gICAgICAgIGxlZnQ6IHRoaXMud2lkdGggLyAyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgaW4gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXIgaG9yaXpvbnRhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqL1xuICAgIGNlbnRlck9iamVjdEg6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCBuZXcgZmFicmljLlBvaW50KHRoaXMuZ2V0Q2VudGVyKCkubGVmdCwgb2JqZWN0LmdldENlbnRlclBvaW50KCkueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IGluIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyIHZlcnRpY2FsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlck9iamVjdFY6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCBuZXcgZmFicmljLlBvaW50KG9iamVjdC5nZXRDZW50ZXJQb2ludCgpLngsIHRoaXMuZ2V0Q2VudGVyKCkudG9wKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseSBpbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlck9iamVjdDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQoY2VudGVyLmxlZnQsIGNlbnRlci50b3ApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5IGluIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXIgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB2aWV3cG9ydENlbnRlck9iamVjdDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgdnBDZW50ZXIgPSB0aGlzLmdldFZwQ2VudGVyKCk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCB2cENlbnRlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IGhvcml6b250YWxseSBpbiB0aGUgdmlld3BvcnQsIG9iamVjdC50b3AgaXMgdW5jaGFuZ2VkXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyT2JqZWN0SDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgdnBDZW50ZXIgPSB0aGlzLmdldFZwQ2VudGVyKCk7XG4gICAgICB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCBuZXcgZmFicmljLlBvaW50KHZwQ2VudGVyLngsIG9iamVjdC5nZXRDZW50ZXJQb2ludCgpLnkpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBWZXJ0aWNhbGx5IGluIHRoZSB2aWV3cG9ydCwgb2JqZWN0LnRvcCBpcyB1bmNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyIHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXJPYmplY3RWOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciB2cENlbnRlciA9IHRoaXMuZ2V0VnBDZW50ZXIoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQob2JqZWN0LmdldENlbnRlclBvaW50KCkueCwgdnBDZW50ZXIueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvaW50IGluIGNhbnZhcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIGNlbnRlciBvZiBhY3R1YWwgdmlld3BvcnQuXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB2cENlbnRlciwgdmlld3BvcnQgY2VudGVyXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGdldFZwQ2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxuICAgICAgICAgIGlWcHQgPSBpbnZlcnRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFRyYW5zZm9ybSk7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtUG9pbnQoeyB4OiBjZW50ZXIubGVmdCwgeTogY2VudGVyLnRvcCB9LCBpVnB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGNlbnRlciBDZW50ZXIgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIF9jZW50ZXJPYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCwgY2VudGVyKSB7XG4gICAgICBvYmplY3Quc2V0UG9zaXRpb25CeU9yaWdpbihjZW50ZXIsICdjZW50ZXInLCAnY2VudGVyJyk7XG4gICAgICBvYmplY3Quc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVycyBkYXRhbGVzcyBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGpzb24gc3RyaW5nXG4gICAgICovXG4gICAgdG9EYXRhbGVzc0pTT046IGZ1bmN0aW9uIChwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0RhdGFsZXNzT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24gKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b09iamVjdE1ldGhvZCgndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkYXRhbGVzcyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24gKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b09iamVjdE1ldGhvZCgndG9EYXRhbGVzc09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b09iamVjdE1ldGhvZDogZnVuY3Rpb24gKG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcblxuICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIHZlcnNpb246IGZhYnJpYy52ZXJzaW9uLFxuICAgICAgICBvYmplY3RzOiB0aGlzLl90b09iamVjdHMobWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSlcbiAgICAgIH07XG5cbiAgICAgIGV4dGVuZChkYXRhLCB0aGlzLl9fc2VyaWFsaXplQmdPdmVybGF5KG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcblxuICAgICAgZmFicmljLnV0aWwucG9wdWxhdGVXaXRoUHJvcGVydGllcyh0aGlzLCBkYXRhLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RvT2JqZWN0czogZnVuY3Rpb24obWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0cygpLmZpbHRlcihmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuICFvYmplY3QuZXhjbHVkZUZyb21FeHBvcnQ7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvT2JqZWN0KGluc3RhbmNlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b09iamVjdDogZnVuY3Rpb24oaW5zdGFuY2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBvcmlnaW5hbFZhbHVlO1xuXG4gICAgICBpZiAoIXRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgb3JpZ2luYWxWYWx1ZSA9IGluc3RhbmNlLmluY2x1ZGVEZWZhdWx0VmFsdWVzO1xuICAgICAgICBpbnN0YW5jZS5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2JqZWN0ID0gaW5zdGFuY2VbbWV0aG9kTmFtZV0ocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBpZiAoIXRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgaW5zdGFuY2UuaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBvcmlnaW5hbFZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfX3NlcmlhbGl6ZUJnT3ZlcmxheTogZnVuY3Rpb24obWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIGRhdGEgPSB7IH0sIGJnSW1hZ2UgPSB0aGlzLmJhY2tncm91bmRJbWFnZSwgb3ZlcmxheSA9IHRoaXMub3ZlcmxheUltYWdlO1xuXG4gICAgICBpZiAodGhpcy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgZGF0YS5iYWNrZ3JvdW5kID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3IudG9PYmplY3RcbiAgICAgICAgICA/IHRoaXMuYmFja2dyb3VuZENvbG9yLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpXG4gICAgICAgICAgOiB0aGlzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3ZlcmxheUNvbG9yKSB7XG4gICAgICAgIGRhdGEub3ZlcmxheSA9IHRoaXMub3ZlcmxheUNvbG9yLnRvT2JqZWN0XG4gICAgICAgICAgPyB0aGlzLm92ZXJsYXlDb2xvci50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKVxuICAgICAgICAgIDogdGhpcy5vdmVybGF5Q29sb3I7XG4gICAgICB9XG4gICAgICBpZiAoYmdJbWFnZSAmJiAhYmdJbWFnZS5leGNsdWRlRnJvbUV4cG9ydCkge1xuICAgICAgICBkYXRhLmJhY2tncm91bmRJbWFnZSA9IHRoaXMuX3RvT2JqZWN0KGJnSW1hZ2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJsYXkgJiYgIW92ZXJsYXkuZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgZGF0YS5vdmVybGF5SW1hZ2UgPSB0aGlzLl90b09iamVjdChvdmVybGF5LCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBnZXRTdmdUcmFuc2Zvcm0oKSB3aWxsIGFwcGx5IHRoZSBTdGF0aWNDYW52YXMudmlld3BvcnRUcmFuc2Zvcm0gdG8gdGhlIFNWRyB0cmFuc2Zvcm1hdGlvbi4gV2hlbiB0cnVlLFxuICAgICAqIGEgem9vbWVkIGNhbnZhcyB3aWxsIHRoZW4gcHJvZHVjZSB6b29tZWQgU1ZHIG91dHB1dC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdmdWaWV3cG9ydFRyYW5zZm9ybWF0aW9uOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBTVkcgcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCBmb3IgU1ZHIG91dHB1dFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3VwcHJlc3NQcmVhbWJsZT1mYWxzZV0gSWYgdHJ1ZSB4bWwgdGFnIGlzIG5vdCBpbmNsdWRlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy52aWV3Qm94XSBTVkcgdmlld2JveCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlld0JveC54XSB4LWNvb3JpZG5hdGUgb2Ygdmlld2JveFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWV3Qm94LnldIHktY29vcmRpbmF0ZSBvZiB2aWV3Ym94XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZpZXdCb3gud2lkdGhdIFdpZHRoIG9mIHZpZXdib3hcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlld0JveC5oZWlnaHRdIEhlaWdodCBvZiB2aWV3Ym94XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPVVURi04XSBFbmNvZGluZyBvZiBTVkcgb3V0cHV0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLndpZHRoXSBkZXNpcmVkIHdpZHRoIG9mIHN2ZyB3aXRoIG9yIHdpdGhvdXQgdW5pdHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaGVpZ2h0XSBkZXNpcmVkIGhlaWdodCBvZiBzdmcgd2l0aCBvciB3aXRob3V0IHVuaXRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjb252ZXJ0ZWQgaW50byBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTVkcgc3RyaW5nXG4gICAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTMjc2VyaWFsaXphdGlvbn1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL2pRM1paL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk5vcm1hbCBTVkcgb3V0cHV0PC9jYXB0aW9uPlxuICAgICAqIHZhciBzdmcgPSBjYW52YXMudG9TVkcoKTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TVkcgb3V0cHV0IHdpdGhvdXQgcHJlYW1ibGUgKHdpdGhvdXQgJmx0Oz94bWwgLi4vPik8L2NhcHRpb24+XG4gICAgICogdmFyIHN2ZyA9IGNhbnZhcy50b1NWRyh7c3VwcHJlc3NQcmVhbWJsZTogdHJ1ZX0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNWRyBvdXRwdXQgd2l0aCB2aWV3Qm94IGF0dHJpYnV0ZTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgc3ZnID0gY2FudmFzLnRvU1ZHKHtcbiAgICAgKiAgIHZpZXdCb3g6IHtcbiAgICAgKiAgICAgeDogMTAwLFxuICAgICAqICAgICB5OiAxMDAsXG4gICAgICogICAgIHdpZHRoOiAyMDAsXG4gICAgICogICAgIGhlaWdodDogMzAwXG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U1ZHIG91dHB1dCB3aXRoIGRpZmZlcmVudCBlbmNvZGluZyAoZGVmYXVsdDogVVRGLTgpPC9jYXB0aW9uPlxuICAgICAqIHZhciBzdmcgPSBjYW52YXMudG9TVkcoe2VuY29kaW5nOiAnSVNPLTg4NTktMSd9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Nb2RpZnkgU1ZHIG91dHB1dCB3aXRoIHJldml2ZXIgZnVuY3Rpb248L2NhcHRpb24+XG4gICAgICogdmFyIHN2ZyA9IGNhbnZhcy50b1NWRyhudWxsLCBmdW5jdGlvbihzdmcpIHtcbiAgICAgKiAgIHJldHVybiBzdmcucmVwbGFjZSgnc3Ryb2tlLWRhc2hhcnJheTogOyBzdHJva2UtbGluZWNhcDogYnV0dDsgc3Ryb2tlLWxpbmVqb2luOiBtaXRlcjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyAnLCAnJyk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKG9wdGlvbnMsIHJldml2ZXIpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB2YXIgbWFya3VwID0gW107XG5cbiAgICAgIHRoaXMuX3NldFNWR1ByZWFtYmxlKG1hcmt1cCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9zZXRTVkdIZWFkZXIobWFya3VwLCBvcHRpb25zKTtcblxuICAgICAgdGhpcy5fc2V0U1ZHQmdPdmVybGF5Q29sb3IobWFya3VwLCAnYmFja2dyb3VuZENvbG9yJyk7XG4gICAgICB0aGlzLl9zZXRTVkdCZ092ZXJsYXlJbWFnZShtYXJrdXAsICdiYWNrZ3JvdW5kSW1hZ2UnLCByZXZpdmVyKTtcblxuICAgICAgdGhpcy5fc2V0U1ZHT2JqZWN0cyhtYXJrdXAsIHJldml2ZXIpO1xuXG4gICAgICB0aGlzLl9zZXRTVkdCZ092ZXJsYXlDb2xvcihtYXJrdXAsICdvdmVybGF5Q29sb3InKTtcbiAgICAgIHRoaXMuX3NldFNWR0JnT3ZlcmxheUltYWdlKG1hcmt1cCwgJ292ZXJsYXlJbWFnZScsIHJldml2ZXIpO1xuXG4gICAgICBtYXJrdXAucHVzaCgnPC9zdmc+Jyk7XG5cbiAgICAgIHJldHVybiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR1ByZWFtYmxlOiBmdW5jdGlvbihtYXJrdXAsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLnN1cHByZXNzUHJlYW1ibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCInLCAob3B0aW9ucy5lbmNvZGluZyB8fCAnVVRGLTgnKSwgJ1wiIHN0YW5kYWxvbmU9XCJub1wiID8+XFxuJyxcbiAgICAgICAgJzwhRE9DVFlQRSBzdmcgUFVCTElDIFwiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU5cIiAnLFxuICAgICAgICAnXCJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGRcIj5cXG4nXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdIZWFkZXI6IGZ1bmN0aW9uKG1hcmt1cCwgb3B0aW9ucykge1xuICAgICAgdmFyIHdpZHRoID0gb3B0aW9ucy53aWR0aCB8fCB0aGlzLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIHZwdCwgdmlld0JveCA9ICd2aWV3Qm94PVwiMCAwICcgKyB0aGlzLndpZHRoICsgJyAnICsgdGhpcy5oZWlnaHQgKyAnXCIgJyxcbiAgICAgICAgICBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuXG4gICAgICBpZiAob3B0aW9ucy52aWV3Qm94KSB7XG4gICAgICAgIHZpZXdCb3ggPSAndmlld0JveD1cIicgK1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudmlld0JveC54ICsgJyAnICtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZpZXdCb3gueSArICcgJyArXG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aWV3Qm94LndpZHRoICsgJyAnICtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZpZXdCb3guaGVpZ2h0ICsgJ1wiICc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuc3ZnVmlld3BvcnRUcmFuc2Zvcm1hdGlvbikge1xuICAgICAgICAgIHZwdCA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm07XG4gICAgICAgICAgdmlld0JveCA9ICd2aWV3Qm94PVwiJyArXG4gICAgICAgICAgICAgICAgICB0b0ZpeGVkKC12cHRbNF0gLyB2cHRbMF0sIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgIHRvRml4ZWQoLXZwdFs1XSAvIHZwdFszXSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLndpZHRoIC8gdnB0WzBdLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICcgJyArXG4gICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuaGVpZ2h0IC8gdnB0WzNdLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICdcIiAnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPHN2ZyAnLFxuICAgICAgICAneG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiICcsXG4gICAgICAgICd4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiAnLFxuICAgICAgICAndmVyc2lvbj1cIjEuMVwiICcsXG4gICAgICAgICd3aWR0aD1cIicsIHdpZHRoLCAnXCIgJyxcbiAgICAgICAgJ2hlaWdodD1cIicsIGhlaWdodCwgJ1wiICcsXG4gICAgICAgIHZpZXdCb3gsXG4gICAgICAgICd4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPlxcbicsXG4gICAgICAgICc8ZGVzYz5DcmVhdGVkIHdpdGggRmFicmljLmpzICcsIGZhYnJpYy52ZXJzaW9uLCAnPC9kZXNjPlxcbicsXG4gICAgICAgICc8ZGVmcz5cXG4nLFxuICAgICAgICB0aGlzLmNyZWF0ZVNWR0ZvbnRGYWNlc01hcmt1cCgpLFxuICAgICAgICB0aGlzLmNyZWF0ZVNWR1JlZkVsZW1lbnRzTWFya3VwKCksXG4gICAgICAgICc8L2RlZnM+XFxuJ1xuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBtYXJrdXAgY29udGFpbmluZyBTVkcgcmVmZXJlbmNlZCBlbGVtZW50cyBsaWtlIHBhdHRlcm5zLCBncmFkaWVudHMgZXRjLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBjcmVhdGVTVkdSZWZFbGVtZW50c01hcmt1cDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIG1hcmt1cCA9IFsnYmFja2dyb3VuZENvbG9yJywgJ292ZXJsYXlDb2xvciddLm1hcChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgICB2YXIgZmlsbCA9IF90aGlzW3Byb3BdO1xuICAgICAgICAgICAgaWYgKGZpbGwgJiYgZmlsbC50b0xpdmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbGwudG9TVkcoX3RoaXMsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIHJldHVybiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbWFya3VwIGNvbnRhaW5pbmcgU1ZHIGZvbnQgZmFjZXMsXG4gICAgICogZm9udCBVUkxzIGZvciBmb250IGZhY2VzIG11c3QgYmUgY29sbGVjdGVkIGJ5IGRldmVsb3BlcnNcbiAgICAgKiBhbmQgYXJlIG5vdCBleHRyYWN0ZWQgZnJvbSB0aGUgRE9NIGJ5IGZhYnJpY2pzXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqZWN0cyBBcnJheSBvZiBmYWJyaWMgb2JqZWN0c1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBjcmVhdGVTVkdGb250RmFjZXNNYXJrdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1hcmt1cCA9ICcnLCBmb250TGlzdCA9IHsgfSwgb2JqLCBmb250RmFtaWx5LFxuICAgICAgICAgIHN0eWxlLCByb3csIHJvd0luZGV4LCBfY2hhciwgY2hhckluZGV4LCBpLCBsZW4sXG4gICAgICAgICAgZm9udFBhdGhzID0gZmFicmljLmZvbnRQYXRocywgb2JqZWN0cyA9IHRoaXMuZ2V0T2JqZWN0cygpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG9iaiA9IG9iamVjdHNbaV07XG4gICAgICAgIGZvbnRGYW1pbHkgPSBvYmouZm9udEZhbWlseTtcbiAgICAgICAgaWYgKG9iai50eXBlLmluZGV4T2YoJ3RleHQnKSA9PT0gLTEgfHwgZm9udExpc3RbZm9udEZhbWlseV0gfHwgIWZvbnRQYXRoc1tmb250RmFtaWx5XSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvbnRMaXN0W2ZvbnRGYW1pbHldID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFvYmouc3R5bGVzKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUgPSBvYmouc3R5bGVzO1xuICAgICAgICBmb3IgKHJvd0luZGV4IGluIHN0eWxlKSB7XG4gICAgICAgICAgcm93ID0gc3R5bGVbcm93SW5kZXhdO1xuICAgICAgICAgIGZvciAoY2hhckluZGV4IGluIHJvdykge1xuICAgICAgICAgICAgX2NoYXIgPSByb3dbY2hhckluZGV4XTtcbiAgICAgICAgICAgIGZvbnRGYW1pbHkgPSBfY2hhci5mb250RmFtaWx5O1xuICAgICAgICAgICAgaWYgKCFmb250TGlzdFtmb250RmFtaWx5XSAmJiBmb250UGF0aHNbZm9udEZhbWlseV0pIHtcbiAgICAgICAgICAgICAgZm9udExpc3RbZm9udEZhbWlseV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqIGluIGZvbnRMaXN0KSB7XG4gICAgICAgIG1hcmt1cCArPSBbXG4gICAgICAgICAgJ1xcdFxcdEBmb250LWZhY2Uge1xcbicsXG4gICAgICAgICAgJ1xcdFxcdFxcdGZvbnQtZmFtaWx5OiBcXCcnLCBqLCAnXFwnO1xcbicsXG4gICAgICAgICAgJ1xcdFxcdFxcdHNyYzogdXJsKFxcJycsIGZvbnRQYXRoc1tqXSwgJ1xcJyk7XFxuJyxcbiAgICAgICAgICAnXFx0XFx0fVxcbidcbiAgICAgICAgXS5qb2luKCcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hcmt1cCkge1xuICAgICAgICBtYXJrdXAgPSBbXG4gICAgICAgICAgJ1xcdDxzdHlsZSB0eXBlPVwidGV4dC9jc3NcIj4nLFxuICAgICAgICAgICc8IVtDREFUQVtcXG4nLFxuICAgICAgICAgIG1hcmt1cCxcbiAgICAgICAgICAnXV0+JyxcbiAgICAgICAgICAnPC9zdHlsZT5cXG4nXG4gICAgICAgIF0uam9pbignJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXJrdXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR09iamVjdHM6IGZ1bmN0aW9uKG1hcmt1cCwgcmV2aXZlcikge1xuICAgICAgdmFyIGluc3RhbmNlLCBpLCBsZW4sIG9iamVjdHMgPSB0aGlzLmdldE9iamVjdHMoKTtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaW5zdGFuY2UgPSBvYmplY3RzW2ldO1xuICAgICAgICBpZiAoaW5zdGFuY2UuZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRTVkdPYmplY3QobWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR09iamVjdDogZnVuY3Rpb24obWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcikge1xuICAgICAgbWFya3VwLnB1c2goaW5zdGFuY2UudG9TVkcocmV2aXZlcikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdCZ092ZXJsYXlJbWFnZTogZnVuY3Rpb24obWFya3VwLCBwcm9wZXJ0eSwgcmV2aXZlcikge1xuICAgICAgaWYgKHRoaXNbcHJvcGVydHldICYmIHRoaXNbcHJvcGVydHldLnRvU1ZHKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKHRoaXNbcHJvcGVydHldLnRvU1ZHKHJldml2ZXIpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHQmdPdmVybGF5Q29sb3I6IGZ1bmN0aW9uKG1hcmt1cCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBmaWxsZXIgPSB0aGlzW3Byb3BlcnR5XSwgdnB0ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybSwgZmluYWxXaWR0aCA9IHRoaXMud2lkdGggLyB2cHRbMF0sXG4gICAgICAgICAgZmluYWxIZWlnaHQgPSB0aGlzLmhlaWdodCAvIHZwdFszXTtcbiAgICAgIGlmICghZmlsbGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsZXIudG9MaXZlKSB7XG4gICAgICAgIHZhciByZXBlYXQgPSBmaWxsZXIucmVwZWF0O1xuICAgICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgICAnPHJlY3QgdHJhbnNmb3JtPVwidHJhbnNsYXRlKCcsIGZpbmFsV2lkdGggLyAyLCAnLCcsIGZpbmFsSGVpZ2h0IC8gMiwgJylcIicsXG4gICAgICAgICAgJyB4PVwiJywgZmlsbGVyLm9mZnNldFggLSBmaW5hbFdpZHRoIC8gMiwgJ1wiIHk9XCInLCBmaWxsZXIub2Zmc2V0WSAtIGZpbmFsSGVpZ2h0IC8gMiwgJ1wiICcsXG4gICAgICAgICAgJ3dpZHRoPVwiJyxcbiAgICAgICAgICAocmVwZWF0ID09PSAncmVwZWF0LXknIHx8IHJlcGVhdCA9PT0gJ25vLXJlcGVhdCdcbiAgICAgICAgICAgID8gZmlsbGVyLnNvdXJjZS53aWR0aFxuICAgICAgICAgICAgOiBmaW5hbFdpZHRoICksXG4gICAgICAgICAgJ1wiIGhlaWdodD1cIicsXG4gICAgICAgICAgKHJlcGVhdCA9PT0gJ3JlcGVhdC14JyB8fCByZXBlYXQgPT09ICduby1yZXBlYXQnXG4gICAgICAgICAgICA/IGZpbGxlci5zb3VyY2UuaGVpZ2h0XG4gICAgICAgICAgICA6IGZpbmFsSGVpZ2h0KSxcbiAgICAgICAgICAnXCIgZmlsbD1cInVybCgjU1ZHSURfJyArIGZpbGxlci5pZCArICcpXCInLFxuICAgICAgICAgICc+PC9yZWN0PlxcbidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgICAnPHJlY3QgeD1cIjBcIiB5PVwiMFwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiAnLFxuICAgICAgICAgICdmaWxsPVwiJywgdGhpc1twcm9wZXJ0eV0sICdcIicsXG4gICAgICAgICAgJz48L3JlY3Q+XFxuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3Qgb3IgdGhlIG9iamVjdHMgb2YgYSBtdWx0aXBsZSBzZWxlY3Rpb25cbiAgICAgKiB0byB0aGUgYm90dG9tIG9mIHRoZSBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmQgdG8gYmFja1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2VuZFRvQmFjazogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGksIG9iaiwgb2JqcztcbiAgICAgIGlmIChvYmplY3QgPT09IGFjdGl2ZVNlbGVjdGlvbiAmJiBvYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpIHtcbiAgICAgICAgb2JqcyA9IGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cztcbiAgICAgICAgZm9yIChpID0gb2Jqcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICBvYmogPSBvYmpzW2ldO1xuICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmopO1xuICAgICAgICAgIHRoaXMuX29iamVjdHMudW5zaGlmdChvYmopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iamVjdCk7XG4gICAgICAgIHRoaXMuX29iamVjdHMudW5zaGlmdChvYmplY3QpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3Qgb3IgdGhlIG9iamVjdHMgb2YgYSBtdWx0aXBsZSBzZWxlY3Rpb25cbiAgICAgKiB0byB0aGUgdG9wIG9mIHRoZSBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGksIG9iaiwgb2JqcztcbiAgICAgIGlmIChvYmplY3QgPT09IGFjdGl2ZVNlbGVjdGlvbiAmJiBvYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpIHtcbiAgICAgICAgb2JqcyA9IGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYmogPSBvYmpzW2ldO1xuICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmopO1xuICAgICAgICAgIHRoaXMuX29iamVjdHMucHVzaChvYmopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iamVjdCk7XG4gICAgICAgIHRoaXMuX29iamVjdHMucHVzaChvYmplY3QpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3Qgb3IgYSBzZWxlY3Rpb24gZG93biBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQW4gb3B0aW9uYWwgcGFyYW10ZXIsIGludGVyc2VjdGluZyBhbGxvd2VzIHRvIG1vdmUgdGhlIG9iamVjdCBpbiBiZWhpbmRcbiAgICAgKiB0aGUgZmlyc3QgaW50ZXJzZWN0aW5nIG9iamVjdC4gV2hlcmUgaW50ZXJzZWN0aW9uIGlzIGNhbGN1bGF0ZWQgd2l0aFxuICAgICAqIGJvdW5kaW5nIGJveC4gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIGZvdW5kLCB0aGVyZSB3aWxsIG5vdCBiZSBjaGFuZ2UgaW4gdGhlXG4gICAgICogc3RhY2suXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgYmVoaW5kIG5leHQgbG93ZXIgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2VuZEJhY2t3YXJkczogZnVuY3Rpb24gKG9iamVjdCwgaW50ZXJzZWN0aW5nKSB7XG4gICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBhY3RpdmVTZWxlY3Rpb24gPSB0aGlzLl9hY3RpdmVPYmplY3QsXG4gICAgICAgICAgaSwgb2JqLCBpZHgsIG5ld0lkeCwgb2Jqcywgb2Jqc01vdmVkID0gMDtcblxuICAgICAgaWYgKG9iamVjdCA9PT0gYWN0aXZlU2VsZWN0aW9uICYmIG9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgICBvYmpzID0gYWN0aXZlU2VsZWN0aW9uLl9vYmplY3RzO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2Jqcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG9iaiA9IG9ianNbaV07XG4gICAgICAgICAgaWR4ID0gdGhpcy5fb2JqZWN0cy5pbmRleE9mKG9iaik7XG4gICAgICAgICAgaWYgKGlkeCA+IDAgKyBvYmpzTW92ZWQpIHtcbiAgICAgICAgICAgIG5ld0lkeCA9IGlkeCAtIDE7XG4gICAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKG5ld0lkeCwgMCwgb2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2Jqc01vdmVkKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZHggPSB0aGlzLl9vYmplY3RzLmluZGV4T2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKGlkeCAhPT0gMCkge1xuICAgICAgICAgIC8vIGlmIG9iamVjdCBpcyBub3Qgb24gdGhlIGJvdHRvbSBvZiBzdGFja1xuICAgICAgICAgIG5ld0lkeCA9IHRoaXMuX2ZpbmROZXdMb3dlckluZGV4KG9iamVjdCwgaWR4LCBpbnRlcnNlY3RpbmcpO1xuICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKG5ld0lkeCwgMCwgb2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kTmV3TG93ZXJJbmRleDogZnVuY3Rpb24ob2JqZWN0LCBpZHgsIGludGVyc2VjdGluZykge1xuICAgICAgdmFyIG5ld0lkeCwgaTtcblxuICAgICAgaWYgKGludGVyc2VjdGluZykge1xuICAgICAgICBuZXdJZHggPSBpZHg7XG5cbiAgICAgICAgLy8gdHJhdmVyc2UgZG93biB0aGUgc3RhY2sgbG9va2luZyBmb3IgdGhlIG5lYXJlc3QgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgICAgICBmb3IgKGkgPSBpZHggLSAxOyBpID49IDA7IC0taSkge1xuXG4gICAgICAgICAgdmFyIGlzSW50ZXJzZWN0aW5nID0gb2JqZWN0LmludGVyc2VjdHNXaXRoT2JqZWN0KHRoaXMuX29iamVjdHNbaV0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KHRoaXMuX29iamVjdHNbaV0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdChvYmplY3QpO1xuXG4gICAgICAgICAgaWYgKGlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICBuZXdJZHggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3SWR4ID0gaWR4IC0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0lkeDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gb2JqZWN0IG9yIGEgc2VsZWN0aW9uIHVwIGluIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICAgKiBBbiBvcHRpb25hbCBwYXJhbXRlciwgaW50ZXJzZWN0aW5nIGFsbG93ZXMgdG8gbW92ZSB0aGUgb2JqZWN0IGluIGZyb250XG4gICAgICogb2YgdGhlIGZpcnN0IGludGVyc2VjdGluZyBvYmplY3QuIFdoZXJlIGludGVyc2VjdGlvbiBpcyBjYWxjdWxhdGVkIHdpdGhcbiAgICAgKiBib3VuZGluZyBib3guIElmIG5vIGludGVyc2VjdGlvbiBpcyBmb3VuZCwgdGhlcmUgd2lsbCBub3QgYmUgY2hhbmdlIGluIHRoZVxuICAgICAqIHN0YWNrLlxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZW5kXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW50ZXJzZWN0aW5nXSBJZiBgdHJ1ZWAsIHNlbmQgb2JqZWN0IGluIGZyb250IG9mIG5leHQgdXBwZXIgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYnJpbmdGb3J3YXJkOiBmdW5jdGlvbiAob2JqZWN0LCBpbnRlcnNlY3RpbmcpIHtcbiAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIGFjdGl2ZVNlbGVjdGlvbiA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBpLCBvYmosIGlkeCwgbmV3SWR4LCBvYmpzLCBvYmpzTW92ZWQgPSAwO1xuXG4gICAgICBpZiAob2JqZWN0ID09PSBhY3RpdmVTZWxlY3Rpb24gJiYgb2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICAgIG9ianMgPSBhY3RpdmVTZWxlY3Rpb24uX29iamVjdHM7XG4gICAgICAgIGZvciAoaSA9IG9ianMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgb2JqID0gb2Jqc1tpXTtcbiAgICAgICAgICBpZHggPSB0aGlzLl9vYmplY3RzLmluZGV4T2Yob2JqKTtcbiAgICAgICAgICBpZiAoaWR4IDwgdGhpcy5fb2JqZWN0cy5sZW5ndGggLSAxIC0gb2Jqc01vdmVkKSB7XG4gICAgICAgICAgICBuZXdJZHggPSBpZHggKyAxO1xuICAgICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iaik7XG4gICAgICAgICAgICB0aGlzLl9vYmplY3RzLnNwbGljZShuZXdJZHgsIDAsIG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9ianNNb3ZlZCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWR4ID0gdGhpcy5fb2JqZWN0cy5pbmRleE9mKG9iamVjdCk7XG4gICAgICAgIGlmIChpZHggIT09IHRoaXMuX29iamVjdHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIC8vIGlmIG9iamVjdCBpcyBub3Qgb24gdG9wIG9mIHN0YWNrIChsYXN0IGl0ZW0gaW4gYW4gYXJyYXkpXG4gICAgICAgICAgbmV3SWR4ID0gdGhpcy5fZmluZE5ld1VwcGVySW5kZXgob2JqZWN0LCBpZHgsIGludGVyc2VjdGluZyk7XG4gICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iamVjdCk7XG4gICAgICAgICAgdGhpcy5fb2JqZWN0cy5zcGxpY2UobmV3SWR4LCAwLCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmROZXdVcHBlckluZGV4OiBmdW5jdGlvbihvYmplY3QsIGlkeCwgaW50ZXJzZWN0aW5nKSB7XG4gICAgICB2YXIgbmV3SWR4LCBpLCBsZW47XG5cbiAgICAgIGlmIChpbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgbmV3SWR4ID0gaWR4O1xuXG4gICAgICAgIC8vIHRyYXZlcnNlIHVwIHRoZSBzdGFjayBsb29raW5nIGZvciB0aGUgbmVhcmVzdCBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAgICAgIGZvciAoaSA9IGlkeCArIDEsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblxuICAgICAgICAgIHZhciBpc0ludGVyc2VjdGluZyA9IG9iamVjdC5pbnRlcnNlY3RzV2l0aE9iamVjdCh0aGlzLl9vYmplY3RzW2ldKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdCh0aGlzLl9vYmplY3RzW2ldKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uaXNDb250YWluZWRXaXRoaW5PYmplY3Qob2JqZWN0KTtcblxuICAgICAgICAgIGlmIChpc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgbmV3SWR4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld0lkeCA9IGlkeCArIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdJZHg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIG9iamVjdCB0byBzcGVjaWZpZWQgbGV2ZWwgaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZW5kXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFBvc2l0aW9uIHRvIG1vdmUgdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIG1vdmVUbzogZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgpIHtcbiAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgdGhpcy5fb2JqZWN0cy5zcGxpY2UoaW5kZXgsIDAsIG9iamVjdCk7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGEgY2FudmFzIGVsZW1lbnQgYW5kIGRpc3Bvc2Ugb2JqZWN0c1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gY2FuY2VsIGV2ZW50dWFsbHkgb25nb2luZyByZW5kZXJzXG4gICAgICBpZiAodGhpcy5pc1JlbmRlcmluZykge1xuICAgICAgICBmYWJyaWMudXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5pc1JlbmRlcmluZyk7XG4gICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5mb3JFYWNoT2JqZWN0KGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3QuZGlzcG9zZSAmJiBvYmplY3QuZGlzcG9zZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9vYmplY3RzID0gW107XG4gICAgICB0aGlzLmJhY2tncm91bmRJbWFnZSA9IG51bGw7XG4gICAgICB0aGlzLm92ZXJsYXlJbWFnZSA9IG51bGw7XG4gICAgICB0aGlzLl9pVGV4dEluc3RhbmNlcyA9IG51bGw7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwgPSBudWxsO1xuICAgICAgdGhpcy5jb250ZXh0Q29udGFpbmVyID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5DYW52YXMgKCcgKyB0aGlzLmNvbXBsZXhpdHkoKSArICcpOiAnICtcbiAgICAgICAgICAgICAgICd7IG9iamVjdHM6ICcgKyB0aGlzLmdldE9iamVjdHMoKS5sZW5ndGggKyAnIH0+JztcbiAgICB9XG4gIH0pO1xuXG4gIGV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgZmFicmljLk9ic2VydmFibGUpO1xuICBleHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIGZhYnJpYy5Db2xsZWN0aW9uKTtcbiAgZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCBmYWJyaWMuRGF0YVVSTEV4cG9ydGVyKTtcblxuICBleHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcywgLyoqIEBsZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzICovIHtcblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIEVNUFRZX0pTT046ICd7XCJvYmplY3RzXCI6IFtdLCBcImJhY2tncm91bmRcIjogXCJ3aGl0ZVwifScsXG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIHdheSB0byBjaGVjayBzdXBwb3J0IG9mIHNvbWUgb2YgdGhlIGNhbnZhcyBtZXRob2RzXG4gICAgICogKGVpdGhlciB0aG9zZSBvZiBIVE1MQ2FudmFzRWxlbWVudCBpdHNlbGYsIG9yIHJlbmRlcmluZyBjb250ZXh0KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZE5hbWUgTWV0aG9kIHRvIGNoZWNrIHN1cHBvcnQgZm9yO1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvdWxkIGJlIG9uZSBvZiBcImdldEltYWdlRGF0YVwiLCBcInRvRGF0YVVSTFwiLCBcInRvRGF0YVVSTFdpdGhRdWFsaXR5XCIgb3IgXCJzZXRMaW5lRGFzaFwiXG4gICAgICogQHJldHVybiB7Qm9vbGVhbiB8IG51bGx9IGB0cnVlYCBpZiBtZXRob2QgaXMgc3VwcG9ydGVkIChvciBhdCBsZWFzdCBleGlzdHMpLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBgbnVsbGAgaWYgY2FudmFzIGVsZW1lbnQgb3IgY29udGV4dCBjYW4gbm90IGJlIGluaXRpYWxpemVkXG4gICAgICovXG4gICAgc3VwcG9ydHM6IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZWwgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG5cbiAgICAgIGlmICghZWwgfHwgIWVsLmdldENvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHggPSBlbC5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAobWV0aG9kTmFtZSkge1xuXG4gICAgICAgIGNhc2UgJ2dldEltYWdlRGF0YSc6XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBjdHguZ2V0SW1hZ2VEYXRhICE9PSAndW5kZWZpbmVkJztcblxuICAgICAgICBjYXNlICdzZXRMaW5lRGFzaCc6XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBjdHguc2V0TGluZURhc2ggIT09ICd1bmRlZmluZWQnO1xuXG4gICAgICAgIGNhc2UgJ3RvRGF0YVVSTCc6XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbC50b0RhdGFVUkwgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgICAgIGNhc2UgJ3RvRGF0YVVSTFdpdGhRdWFsaXR5JzpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZWwudG9EYXRhVVJMKCdpbWFnZS9qcGVnJywgMCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICogQHJldHVybiB7U3RyaW5nfSBKU09OIHN0cmluZ1xuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNzZXJpYWxpemF0aW9ufVxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL3BlYzg2L3xqc0ZpZGRsZSBkZW1vfVxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5KU09OIHdpdGhvdXQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzPC9jYXB0aW9uPlxuICAgKiB2YXIganNvbiA9IGNhbnZhcy50b0pTT04oKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+SlNPTiB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllcyBpbmNsdWRlZDwvY2FwdGlvbj5cbiAgICogdmFyIGpzb24gPSBjYW52YXMudG9KU09OKFsnbG9ja01vdmVtZW50WCcsICdsb2NrTW92ZW1lbnRZJywgJ2xvY2tSb3RhdGlvbicsICdsb2NrU2NhbGluZ1gnLCAnbG9ja1NjYWxpbmdZJywgJ2xvY2tVbmlTY2FsaW5nJ10pO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5KU09OIHdpdGhvdXQgZGVmYXVsdCB2YWx1ZXM8L2NhcHRpb24+XG4gICAqIGNhbnZhcy5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IGZhbHNlO1xuICAgKiB2YXIganNvbiA9IGNhbnZhcy50b0pTT04oKTtcbiAgICovXG4gIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLnRvSlNPTiA9IGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLnRvT2JqZWN0O1xuXG4gIGlmIChmYWJyaWMuaXNMaWtlbHlOb2RlKSB7XG4gICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuY3JlYXRlUE5HU3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW1wbCA9IGZhYnJpYy51dGlsLmdldE5vZGVDYW52YXModGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIHJldHVybiBpbXBsICYmIGltcGwuY3JlYXRlUE5HU3RyZWFtKCk7XG4gICAgfTtcbiAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5jcmVhdGVKUEVHU3RyZWFtID0gZnVuY3Rpb24ob3B0cykge1xuICAgICAgdmFyIGltcGwgPSBmYWJyaWMudXRpbC5nZXROb2RlQ2FudmFzKHRoaXMubG93ZXJDYW52YXNFbCk7XG4gICAgICByZXR1cm4gaW1wbCAmJiBpbXBsLmNyZWF0ZUpQRUdTdHJlYW0ob3B0cyk7XG4gICAgfTtcbiAgfVxufSkoKTtcblxuXG4vKipcbiAqIEJhc2VCcnVzaCBjbGFzc1xuICogQGNsYXNzIGZhYnJpYy5CYXNlQnJ1c2hcbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZnJlZWRyYXdpbmd8RnJlZWRyYXdpbmcgZGVtb31cbiAqL1xuZmFicmljLkJhc2VCcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLkJhc2VCcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBDb2xvciBvZiBhIGJydXNoXG4gICAqIEB0eXBlIFN0cmluZ1xuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgY29sb3I6ICdyZ2IoMCwgMCwgMCknLFxuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiBhIGJydXNoLCBoYXMgdG8gYmUgYSBOdW1iZXIsIG5vIHN0cmluZyBsaXRlcmFsc1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHdpZHRoOiAxLFxuXG4gIC8qKlxuICAgKiBTaGFkb3cgb2JqZWN0IHJlcHJlc2VudGluZyBzaGFkb3cgb2YgdGhpcyBzaGFwZS5cbiAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSByZXBsYWNlcyBcInNoYWRvd0NvbG9yXCIgKFN0cmluZyksIFwic2hhZG93T2Zmc2V0WFwiIChOdW1iZXIpLFxuICAgKiBcInNoYWRvd09mZnNldFlcIiAoTnVtYmVyKSBhbmQgXCJzaGFkb3dCbHVyXCIgKE51bWJlcikgc2luY2UgdjEuMi4xMlxuICAgKiBAdHlwZSBmYWJyaWMuU2hhZG93XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzaGFkb3c6IG51bGwsXG5cbiAgLyoqXG4gICAqIExpbmUgZW5kaW5ncyBzdHlsZSBvZiBhIGJydXNoIChvbmUgb2YgXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIilcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzdHJva2VMaW5lQ2FwOiAncm91bmQnLFxuXG4gIC8qKlxuICAgKiBDb3JuZXIgc3R5bGUgb2YgYSBicnVzaCAob25lIG9mIFwiYmV2ZWxcIiwgXCJyb3VuZFwiLCBcIm1pdGVyXCIpXG4gICAqIEB0eXBlIFN0cmluZ1xuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgc3Ryb2tlTGluZUpvaW46ICdyb3VuZCcsXG5cbiAgLyoqXG4gICAqIE1heGltdW0gbWl0ZXIgbGVuZ3RoICh1c2VkIGZvciBzdHJva2VMaW5lSm9pbiA9IFwibWl0ZXJcIikgb2YgYSBicnVzaCdzXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgc3Ryb2tlTWl0ZXJMaW1pdDogICAgICAgICAxMCxcblxuICAvKipcbiAgICogU3Ryb2tlIERhc2ggQXJyYXkuXG4gICAqIEB0eXBlIEFycmF5XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzdHJva2VEYXNoQXJyYXk6IG51bGwsXG5cbiAgLyoqXG4gICAqIFNldHMgc2hhZG93IG9mIGFuIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCBvciBzdHJpbmcgKGUuZy4gXCIycHggMnB4IDEwcHggcmdiYSgwLDAsMCwwLjIpXCIpXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc2V0U2hhZG93OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5zaGFkb3cgPSBuZXcgZmFicmljLlNoYWRvdyhvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBicnVzaCBzdHlsZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRCcnVzaFN0eWxlczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjdHgubGluZUNhcCA9IHRoaXMuc3Ryb2tlTGluZUNhcDtcbiAgICBjdHgubWl0ZXJMaW1pdCA9IHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdDtcbiAgICBjdHgubGluZUpvaW4gPSB0aGlzLnN0cm9rZUxpbmVKb2luO1xuICAgIGlmIChmYWJyaWMuU3RhdGljQ2FudmFzLnN1cHBvcnRzKCdzZXRMaW5lRGFzaCcpKSB7XG4gICAgICBjdHguc2V0TGluZURhc2godGhpcy5zdHJva2VEYXNoQXJyYXkgfHwgW10pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdHJhbnNmb3JtYXRpb24gb24gZ2l2ZW4gY29udGV4dFxuICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHQyZH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2F2ZUFuZFRyYW5zZm9ybTogZnVuY3Rpb24oY3R4KSB7XG4gICAgdmFyIHYgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYnJ1c2ggc2hhZG93IHN0eWxlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldFNoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnNoYWRvdykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLFxuICAgICAgICB6b29tID0gdGhpcy5jYW52YXMuZ2V0Wm9vbSgpO1xuXG4gICAgY3R4LnNoYWRvd0NvbG9yID0gdGhpcy5zaGFkb3cuY29sb3I7XG4gICAgY3R4LnNoYWRvd0JsdXIgPSB0aGlzLnNoYWRvdy5ibHVyICogem9vbTtcbiAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHRoaXMuc2hhZG93Lm9mZnNldFggKiB6b29tO1xuICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gdGhpcy5zaGFkb3cub2Zmc2V0WSAqIHpvb207XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYnJ1c2ggc2hhZG93IHN0eWxlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0U2hhZG93OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcDtcblxuICAgIGN0eC5zaGFkb3dDb2xvciA9ICcnO1xuICAgIGN0eC5zaGFkb3dCbHVyID0gY3R4LnNoYWRvd09mZnNldFggPSBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gIH1cbn0pO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogUGVuY2lsQnJ1c2ggY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5QZW5jaWxCcnVzaFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuQmFzZUJydXNoXG4gICAqL1xuICBmYWJyaWMuUGVuY2lsQnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQmFzZUJydXNoLCAvKiogQGxlbmRzIGZhYnJpYy5QZW5jaWxCcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5DYW52YXN9IGNhbnZhc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5QZW5jaWxCcnVzaH0gSW5zdGFuY2Ugb2YgYSBwZW5jaWwgYnJ1c2hcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgdGhpcy5fcG9pbnRzID0gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgaW5zaWRlIG9uIG1vdXNlIGRvd24gYW5kIG1vdXNlIG1vdmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgICAqL1xuICAgIF9kcmF3U2VnbWVudDogZnVuY3Rpb24gKGN0eCwgcDEsIHAyKSB7XG4gICAgICB2YXIgbWlkUG9pbnQgPSBwMS5taWRQb2ludEZyb20ocDIpO1xuICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8ocDEueCwgcDEueSwgbWlkUG9pbnQueCwgbWlkUG9pbnQueSk7XG4gICAgICByZXR1cm4gbWlkUG9pbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElub3Zva2VkIG9uIG1vdXNlIGRvd25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgICAqL1xuICAgIG9uTW91c2VEb3duOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICB0aGlzLl9wcmVwYXJlRm9yRHJhd2luZyhwb2ludGVyKTtcbiAgICAgIC8vIGNhcHR1cmUgY29vcmRpbmF0ZXMgaW1tZWRpYXRlbHlcbiAgICAgIC8vIHRoaXMgYWxsb3dzIHRvIGRyYXcgZG90cyAod2hlbiBtb3ZlbWVudCBuZXZlciBvY2N1cnMpXG4gICAgICB0aGlzLl9jYXB0dXJlRHJhd2luZ1BhdGgocG9pbnRlcik7XG4gICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5vdm9rZWQgb24gbW91c2UgbW92ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAgICovXG4gICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICAgIGlmICh0aGlzLl9jYXB0dXJlRHJhd2luZ1BhdGgocG9pbnRlcikgJiYgdGhpcy5fcG9pbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaWYgKHRoaXMubmVlZHNGdWxsUmVuZGVyKSB7XG4gICAgICAgICAgLy8gcmVkcmF3IGN1cnZlXG4gICAgICAgICAgLy8gY2xlYXIgdG9wIGNhbnZhc1xuICAgICAgICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICAgICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5fcG9pbnRzLCBsZW5ndGggPSBwb2ludHMubGVuZ3RoLCBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgICAgICAgIC8vIGRyYXcgdGhlIGN1cnZlIHVwZGF0ZVxuICAgICAgICAgIHRoaXMuX3NhdmVBbmRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICBpZiAodGhpcy5vbGRFbmQpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8odGhpcy5vbGRFbmQueCwgdGhpcy5vbGRFbmQueSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub2xkRW5kID0gdGhpcy5fZHJhd1NlZ21lbnQoY3R4LCBwb2ludHNbbGVuZ3RoIC0gMl0sIHBvaW50c1tsZW5ndGggLSAxXSwgdHJ1ZSk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBvbiBtb3VzZSB1cFxuICAgICAqL1xuICAgIG9uTW91c2VVcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm9sZEVuZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2ZpbmFsaXplQW5kQWRkUGF0aCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyIEFjdHVhbCBtb3VzZSBwb3NpdGlvbiByZWxhdGVkIHRvIHRoZSBjYW52YXMuXG4gICAgICovXG4gICAgX3ByZXBhcmVGb3JEcmF3aW5nOiBmdW5jdGlvbihwb2ludGVyKSB7XG5cbiAgICAgIHZhciBwID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSk7XG5cbiAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICB0aGlzLl9hZGRQb2ludChwKTtcbiAgICAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AubW92ZVRvKHAueCwgcC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgUG9pbnQgdG8gYmUgYWRkZWQgdG8gcG9pbnRzIGFycmF5XG4gICAgICovXG4gICAgX2FkZFBvaW50OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgaWYgKHRoaXMuX3BvaW50cy5sZW5ndGggPiAxICYmIHBvaW50LmVxKHRoaXMuX3BvaW50c1t0aGlzLl9wb2ludHMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBwb2ludHMgYXJyYXkgYW5kIHNldCBjb250ZXh0VG9wIGNhbnZhcyBzdHlsZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9wb2ludHMubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuX3NldEJydXNoU3R5bGVzKCk7XG4gICAgICB2YXIgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpO1xuICAgICAgdGhpcy5uZWVkc0Z1bGxSZW5kZXIgPSAoY29sb3IuZ2V0QWxwaGEoKSA8IDEpO1xuICAgICAgdGhpcy5fc2V0U2hhZG93KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXIgQWN0dWFsIG1vdXNlIHBvc2l0aW9uIHJlbGF0ZWQgdG8gdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBfY2FwdHVyZURyYXdpbmdQYXRoOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICB2YXIgcG9pbnRlclBvaW50ID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSk7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkUG9pbnQocG9pbnRlclBvaW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhdyBhIHNtb290aCBwYXRoIG9uIHRoZSB0b3BDYW52YXMgdXNpbmcgcXVhZHJhdGljQ3VydmVUb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3R4ICA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3AsIGksIGxlbixcbiAgICAgICAgICBwMSA9IHRoaXMuX3BvaW50c1swXSxcbiAgICAgICAgICBwMiA9IHRoaXMuX3BvaW50c1sxXTtcblxuICAgICAgdGhpcy5fc2F2ZUFuZFRyYW5zZm9ybShjdHgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgLy9pZiB3ZSBvbmx5IGhhdmUgMiBwb2ludHMgaW4gdGhlIHBhdGggYW5kIHRoZXkgYXJlIHRoZSBzYW1lXG4gICAgICAvL2l0IG1lYW5zIHRoYXQgdGhlIHVzZXIgb25seSBjbGlja2VkIHRoZSBjYW52YXMgd2l0aG91dCBtb3ZpbmcgdGhlIG1vdXNlXG4gICAgICAvL3RoZW4gd2Ugc2hvdWxkIGJlIGRyYXdpbmcgYSBkb3QuIEEgcGF0aCBpc24ndCBkcmF3biBiZXR3ZWVuIHR3byBpZGVudGljYWwgZG90c1xuICAgICAgLy90aGF0J3Mgd2h5IHdlIHNldCB0aGVtIGFwYXJ0IGEgYml0XG4gICAgICBpZiAodGhpcy5fcG9pbnRzLmxlbmd0aCA9PT0gMiAmJiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnkpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCAvIDEwMDA7XG4gICAgICAgIHAxID0gbmV3IGZhYnJpYy5Qb2ludChwMS54LCBwMS55KTtcbiAgICAgICAgcDIgPSBuZXcgZmFicmljLlBvaW50KHAyLngsIHAyLnkpO1xuICAgICAgICBwMS54IC09IHdpZHRoO1xuICAgICAgICBwMi54ICs9IHdpZHRoO1xuICAgICAgfVxuICAgICAgY3R4Lm1vdmVUbyhwMS54LCBwMS55KTtcblxuICAgICAgZm9yIChpID0gMSwgbGVuID0gdGhpcy5fcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIHdlIHBpY2sgdGhlIHBvaW50IGJldHdlZW4gcGkgKyAxICYgcGkgKyAyIGFzIHRoZVxuICAgICAgICAvLyBlbmQgcG9pbnQgYW5kIHAxIGFzIG91ciBjb250cm9sIHBvaW50LlxuICAgICAgICB0aGlzLl9kcmF3U2VnbWVudChjdHgsIHAxLCBwMik7XG4gICAgICAgIHAxID0gdGhpcy5fcG9pbnRzW2ldO1xuICAgICAgICBwMiA9IHRoaXMuX3BvaW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBEcmF3IGxhc3QgbGluZSBhcyBhIHN0cmFpZ2h0IGxpbmUgd2hpbGVcbiAgICAgIC8vIHdlIHdhaXQgZm9yIHRoZSBuZXh0IHBvaW50IHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlXG4gICAgICAvLyB0aGUgYmV6aWVyIGNvbnRyb2wgcG9pbnRcbiAgICAgIGN0eC5saW5lVG8ocDEueCwgcDEueSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBwb2ludHMgdG8gU1ZHIHBhdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgQXJyYXkgb2YgcG9pbnRzXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTVkcgcGF0aFxuICAgICAqL1xuICAgIGNvbnZlcnRQb2ludHNUb1NWR1BhdGg6IGZ1bmN0aW9uKHBvaW50cykge1xuICAgICAgdmFyIHBhdGggPSBbXSwgaSwgd2lkdGggPSB0aGlzLndpZHRoIC8gMTAwMCxcbiAgICAgICAgICBwMSA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRzWzBdLngsIHBvaW50c1swXS55KSxcbiAgICAgICAgICBwMiA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRzWzFdLngsIHBvaW50c1sxXS55KSxcbiAgICAgICAgICBsZW4gPSBwb2ludHMubGVuZ3RoLCBtdWx0U2lnblggPSAxLCBtdWx0U2lnblkgPSAxLCBtYW55UG9pbnRzID0gbGVuID4gMjtcblxuICAgICAgaWYgKG1hbnlQb2ludHMpIHtcbiAgICAgICAgbXVsdFNpZ25YID0gcG9pbnRzWzJdLnggPCBwMi54ID8gLTEgOiBwb2ludHNbMl0ueCA9PT0gcDIueCA/IDAgOiAxO1xuICAgICAgICBtdWx0U2lnblkgPSBwb2ludHNbMl0ueSA8IHAyLnkgPyAtMSA6IHBvaW50c1syXS55ID09PSBwMi55ID8gMCA6IDE7XG4gICAgICB9XG4gICAgICBwYXRoLnB1c2goJ00gJywgcDEueCAtIG11bHRTaWduWCAqIHdpZHRoLCAnICcsIHAxLnkgLSBtdWx0U2lnblkgKiB3aWR0aCwgJyAnKTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoIXAxLmVxKHAyKSkge1xuICAgICAgICAgIHZhciBtaWRQb2ludCA9IHAxLm1pZFBvaW50RnJvbShwMik7XG4gICAgICAgICAgLy8gcDEgaXMgb3VyIGJlemllciBjb250cm9sIHBvaW50XG4gICAgICAgICAgLy8gbWlkcG9pbnQgaXMgb3VyIGVuZHBvaW50XG4gICAgICAgICAgLy8gc3RhcnQgcG9pbnQgaXMgcChpLTEpIHZhbHVlLlxuICAgICAgICAgIHBhdGgucHVzaCgnUSAnLCBwMS54LCAnICcsIHAxLnksICcgJywgbWlkUG9pbnQueCwgJyAnLCBtaWRQb2ludC55LCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIHAxID0gcG9pbnRzW2ldO1xuICAgICAgICBpZiAoKGkgKyAxKSA8IHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBwMiA9IHBvaW50c1tpICsgMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtYW55UG9pbnRzKSB7XG4gICAgICAgIG11bHRTaWduWCA9IHAxLnggPiBwb2ludHNbaSAtIDJdLnggPyAxIDogcDEueCA9PT0gcG9pbnRzW2kgLSAyXS54ID8gMCA6IC0xO1xuICAgICAgICBtdWx0U2lnblkgPSBwMS55ID4gcG9pbnRzW2kgLSAyXS55ID8gMSA6IHAxLnkgPT09IHBvaW50c1tpIC0gMl0ueSA/IDAgOiAtMTtcbiAgICAgIH1cbiAgICAgIHBhdGgucHVzaCgnTCAnLCBwMS54ICsgbXVsdFNpZ25YICogd2lkdGgsICcgJywgcDEueSArIG11bHRTaWduWSAqIHdpZHRoKTtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGZhYnJpYy5QYXRoIG9iamVjdCB0byBhZGQgb24gY2FudmFzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhEYXRhIFBhdGggZGF0YVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5QYXRofSBQYXRoIHRvIGFkZCBvbiBjYW52YXNcbiAgICAgKi9cbiAgICBjcmVhdGVQYXRoOiBmdW5jdGlvbihwYXRoRGF0YSkge1xuICAgICAgdmFyIHBhdGggPSBuZXcgZmFicmljLlBhdGgocGF0aERhdGEsIHtcbiAgICAgICAgZmlsbDogbnVsbCxcbiAgICAgICAgc3Ryb2tlOiB0aGlzLmNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgc3Ryb2tlTGluZUNhcDogdGhpcy5zdHJva2VMaW5lQ2FwLFxuICAgICAgICBzdHJva2VNaXRlckxpbWl0OiB0aGlzLnN0cm9rZU1pdGVyTGltaXQsXG4gICAgICAgIHN0cm9rZUxpbmVKb2luOiB0aGlzLnN0cm9rZUxpbmVKb2luLFxuICAgICAgICBzdHJva2VEYXNoQXJyYXk6IHRoaXMuc3Ryb2tlRGFzaEFycmF5LFxuICAgICAgfSk7XG4gICAgICB2YXIgcG9zaXRpb24gPSBuZXcgZmFicmljLlBvaW50KHBhdGgubGVmdCArIHBhdGgud2lkdGggLyAyLCBwYXRoLnRvcCArIHBhdGguaGVpZ2h0IC8gMik7XG4gICAgICBwb3NpdGlvbiA9IHBhdGgudHJhbnNsYXRlVG9HaXZlbk9yaWdpbihwb3NpdGlvbiwgJ2NlbnRlcicsICdjZW50ZXInLCBwYXRoLm9yaWdpblgsIHBhdGgub3JpZ2luWSk7XG4gICAgICBwYXRoLnRvcCA9IHBvc2l0aW9uLnk7XG4gICAgICBwYXRoLmxlZnQgPSBwb3NpdGlvbi54O1xuICAgICAgaWYgKHRoaXMuc2hhZG93KSB7XG4gICAgICAgIHRoaXMuc2hhZG93LmFmZmVjdFN0cm9rZSA9IHRydWU7XG4gICAgICAgIHBhdGguc2V0U2hhZG93KHRoaXMuc2hhZG93KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNldXAgYWZ0ZXIgZHJhd2luZyB0aGUgcGF0aCBvbiBjb250ZXh0VG9wIGNhbnZhc1xuICAgICAqIHdlIHVzZSB0aGUgcG9pbnRzIGNhcHR1cmVkIHRvIGNyZWF0ZSBhbiBuZXcgZmFicmljIHBhdGggb2JqZWN0XG4gICAgICogYW5kIGFkZCBpdCB0byB0aGUgZmFicmljIGNhbnZhcy5cbiAgICAgKi9cbiAgICBfZmluYWxpemVBbmRBZGRQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICB2YXIgcGF0aERhdGEgPSB0aGlzLmNvbnZlcnRQb2ludHNUb1NWR1BhdGgodGhpcy5fcG9pbnRzKS5qb2luKCcnKTtcbiAgICAgIGlmIChwYXRoRGF0YSA9PT0gJ00gMCAwIFEgMCAwIDAgMCBMIDAgMCcpIHtcbiAgICAgICAgLy8gZG8gbm90IGNyZWF0ZSAwIHdpZHRoL2hlaWdodCBwYXRocywgYXMgdGhleSBhcmVcbiAgICAgICAgLy8gcmVuZGVyZWQgaW5jb25zaXN0ZW50bHkgYWNyb3NzIGJyb3dzZXJzXG4gICAgICAgIC8vIEZpcmVmb3ggNCwgZm9yIGV4YW1wbGUsIHJlbmRlcnMgYSBkb3QsXG4gICAgICAgIC8vIHdoZXJlYXMgQ2hyb21lIDEwIHJlbmRlcnMgbm90aGluZ1xuICAgICAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhdGggPSB0aGlzLmNyZWF0ZVBhdGgocGF0aERhdGEpO1xuICAgICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgICAgdGhpcy5jYW52YXMuYWRkKHBhdGgpO1xuICAgICAgdGhpcy5jYW52YXMucmVuZGVyQWxsKCk7XG4gICAgICBwYXRoLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5fcmVzZXRTaGFkb3coKTtcblxuXG4gICAgICAvLyBmaXJlIGV2ZW50ICdwYXRoJyBjcmVhdGVkXG4gICAgICB0aGlzLmNhbnZhcy5maXJlKCdwYXRoOmNyZWF0ZWQnLCB7IHBhdGg6IHBhdGggfSk7XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuLyoqXG4gKiBDaXJjbGVCcnVzaCBjbGFzc1xuICogQGNsYXNzIGZhYnJpYy5DaXJjbGVCcnVzaFxuICovXG5mYWJyaWMuQ2lyY2xlQnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQmFzZUJydXNoLCAvKiogQGxlbmRzIGZhYnJpYy5DaXJjbGVCcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiBhIGJydXNoXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgd2lkdGg6IDEwLFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge2ZhYnJpYy5DYW52YXN9IGNhbnZhc1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2lyY2xlQnJ1c2h9IEluc3RhbmNlIG9mIGEgY2lyY2xlIGJydXNoXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLnBvaW50cyA9IFtdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGluc2lkZSBvbiBtb3VzZSBkb3duIGFuZCBtb3VzZSBtb3ZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqL1xuICBkcmF3RG90OiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdmFyIHBvaW50ID0gdGhpcy5hZGRQb2ludChwb2ludGVyKSxcbiAgICAgICAgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcDtcbiAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHBvaW50LmZpbGw7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMocG9pbnQueCwgcG9pbnQueSwgcG9pbnQucmFkaXVzLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbCgpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSBkb3duXG4gICAqL1xuICBvbk1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHRoaXMucG9pbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgIHRoaXMuX3NldFNoYWRvdygpO1xuICAgIHRoaXMuZHJhd0RvdChwb2ludGVyKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBmdWxsIHN0YXRlIG9mIHRoZSBicnVzaFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0eCAgPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLCBpLCBsZW4sXG4gICAgICAgIHBvaW50cyA9IHRoaXMucG9pbnRzLCBwb2ludDtcbiAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG4gICAgZm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBwb2ludC5maWxsO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYyhwb2ludC54LCBwb2ludC55LCBwb2ludC5yYWRpdXMsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIG1vdmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICovXG4gIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdGhpcy5kcmF3RG90KHBvaW50ZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIHVwXG4gICAqL1xuICBvbk1vdXNlVXA6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlID0gdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmUsIGksIGxlbjtcbiAgICB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSA9IGZhbHNlO1xuXG4gICAgdmFyIGNpcmNsZXMgPSBbXTtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcG9pbnQgPSB0aGlzLnBvaW50c1tpXSxcbiAgICAgICAgICBjaXJjbGUgPSBuZXcgZmFicmljLkNpcmNsZSh7XG4gICAgICAgICAgICByYWRpdXM6IHBvaW50LnJhZGl1cyxcbiAgICAgICAgICAgIGxlZnQ6IHBvaW50LngsXG4gICAgICAgICAgICB0b3A6IHBvaW50LnksXG4gICAgICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgICAgICAgIG9yaWdpblk6ICdjZW50ZXInLFxuICAgICAgICAgICAgZmlsbDogcG9pbnQuZmlsbFxuICAgICAgICAgIH0pO1xuXG4gICAgICB0aGlzLnNoYWRvdyAmJiBjaXJjbGUuc2V0U2hhZG93KHRoaXMuc2hhZG93KTtcblxuICAgICAgY2lyY2xlcy5wdXNoKGNpcmNsZSk7XG4gICAgfVxuICAgIHZhciBncm91cCA9IG5ldyBmYWJyaWMuR3JvdXAoY2lyY2xlcywgeyBvcmlnaW5YOiAnY2VudGVyJywgb3JpZ2luWTogJ2NlbnRlcicgfSk7XG4gICAgZ3JvdXAuY2FudmFzID0gdGhpcy5jYW52YXM7XG5cbiAgICB0aGlzLmNhbnZhcy5hZGQoZ3JvdXApO1xuICAgIHRoaXMuY2FudmFzLmZpcmUoJ3BhdGg6Y3JlYXRlZCcsIHsgcGF0aDogZ3JvdXAgfSk7XG5cbiAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5fcmVzZXRTaGFkb3coKTtcbiAgICB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSA9IG9yaWdpbmFsUmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IEp1c3QgYWRkZWQgcG9pbnRlciBwb2ludFxuICAgKi9cbiAgYWRkUG9pbnQ6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB2YXIgcG9pbnRlclBvaW50ID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSksXG5cbiAgICAgICAgY2lyY2xlUmFkaXVzID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tSW50KFxuICAgICAgICAgIE1hdGgubWF4KDAsIHRoaXMud2lkdGggLSAyMCksIHRoaXMud2lkdGggKyAyMCkgLyAyLFxuXG4gICAgICAgIGNpcmNsZUNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKVxuICAgICAgICAgIC5zZXRBbHBoYShmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQoMCwgMTAwKSAvIDEwMClcbiAgICAgICAgICAudG9SZ2JhKCk7XG5cbiAgICBwb2ludGVyUG9pbnQucmFkaXVzID0gY2lyY2xlUmFkaXVzO1xuICAgIHBvaW50ZXJQb2ludC5maWxsID0gY2lyY2xlQ29sb3I7XG5cbiAgICB0aGlzLnBvaW50cy5wdXNoKHBvaW50ZXJQb2ludCk7XG5cbiAgICByZXR1cm4gcG9pbnRlclBvaW50O1xuICB9XG59KTtcblxuXG4vKipcbiAqIFNwcmF5QnJ1c2ggY2xhc3NcbiAqIEBjbGFzcyBmYWJyaWMuU3ByYXlCcnVzaFxuICovXG5mYWJyaWMuU3ByYXlCcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKCBmYWJyaWMuQmFzZUJydXNoLCAvKiogQGxlbmRzIGZhYnJpYy5TcHJheUJydXNoLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIFdpZHRoIG9mIGEgc3ByYXlcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICB3aWR0aDogICAgICAgICAgICAgIDEwLFxuXG4gIC8qKlxuICAgKiBEZW5zaXR5IG9mIGEgc3ByYXkgKG51bWJlciBvZiBkb3RzIHBlciBjaHVuaylcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBkZW5zaXR5OiAgICAgICAgICAgIDIwLFxuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiBzcHJheSBkb3RzXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgZG90V2lkdGg6ICAgICAgICAgICAxLFxuXG4gIC8qKlxuICAgKiBXaWR0aCB2YXJpYW5jZSBvZiBzcHJheSBkb3RzXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgZG90V2lkdGhWYXJpYW5jZTogICAxLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9wYWNpdHkgb2YgYSBkb3Qgc2hvdWxkIGJlIHJhbmRvbVxuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICByYW5kb21PcGFjaXR5OiAgICAgICAgZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3ZlcmxhcHBpbmcgZG90cyAocmVjdGFuZ2xlcykgc2hvdWxkIGJlIHJlbW92ZWQgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKVxuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBvcHRpbWl6ZU92ZXJsYXBwaW5nOiAgdHJ1ZSxcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtmYWJyaWMuQ2FudmFzfSBjYW52YXNcbiAgICogQHJldHVybiB7ZmFicmljLlNwcmF5QnJ1c2h9IEluc3RhbmNlIG9mIGEgc3ByYXkgYnJ1c2hcbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuc3ByYXlDaHVua3MgPSBbXTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSBkb3duXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqL1xuICBvbk1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHRoaXMuc3ByYXlDaHVua3MubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5fc2V0U2hhZG93KCk7XG5cbiAgICB0aGlzLmFkZFNwcmF5Q2h1bmsocG9pbnRlcik7XG4gICAgdGhpcy5yZW5kZXIodGhpcy5zcHJheUNodW5rUG9pbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSBtb3ZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqL1xuICBvbk1vdXNlTW92ZTogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHRoaXMuYWRkU3ByYXlDaHVuayhwb2ludGVyKTtcbiAgICB0aGlzLnJlbmRlcih0aGlzLnNwcmF5Q2h1bmtQb2ludHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIHVwXG4gICAqL1xuICBvbk1vdXNlVXA6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlID0gdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmUgPSBmYWxzZTtcblxuICAgIHZhciByZWN0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsZW4gPSB0aGlzLnNwcmF5Q2h1bmtzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdmFyIHNwcmF5Q2h1bmsgPSB0aGlzLnNwcmF5Q2h1bmtzW2ldO1xuXG4gICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IHNwcmF5Q2h1bmsubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG5cbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgZmFicmljLlJlY3Qoe1xuICAgICAgICAgIHdpZHRoOiBzcHJheUNodW5rW2pdLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogc3ByYXlDaHVua1tqXS53aWR0aCxcbiAgICAgICAgICBsZWZ0OiBzcHJheUNodW5rW2pdLnggKyAxLFxuICAgICAgICAgIHRvcDogc3ByYXlDaHVua1tqXS55ICsgMSxcbiAgICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJyxcbiAgICAgICAgICBmaWxsOiB0aGlzLmNvbG9yXG4gICAgICAgIH0pO1xuICAgICAgICByZWN0cy5wdXNoKHJlY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGltaXplT3ZlcmxhcHBpbmcpIHtcbiAgICAgIHJlY3RzID0gdGhpcy5fZ2V0T3B0aW1pemVkUmVjdHMocmVjdHMpO1xuICAgIH1cblxuICAgIHZhciBncm91cCA9IG5ldyBmYWJyaWMuR3JvdXAocmVjdHMsIHsgb3JpZ2luWDogJ2NlbnRlcicsIG9yaWdpblk6ICdjZW50ZXInIH0pO1xuICAgIHRoaXMuc2hhZG93ICYmIGdyb3VwLnNldFNoYWRvdyh0aGlzLnNoYWRvdyk7XG4gICAgdGhpcy5jYW52YXMuYWRkKGdyb3VwKTtcbiAgICB0aGlzLmNhbnZhcy5maXJlKCdwYXRoOmNyZWF0ZWQnLCB7IHBhdGg6IGdyb3VwIH0pO1xuXG4gICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgIHRoaXMuX3Jlc2V0U2hhZG93KCk7XG4gICAgdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmUgPSBvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlO1xuICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gcmVjdHNcbiAgICovXG4gIF9nZXRPcHRpbWl6ZWRSZWN0czogZnVuY3Rpb24ocmVjdHMpIHtcblxuICAgIC8vIGF2b2lkIGNyZWF0aW5nIGR1cGxpY2F0ZSByZWN0cyBhdCB0aGUgc2FtZSBjb29yZGluYXRlc1xuICAgIHZhciB1bmlxdWVSZWN0cyA9IHsgfSwga2V5LCBpLCBsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAga2V5ID0gcmVjdHNbaV0ubGVmdCArICcnICsgcmVjdHNbaV0udG9wO1xuICAgICAgaWYgKCF1bmlxdWVSZWN0c1trZXldKSB7XG4gICAgICAgIHVuaXF1ZVJlY3RzW2tleV0gPSByZWN0c1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVuaXF1ZVJlY3RzQXJyYXkgPSBbXTtcbiAgICBmb3IgKGtleSBpbiB1bmlxdWVSZWN0cykge1xuICAgICAgdW5pcXVlUmVjdHNBcnJheS5wdXNoKHVuaXF1ZVJlY3RzW2tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiB1bmlxdWVSZWN0c0FycmF5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgbmV3IGNodW5rIG9mIHNwcmF5IGJydXNoXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uKHNwcmF5Q2h1bmspIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcCwgaSwgbGVuO1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yO1xuXG4gICAgdGhpcy5fc2F2ZUFuZFRyYW5zZm9ybShjdHgpO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gc3ByYXlDaHVuay5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHBvaW50ID0gc3ByYXlDaHVua1tpXTtcbiAgICAgIGlmICh0eXBlb2YgcG9pbnQub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gcG9pbnQub3BhY2l0eTtcbiAgICAgIH1cbiAgICAgIGN0eC5maWxsUmVjdChwb2ludC54LCBwb2ludC55LCBwb2ludC53aWR0aCwgcG9pbnQud2lkdGgpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYWxsIHNwcmF5IGNodW5rc1xuICAgKi9cbiAgX3JlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3AsIGksIGlsZW47XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XG5cbiAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGhpcy5zcHJheUNodW5rcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHRoaXMucmVuZGVyKHRoaXMuc3ByYXlDaHVua3NbaV0pO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKi9cbiAgYWRkU3ByYXlDaHVuazogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHRoaXMuc3ByYXlDaHVua1BvaW50cyA9IFtdO1xuXG4gICAgdmFyIHgsIHksIHdpZHRoLCByYWRpdXMgPSB0aGlzLndpZHRoIC8gMiwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmRlbnNpdHk7IGkrKykge1xuXG4gICAgICB4ID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tSW50KHBvaW50ZXIueCAtIHJhZGl1cywgcG9pbnRlci54ICsgcmFkaXVzKTtcbiAgICAgIHkgPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQocG9pbnRlci55IC0gcmFkaXVzLCBwb2ludGVyLnkgKyByYWRpdXMpO1xuXG4gICAgICBpZiAodGhpcy5kb3RXaWR0aFZhcmlhbmNlKSB7XG4gICAgICAgIHdpZHRoID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tSW50KFxuICAgICAgICAgIC8vIGJvdHRvbSBjbGFtcCB3aWR0aCB0byAxXG4gICAgICAgICAgTWF0aC5tYXgoMSwgdGhpcy5kb3RXaWR0aCAtIHRoaXMuZG90V2lkdGhWYXJpYW5jZSksXG4gICAgICAgICAgdGhpcy5kb3RXaWR0aCArIHRoaXMuZG90V2lkdGhWYXJpYW5jZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgd2lkdGggPSB0aGlzLmRvdFdpZHRoO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnQgPSBuZXcgZmFicmljLlBvaW50KHgsIHkpO1xuICAgICAgcG9pbnQud2lkdGggPSB3aWR0aDtcblxuICAgICAgaWYgKHRoaXMucmFuZG9tT3BhY2l0eSkge1xuICAgICAgICBwb2ludC5vcGFjaXR5ID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tSW50KDAsIDEwMCkgLyAxMDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3ByYXlDaHVua1BvaW50cy5wdXNoKHBvaW50KTtcbiAgICB9XG5cbiAgICB0aGlzLnNwcmF5Q2h1bmtzLnB1c2godGhpcy5zcHJheUNodW5rUG9pbnRzKTtcbiAgfVxufSk7XG5cblxuLyoqXG4gKiBQYXR0ZXJuQnJ1c2ggY2xhc3NcbiAqIEBjbGFzcyBmYWJyaWMuUGF0dGVybkJydXNoXG4gKiBAZXh0ZW5kcyBmYWJyaWMuQmFzZUJydXNoXG4gKi9cbmZhYnJpYy5QYXR0ZXJuQnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuUGVuY2lsQnJ1c2gsIC8qKiBAbGVuZHMgZmFicmljLlBhdHRlcm5CcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gIGdldFBhdHRlcm5TcmM6IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGRvdFdpZHRoID0gMjAsXG4gICAgICAgIGRvdERpc3RhbmNlID0gNSxcbiAgICAgICAgcGF0dGVybkNhbnZhcyA9IGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcbiAgICAgICAgcGF0dGVybkN0eCA9IHBhdHRlcm5DYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIHBhdHRlcm5DYW52YXMud2lkdGggPSBwYXR0ZXJuQ2FudmFzLmhlaWdodCA9IGRvdFdpZHRoICsgZG90RGlzdGFuY2U7XG5cbiAgICBwYXR0ZXJuQ3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgcGF0dGVybkN0eC5iZWdpblBhdGgoKTtcbiAgICBwYXR0ZXJuQ3R4LmFyYyhkb3RXaWR0aCAvIDIsIGRvdFdpZHRoIC8gMiwgZG90V2lkdGggLyAyLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgIHBhdHRlcm5DdHguY2xvc2VQYXRoKCk7XG4gICAgcGF0dGVybkN0eC5maWxsKCk7XG5cbiAgICByZXR1cm4gcGF0dGVybkNhbnZhcztcbiAgfSxcblxuICBnZXRQYXR0ZXJuU3JjRnVuY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy5nZXRQYXR0ZXJuU3JjKS5yZXBsYWNlKCd0aGlzLmNvbG9yJywgJ1wiJyArIHRoaXMuY29sb3IgKyAnXCInKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBcInBhdHRlcm5cIiBpbnN0YW5jZSBwcm9wZXJ0eVxuICAgKi9cbiAgZ2V0UGF0dGVybjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuY3JlYXRlUGF0dGVybih0aGlzLnNvdXJjZSB8fCB0aGlzLmdldFBhdHRlcm5TcmMoKSwgJ3JlcGVhdCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGJydXNoIHN0eWxlc1xuICAgKi9cbiAgX3NldEJydXNoU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNhbGxTdXBlcignX3NldEJydXNoU3R5bGVzJyk7XG4gICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5zdHJva2VTdHlsZSA9IHRoaXMuZ2V0UGF0dGVybigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHBhdGhcbiAgICovXG4gIGNyZWF0ZVBhdGg6IGZ1bmN0aW9uKHBhdGhEYXRhKSB7XG4gICAgdmFyIHBhdGggPSB0aGlzLmNhbGxTdXBlcignY3JlYXRlUGF0aCcsIHBhdGhEYXRhKSxcbiAgICAgICAgdG9wTGVmdCA9IHBhdGguX2dldExlZnRUb3BDb29yZHMoKS5zY2FsYXJBZGQocGF0aC5zdHJva2VXaWR0aCAvIDIpO1xuXG4gICAgcGF0aC5zdHJva2UgPSBuZXcgZmFicmljLlBhdHRlcm4oe1xuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSB8fCB0aGlzLmdldFBhdHRlcm5TcmNGdW5jdGlvbigpLFxuICAgICAgb2Zmc2V0WDogLXRvcExlZnQueCxcbiAgICAgIG9mZnNldFk6IC10b3BMZWZ0LnlcbiAgICB9KTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBnZXRQb2ludGVyID0gZmFicmljLnV0aWwuZ2V0UG9pbnRlcixcbiAgICAgIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zLFxuICAgICAgcmFkaWFuc1RvRGVncmVlcyA9IGZhYnJpYy51dGlsLnJhZGlhbnNUb0RlZ3JlZXMsXG4gICAgICBhdGFuMiA9IE1hdGguYXRhbjIsXG4gICAgICBhYnMgPSBNYXRoLmFicyxcbiAgICAgIHN1cHBvcnRMaW5lRGFzaCA9IGZhYnJpYy5TdGF0aWNDYW52YXMuc3VwcG9ydHMoJ3NldExpbmVEYXNoJyksXG5cbiAgICAgIFNUUk9LRV9PRkZTRVQgPSAwLjU7XG5cbiAgLyoqXG4gICAqIENhbnZhcyBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkNhbnZhc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0xI2NhbnZhc31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkNhbnZhcyNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKlxuICAgKiBAZmlyZXMgb2JqZWN0Om1vZGlmaWVkXG4gICAqIEBmaXJlcyBvYmplY3Q6cm90YXRlZFxuICAgKiBAZmlyZXMgb2JqZWN0OnNjYWxlZFxuICAgKiBAZmlyZXMgb2JqZWN0Om1vdmVkXG4gICAqIEBmaXJlcyBvYmplY3Q6c2tld2VkXG4gICAqIEBmaXJlcyBvYmplY3Q6cm90YXRpbmdcbiAgICogQGZpcmVzIG9iamVjdDpzY2FsaW5nXG4gICAqIEBmaXJlcyBvYmplY3Q6bW92aW5nXG4gICAqIEBmaXJlcyBvYmplY3Q6c2tld2luZ1xuICAgKiBAZmlyZXMgb2JqZWN0OnNlbGVjdGVkIHRoaXMgZXZlbnQgaXMgZGVwcmVjYXRlZC4gdXNlIHNlbGVjdGlvbjpjcmVhdGVkXG4gICAqXG4gICAqIEBmaXJlcyBiZWZvcmU6dHJhbnNmb3JtXG4gICAqIEBmaXJlcyBiZWZvcmU6c2VsZWN0aW9uOmNsZWFyZWRcbiAgICogQGZpcmVzIHNlbGVjdGlvbjpjbGVhcmVkXG4gICAqIEBmaXJlcyBzZWxlY3Rpb246dXBkYXRlZFxuICAgKiBAZmlyZXMgc2VsZWN0aW9uOmNyZWF0ZWRcbiAgICpcbiAgICogQGZpcmVzIHBhdGg6Y3JlYXRlZFxuICAgKiBAZmlyZXMgbW91c2U6ZG93blxuICAgKiBAZmlyZXMgbW91c2U6bW92ZVxuICAgKiBAZmlyZXMgbW91c2U6dXBcbiAgICogQGZpcmVzIG1vdXNlOmRvd246YmVmb3JlXG4gICAqIEBmaXJlcyBtb3VzZTptb3ZlOmJlZm9yZVxuICAgKiBAZmlyZXMgbW91c2U6dXA6YmVmb3JlXG4gICAqIEBmaXJlcyBtb3VzZTpvdmVyXG4gICAqIEBmaXJlcyBtb3VzZTpvdXRcbiAgICogQGZpcmVzIG1vdXNlOmRibGNsaWNrXG4gICAqXG4gICAqIEBmaXJlcyBkcmFnb3ZlclxuICAgKiBAZmlyZXMgZHJhZ2VudGVyXG4gICAqIEBmaXJlcyBkcmFnbGVhdmVcbiAgICogQGZpcmVzIGRyb3BcbiAgICpcbiAgICovXG4gIGZhYnJpYy5DYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuU3RhdGljQ2FudmFzLCAvKiogQGxlbmRzIGZhYnJpYy5DYW52YXMucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFN0cmluZ30gZWwgJmx0O2NhbnZhcz4gZWxlbWVudCB0byBpbml0aWFsaXplIGluc3RhbmNlIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGVsLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIHRoaXMucmVuZGVyQW5kUmVzZXRCb3VuZCA9IHRoaXMucmVuZGVyQW5kUmVzZXQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2luaXRTdGF0aWMoZWwsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5faW5pdEludGVyYWN0aXZlKCk7XG4gICAgICB0aGlzLl9jcmVhdGVDYWNoZUNhbnZhcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdHMgY2FuIGJlIHRyYW5zZm9ybWVkIGJ5IG9uZSBzaWRlICh1bnByb3BvcnRpb25hbGx5KVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHVuaVNjYWxlVHJhbnNmb3JtOiAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBlbmFibGUgdW5wcm9wb3J0aW9uYWwgc2NhbGluZ1xuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBJZiBgbnVsbGAgb3IgJ25vbmUnIG9yIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkIGZlYXR1cmUgZGlzYWJsZWQuXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB1bmlTY2FsZUtleTogICAgICAgICAgICdzaGlmdEtleScsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdHMgdXNlIGNlbnRlciBwb2ludCBhcyB0aGUgb3JpZ2luIG9mIHNjYWxlIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgcmVwbGFjZXMgXCJjZW50ZXJUcmFuc2Zvcm1cIiAoQm9vbGVhbikuXG4gICAgICogQHNpbmNlIDEuMy40XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2VudGVyZWRTY2FsaW5nOiAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdHMgdXNlIGNlbnRlciBwb2ludCBhcyB0aGUgb3JpZ2luIG9mIHJvdGF0ZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHJlcGxhY2VzIFwiY2VudGVyVHJhbnNmb3JtXCIgKEJvb2xlYW4pLlxuICAgICAqIEBzaW5jZSAxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkUm90YXRpb246ICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBlbmFibGUgY2VudGVyZWQgVHJhbnNmb3JtXG4gICAgICogdmFsdWVzOiAnYWx0S2V5JywgJ3NoaWZ0S2V5JywgJ2N0cmxLZXknLlxuICAgICAqIElmIGBudWxsYCBvciAnbm9uZScgb3IgYW55IG90aGVyIHN0cmluZyB0aGF0IGlzIG5vdCBhIG1vZGlmaWVyIGtleVxuICAgICAqIGZlYXR1cmUgaXMgZGlzYWJsZWQgZmVhdHVyZSBkaXNhYmxlZC5cbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkS2V5OiAgICAgICAgICAgJ2FsdEtleScsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hpY2gga2V5IGVuYWJsZSBhbHRlcm5hdGUgYWN0aW9uIG9uIGNvcm5lclxuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBJZiBgbnVsbGAgb3IgJ25vbmUnIG9yIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkIGZlYXR1cmUgZGlzYWJsZWQuXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBhbHRBY3Rpb25LZXk6ICAgICAgICAgICAnc2hpZnRLZXknLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgY2FudmFzIGlzIGludGVyYWN0aXZlLiBUaGlzIHByb3BlcnR5IHNob3VsZCBub3QgYmUgY2hhbmdlZC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbnRlcmFjdGl2ZTogICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgZ3JvdXAgc2VsZWN0aW9uIHNob3VsZCBiZSBlbmFibGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uOiAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBrZXkgb3Iga2V5cyBlbmFibGUgbXVsdGlwbGUgY2xpY2sgc2VsZWN0aW9uXG4gICAgICogUGFzcyB2YWx1ZSBhcyBhIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzXG4gICAgICogdmFsdWVzOiAnYWx0S2V5JywgJ3NoaWZ0S2V5JywgJ2N0cmxLZXknLlxuICAgICAqIElmIGBudWxsYCBvciBlbXB0eSBvciBjb250YWluaW5nIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkLlxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ3xBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uS2V5OiAgICAgICAgICAgJ3NoaWZ0S2V5JyxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBrZXkgZW5hYmxlIGFsdGVybmF0aXZlIHNlbGVjdGlvblxuICAgICAqIGluIGNhc2Ugb2YgdGFyZ2V0IG92ZXJsYXBwaW5nIHdpdGggYWN0aXZlIG9iamVjdFxuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBGb3IgYSBzZXJpZXMgb2YgcmVhc29uIHRoYXQgY29tZSBmcm9tIHRoZSBnZW5lcmFsIGV4cGVjdGF0aW9ucyBvbiBob3dcbiAgICAgKiB0aGluZ3Mgc2hvdWxkIHdvcmssIHRoaXMgZmVhdHVyZSB3b3JrcyBvbmx5IGZvciBwcmVzZXJ2ZU9iamVjdFN0YWNraW5nIHRydWUuXG4gICAgICogSWYgYG51bGxgIG9yICdub25lJyBvciBhbnkgb3RoZXIgc3RyaW5nIHRoYXQgaXMgbm90IGEgbW9kaWZpZXIga2V5XG4gICAgICogZmVhdHVyZSBpcyBkaXNhYmxlZC5cbiAgICAgKiBAc2luY2UgMS42LjVcbiAgICAgKiBAdHlwZSBudWxsfFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYWx0U2VsZWN0aW9uS2V5OiAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIHNlbGVjdGlvblxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uQ29sb3I6ICAgICAgICAgJ3JnYmEoMTAwLCAxMDAsIDI1NSwgMC4zKScsIC8vIGJsdWVcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgZGFzaCBhcnJheSBwYXR0ZXJuXG4gICAgICogSWYgbm90IGVtcHR5IHRoZSBzZWxlY3Rpb24gYm9yZGVyIGlzIGRhc2hlZFxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc2VsZWN0aW9uRGFzaEFycmF5OiAgICAgW10sXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiB0aGUgYm9yZGVyIG9mIHNlbGVjdGlvbiAodXN1YWxseSBzbGlnaHRseSBkYXJrZXIgdGhhbiBjb2xvciBvZiBzZWxlY3Rpb24gaXRzZWxmKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uQm9yZGVyQ29sb3I6ICAgJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKScsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBhIGxpbmUgdXNlZCBpbiBvYmplY3QvZ3JvdXAgc2VsZWN0aW9uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25MaW5lV2lkdGg6ICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IG9ubHkgc2hhcGVzIHRoYXQgYXJlIGZ1bGx5IGNvbnRhaW5lZCBpbiB0aGUgZHJhZ2dlZCBzZWxlY3Rpb24gcmVjdGFuZ2xlLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkZ1bGx5Q29udGFpbmVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgY3Vyc29yIHZhbHVlIHVzZWQgd2hlbiBob3ZlcmluZyBvdmVyIGFuIG9iamVjdCBvbiBjYW52YXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhvdmVyQ3Vyc29yOiAgICAgICAgICAgICdtb3ZlJyxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgY3Vyc29yIHZhbHVlIHVzZWQgd2hlbiBtb3ZpbmcgYW4gb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbW92ZUN1cnNvcjogICAgICAgICAgICAgJ21vdmUnLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCBmb3IgdGhlIGVudGlyZSBjYW52YXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGRlZmF1bHRDdXJzb3I6ICAgICAgICAgICdkZWZhdWx0JyxcblxuICAgIC8qKlxuICAgICAqIEN1cnNvciB2YWx1ZSB1c2VkIGR1cmluZyBmcmVlIGRyYXdpbmdcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZyZWVEcmF3aW5nQ3Vyc29yOiAgICAgICdjcm9zc2hhaXInLFxuXG4gICAgLyoqXG4gICAgICogQ3Vyc29yIHZhbHVlIHVzZWQgZm9yIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByb3RhdGlvbkN1cnNvcjogICAgICAgICAnY3Jvc3NoYWlyJyxcblxuICAgIC8qKlxuICAgICAqIEN1cnNvciB2YWx1ZSB1c2VkIGZvciBkaXNhYmxlZCBlbGVtZW50cyAoIGNvcm5lcnMgd2l0aCBkaXNhYmxlZCBhY3Rpb24gKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbm90QWxsb3dlZEN1cnNvcjogICAgICAgICAnbm90LWFsbG93ZWQnLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBlbGVtZW50IGNsYXNzIHRoYXQncyBnaXZlbiB0byB3cmFwcGVyIChkaXYpIGVsZW1lbnQgb2YgY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb250YWluZXJDbGFzczogICAgICAgICAnY2FudmFzLWNvbnRhaW5lcicsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdCBkZXRlY3Rpb24gaGFwcGVucyBvbiBwZXItcGl4ZWwgYmFzaXMgcmF0aGVyIHRoYW4gb24gcGVyLWJvdW5kaW5nLWJveFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBlclBpeGVsVGFyZ2V0RmluZDogICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHBpeGVscyBhcm91bmQgdGFyZ2V0IHBpeGVsIHRvIHRvbGVyYXRlIChjb25zaWRlciBhY3RpdmUpIGR1cmluZyBvYmplY3QgZGV0ZWN0aW9uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0YXJnZXRGaW5kVG9sZXJhbmNlOiAgICAwLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0YXJnZXQgZGV0ZWN0aW9uIGlzIHNraXBwZWQgd2hlbiBob3ZlcmluZyBvdmVyIGNhbnZhcy4gVGhpcyBjYW4gYmUgdXNlZCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNraXBUYXJnZXRGaW5kOiAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBtb3VzZSBldmVudHMgb24gY2FudmFzIChtb3VzZWRvd24vbW91c2Vtb3ZlL21vdXNldXApIHJlc3VsdCBpbiBmcmVlIGRyYXdpbmcuXG4gICAgICogQWZ0ZXIgbW91c2Vkb3duLCBtb3VzZW1vdmUgY3JlYXRlcyBhIHNoYXBlLFxuICAgICAqIGFuZCB0aGVuIG1vdXNldXAgZmluYWxpemVzIGl0IGFuZCBhZGRzIGFuIGluc3RhbmNlIG9mIGBmYWJyaWMuUGF0aGAgb250byBjYW52YXMuXG4gICAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTQjZnJlZV9kcmF3aW5nfVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGlzRHJhd2luZ01vZGU6ICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgb2JqZWN0cyBzaG91bGQgcmVtYWluIGluIGN1cnJlbnQgc3RhY2sgcG9zaXRpb24gd2hlbiBzZWxlY3RlZC5cbiAgICAgKiBXaGVuIGZhbHNlIG9iamVjdHMgYXJlIGJyb3VnaHQgdG8gdG9wIGFuZCByZW5kZXJlZCBhcyBwYXJ0IG9mIHRoZSBzZWxlY3Rpb24gZ3JvdXBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwcmVzZXJ2ZU9iamVjdFN0YWNraW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgYW5nbGUgdGhhdCBhbiBvYmplY3Qgd2lsbCBsb2NrIHRvIHdoaWxlIHJvdGF0aW5nLlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBzaW5jZSAxLjYuN1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc25hcEFuZ2xlOiAwLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBzbmFwQW5nbGUgdGhlIHJvdGF0aW9uIHdpbGwgbG9jayB0byB0aGUgc25hcEFuZ2xlLlxuICAgICAqIFdoZW4gYG51bGxgLCB0aGUgc25hcFRocmVzaG9sZCB3aWxsIGRlZmF1bHQgdG8gdGhlIHNuYXBBbmdsZS5cbiAgICAgKiBAdHlwZSBudWxsfE51bWJlclxuICAgICAqIEBzaW5jZSAxLjYuN1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc25hcFRocmVzaG9sZDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgcmlnaHQgY2xpY2sgb24gY2FudmFzIGNhbiBvdXRwdXQgdGhlIGNvbnRleHQgbWVudSBvciBub3RcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHNpbmNlIDEuNi41XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdG9wQ29udGV4dE1lbnU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSBjYW52YXMgY2FuIGZpcmUgcmlnaHQgY2xpY2sgZXZlbnRzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBzaW5jZSAxLjYuNVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmlyZVJpZ2h0Q2xpY2s6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSBjYW52YXMgY2FuIGZpcmUgbWlkZGxlIGNsaWNrIGV2ZW50c1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAc2luY2UgMS43LjhcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZpcmVNaWRkbGVDbGljazogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0SW50ZXJhY3RpdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY3VycmVudFRyYW5zZm9ybSA9IG51bGw7XG4gICAgICB0aGlzLl9ncm91cFNlbGVjdG9yID0gbnVsbDtcbiAgICAgIHRoaXMuX2luaXRXcmFwcGVyRWxlbWVudCgpO1xuICAgICAgdGhpcy5fY3JlYXRlVXBwZXJDYW52YXMoKTtcbiAgICAgIHRoaXMuX2luaXRFdmVudExpc3RlbmVycygpO1xuXG4gICAgICB0aGlzLl9pbml0UmV0aW5hU2NhbGluZygpO1xuXG4gICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2ggPSBmYWJyaWMuUGVuY2lsQnJ1c2ggJiYgbmV3IGZhYnJpYy5QZW5jaWxCcnVzaCh0aGlzKTtcblxuICAgICAgdGhpcy5jYWxjT2Zmc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgb2JqZWN0cyBpbiB0d28gZ3JvdXBzLCBvbmUgdG8gcmVuZGVyIGltbWVkaWF0ZWx5XG4gICAgICogYW5kIG9uZSB0byByZW5kZXIgYXMgYWN0aXZlR3JvdXAuXG4gICAgICogQHJldHVybiB7QXJyYXl9IG9iamVjdHMgdG8gcmVuZGVyIGltbWVkaWF0ZWx5IGFuZCBwdXNoZXMgdGhlIG90aGVyIGluIHRoZSBhY3RpdmVHcm91cC5cbiAgICAgKi9cbiAgICBfY2hvb3NlT2JqZWN0c1RvUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3RzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCksXG4gICAgICAgICAgb2JqZWN0LCBvYmpzVG9SZW5kZXIsIGFjdGl2ZUdyb3VwT2JqZWN0cztcblxuICAgICAgaWYgKGFjdGl2ZU9iamVjdHMubGVuZ3RoID4gMCAmJiAhdGhpcy5wcmVzZXJ2ZU9iamVjdFN0YWNraW5nKSB7XG4gICAgICAgIG9ianNUb1JlbmRlciA9IFtdO1xuICAgICAgICBhY3RpdmVHcm91cE9iamVjdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYmplY3QgPSB0aGlzLl9vYmplY3RzW2ldO1xuICAgICAgICAgIGlmIChhY3RpdmVPYmplY3RzLmluZGV4T2Yob2JqZWN0KSA9PT0gLTEgKSB7XG4gICAgICAgICAgICBvYmpzVG9SZW5kZXIucHVzaChvYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjdGl2ZUdyb3VwT2JqZWN0cy5wdXNoKG9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhY3RpdmVPYmplY3RzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aGlzLl9hY3RpdmVPYmplY3QuX29iamVjdHMgPSBhY3RpdmVHcm91cE9iamVjdHM7XG4gICAgICAgIH1cbiAgICAgICAgb2Jqc1RvUmVuZGVyLnB1c2guYXBwbHkob2Jqc1RvUmVuZGVyLCBhY3RpdmVHcm91cE9iamVjdHMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9ianNUb1JlbmRlciA9IHRoaXMuX29iamVjdHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Jqc1RvUmVuZGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGJvdGggdGhlIHRvcCBjYW52YXMgYW5kIHRoZSBzZWNvbmRhcnkgY29udGFpbmVyIGNhbnZhcy5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW5kZXJBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRUb3BEaXJ0eSAmJiAhdGhpcy5fZ3JvdXBTZWxlY3RvciAmJiAhdGhpcy5pc0RyYXdpbmdNb2RlKSB7XG4gICAgICAgIHRoaXMuY2xlYXJDb250ZXh0KHRoaXMuY29udGV4dFRvcCk7XG4gICAgICAgIHRoaXMuY29udGV4dFRvcERpcnR5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNMb3N0Q29udGV4dCkge1xuICAgICAgICB0aGlzLnJlbmRlclRvcExheWVyKHRoaXMuY29udGV4dFRvcCk7XG4gICAgICB9XG4gICAgICB2YXIgY2FudmFzVG9EcmF3T24gPSB0aGlzLmNvbnRleHRDb250YWluZXI7XG4gICAgICB0aGlzLnJlbmRlckNhbnZhcyhjYW52YXNUb0RyYXdPbiwgdGhpcy5fY2hvb3NlT2JqZWN0c1RvUmVuZGVyKCkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbmRlclRvcExheWVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICh0aGlzLmlzRHJhd2luZ01vZGUgJiYgdGhpcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaCAmJiB0aGlzLmZyZWVEcmF3aW5nQnJ1c2guX3JlbmRlcigpO1xuICAgICAgfVxuICAgICAgLy8gd2UgcmVuZGVyIHRoZSB0b3AgY29udGV4dCAtIGxhc3Qgb2JqZWN0XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb24gJiYgdGhpcy5fZ3JvdXBTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLl9kcmF3U2VsZWN0aW9uKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byByZW5kZXIgb25seSB0aGUgdG9wIGNhbnZhcy5cbiAgICAgKiBBbHNvIHVzZWQgdG8gcmVuZGVyIHRoZSBncm91cCBzZWxlY3Rpb24gYm94LlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVuZGVyVG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0VG9wO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcbiAgICAgIHRoaXMucmVuZGVyVG9wTGF5ZXIoY3R4KTtcbiAgICAgIHRoaXMuZmlyZSgnYWZ0ZXI6cmVuZGVyJyk7XG4gICAgICB0aGlzLmNvbnRleHRUb3BEaXJ0eSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBjdXJyZW50IHRyYW5zZm9ybSB0byBpdHMgb3JpZ2luYWwgdmFsdWVzIGFuZCBjaG9vc2VzIHRoZSB0eXBlIG9mIHJlc2l6aW5nIGJhc2VkIG9uIHRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0Q3VycmVudFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm07XG5cbiAgICAgIHQudGFyZ2V0LnNldCh7XG4gICAgICAgIHNjYWxlWDogdC5vcmlnaW5hbC5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogdC5vcmlnaW5hbC5zY2FsZVksXG4gICAgICAgIHNrZXdYOiB0Lm9yaWdpbmFsLnNrZXdYLFxuICAgICAgICBza2V3WTogdC5vcmlnaW5hbC5za2V3WSxcbiAgICAgICAgbGVmdDogdC5vcmlnaW5hbC5sZWZ0LFxuICAgICAgICB0b3A6IHQub3JpZ2luYWwudG9wXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuX3Nob3VsZENlbnRlclRyYW5zZm9ybSh0LnRhcmdldCkpIHtcbiAgICAgICAgaWYgKHQub3JpZ2luWCAhPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICBpZiAodC5vcmlnaW5YID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICB0Lm1vdXNlWFNpZ24gPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0Lm1vdXNlWFNpZ24gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodC5vcmlnaW5ZICE9PSAnY2VudGVyJykge1xuICAgICAgICAgIGlmICh0Lm9yaWdpblkgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICB0Lm1vdXNlWVNpZ24gPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0Lm1vdXNlWVNpZ24gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHQub3JpZ2luWCA9ICdjZW50ZXInO1xuICAgICAgICB0Lm9yaWdpblkgPSAnY2VudGVyJztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0Lm9yaWdpblggPSB0Lm9yaWdpbmFsLm9yaWdpblg7XG4gICAgICAgIHQub3JpZ2luWSA9IHQub3JpZ2luYWwub3JpZ2luWTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHBvaW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYW4gYXJlYSBvZiBnaXZlbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0IE9iamVjdCB0byB0ZXN0IGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BvaW50XSB4LHkgb2JqZWN0IG9mIHBvaW50IGNvb3JkaW5hdGVzIHdlIHdhbnQgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIGFuIGFyZWEgb2YgZ2l2ZW4gb2JqZWN0XG4gICAgICovXG4gICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24gKGUsIHRhcmdldCwgcG9pbnQpIHtcbiAgICAgIHZhciBpZ25vcmVab29tID0gdHJ1ZSxcbiAgICAgICAgICBwb2ludGVyID0gcG9pbnQgfHwgdGhpcy5nZXRQb2ludGVyKGUsIGlnbm9yZVpvb20pLFxuICAgICAgICAgIHh5O1xuXG4gICAgICBpZiAodGFyZ2V0Lmdyb3VwICYmIHRhcmdldC5ncm91cCA9PT0gdGhpcy5fYWN0aXZlT2JqZWN0ICYmIHRhcmdldC5ncm91cC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgICB4eSA9IHRoaXMuX25vcm1hbGl6ZVBvaW50ZXIodGFyZ2V0Lmdyb3VwLCBwb2ludGVyKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB4eSA9IHsgeDogcG9pbnRlci54LCB5OiBwb2ludGVyLnkgfTtcbiAgICAgIH1cbiAgICAgIC8vIGh0dHA6Ly93d3cuZ2VvZy51YmMuY2EvY291cnNlcy9rbGluay9naXMubm90ZXMvbmNnaWEvdTMyLmh0bWxcbiAgICAgIC8vIGh0dHA6Ly9pZGF2LnVjZGF2aXMuZWR1L35va3JleWxvcy9UQXNoaXAvU3ByaW5nMjAwMC9Qb2ludEluUG9seWdvbi5odG1sXG4gICAgICByZXR1cm4gKHRhcmdldC5jb250YWluc1BvaW50KHh5KSB8fCB0YXJnZXQuX2ZpbmRUYXJnZXRDb3JuZXIocG9pbnRlcikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9ub3JtYWxpemVQb2ludGVyOiBmdW5jdGlvbiAob2JqZWN0LCBwb2ludGVyKSB7XG4gICAgICB2YXIgbSA9IG9iamVjdC5jYWxjVHJhbnNmb3JtTWF0cml4KCksXG4gICAgICAgICAgaW52ZXJ0ZWRNID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKG0pLFxuICAgICAgICAgIHZwdFBvaW50ZXIgPSB0aGlzLnJlc3RvcmVQb2ludGVyVnB0KHBvaW50ZXIpO1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHZwdFBvaW50ZXIsIGludmVydGVkTSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgdHJhbnNwYXJlbnQgYXQgYSBjZXJ0YWluIGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXQgT2JqZWN0IHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggTGVmdCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVG9wIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVGFyZ2V0VHJhbnNwYXJlbnQ6IGZ1bmN0aW9uICh0YXJnZXQsIHgsIHkpIHtcbiAgICAgIGlmICh0YXJnZXQuc2hvdWxkQ2FjaGUoKSAmJiB0YXJnZXQuX2NhY2hlQ2FudmFzKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkUG9pbnRlciA9IHRoaXMuX25vcm1hbGl6ZVBvaW50ZXIodGFyZ2V0LCB7eDogeCwgeTogeX0pLFxuICAgICAgICAgICAgdGFyZ2V0UmVsYXRpdmVYID0gdGFyZ2V0LmNhY2hlVHJhbnNsYXRpb25YICsgKG5vcm1hbGl6ZWRQb2ludGVyLnggKiB0YXJnZXQuem9vbVgpLFxuICAgICAgICAgICAgdGFyZ2V0UmVsYXRpdmVZID0gdGFyZ2V0LmNhY2hlVHJhbnNsYXRpb25ZICsgKG5vcm1hbGl6ZWRQb2ludGVyLnkgKiB0YXJnZXQuem9vbVkpO1xuXG4gICAgICAgIHZhciBpc1RyYW5zcGFyZW50ID0gZmFicmljLnV0aWwuaXNUcmFuc3BhcmVudChcbiAgICAgICAgICB0YXJnZXQuX2NhY2hlQ29udGV4dCwgdGFyZ2V0UmVsYXRpdmVYLCB0YXJnZXRSZWxhdGl2ZVksIHRoaXMudGFyZ2V0RmluZFRvbGVyYW5jZSk7XG5cbiAgICAgICAgcmV0dXJuIGlzVHJhbnNwYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHRDYWNoZSxcbiAgICAgICAgICBvcmlnaW5hbENvbG9yID0gdGFyZ2V0LnNlbGVjdGlvbkJhY2tncm91bmRDb2xvciwgdiA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm07XG5cbiAgICAgIHRhcmdldC5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3IgPSAnJztcblxuICAgICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gICAgICB0YXJnZXQucmVuZGVyKGN0eCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICB0YXJnZXQgPT09IHRoaXMuX2FjdGl2ZU9iamVjdCAmJiB0YXJnZXQuX3JlbmRlckNvbnRyb2xzKGN0eCwge1xuICAgICAgICBoYXNCb3JkZXJzOiBmYWxzZSxcbiAgICAgICAgdHJhbnNwYXJlbnRDb3JuZXJzOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBoYXNCb3JkZXJzOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICB0YXJnZXQuc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yID0gb3JpZ2luYWxDb2xvcjtcblxuICAgICAgdmFyIGlzVHJhbnNwYXJlbnQgPSBmYWJyaWMudXRpbC5pc1RyYW5zcGFyZW50KFxuICAgICAgICBjdHgsIHgsIHksIHRoaXMudGFyZ2V0RmluZFRvbGVyYW5jZSk7XG5cbiAgICAgIHJldHVybiBpc1RyYW5zcGFyZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB0YWtlcyBhbiBldmVudCBhbmQgZGV0ZXJtaW5zIGlmIHNlbGVjdGlvbiBrZXkgaGFzIGJlZW4gcHJlc3NlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfaXNTZWxlY3Rpb25LZXlQcmVzc2VkOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uS2V5UHJlc3NlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMuc2VsZWN0aW9uS2V5KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICBzZWxlY3Rpb25LZXlQcmVzc2VkID0gISF0aGlzLnNlbGVjdGlvbktleS5maW5kKGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gZVtrZXldID09PSB0cnVlOyB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWxlY3Rpb25LZXlQcmVzc2VkID0gZVt0aGlzLnNlbGVjdGlvbktleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxlY3Rpb25LZXlQcmVzc2VkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfc2hvdWxkQ2xlYXJTZWxlY3Rpb246IGZ1bmN0aW9uIChlLCB0YXJnZXQpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3RzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCksXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICAhdGFyZ2V0XG4gICAgICAgIHx8XG4gICAgICAgICh0YXJnZXQgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3QgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3RzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3RzLmluZGV4T2YodGFyZ2V0KSA9PT0gLTEgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3QgIT09IHRhcmdldCAmJlxuICAgICAgICAgICF0aGlzLl9pc1NlbGVjdGlvbktleVByZXNzZWQoZSkpXG4gICAgICAgIHx8XG4gICAgICAgICh0YXJnZXQgJiYgIXRhcmdldC5ldmVudGVkKVxuICAgICAgICB8fFxuICAgICAgICAodGFyZ2V0ICYmXG4gICAgICAgICAgIXRhcmdldC5zZWxlY3RhYmxlICYmXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ICYmXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ICE9PSB0YXJnZXQpXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjZW50ZXJlZFNjYWxpbmcgZnJvbSBvYmplY3QgY2FuJ3Qgb3ZlcnJpZGUgY2VudGVyZWRTY2FsaW5nIGZyb20gY2FudmFzLlxuICAgICAqIHRoaXMgc2hvdWxkIGJlIGZpeGVkLCBzaW5jZSBvYmplY3Qgc2V0dGluZyBzaG91bGQgdGFrZSBwcmVjZWRlbmNlIG92ZXIgY2FudmFzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfc2hvdWxkQ2VudGVyVHJhbnNmb3JtOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0ID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybSxcbiAgICAgICAgICBjZW50ZXJUcmFuc2Zvcm07XG5cbiAgICAgIGlmICh0LmFjdGlvbiA9PT0gJ3NjYWxlJyB8fCB0LmFjdGlvbiA9PT0gJ3NjYWxlWCcgfHwgdC5hY3Rpb24gPT09ICdzY2FsZVknKSB7XG4gICAgICAgIGNlbnRlclRyYW5zZm9ybSA9IHRoaXMuY2VudGVyZWRTY2FsaW5nIHx8IHRhcmdldC5jZW50ZXJlZFNjYWxpbmc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0LmFjdGlvbiA9PT0gJ3JvdGF0ZScpIHtcbiAgICAgICAgY2VudGVyVHJhbnNmb3JtID0gdGhpcy5jZW50ZXJlZFJvdGF0aW9uIHx8IHRhcmdldC5jZW50ZXJlZFJvdGF0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2VudGVyVHJhbnNmb3JtID8gIXQuYWx0S2V5IDogdC5hbHRLZXk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldE9yaWdpbkZyb21Db3JuZXI6IGZ1bmN0aW9uKHRhcmdldCwgY29ybmVyKSB7XG4gICAgICB2YXIgb3JpZ2luID0ge1xuICAgICAgICB4OiB0YXJnZXQub3JpZ2luWCxcbiAgICAgICAgeTogdGFyZ2V0Lm9yaWdpbllcbiAgICAgIH07XG5cbiAgICAgIGlmIChjb3JuZXIgPT09ICdtbCcgfHwgY29ybmVyID09PSAndGwnIHx8IGNvcm5lciA9PT0gJ2JsJykge1xuICAgICAgICBvcmlnaW4ueCA9ICdyaWdodCc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb3JuZXIgPT09ICdtcicgfHwgY29ybmVyID09PSAndHInIHx8IGNvcm5lciA9PT0gJ2JyJykge1xuICAgICAgICBvcmlnaW4ueCA9ICdsZWZ0JztcbiAgICAgIH1cblxuICAgICAgaWYgKGNvcm5lciA9PT0gJ3RsJyB8fCBjb3JuZXIgPT09ICdtdCcgfHwgY29ybmVyID09PSAndHInKSB7XG4gICAgICAgIG9yaWdpbi55ID0gJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb3JuZXIgPT09ICdibCcgfHwgY29ybmVyID09PSAnbWInIHx8IGNvcm5lciA9PT0gJ2JyJykge1xuICAgICAgICBvcmlnaW4ueSA9ICd0b3AnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3JpZ2luO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRBY3Rpb25Gcm9tQ29ybmVyOiBmdW5jdGlvbih0YXJnZXQsIGNvcm5lciwgZSkge1xuICAgICAgaWYgKCFjb3JuZXIpIHtcbiAgICAgICAgcmV0dXJuICdkcmFnJztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjb3JuZXIpIHtcbiAgICAgICAgY2FzZSAnbXRyJzpcbiAgICAgICAgICByZXR1cm4gJ3JvdGF0ZSc7XG4gICAgICAgIGNhc2UgJ21sJzpcbiAgICAgICAgY2FzZSAnbXInOlxuICAgICAgICAgIHJldHVybiBlW3RoaXMuYWx0QWN0aW9uS2V5XSA/ICdza2V3WScgOiAnc2NhbGVYJztcbiAgICAgICAgY2FzZSAnbXQnOlxuICAgICAgICBjYXNlICdtYic6XG4gICAgICAgICAgcmV0dXJuIGVbdGhpcy5hbHRBY3Rpb25LZXldID8gJ3NrZXdYJyA6ICdzY2FsZVknO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAnc2NhbGUnO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfc2V0dXBDdXJyZW50VHJhbnNmb3JtOiBmdW5jdGlvbiAoZSwgdGFyZ2V0KSB7XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUpLFxuICAgICAgICAgIGNvcm5lciA9IHRhcmdldC5fZmluZFRhcmdldENvcm5lcih0aGlzLmdldFBvaW50ZXIoZSwgdHJ1ZSkpLFxuICAgICAgICAgIGFjdGlvbiA9IHRoaXMuX2dldEFjdGlvbkZyb21Db3JuZXIodGFyZ2V0LCBjb3JuZXIsIGUpLFxuICAgICAgICAgIG9yaWdpbiA9IHRoaXMuX2dldE9yaWdpbkZyb21Db3JuZXIodGFyZ2V0LCBjb3JuZXIpO1xuXG4gICAgICB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0ge1xuICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGNvcm5lcjogY29ybmVyLFxuICAgICAgICBzY2FsZVg6IHRhcmdldC5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogdGFyZ2V0LnNjYWxlWSxcbiAgICAgICAgc2tld1g6IHRhcmdldC5za2V3WCxcbiAgICAgICAgc2tld1k6IHRhcmdldC5za2V3WSxcbiAgICAgICAgLy8gdXNlZCBieSB0cmFuc2F0aW9uXG4gICAgICAgIG9mZnNldFg6IHBvaW50ZXIueCAtIHRhcmdldC5sZWZ0LFxuICAgICAgICBvZmZzZXRZOiBwb2ludGVyLnkgLSB0YXJnZXQudG9wLFxuICAgICAgICBvcmlnaW5YOiBvcmlnaW4ueCxcbiAgICAgICAgb3JpZ2luWTogb3JpZ2luLnksXG4gICAgICAgIGV4OiBwb2ludGVyLngsXG4gICAgICAgIGV5OiBwb2ludGVyLnksXG4gICAgICAgIGxhc3RYOiBwb2ludGVyLngsXG4gICAgICAgIGxhc3RZOiBwb2ludGVyLnksXG4gICAgICAgIC8vIHVuc3VyZSB0aGV5IGFyZSB1c2VmdWxsIGFueW1vcmUuXG4gICAgICAgIC8vIGxlZnQ6IHRhcmdldC5sZWZ0LFxuICAgICAgICAvLyB0b3A6IHRhcmdldC50b3AsXG4gICAgICAgIHRoZXRhOiBkZWdyZWVzVG9SYWRpYW5zKHRhcmdldC5hbmdsZSksXG4gICAgICAgIC8vIGVuZCBvZiB1bnN1cmVcbiAgICAgICAgd2lkdGg6IHRhcmdldC53aWR0aCAqIHRhcmdldC5zY2FsZVgsXG4gICAgICAgIG1vdXNlWFNpZ246IDEsXG4gICAgICAgIG1vdXNlWVNpZ246IDEsXG4gICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5LFxuICAgICAgICBhbHRLZXk6IGVbdGhpcy5jZW50ZXJlZEtleV1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0ub3JpZ2luYWwgPSB7XG4gICAgICAgIGxlZnQ6IHRhcmdldC5sZWZ0LFxuICAgICAgICB0b3A6IHRhcmdldC50b3AsXG4gICAgICAgIHNjYWxlWDogdGFyZ2V0LnNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiB0YXJnZXQuc2NhbGVZLFxuICAgICAgICBza2V3WDogdGFyZ2V0LnNrZXdYLFxuICAgICAgICBza2V3WTogdGFyZ2V0LnNrZXdZLFxuICAgICAgICBvcmlnaW5YOiBvcmlnaW4ueCxcbiAgICAgICAgb3JpZ2luWTogb3JpZ2luLnlcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3Jlc2V0Q3VycmVudFRyYW5zZm9ybSgpO1xuICAgICAgdGhpcy5fYmVmb3JlVHJhbnNmb3JtKGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIG9iamVjdCBieSBcInNldHRpbmdcIiBpdHMgbGVmdC90b3BcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHBvaW50ZXIncyB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBwb2ludGVyJ3MgeSBjb29yZGluYXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgdHJhbnNsYXRpb24gb2NjdXJyZWRcbiAgICAgKi9cbiAgICBfdHJhbnNsYXRlT2JqZWN0OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgICBuZXdMZWZ0ID0geCAtIHRyYW5zZm9ybS5vZmZzZXRYLFxuICAgICAgICAgIG5ld1RvcCA9IHkgLSB0cmFuc2Zvcm0ub2Zmc2V0WSxcbiAgICAgICAgICBtb3ZlWCA9ICF0YXJnZXQuZ2V0KCdsb2NrTW92ZW1lbnRYJykgJiYgdGFyZ2V0LmxlZnQgIT09IG5ld0xlZnQsXG4gICAgICAgICAgbW92ZVkgPSAhdGFyZ2V0LmdldCgnbG9ja01vdmVtZW50WScpICYmIHRhcmdldC50b3AgIT09IG5ld1RvcDtcblxuICAgICAgbW92ZVggJiYgdGFyZ2V0LnNldCgnbGVmdCcsIG5ld0xlZnQpO1xuICAgICAgbW92ZVkgJiYgdGFyZ2V0LnNldCgndG9wJywgbmV3VG9wKTtcbiAgICAgIHJldHVybiBtb3ZlWCB8fCBtb3ZlWTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgd2UgYXJlIGluY3JlYXNpbmcgYSBwb3NpdGl2ZSBza2V3IG9yIGxvd2VyIGl0LFxuICAgICAqIGNoZWNraW5nIG1vdXNlIGRpcmVjdGlvbiBhbmQgcHJlc3NlZCBjb3JuZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2hhbmdlU2tld1RyYW5zZm9ybU9yaWdpbjogZnVuY3Rpb24obW91c2VNb3ZlLCB0LCBieSkge1xuICAgICAgdmFyIHByb3BlcnR5ID0gJ29yaWdpblgnLCBvcmlnaW5zID0geyAwOiAnY2VudGVyJyB9LFxuICAgICAgICAgIHNrZXcgPSB0LnRhcmdldC5za2V3WCwgb3JpZ2luQSA9ICdsZWZ0Jywgb3JpZ2luQiA9ICdyaWdodCcsXG4gICAgICAgICAgY29ybmVyID0gdC5jb3JuZXIgPT09ICdtdCcgfHwgdC5jb3JuZXIgPT09ICdtbCcgPyAxIDogLTEsXG4gICAgICAgICAgZmxpcFNpZ24gPSAxO1xuXG4gICAgICBtb3VzZU1vdmUgPSBtb3VzZU1vdmUgPiAwID8gMSA6IC0xO1xuICAgICAgaWYgKGJ5ID09PSAneScpIHtcbiAgICAgICAgc2tldyA9IHQudGFyZ2V0LnNrZXdZO1xuICAgICAgICBvcmlnaW5BID0gJ3RvcCc7XG4gICAgICAgIG9yaWdpbkIgPSAnYm90dG9tJztcbiAgICAgICAgcHJvcGVydHkgPSAnb3JpZ2luWSc7XG4gICAgICB9XG4gICAgICBvcmlnaW5zWy0xXSA9IG9yaWdpbkE7XG4gICAgICBvcmlnaW5zWzFdID0gb3JpZ2luQjtcblxuICAgICAgdC50YXJnZXQuZmxpcFggJiYgKGZsaXBTaWduICo9IC0xKTtcbiAgICAgIHQudGFyZ2V0LmZsaXBZICYmIChmbGlwU2lnbiAqPSAtMSk7XG5cbiAgICAgIGlmIChza2V3ID09PSAwKSB7XG4gICAgICAgIHQuc2tld1NpZ24gPSAtY29ybmVyICogbW91c2VNb3ZlICogZmxpcFNpZ247XG4gICAgICAgIHRbcHJvcGVydHldID0gb3JpZ2luc1stbW91c2VNb3ZlXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBza2V3ID0gc2tldyA+IDAgPyAxIDogLTE7XG4gICAgICAgIHQuc2tld1NpZ24gPSBza2V3O1xuICAgICAgICB0W3Byb3BlcnR5XSA9IG9yaWdpbnNbc2tldyAqIGNvcm5lciAqIGZsaXBTaWduXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2tldyBvYmplY3QgYnkgbW91c2UgZXZlbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBwb2ludGVyJ3MgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgcG9pbnRlcidzIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBieSBFaXRoZXIgJ3gnIG9yICd5J1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNrZXdpbmcgb2NjdXJyZWRcbiAgICAgKi9cbiAgICBfc2tld09iamVjdDogZnVuY3Rpb24gKHgsIHksIGJ5KSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdGFyZ2V0ID0gdC50YXJnZXQsIHNrZXdlZCA9IGZhbHNlLFxuICAgICAgICAgIGxvY2tTa2V3aW5nWCA9IHRhcmdldC5nZXQoJ2xvY2tTa2V3aW5nWCcpLFxuICAgICAgICAgIGxvY2tTa2V3aW5nWSA9IHRhcmdldC5nZXQoJ2xvY2tTa2V3aW5nWScpO1xuXG4gICAgICBpZiAoKGxvY2tTa2V3aW5nWCAmJiBieSA9PT0gJ3gnKSB8fCAobG9ja1NrZXdpbmdZICYmIGJ5ID09PSAneScpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHRoZSBjb25zdHJhaW50IHBvaW50XG4gICAgICB2YXIgY2VudGVyID0gdGFyZ2V0LmdldENlbnRlclBvaW50KCksXG4gICAgICAgICAgYWN0dWFsTW91c2VCeUNlbnRlciA9IHRhcmdldC50b0xvY2FsUG9pbnQobmV3IGZhYnJpYy5Qb2ludCh4LCB5KSwgJ2NlbnRlcicsICdjZW50ZXInKVtieV0sXG4gICAgICAgICAgbGFzdE1vdXNlQnlDZW50ZXIgPSB0YXJnZXQudG9Mb2NhbFBvaW50KG5ldyBmYWJyaWMuUG9pbnQodC5sYXN0WCwgdC5sYXN0WSksICdjZW50ZXInLCAnY2VudGVyJylbYnldLFxuICAgICAgICAgIGFjdHVhbE1vdXNlQnlPcmlnaW4sIGNvbnN0cmFpbnRQb3NpdGlvbiwgZGltID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKTtcblxuICAgICAgdGhpcy5fY2hhbmdlU2tld1RyYW5zZm9ybU9yaWdpbihhY3R1YWxNb3VzZUJ5Q2VudGVyIC0gbGFzdE1vdXNlQnlDZW50ZXIsIHQsIGJ5KTtcbiAgICAgIGFjdHVhbE1vdXNlQnlPcmlnaW4gPSB0YXJnZXQudG9Mb2NhbFBvaW50KG5ldyBmYWJyaWMuUG9pbnQoeCwgeSksIHQub3JpZ2luWCwgdC5vcmlnaW5ZKVtieV07XG4gICAgICBjb25zdHJhaW50UG9zaXRpb24gPSB0YXJnZXQudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChjZW50ZXIsIHQub3JpZ2luWCwgdC5vcmlnaW5ZKTtcbiAgICAgIC8vIEFjdHVhbGx5IHNrZXcgdGhlIG9iamVjdFxuICAgICAgc2tld2VkID0gdGhpcy5fc2V0T2JqZWN0U2tldyhhY3R1YWxNb3VzZUJ5T3JpZ2luLCB0LCBieSwgZGltKTtcbiAgICAgIHQubGFzdFggPSB4O1xuICAgICAgdC5sYXN0WSA9IHk7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIGNvbnN0cmFpbnRzIGFwcGx5XG4gICAgICB0YXJnZXQuc2V0UG9zaXRpb25CeU9yaWdpbihjb25zdHJhaW50UG9zaXRpb24sIHQub3JpZ2luWCwgdC5vcmlnaW5ZKTtcbiAgICAgIHJldHVybiBza2V3ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBvYmplY3Qgc2tld1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2tld2luZyBvY2N1cnJlZFxuICAgICAqL1xuICAgIF9zZXRPYmplY3RTa2V3OiBmdW5jdGlvbihsb2NhbE1vdXNlLCB0cmFuc2Zvcm0sIGJ5LCBfZGltKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCwgbmV3VmFsdWUsIHNrZXdlZCA9IGZhbHNlLFxuICAgICAgICAgIHNrZXdTaWduID0gdHJhbnNmb3JtLnNrZXdTaWduLCBuZXdEaW0sIGRpbU5vU2tldyxcbiAgICAgICAgICBvdGhlckJ5LCBfb3RoZXJCeSwgX2J5LCBuZXdEaW1Nb3VzZSwgc2tld1gsIHNrZXdZO1xuXG4gICAgICBpZiAoYnkgPT09ICd4Jykge1xuICAgICAgICBvdGhlckJ5ID0gJ3knO1xuICAgICAgICBfb3RoZXJCeSA9ICdZJztcbiAgICAgICAgX2J5ID0gJ1gnO1xuICAgICAgICBza2V3WCA9IDA7XG4gICAgICAgIHNrZXdZID0gdGFyZ2V0LnNrZXdZO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG90aGVyQnkgPSAneCc7XG4gICAgICAgIF9vdGhlckJ5ID0gJ1gnO1xuICAgICAgICBfYnkgPSAnWSc7XG4gICAgICAgIHNrZXdYID0gdGFyZ2V0LnNrZXdYO1xuICAgICAgICBza2V3WSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGRpbU5vU2tldyA9IHRhcmdldC5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKHNrZXdYLCBza2V3WSk7XG4gICAgICBuZXdEaW1Nb3VzZSA9IDIgKiBNYXRoLmFicyhsb2NhbE1vdXNlKSAtIGRpbU5vU2tld1tieV07XG4gICAgICBpZiAobmV3RGltTW91c2UgPD0gMikge1xuICAgICAgICBuZXdWYWx1ZSA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBza2V3U2lnbiAqIE1hdGguYXRhbigobmV3RGltTW91c2UgLyB0YXJnZXRbJ3NjYWxlJyArIF9ieV0pIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGltTm9Ta2V3W290aGVyQnldIC8gdGFyZ2V0WydzY2FsZScgKyBfb3RoZXJCeV0pKTtcbiAgICAgICAgbmV3VmFsdWUgPSBmYWJyaWMudXRpbC5yYWRpYW5zVG9EZWdyZWVzKG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHNrZXdlZCA9IHRhcmdldFsnc2tldycgKyBfYnldICE9PSBuZXdWYWx1ZTtcbiAgICAgIHRhcmdldC5zZXQoJ3NrZXcnICsgX2J5LCBuZXdWYWx1ZSk7XG4gICAgICBpZiAodGFyZ2V0Wydza2V3JyArIF9vdGhlckJ5XSAhPT0gMCkge1xuICAgICAgICBuZXdEaW0gPSB0YXJnZXQuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICAgICAgICBuZXdWYWx1ZSA9IChfZGltW290aGVyQnldIC8gbmV3RGltW290aGVyQnldKSAqIHRhcmdldFsnc2NhbGUnICsgX290aGVyQnldO1xuICAgICAgICB0YXJnZXQuc2V0KCdzY2FsZScgKyBfb3RoZXJCeSwgbmV3VmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNrZXdlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIG9iamVjdCBieSBpbnZva2luZyBpdHMgc2NhbGVYL3NjYWxlWSBtZXRob2RzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBwb2ludGVyJ3MgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgcG9pbnRlcidzIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBieSBFaXRoZXIgJ3gnIG9yICd5JyAtIHNwZWNpZmllcyBkaW1lbnNpb24gY29uc3RyYWludCBieSB3aGljaCB0byBzY2FsZSBhbiBvYmplY3QuXG4gICAgICogICAgICAgICAgICAgICAgICAgIFdoZW4gbm90IHByb3ZpZGVkLCBhbiBvYmplY3QgaXMgc2NhbGVkIGJ5IGJvdGggZGltZW5zaW9ucyBlcXVhbGx5XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2NhbGluZyBvY2N1cnJlZFxuICAgICAqL1xuICAgIF9zY2FsZU9iamVjdDogZnVuY3Rpb24gKHgsIHksIGJ5KSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdGFyZ2V0ID0gdC50YXJnZXQsXG4gICAgICAgICAgbG9ja1NjYWxpbmdYID0gdGFyZ2V0LmxvY2tTY2FsaW5nWCxcbiAgICAgICAgICBsb2NrU2NhbGluZ1kgPSB0YXJnZXQubG9ja1NjYWxpbmdZLFxuICAgICAgICAgIGxvY2tTY2FsaW5nRmxpcCA9IHRhcmdldC5sb2NrU2NhbGluZ0ZsaXA7XG5cbiAgICAgIGlmIChsb2NrU2NhbGluZ1ggJiYgbG9ja1NjYWxpbmdZKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHRoZSBjb25zdHJhaW50IHBvaW50XG4gICAgICB2YXIgY29uc3RyYWludFBvc2l0aW9uID0gdGFyZ2V0LnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQodGFyZ2V0LmdldENlbnRlclBvaW50KCksIHQub3JpZ2luWCwgdC5vcmlnaW5ZKSxcbiAgICAgICAgICBsb2NhbE1vdXNlID0gdGFyZ2V0LnRvTG9jYWxQb2ludChuZXcgZmFicmljLlBvaW50KHgsIHkpLCB0Lm9yaWdpblgsIHQub3JpZ2luWSksXG4gICAgICAgICAgZGltID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKSwgc2NhbGVkID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX3NldExvY2FsTW91c2UobG9jYWxNb3VzZSwgdCk7XG5cbiAgICAgIC8vIEFjdHVhbGx5IHNjYWxlIHRoZSBvYmplY3RcbiAgICAgIHNjYWxlZCA9IHRoaXMuX3NldE9iamVjdFNjYWxlKGxvY2FsTW91c2UsIHQsIGxvY2tTY2FsaW5nWCwgbG9ja1NjYWxpbmdZLCBieSwgbG9ja1NjYWxpbmdGbGlwLCBkaW0pO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIGNvbnN0cmFpbnRzIGFwcGx5XG4gICAgICB0YXJnZXQuc2V0UG9zaXRpb25CeU9yaWdpbihjb25zdHJhaW50UG9zaXRpb24sIHQub3JpZ2luWCwgdC5vcmlnaW5ZKTtcbiAgICAgIHJldHVybiBzY2FsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2NhbGluZyBvY2N1cnJlZFxuICAgICAqL1xuICAgIF9zZXRPYmplY3RTY2FsZTogZnVuY3Rpb24obG9jYWxNb3VzZSwgdHJhbnNmb3JtLCBsb2NrU2NhbGluZ1gsIGxvY2tTY2FsaW5nWSwgYnksIGxvY2tTY2FsaW5nRmxpcCwgX2RpbSkge1xuICAgICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsIGZvcmJpZFNjYWxpbmdYID0gZmFsc2UsIGZvcmJpZFNjYWxpbmdZID0gZmFsc2UsIHNjYWxlZCA9IGZhbHNlLFxuICAgICAgICAgIGNoYW5nZVgsIGNoYW5nZVksIHNjYWxlWCwgc2NhbGVZO1xuXG4gICAgICBzY2FsZVggPSBsb2NhbE1vdXNlLnggKiB0YXJnZXQuc2NhbGVYIC8gX2RpbS54O1xuICAgICAgc2NhbGVZID0gbG9jYWxNb3VzZS55ICogdGFyZ2V0LnNjYWxlWSAvIF9kaW0ueTtcbiAgICAgIGNoYW5nZVggPSB0YXJnZXQuc2NhbGVYICE9PSBzY2FsZVg7XG4gICAgICBjaGFuZ2VZID0gdGFyZ2V0LnNjYWxlWSAhPT0gc2NhbGVZO1xuXG4gICAgICBpZiAobG9ja1NjYWxpbmdGbGlwICYmIHNjYWxlWCA8PSAwICYmIHNjYWxlWCA8IHRhcmdldC5zY2FsZVgpIHtcbiAgICAgICAgZm9yYmlkU2NhbGluZ1ggPSB0cnVlO1xuICAgICAgICBsb2NhbE1vdXNlLnggPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAobG9ja1NjYWxpbmdGbGlwICYmIHNjYWxlWSA8PSAwICYmIHNjYWxlWSA8IHRhcmdldC5zY2FsZVkpIHtcbiAgICAgICAgZm9yYmlkU2NhbGluZ1kgPSB0cnVlO1xuICAgICAgICBsb2NhbE1vdXNlLnkgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnkgPT09ICdlcXVhbGx5JyAmJiAhbG9ja1NjYWxpbmdYICYmICFsb2NrU2NhbGluZ1kpIHtcbiAgICAgICAgc2NhbGVkID0gdGhpcy5fc2NhbGVPYmplY3RFcXVhbGx5KGxvY2FsTW91c2UsIHRhcmdldCwgdHJhbnNmb3JtLCBfZGltKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFieSkge1xuICAgICAgICBmb3JiaWRTY2FsaW5nWCB8fCBsb2NrU2NhbGluZ1ggfHwgKHRhcmdldC5zZXQoJ3NjYWxlWCcsIHNjYWxlWCkgJiYgKHNjYWxlZCA9IHNjYWxlZCB8fCBjaGFuZ2VYKSk7XG4gICAgICAgIGZvcmJpZFNjYWxpbmdZIHx8IGxvY2tTY2FsaW5nWSB8fCAodGFyZ2V0LnNldCgnc2NhbGVZJywgc2NhbGVZKSAmJiAoc2NhbGVkID0gc2NhbGVkIHx8IGNoYW5nZVkpKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJ5ID09PSAneCcgJiYgIXRhcmdldC5nZXQoJ2xvY2tVbmlTY2FsaW5nJykpIHtcbiAgICAgICAgZm9yYmlkU2NhbGluZ1ggfHwgbG9ja1NjYWxpbmdYIHx8ICh0YXJnZXQuc2V0KCdzY2FsZVgnLCBzY2FsZVgpICYmIChzY2FsZWQgPSBzY2FsZWQgfHwgY2hhbmdlWCkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYnkgPT09ICd5JyAmJiAhdGFyZ2V0LmdldCgnbG9ja1VuaVNjYWxpbmcnKSkge1xuICAgICAgICBmb3JiaWRTY2FsaW5nWSB8fCBsb2NrU2NhbGluZ1kgfHwgKHRhcmdldC5zZXQoJ3NjYWxlWScsIHNjYWxlWSkgJiYgKHNjYWxlZCA9IHNjYWxlZCB8fCBjaGFuZ2VZKSk7XG4gICAgICB9XG4gICAgICB0cmFuc2Zvcm0ubmV3U2NhbGVYID0gc2NhbGVYO1xuICAgICAgdHJhbnNmb3JtLm5ld1NjYWxlWSA9IHNjYWxlWTtcbiAgICAgIGZvcmJpZFNjYWxpbmdYIHx8IGZvcmJpZFNjYWxpbmdZIHx8IHRoaXMuX2ZsaXBPYmplY3QodHJhbnNmb3JtLCBieSk7XG4gICAgICByZXR1cm4gc2NhbGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNjYWxpbmcgb2NjdXJyZWRcbiAgICAgKi9cbiAgICBfc2NhbGVPYmplY3RFcXVhbGx5OiBmdW5jdGlvbihsb2NhbE1vdXNlLCB0YXJnZXQsIHRyYW5zZm9ybSwgX2RpbSkge1xuXG4gICAgICB2YXIgZGlzdCA9IGxvY2FsTW91c2UueSArIGxvY2FsTW91c2UueCxcbiAgICAgICAgICBsYXN0RGlzdCA9IF9kaW0ueSAqIHRyYW5zZm9ybS5vcmlnaW5hbC5zY2FsZVkgLyB0YXJnZXQuc2NhbGVZICtcbiAgICAgICAgICAgICAgICAgICAgIF9kaW0ueCAqIHRyYW5zZm9ybS5vcmlnaW5hbC5zY2FsZVggLyB0YXJnZXQuc2NhbGVYLFxuICAgICAgICAgIHNjYWxlZCwgc2lnblggPSBsb2NhbE1vdXNlLnggPCAwID8gLTEgOiAxLFxuICAgICAgICAgIHNpZ25ZID0gbG9jYWxNb3VzZS55IDwgMCA/IC0xIDogMTtcblxuICAgICAgLy8gV2UgdXNlIHRyYW5zZm9ybS5zY2FsZVgvWSBpbnN0ZWFkIG9mIHRhcmdldC5zY2FsZVgvWVxuICAgICAgLy8gYmVjYXVzZSB0aGUgb2JqZWN0IG1heSBoYXZlIGEgbWluIHNjYWxlIGFuZCB3ZSdsbCBsb29zZSB0aGUgcHJvcG9ydGlvbnNcbiAgICAgIHRyYW5zZm9ybS5uZXdTY2FsZVggPSBzaWduWCAqIE1hdGguYWJzKHRyYW5zZm9ybS5vcmlnaW5hbC5zY2FsZVggKiBkaXN0IC8gbGFzdERpc3QpO1xuICAgICAgdHJhbnNmb3JtLm5ld1NjYWxlWSA9IHNpZ25ZICogTWF0aC5hYnModHJhbnNmb3JtLm9yaWdpbmFsLnNjYWxlWSAqIGRpc3QgLyBsYXN0RGlzdCk7XG4gICAgICBzY2FsZWQgPSB0cmFuc2Zvcm0ubmV3U2NhbGVYICE9PSB0YXJnZXQuc2NhbGVYIHx8IHRyYW5zZm9ybS5uZXdTY2FsZVkgIT09IHRhcmdldC5zY2FsZVk7XG4gICAgICB0YXJnZXQuc2V0KCdzY2FsZVgnLCB0cmFuc2Zvcm0ubmV3U2NhbGVYKTtcbiAgICAgIHRhcmdldC5zZXQoJ3NjYWxlWScsIHRyYW5zZm9ybS5uZXdTY2FsZVkpO1xuICAgICAgcmV0dXJuIHNjYWxlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmxpcE9iamVjdDogZnVuY3Rpb24odHJhbnNmb3JtLCBieSkge1xuICAgICAgaWYgKHRyYW5zZm9ybS5uZXdTY2FsZVggPCAwICYmIGJ5ICE9PSAneScpIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybS5vcmlnaW5YID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB0cmFuc2Zvcm0ub3JpZ2luWCA9ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHJhbnNmb3JtLm9yaWdpblggPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB0cmFuc2Zvcm0ub3JpZ2luWCA9ICdsZWZ0JztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNmb3JtLm5ld1NjYWxlWSA8IDAgJiYgYnkgIT09ICd4Jykge1xuICAgICAgICBpZiAodHJhbnNmb3JtLm9yaWdpblkgPT09ICd0b3AnKSB7XG4gICAgICAgICAgdHJhbnNmb3JtLm9yaWdpblkgPSAnYm90dG9tJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0cmFuc2Zvcm0ub3JpZ2luWSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICB0cmFuc2Zvcm0ub3JpZ2luWSA9ICd0b3AnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldExvY2FsTW91c2U6IGZ1bmN0aW9uKGxvY2FsTW91c2UsIHQpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0LnRhcmdldCwgem9vbSA9IHRoaXMuZ2V0Wm9vbSgpLFxuICAgICAgICAgIHBhZGRpbmcgPSB0YXJnZXQucGFkZGluZyAvIHpvb207XG5cbiAgICAgIGlmICh0Lm9yaWdpblggPT09ICdyaWdodCcpIHtcbiAgICAgICAgbG9jYWxNb3VzZS54ICo9IC0xO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodC5vcmlnaW5YID09PSAnY2VudGVyJykge1xuICAgICAgICBsb2NhbE1vdXNlLnggKj0gdC5tb3VzZVhTaWduICogMjtcbiAgICAgICAgaWYgKGxvY2FsTW91c2UueCA8IDApIHtcbiAgICAgICAgICB0Lm1vdXNlWFNpZ24gPSAtdC5tb3VzZVhTaWduO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0Lm9yaWdpblkgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGxvY2FsTW91c2UueSAqPSAtMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHQub3JpZ2luWSA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgbG9jYWxNb3VzZS55ICo9IHQubW91c2VZU2lnbiAqIDI7XG4gICAgICAgIGlmIChsb2NhbE1vdXNlLnkgPCAwKSB7XG4gICAgICAgICAgdC5tb3VzZVlTaWduID0gLXQubW91c2VZU2lnbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBhZGp1c3QgdGhlIG1vdXNlIGNvb3JkaW5hdGVzIHdoZW4gZGVhbGluZyB3aXRoIHBhZGRpbmdcbiAgICAgIGlmIChhYnMobG9jYWxNb3VzZS54KSA+IHBhZGRpbmcpIHtcbiAgICAgICAgaWYgKGxvY2FsTW91c2UueCA8IDApIHtcbiAgICAgICAgICBsb2NhbE1vdXNlLnggKz0gcGFkZGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsb2NhbE1vdXNlLnggLT0gcGFkZGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7IC8vIG1vdXNlIGlzIHdpdGhpbiB0aGUgcGFkZGluZywgc2V0IHRvIDBcbiAgICAgICAgbG9jYWxNb3VzZS54ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGFicyhsb2NhbE1vdXNlLnkpID4gcGFkZGluZykge1xuICAgICAgICBpZiAobG9jYWxNb3VzZS55IDwgMCkge1xuICAgICAgICAgIGxvY2FsTW91c2UueSArPSBwYWRkaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGxvY2FsTW91c2UueSAtPSBwYWRkaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbG9jYWxNb3VzZS55ID0gMDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyBvYmplY3QgYnkgaW52b2tpbmcgaXRzIHJvdGF0ZSBtZXRob2RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHBvaW50ZXIncyB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBwb2ludGVyJ3MgeSBjb29yZGluYXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgcm90YXRpb24gb2NjdXJyZWRcbiAgICAgKi9cbiAgICBfcm90YXRlT2JqZWN0OiBmdW5jdGlvbiAoeCwgeSkge1xuXG4gICAgICB2YXIgdCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdGFyZ2V0ID0gdC50YXJnZXQsIGNvbnN0cmFpbnRQb3NpdGlvbixcbiAgICAgICAgICBjb25zdHJhaW50UG9zaXRpb24gPSB0YXJnZXQudHJhbnNsYXRlVG9PcmlnaW5Qb2ludCh0YXJnZXQuZ2V0Q2VudGVyUG9pbnQoKSwgdC5vcmlnaW5YLCB0Lm9yaWdpblkpO1xuXG4gICAgICBpZiAodGFyZ2V0LmxvY2tSb3RhdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXN0QW5nbGUgPSBhdGFuMih0LmV5IC0gY29uc3RyYWludFBvc2l0aW9uLnksIHQuZXggLSBjb25zdHJhaW50UG9zaXRpb24ueCksXG4gICAgICAgICAgY3VyQW5nbGUgPSBhdGFuMih5IC0gY29uc3RyYWludFBvc2l0aW9uLnksIHggLSBjb25zdHJhaW50UG9zaXRpb24ueCksXG4gICAgICAgICAgYW5nbGUgPSByYWRpYW5zVG9EZWdyZWVzKGN1ckFuZ2xlIC0gbGFzdEFuZ2xlICsgdC50aGV0YSksXG4gICAgICAgICAgaGFzUm90YXRlZCA9IHRydWU7XG5cbiAgICAgIGlmICh0YXJnZXQuc25hcEFuZ2xlID4gMCkge1xuICAgICAgICB2YXIgc25hcEFuZ2xlICA9IHRhcmdldC5zbmFwQW5nbGUsXG4gICAgICAgICAgICBzbmFwVGhyZXNob2xkICA9IHRhcmdldC5zbmFwVGhyZXNob2xkIHx8IHNuYXBBbmdsZSxcbiAgICAgICAgICAgIHJpZ2h0QW5nbGVMb2NrZWQgPSBNYXRoLmNlaWwoYW5nbGUgLyBzbmFwQW5nbGUpICogc25hcEFuZ2xlLFxuICAgICAgICAgICAgbGVmdEFuZ2xlTG9ja2VkID0gTWF0aC5mbG9vcihhbmdsZSAvIHNuYXBBbmdsZSkgKiBzbmFwQW5nbGU7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGFuZ2xlIC0gbGVmdEFuZ2xlTG9ja2VkKSA8IHNuYXBUaHJlc2hvbGQpIHtcbiAgICAgICAgICBhbmdsZSA9IGxlZnRBbmdsZUxvY2tlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhhbmdsZSAtIHJpZ2h0QW5nbGVMb2NrZWQpIDwgc25hcFRocmVzaG9sZCkge1xuICAgICAgICAgIGFuZ2xlID0gcmlnaHRBbmdsZUxvY2tlZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBub3JtYWxpemUgYW5nbGUgdG8gcG9zaXRpdmUgdmFsdWVcbiAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgYW5nbGUgPSAzNjAgKyBhbmdsZTtcbiAgICAgIH1cbiAgICAgIGFuZ2xlICU9IDM2MDtcblxuICAgICAgaWYgKHRhcmdldC5hbmdsZSA9PT0gYW5nbGUpIHtcbiAgICAgICAgaGFzUm90YXRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHJvdGF0aW9uIG9ubHkgaGFwcGVuIGhlcmVcbiAgICAgICAgdGFyZ2V0LmFuZ2xlID0gYW5nbGU7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgY29uc3RyYWludHMgYXBwbHlcbiAgICAgICAgdGFyZ2V0LnNldFBvc2l0aW9uQnlPcmlnaW4oY29uc3RyYWludFBvc2l0aW9uLCB0Lm9yaWdpblgsIHQub3JpZ2luWSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNSb3RhdGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGN1cnNvciB0eXBlIG9mIHRoZSBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBDdXJzb3IgdHlwZSBvZiB0aGUgY2FudmFzIGVsZW1lbnQuXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXVpLyNjdXJzb3JcbiAgICAgKi9cbiAgICBzZXRDdXJzb3I6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdGhpcy51cHBlckNhbnZhc0VsLnN0eWxlLmN1cnNvciA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldCB0byByZXNldCB0cmFuc2Zvcm1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldE9iamVjdFRyYW5zZm9ybTogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgdGFyZ2V0LnNjYWxlWCA9IDE7XG4gICAgICB0YXJnZXQuc2NhbGVZID0gMTtcbiAgICAgIHRhcmdldC5za2V3WCA9IDA7XG4gICAgICB0YXJnZXQuc2tld1kgPSAwO1xuICAgICAgdGFyZ2V0LnJvdGF0ZSgwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IHRvIGRyYXcgdGhlIHNlbGVjdGlvbiBvblxuICAgICAqL1xuICAgIF9kcmF3U2VsZWN0aW9uOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICB2YXIgZ3JvdXBTZWxlY3RvciA9IHRoaXMuX2dyb3VwU2VsZWN0b3IsXG4gICAgICAgICAgbGVmdCA9IGdyb3VwU2VsZWN0b3IubGVmdCxcbiAgICAgICAgICB0b3AgPSBncm91cFNlbGVjdG9yLnRvcCxcbiAgICAgICAgICBhbGVmdCA9IGFicyhsZWZ0KSxcbiAgICAgICAgICBhdG9wID0gYWJzKHRvcCk7XG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbkNvbG9yKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnNlbGVjdGlvbkNvbG9yO1xuXG4gICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICBncm91cFNlbGVjdG9yLmV4IC0gKChsZWZ0ID4gMCkgPyAwIDogLWxlZnQpLFxuICAgICAgICAgIGdyb3VwU2VsZWN0b3IuZXkgLSAoKHRvcCA+IDApID8gMCA6IC10b3ApLFxuICAgICAgICAgIGFsZWZ0LFxuICAgICAgICAgIGF0b3BcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbkxpbmVXaWR0aCB8fCAhdGhpcy5zZWxlY3Rpb25Cb3JkZXJDb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5zZWxlY3Rpb25MaW5lV2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnNlbGVjdGlvbkJvcmRlckNvbG9yO1xuXG4gICAgICAvLyBzZWxlY3Rpb24gYm9yZGVyXG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25EYXNoQXJyYXkubGVuZ3RoID4gMSAmJiAhc3VwcG9ydExpbmVEYXNoKSB7XG5cbiAgICAgICAgdmFyIHB4ID0gZ3JvdXBTZWxlY3Rvci5leCArIFNUUk9LRV9PRkZTRVQgLSAoKGxlZnQgPiAwKSA/IDAgOiBhbGVmdCksXG4gICAgICAgICAgICBweSA9IGdyb3VwU2VsZWN0b3IuZXkgKyBTVFJPS0VfT0ZGU0VUIC0gKCh0b3AgPiAwKSA/IDAgOiBhdG9wKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCBweCwgcHksIHB4ICsgYWxlZnQsIHB5LCB0aGlzLnNlbGVjdGlvbkRhc2hBcnJheSk7XG4gICAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgcHgsIHB5ICsgYXRvcCAtIDEsIHB4ICsgYWxlZnQsIHB5ICsgYXRvcCAtIDEsIHRoaXMuc2VsZWN0aW9uRGFzaEFycmF5KTtcbiAgICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCBweCwgcHksIHB4LCBweSArIGF0b3AsIHRoaXMuc2VsZWN0aW9uRGFzaEFycmF5KTtcbiAgICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCBweCArIGFsZWZ0IC0gMSwgcHksIHB4ICsgYWxlZnQgLSAxLCBweSArIGF0b3AsIHRoaXMuc2VsZWN0aW9uRGFzaEFycmF5KTtcblxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5fc2V0TGluZURhc2guY2FsbCh0aGlzLCBjdHgsIHRoaXMuc2VsZWN0aW9uRGFzaEFycmF5KTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3QoXG4gICAgICAgICAgZ3JvdXBTZWxlY3Rvci5leCArIFNUUk9LRV9PRkZTRVQgLSAoKGxlZnQgPiAwKSA/IDAgOiBhbGVmdCksXG4gICAgICAgICAgZ3JvdXBTZWxlY3Rvci5leSArIFNUUk9LRV9PRkZTRVQgLSAoKHRvcCA+IDApID8gMCA6IGF0b3ApLFxuICAgICAgICAgIGFsZWZ0LFxuICAgICAgICAgIGF0b3BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGV0ZXJtaW5lcyB3aGF0IG9iamVjdCB3ZSBhcmUgY2xpY2tpbmcgb25cbiAgICAgKiB0aGUgc2tpcEdyb3VwIHBhcmFtZXRlciBpcyBmb3IgaW50ZXJuYWwgdXNlLCBpcyBuZWVkZWQgZm9yIHNoaWZ0K2NsaWNrIGFjdGlvblxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBHcm91cCB3aGVuIHRydWUsIGFjdGl2ZUdyb3VwIGlzIHNraXBwZWQgYW5kIG9ubHkgb2JqZWN0cyBhcmUgdHJhdmVyc2VkIHRocm91Z2hcbiAgICAgKi9cbiAgICBmaW5kVGFyZ2V0OiBmdW5jdGlvbiAoZSwgc2tpcEdyb3VwKSB7XG4gICAgICBpZiAodGhpcy5za2lwVGFyZ2V0RmluZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpZ25vcmVab29tID0gdHJ1ZSxcbiAgICAgICAgICBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUsIGlnbm9yZVpvb20pLFxuICAgICAgICAgIGFjdGl2ZU9iamVjdCA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBhT2JqZWN0cyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpLFxuICAgICAgICAgIGFjdGl2ZVRhcmdldCwgYWN0aXZlVGFyZ2V0U3VicztcblxuICAgICAgLy8gZmlyc3QgY2hlY2sgY3VycmVudCBncm91cCAoaWYgb25lIGV4aXN0cylcbiAgICAgIC8vIGFjdGl2ZSBncm91cCBkb2VzIG5vdCBjaGVjayBzdWIgdGFyZ2V0cyBsaWtlIG5vcm1hbCBncm91cHMuXG4gICAgICAvLyBpZiBhY3RpdmUgZ3JvdXAganVzdCBleGl0cy5cbiAgICAgIHRoaXMudGFyZ2V0cyA9IFtdO1xuXG4gICAgICBpZiAoYU9iamVjdHMubGVuZ3RoID4gMSAmJiAhc2tpcEdyb3VwICYmIGFjdGl2ZU9iamVjdCA9PT0gdGhpcy5fc2VhcmNoUG9zc2libGVUYXJnZXRzKFthY3RpdmVPYmplY3RdLCBwb2ludGVyKSkge1xuICAgICAgICByZXR1cm4gYWN0aXZlT2JqZWN0O1xuICAgICAgfVxuICAgICAgLy8gaWYgd2UgaGl0IHRoZSBjb3JuZXIgb2YgYW4gYWN0aXZlT2JqZWN0LCBsZXQncyByZXR1cm4gdGhhdC5cbiAgICAgIGlmIChhT2JqZWN0cy5sZW5ndGggPT09IDEgJiYgYWN0aXZlT2JqZWN0Ll9maW5kVGFyZ2V0Q29ybmVyKHBvaW50ZXIpKSB7XG4gICAgICAgIHJldHVybiBhY3RpdmVPYmplY3Q7XG4gICAgICB9XG4gICAgICBpZiAoYU9iamVjdHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGFjdGl2ZU9iamVjdCA9PT0gdGhpcy5fc2VhcmNoUG9zc2libGVUYXJnZXRzKFthY3RpdmVPYmplY3RdLCBwb2ludGVyKSkge1xuICAgICAgICBpZiAoIXRoaXMucHJlc2VydmVPYmplY3RTdGFja2luZykge1xuICAgICAgICAgIHJldHVybiBhY3RpdmVPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYWN0aXZlVGFyZ2V0ID0gYWN0aXZlT2JqZWN0O1xuICAgICAgICAgIGFjdGl2ZVRhcmdldFN1YnMgPSB0aGlzLnRhcmdldHM7XG4gICAgICAgICAgdGhpcy50YXJnZXRzID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9zZWFyY2hQb3NzaWJsZVRhcmdldHModGhpcy5fb2JqZWN0cywgcG9pbnRlcik7XG4gICAgICBpZiAoZVt0aGlzLmFsdFNlbGVjdGlvbktleV0gJiYgdGFyZ2V0ICYmIGFjdGl2ZVRhcmdldCAmJiB0YXJnZXQgIT09IGFjdGl2ZVRhcmdldCkge1xuICAgICAgICB0YXJnZXQgPSBhY3RpdmVUYXJnZXQ7XG4gICAgICAgIHRoaXMudGFyZ2V0cyA9IGFjdGl2ZVRhcmdldFN1YnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGVja1RhcmdldDogZnVuY3Rpb24ocG9pbnRlciwgb2JqKSB7XG4gICAgICBpZiAob2JqICYmXG4gICAgICAgICAgb2JqLnZpc2libGUgJiZcbiAgICAgICAgICBvYmouZXZlbnRlZCAmJlxuICAgICAgICAgIHRoaXMuY29udGFpbnNQb2ludChudWxsLCBvYmosIHBvaW50ZXIpKXtcbiAgICAgICAgaWYgKCh0aGlzLnBlclBpeGVsVGFyZ2V0RmluZCB8fCBvYmoucGVyUGl4ZWxUYXJnZXRGaW5kKSAmJiAhb2JqLmlzRWRpdGluZykge1xuICAgICAgICAgIHZhciBpc1RyYW5zcGFyZW50ID0gdGhpcy5pc1RhcmdldFRyYW5zcGFyZW50KG9iaiwgcG9pbnRlci54LCBwb2ludGVyLnkpO1xuICAgICAgICAgIGlmICghaXNUcmFuc3BhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NlYXJjaFBvc3NpYmxlVGFyZ2V0czogZnVuY3Rpb24ob2JqZWN0cywgcG9pbnRlcikge1xuXG4gICAgICAvLyBDYWNoZSBhbGwgdGFyZ2V0cyB3aGVyZSB0aGVpciBib3VuZGluZyBib3ggY29udGFpbnMgcG9pbnQuXG4gICAgICB2YXIgdGFyZ2V0LCBpID0gb2JqZWN0cy5sZW5ndGgsIG5vcm1hbGl6ZWRQb2ludGVyLCBzdWJUYXJnZXQ7XG4gICAgICAvLyBEbyBub3QgY2hlY2sgZm9yIGN1cnJlbnRseSBncm91cGVkIG9iamVjdHMsIHNpbmNlIHdlIGNoZWNrIHRoZSBwYXJlbnQgZ3JvdXAgaXRzZWxmLlxuICAgICAgLy8gdW50aWwgd2UgY2FsbCB0aGlzIGZ1bmN0aW9uIHNwZWNpZmljYWxseSB0byBzZWFyY2ggaW5zaWRlIHRoZSBhY3RpdmVHcm91cFxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAodGhpcy5fY2hlY2tUYXJnZXQocG9pbnRlciwgb2JqZWN0c1tpXSkpIHtcbiAgICAgICAgICB0YXJnZXQgPSBvYmplY3RzW2ldO1xuICAgICAgICAgIGlmICh0YXJnZXQuc3ViVGFyZ2V0Q2hlY2sgJiYgdGFyZ2V0IGluc3RhbmNlb2YgZmFicmljLkdyb3VwKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkUG9pbnRlciA9IHRoaXMuX25vcm1hbGl6ZVBvaW50ZXIodGFyZ2V0LCBwb2ludGVyKTtcbiAgICAgICAgICAgIHN1YlRhcmdldCA9IHRoaXMuX3NlYXJjaFBvc3NpYmxlVGFyZ2V0cyh0YXJnZXQuX29iamVjdHMsIG5vcm1hbGl6ZWRQb2ludGVyKTtcbiAgICAgICAgICAgIHN1YlRhcmdldCAmJiB0aGlzLnRhcmdldHMucHVzaChzdWJUYXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwb2ludGVyIGNvb3JkaW5hdGVzIHdpdGhvdXQgdGhlIGVmZmVjdCBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlciB3aXRoIFwieFwiIGFuZCBcInlcIiBudW1iZXIgdmFsdWVzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBcInhcIiBhbmQgXCJ5XCIgbnVtYmVyIHZhbHVlc1xuICAgICAqL1xuICAgIHJlc3RvcmVQb2ludGVyVnB0OiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoXG4gICAgICAgIHBvaW50ZXIsXG4gICAgICAgIGZhYnJpYy51dGlsLmludmVydFRyYW5zZm9ybSh0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwb2ludGVyIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIGNhbnZhcy5cbiAgICAgKiBDYW4gcmV0dXJuIGNvb3JkaW5hdGVzIHdpdGggb3Igd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybS5cbiAgICAgKiBpZ25vcmVab29tIGZhbHNlIGdpdmVzIGJhY2sgY29vcmRpbmF0ZXMgdGhhdCByZXByZXNlbnRcbiAgICAgKiB0aGUgcG9pbnQgY2xpY2tlZCBvbiBjYW52YXMgZWxlbWVudC5cbiAgICAgKiBpZ25vcmVab29tIHRydWUgZ2l2ZXMgYmFjayBjb29yZGluYXRlcyBhZnRlciBiZWluZyBwcm9jZXNzZWRcbiAgICAgKiBieSB0aGUgdmlld3BvcnRUcmFuc2Zvcm0gKCBzb3J0IG9mIGNvb3JkaW5hdGVzIG9mIHdoYXQgaXMgZGlzcGxheWVkXG4gICAgICogb24gdGhlIGNhbnZhcyB3aGVyZSB5b3UgYXJlIGNsaWNraW5nLlxuICAgICAqIGlnbm9yZVpvb20gdHJ1ZSA9IEhUTUxFbGVtZW50IGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHRvcCxsZWZ0XG4gICAgICogaWdub3JlWm9vbSBmYWxzZSwgZGVmYXVsdCA9IGZhYnJpYyBzcGFjZSBjb29yZGluYXRlcywgdGhlIHNhbWUgdXNlZCBmb3Igc2hhcGUgcG9zaXRpb25cbiAgICAgKiBUbyBpbnRlcmFjdCB3aXRoIHlvdXIgc2hhcGVzIHRvcCBhbmQgbGVmdCB5b3Ugd2FudCB0byB1c2UgaWdub3JlWm9vbSB0cnVlXG4gICAgICogbW9zdCBvZiB0aGUgdGltZSwgd2hpbGUgaWdub3JlWm9vbSBmYWxzZSB3aWxsIGdpdmUgeW91IGNvb3JkaW5hdGVzXG4gICAgICogY29tcGF0aWJsZSB3aXRoIHRoZSBvYmplY3Qub0Nvb3JkcyBzeXN0ZW0uXG4gICAgICogb2YgdGhlIHRpbWUuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlWm9vbVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggXCJ4XCIgYW5kIFwieVwiIG51bWJlciB2YWx1ZXNcbiAgICAgKi9cbiAgICBnZXRQb2ludGVyOiBmdW5jdGlvbiAoZSwgaWdub3JlWm9vbSkge1xuICAgICAgLy8gcmV0dXJuIGNhY2hlZCB2YWx1ZXMgaWYgd2UgYXJlIGluIHRoZSBldmVudCBwcm9jZXNzaW5nIGNoYWluXG4gICAgICBpZiAodGhpcy5fYWJzb2x1dGVQb2ludGVyICYmICFpZ25vcmVab29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hYnNvbHV0ZVBvaW50ZXI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcG9pbnRlciAmJiBpZ25vcmVab29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2ludGVyO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRlciA9IGdldFBvaW50ZXIoZSksXG4gICAgICAgICAgdXBwZXJDYW52YXNFbCA9IHRoaXMudXBwZXJDYW52YXNFbCxcbiAgICAgICAgICBib3VuZHMgPSB1cHBlckNhbnZhc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgIGJvdW5kc1dpZHRoID0gYm91bmRzLndpZHRoIHx8IDAsXG4gICAgICAgICAgYm91bmRzSGVpZ2h0ID0gYm91bmRzLmhlaWdodCB8fCAwLFxuICAgICAgICAgIGNzc1NjYWxlO1xuXG4gICAgICBpZiAoIWJvdW5kc1dpZHRoIHx8ICFib3VuZHNIZWlnaHQgKSB7XG4gICAgICAgIGlmICgndG9wJyBpbiBib3VuZHMgJiYgJ2JvdHRvbScgaW4gYm91bmRzKSB7XG4gICAgICAgICAgYm91bmRzSGVpZ2h0ID0gTWF0aC5hYnMoIGJvdW5kcy50b3AgLSBib3VuZHMuYm90dG9tICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdyaWdodCcgaW4gYm91bmRzICYmICdsZWZ0JyBpbiBib3VuZHMpIHtcbiAgICAgICAgICBib3VuZHNXaWR0aCA9IE1hdGguYWJzKCBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdCApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuICAgICAgcG9pbnRlci54ID0gcG9pbnRlci54IC0gdGhpcy5fb2Zmc2V0LmxlZnQ7XG4gICAgICBwb2ludGVyLnkgPSBwb2ludGVyLnkgLSB0aGlzLl9vZmZzZXQudG9wO1xuICAgICAgaWYgKCFpZ25vcmVab29tKSB7XG4gICAgICAgIHBvaW50ZXIgPSB0aGlzLnJlc3RvcmVQb2ludGVyVnB0KHBvaW50ZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRzV2lkdGggPT09IDAgfHwgYm91bmRzSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIC8vIElmIGJvdW5kcyBhcmUgbm90IGF2YWlsYWJsZSAoaS5lLiBub3QgdmlzaWJsZSksIGRvIG5vdCBhcHBseSBzY2FsZS5cbiAgICAgICAgY3NzU2NhbGUgPSB7IHdpZHRoOiAxLCBoZWlnaHQ6IDEgfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjc3NTY2FsZSA9IHtcbiAgICAgICAgICB3aWR0aDogdXBwZXJDYW52YXNFbC53aWR0aCAvIGJvdW5kc1dpZHRoLFxuICAgICAgICAgIGhlaWdodDogdXBwZXJDYW52YXNFbC5oZWlnaHQgLyBib3VuZHNIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcG9pbnRlci54ICogY3NzU2NhbGUud2lkdGgsXG4gICAgICAgIHk6IHBvaW50ZXIueSAqIGNzc1NjYWxlLmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdGhyb3dzIHtDQU5WQVNfSU5JVF9FUlJPUn0gSWYgY2FudmFzIGNhbiBub3QgYmUgaW5pdGlhbGl6ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlVXBwZXJDYW52YXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsb3dlckNhbnZhc0NsYXNzID0gdGhpcy5sb3dlckNhbnZhc0VsLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMqbG93ZXItY2FudmFzXFxzKi8sICcnKTtcblxuICAgICAgLy8gdGhlcmUgaXMgbm8gbmVlZCB0byBjcmVhdGUgYSBuZXcgdXBwZXJDYW52YXMgZWxlbWVudCBpZiB3ZSBoYXZlIGFscmVhZHkgb25lLlxuICAgICAgaWYgKHRoaXMudXBwZXJDYW52YXNFbCkge1xuICAgICAgICB0aGlzLnVwcGVyQ2FudmFzRWwuY2xhc3NOYW1lID0gJyc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy51cHBlckNhbnZhc0VsID0gdGhpcy5fY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgfVxuICAgICAgZmFicmljLnV0aWwuYWRkQ2xhc3ModGhpcy51cHBlckNhbnZhc0VsLCAndXBwZXItY2FudmFzICcgKyBsb3dlckNhbnZhc0NsYXNzKTtcblxuICAgICAgdGhpcy53cmFwcGVyRWwuYXBwZW5kQ2hpbGQodGhpcy51cHBlckNhbnZhc0VsKTtcblxuICAgICAgdGhpcy5fY29weUNhbnZhc1N0eWxlKHRoaXMubG93ZXJDYW52YXNFbCwgdGhpcy51cHBlckNhbnZhc0VsKTtcbiAgICAgIHRoaXMuX2FwcGx5Q2FudmFzU3R5bGUodGhpcy51cHBlckNhbnZhc0VsKTtcbiAgICAgIHRoaXMuY29udGV4dFRvcCA9IHRoaXMudXBwZXJDYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVDYWNoZUNhbnZhczogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYWNoZUNhbnZhc0VsID0gdGhpcy5fY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgdGhpcy5jYWNoZUNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLndpZHRoKTtcbiAgICAgIHRoaXMuY2FjaGVDYW52YXNFbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMuY29udGV4dENhY2hlID0gdGhpcy5jYWNoZUNhbnZhc0VsLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRXcmFwcGVyRWxlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy53cmFwcGVyRWwgPSBmYWJyaWMudXRpbC53cmFwRWxlbWVudCh0aGlzLmxvd2VyQ2FudmFzRWwsICdkaXYnLCB7XG4gICAgICAgICdjbGFzcyc6IHRoaXMuY29udGFpbmVyQ2xhc3NcbiAgICAgIH0pO1xuICAgICAgZmFicmljLnV0aWwuc2V0U3R5bGUodGhpcy53cmFwcGVyRWwsIHtcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGggKyAncHgnLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0ICsgJ3B4JyxcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgIH0pO1xuICAgICAgZmFicmljLnV0aWwubWFrZUVsZW1lbnRVbnNlbGVjdGFibGUodGhpcy53cmFwcGVyRWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgY2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgc3R5bGVzIG9uXG4gICAgICovXG4gICAgX2FwcGx5Q2FudmFzU3R5bGU6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoIHx8IGVsZW1lbnQud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgfHwgZWxlbWVudC5oZWlnaHQ7XG5cbiAgICAgIGZhYnJpYy51dGlsLnNldFN0eWxlKGVsZW1lbnQsIHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHdpZHRoOiB3aWR0aCArICdweCcsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICsgJ3B4JyxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICAndG91Y2gtYWN0aW9uJzogdGhpcy5hbGxvd1RvdWNoU2Nyb2xsaW5nID8gJ21hbmlwdWxhdGlvbicgOiAnbm9uZSdcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudC53aWR0aCA9IHdpZHRoO1xuICAgICAgZWxlbWVudC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBmYWJyaWMudXRpbC5tYWtlRWxlbWVudFVuc2VsZWN0YWJsZShlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29weSB0aGUgZW50aXJlIGlubGluZSBzdHlsZSBmcm9tIG9uZSBlbGVtZW50IChmcm9tRWwpIHRvIGFub3RoZXIgKHRvRWwpXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGZyb21FbCBFbGVtZW50IHN0eWxlIGlzIGNvcGllZCBmcm9tXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0b0VsIEVsZW1lbnQgY29waWVkIHN0eWxlIGlzIGFwcGxpZWQgdG9cbiAgICAgKi9cbiAgICBfY29weUNhbnZhc1N0eWxlOiBmdW5jdGlvbiAoZnJvbUVsLCB0b0VsKSB7XG4gICAgICB0b0VsLnN0eWxlLmNzc1RleHQgPSBmcm9tRWwuc3R5bGUuY3NzVGV4dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250ZXh0IG9mIGNhbnZhcyB3aGVyZSBvYmplY3Qgc2VsZWN0aW9uIGlzIGRyYXduXG4gICAgICogQHJldHVybiB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIGdldFNlbGVjdGlvbkNvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dFRvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyAmbHQ7Y2FudmFzPiBlbGVtZW50IG9uIHdoaWNoIG9iamVjdCBzZWxlY3Rpb24gaXMgZHJhd25cbiAgICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb25FbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy51cHBlckNhbnZhc0VsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGN1cnJlbnRseSBhY3RpdmUgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gYWN0aXZlIG9iamVjdFxuICAgICAqL1xuICAgIGdldEFjdGl2ZU9iamVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSBjdXJyZW50IHNlbGVjdGVkIG9iamVjdHNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSBhY3RpdmUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0QWN0aXZlT2JqZWN0czogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgaWYgKGFjdGl2ZS50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJyAmJiBhY3RpdmUuX29iamVjdHMpIHtcbiAgICAgICAgICByZXR1cm4gYWN0aXZlLl9vYmplY3RzLnNsaWNlKDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbYWN0aXZlXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqIE9iamVjdCB0aGF0IHdhcyByZW1vdmVkXG4gICAgICovXG4gICAgX29uT2JqZWN0UmVtb3ZlZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAvLyByZW1vdmluZyBhY3RpdmUgb2JqZWN0IHNob3VsZCBmaXJlIFwic2VsZWN0aW9uOmNsZWFyZWRcIiBldmVudHNcbiAgICAgIGlmIChvYmogPT09IHRoaXMuX2FjdGl2ZU9iamVjdCkge1xuICAgICAgICB0aGlzLmZpcmUoJ2JlZm9yZTpzZWxlY3Rpb246Y2xlYXJlZCcsIHsgdGFyZ2V0OiBvYmogfSk7XG4gICAgICAgIHRoaXMuX2Rpc2NhcmRBY3RpdmVPYmplY3QoKTtcbiAgICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y2xlYXJlZCcsIHsgdGFyZ2V0OiBvYmogfSk7XG4gICAgICAgIG9iai5maXJlKCdkZXNlbGVjdGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faG92ZXJlZFRhcmdldCA9PT0gb2JqKSB7XG4gICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19vbk9iamVjdFJlbW92ZWQnLCBvYmopO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIENvbXBhcmVzIHRoZSBvbGQgYWN0aXZlT2JqZWN0IHdpdGggdGhlIGN1cnJlbnQgb25lIGFuZCBmaXJlcyBjb3JyZWN0IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqIG9sZCBhY3RpdmVPYmplY3RcbiAgICAgKi9cbiAgICBfZmlyZVNlbGVjdGlvbkV2ZW50czogZnVuY3Rpb24ob2xkT2JqZWN0cywgZSkge1xuICAgICAgdmFyIHNvbWV0aGluZ0NoYW5nZWQgPSBmYWxzZSwgb2JqZWN0cyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpLFxuICAgICAgICAgIGFkZGVkID0gW10sIHJlbW92ZWQgPSBbXSwgb3B0ID0geyBlOiBlIH07XG4gICAgICBvbGRPYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2xkT2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3RzLmluZGV4T2Yob2xkT2JqZWN0KSA9PT0gLTEpIHtcbiAgICAgICAgICBzb21ldGhpbmdDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICBvbGRPYmplY3QuZmlyZSgnZGVzZWxlY3RlZCcsIG9wdCk7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKG9sZE9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBpZiAob2xkT2JqZWN0cy5pbmRleE9mKG9iamVjdCkgPT09IC0xKSB7XG4gICAgICAgICAgc29tZXRoaW5nQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgb2JqZWN0LmZpcmUoJ3NlbGVjdGVkJywgb3B0KTtcbiAgICAgICAgICBhZGRlZC5wdXNoKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKG9sZE9iamVjdHMubGVuZ3RoID4gMCAmJiBvYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3B0LnNlbGVjdGVkID0gYWRkZWQ7XG4gICAgICAgIG9wdC5kZXNlbGVjdGVkID0gcmVtb3ZlZDtcbiAgICAgICAgLy8gYWRkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgb3B0LnVwZGF0ZWQgPSBhZGRlZFswXSB8fCByZW1vdmVkWzBdO1xuICAgICAgICBvcHQudGFyZ2V0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgICBzb21ldGhpbmdDaGFuZ2VkICYmIHRoaXMuZmlyZSgnc2VsZWN0aW9uOnVwZGF0ZWQnLCBvcHQpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIGRlcHJlY2F0ZWQgZXZlbnRcbiAgICAgICAgaWYgKG9iamVjdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgb3B0LnRhcmdldCA9IGFkZGVkWzBdO1xuICAgICAgICAgIHRoaXMuZmlyZSgnb2JqZWN0OnNlbGVjdGVkJywgb3B0KTtcbiAgICAgICAgfVxuICAgICAgICBvcHQuc2VsZWN0ZWQgPSBhZGRlZDtcbiAgICAgICAgLy8gYWRkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgb3B0LnRhcmdldCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y3JlYXRlZCcsIG9wdCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvbGRPYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3B0LmRlc2VsZWN0ZWQgPSByZW1vdmVkO1xuICAgICAgICB0aGlzLmZpcmUoJ3NlbGVjdGlvbjpjbGVhcmVkJywgb3B0KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBnaXZlbiBvYmplY3QgYXMgdGhlIG9ubHkgYWN0aXZlIG9iamVjdCBvbiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc2V0IGFzIGFuIGFjdGl2ZSBvbmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgKHBhc3NlZCBhbG9uZyB3aGVuIGZpcmluZyBcIm9iamVjdDpzZWxlY3RlZFwiKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0QWN0aXZlT2JqZWN0OiBmdW5jdGlvbiAob2JqZWN0LCBlKSB7XG4gICAgICB2YXIgY3VycmVudEFjdGl2ZXMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKTtcbiAgICAgIHRoaXMuX3NldEFjdGl2ZU9iamVjdChvYmplY3QsIGUpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkV2ZW50cyhjdXJyZW50QWN0aXZlcywgZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIHNldCBhcyBhY3RpdmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgKHBhc3NlZCBhbG9uZyB3aGVuIGZpcmluZyBcIm9iamVjdDpzZWxlY3RlZFwiKVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNlbGVjdGlvbiBoYXBwZW5lZFxuICAgICAqL1xuICAgIF9zZXRBY3RpdmVPYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCwgZSkge1xuICAgICAgaWYgKHRoaXMuX2FjdGl2ZU9iamVjdCA9PT0gb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fZGlzY2FyZEFjdGl2ZU9iamVjdChlLCBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3Qub25TZWxlY3QoeyBlOiBlIH0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdCA9IG9iamVjdDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kaXNjYXJkQWN0aXZlT2JqZWN0OiBmdW5jdGlvbihlLCBvYmplY3QpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICBpZiAob2JqKSB7XG4gICAgICAgIC8vIG9uRGVzZWxlY3QgcmV0dXJuIFRSVUUgdG8gY2FuY2VsIHNlbGVjdGlvbjtcbiAgICAgICAgaWYgKG9iai5vbkRlc2VsZWN0KHsgZTogZSwgb2JqZWN0OiBvYmplY3QgfSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWN0aXZlT2JqZWN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNjYXJkcyBjdXJyZW50bHkgYWN0aXZlIG9iamVjdCBhbmQgZmlyZSBldmVudHMuIElmIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgZmFicmljXG4gICAgICogYXMgYSBjb25zZXF1ZW5jZSBvZiBhIG1vdXNlIGV2ZW50LCB0aGUgZXZlbnQgaXMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyIGFuZFxuICAgICAqIHNlbnQgdG8gdGhlIGZpcmUgZnVuY3Rpb24gZm9yIHRoZSBjdXN0b20gZXZlbnRzLiBXaGVuIHVzZWQgYXMgYSBtZXRob2QgdGhlXG4gICAgICogZSBwYXJhbSBkb2VzIG5vdCBoYXZlIGFueSBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkaXNjYXJkQWN0aXZlT2JqZWN0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGN1cnJlbnRBY3RpdmVzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCk7XG4gICAgICBpZiAoY3VycmVudEFjdGl2ZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnYmVmb3JlOnNlbGVjdGlvbjpjbGVhcmVkJywgeyB0YXJnZXQ6IGN1cnJlbnRBY3RpdmVzWzBdLCBlOiBlIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fZGlzY2FyZEFjdGl2ZU9iamVjdChlKTtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25FdmVudHMoY3VycmVudEFjdGl2ZXMsIGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhIGNhbnZhcyBlbGVtZW50IGFuZCByZW1vdmVzIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdGhpcy53cmFwcGVyRWw7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgd3JhcHBlci5yZW1vdmVDaGlsZCh0aGlzLnVwcGVyQ2FudmFzRWwpO1xuICAgICAgd3JhcHBlci5yZW1vdmVDaGlsZCh0aGlzLmxvd2VyQ2FudmFzRWwpO1xuICAgICAgdGhpcy51cHBlckNhbnZhc0VsID0gbnVsbDtcbiAgICAgIHRoaXMuY2FjaGVDYW52YXNFbCA9IG51bGw7XG4gICAgICB0aGlzLmNvbnRleHRDYWNoZSA9IG51bGw7XG4gICAgICB0aGlzLmNvbnRleHRUb3AgPSBudWxsO1xuICAgICAgaWYgKHdyYXBwZXIucGFyZW50Tm9kZSkge1xuICAgICAgICB3cmFwcGVyLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHRoaXMubG93ZXJDYW52YXNFbCwgdGhpcy53cmFwcGVyRWwpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMud3JhcHBlckVsO1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY29udGV4dHMgKGJhY2tncm91bmQsIG1haW4sIHRvcCkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB0aGlzLmRpc2NhcmRBY3RpdmVHcm91cCgpO1xuICAgICAgdGhpcy5kaXNjYXJkQWN0aXZlT2JqZWN0KCk7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dCh0aGlzLmNvbnRleHRUb3ApO1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCdjbGVhcicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBvYmplY3RzJyBjb250cm9scyAoYm9yZGVycy9jb250cm9scylcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIGNvbnRyb2xzIG9uXG4gICAgICovXG4gICAgZHJhd0NvbnRyb2xzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG5cbiAgICAgIGlmIChhY3RpdmVPYmplY3QpIHtcbiAgICAgICAgYWN0aXZlT2JqZWN0Ll9yZW5kZXJDb250cm9scyhjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b09iamVjdDogZnVuY3Rpb24oaW5zdGFuY2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIC8vSWYgdGhlIG9iamVjdCBpcyBwYXJ0IG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBncm91cCwgaXQgc2hvdWxkXG4gICAgICAvL2JlIHRyYW5zZm9ybWVkIGFwcHJvcHJpYXRlbHlcbiAgICAgIC8vaS5lLiBpdCBzaG91bGQgYmUgc2VyaWFsaXNlZCBhcyBpdCB3b3VsZCBhcHBlYXIgaWYgdGhlIHNlbGVjdGlvbiBncm91cFxuICAgICAgLy93ZXJlIHRvIGJlIGRlc3Ryb3llZC5cbiAgICAgIHZhciBvcmlnaW5hbFByb3BlcnRpZXMgPSB0aGlzLl9yZWFsaXplR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdChpbnN0YW5jZSksXG4gICAgICAgICAgb2JqZWN0ID0gdGhpcy5jYWxsU3VwZXIoJ190b09iamVjdCcsIGluc3RhbmNlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIC8vVW5kbyB0aGUgZGFtYWdlIHdlIGRpZCBieSBjaGFuZ2luZyBhbGwgb2YgaXRzIHByb3BlcnRpZXNcbiAgICAgIHRoaXMuX3Vud2luZEdyb3VwVHJhbnNmb3JtT25PYmplY3QoaW5zdGFuY2UsIG9yaWdpbmFsUHJvcGVydGllcyk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFsaXNlcyBhbiBvYmplY3QncyBncm91cCB0cmFuc2Zvcm1hdGlvbiBvbiBpdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBbaW5zdGFuY2VdIHRoZSBvYmplY3QgdG8gdHJhbnNmb3JtIChnZXRzIG11dGF0ZWQpXG4gICAgICogQHJldHVybnMgdGhlIG9yaWdpbmFsIHZhbHVlcyBvZiBpbnN0YW5jZSB3aGljaCB3ZXJlIGNoYW5nZWRcbiAgICAgKi9cbiAgICBfcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3Q6IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuZ3JvdXAgJiYgaW5zdGFuY2UuZ3JvdXAudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicgJiYgdGhpcy5fYWN0aXZlT2JqZWN0ID09PSBpbnN0YW5jZS5ncm91cCkge1xuICAgICAgICB2YXIgbGF5b3V0UHJvcHMgPSBbJ2FuZ2xlJywgJ2ZsaXBYJywgJ2ZsaXBZJywgJ2xlZnQnLCAnc2NhbGVYJywgJ3NjYWxlWScsICdza2V3WCcsICdza2V3WScsICd0b3AnXTtcbiAgICAgICAgLy9Db3B5IGFsbCB0aGUgcG9zaXRpb25hbGx5IHJlbGV2YW50IHByb3BlcnRpZXMgYWNyb3NzIG5vd1xuICAgICAgICB2YXIgb3JpZ2luYWxWYWx1ZXMgPSB7fTtcbiAgICAgICAgbGF5b3V0UHJvcHMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgb3JpZ2luYWxWYWx1ZXNbcHJvcF0gPSBpbnN0YW5jZVtwcm9wXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdC5yZWFsaXplVHJhbnNmb3JtKGluc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsVmFsdWVzO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyB0aGUgY2hhbmdlZCBwcm9wZXJ0aWVzIG9mIGluc3RhbmNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IFtpbnN0YW5jZV0gdGhlIG9iamVjdCB0byB1bi10cmFuc2Zvcm0gKGdldHMgbXV0YXRlZClcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29yaWdpbmFsVmFsdWVzXSB0aGUgb3JpZ2luYWwgdmFsdWVzIG9mIGluc3RhbmNlLCBhcyByZXR1cm5lZCBieSBfcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3RcbiAgICAgKi9cbiAgICBfdW53aW5kR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdDogZnVuY3Rpb24oaW5zdGFuY2UsIG9yaWdpbmFsVmFsdWVzKSB7XG4gICAgICBpZiAob3JpZ2luYWxWYWx1ZXMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0KG9yaWdpbmFsVmFsdWVzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHT2JqZWN0OiBmdW5jdGlvbihtYXJrdXAsIGluc3RhbmNlLCByZXZpdmVyKSB7XG4gICAgICAvL0lmIHRoZSBvYmplY3QgaXMgaW4gYSBzZWxlY3Rpb24gZ3JvdXAsIHNpbXVsYXRlIHdoYXQgd291bGQgaGFwcGVuIHRvIHRoYXRcbiAgICAgIC8vb2JqZWN0IHdoZW4gdGhlIGdyb3VwIGlzIGRlc2VsZWN0ZWRcbiAgICAgIHZhciBvcmlnaW5hbFByb3BlcnRpZXMgPSB0aGlzLl9yZWFsaXplR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdChpbnN0YW5jZSk7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3NldFNWR09iamVjdCcsIG1hcmt1cCwgaW5zdGFuY2UsIHJldml2ZXIpO1xuICAgICAgdGhpcy5fdW53aW5kR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdChpbnN0YW5jZSwgb3JpZ2luYWxQcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgc2V0Vmlld3BvcnRUcmFuc2Zvcm06IGZ1bmN0aW9uICh2cHQpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMuX2FjdGl2ZU9iamVjdCAmJiB0aGlzLl9hY3RpdmVPYmplY3QuaXNFZGl0aW5nKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdC5jbGVhckNvbnRleHRUb3AoKTtcbiAgICAgIH1cbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLnNldFZpZXdwb3J0VHJhbnNmb3JtLmNhbGwodGhpcywgdnB0KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGNvcHlpbmcgc3RhdGljIHByb3BlcnRpZXMgbWFudWFsbHkgdG8gd29yayBhcm91bmQgT3BlcmEncyBidWcsXG4gIC8vIHdoZXJlIFwicHJvdG90eXBlXCIgcHJvcGVydHkgaXMgZW51bWVyYWJsZSBhbmQgb3ZlcnJpZGVzIGV4aXN0aW5nIHByb3RvdHlwZVxuICBmb3IgKHZhciBwcm9wIGluIGZhYnJpYy5TdGF0aWNDYW52YXMpIHtcbiAgICBpZiAocHJvcCAhPT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgIGZhYnJpYy5DYW52YXNbcHJvcF0gPSBmYWJyaWMuU3RhdGljQ2FudmFzW3Byb3BdO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmYWJyaWMuaXNUb3VjaFN1cHBvcnRlZCkge1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgZmFicmljLkNhbnZhcy5wcm90b3R5cGUuX3NldEN1cnNvckZyb21FdmVudCA9IGZ1bmN0aW9uKCkgeyB9O1xuICB9XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgY3Vyc29yT2Zmc2V0ID0ge1xuICAgICAgICBtdDogMCwgLy8gblxuICAgICAgICB0cjogMSwgLy8gbmVcbiAgICAgICAgbXI6IDIsIC8vIGVcbiAgICAgICAgYnI6IDMsIC8vIHNlXG4gICAgICAgIG1iOiA0LCAvLyBzXG4gICAgICAgIGJsOiA1LCAvLyBzd1xuICAgICAgICBtbDogNiwgLy8gd1xuICAgICAgICB0bDogNyAvLyBud1xuICAgICAgfSxcbiAgICAgIGFkZExpc3RlbmVyID0gZmFicmljLnV0aWwuYWRkTGlzdGVuZXIsXG4gICAgICByZW1vdmVMaXN0ZW5lciA9IGZhYnJpYy51dGlsLnJlbW92ZUxpc3RlbmVyLFxuICAgICAgUklHSFRfQ0xJQ0sgPSAzLCBNSURETEVfQ0xJQ0sgPSAyLCBMRUZUX0NMSUNLID0gMSxcbiAgICAgIGFkZEV2ZW50T3B0aW9ucyA9IHsgcGFzc2l2ZTogZmFsc2UgfTtcblxuICBmdW5jdGlvbiBjaGVja0NsaWNrKGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuICd3aGljaCcgaW4gZSA/IGUud2hpY2ggPT09IHZhbHVlIDogZS5idXR0b24gPT09IHZhbHVlIC0gMTtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLkNhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLkNhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogTWFwIG9mIGN1cnNvciBzdHlsZSB2YWx1ZXMgZm9yIGVhY2ggb2YgdGhlIG9iamVjdCBjb250cm9sc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3Vyc29yTWFwOiBbXG4gICAgICAnbi1yZXNpemUnLFxuICAgICAgJ25lLXJlc2l6ZScsXG4gICAgICAnZS1yZXNpemUnLFxuICAgICAgJ3NlLXJlc2l6ZScsXG4gICAgICAncy1yZXNpemUnLFxuICAgICAgJ3N3LXJlc2l6ZScsXG4gICAgICAndy1yZXNpemUnLFxuICAgICAgJ253LXJlc2l6ZSdcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBtb3VzZSBsaXN0ZW5lcnMgdG8gY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdEV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBpbiBjYXNlIHdlIGluaXRpYWxpemVkIHRoZSBjbGFzcyB0d2ljZS4gVGhpcyBzaG91bGQgbm90IGhhcHBlbiBub3JtYWxseVxuICAgICAgLy8gYnV0IGluIHNvbWUga2luZCBvZiBhcHBsaWNhdGlvbnMgd2hlcmUgdGhlIGNhbnZhcyBlbGVtZW50IG1heSBiZSBjaGFuZ2VkXG4gICAgICAvLyB0aGlzIGlzIGEgd29ya2Fyb3VuZCB0byBoYXZpbmcgZG91YmxlIGxpc3RlbmVycy5cbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gICAgICB0aGlzLmFkZE9yUmVtb3ZlKGFkZExpc3RlbmVyLCAnYWRkJyk7XG4gICAgfSxcblxuICAgIGFkZE9yUmVtb3ZlOiBmdW5jdGlvbihmdW5jdG9yLCBldmVudGpzRnVuY3Rvcikge1xuICAgICAgZnVuY3RvcihmYWJyaWMud2luZG93LCAncmVzaXplJywgdGhpcy5fb25SZXNpemUpO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93bik7XG4gICAgICBmdW5jdG9yKHRoaXMudXBwZXJDYW52YXNFbCwgJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICdtb3VzZW91dCcsIHRoaXMuX29uTW91c2VPdXQpO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICdtb3VzZWVudGVyJywgdGhpcy5fb25Nb3VzZUVudGVyKTtcbiAgICAgIGZ1bmN0b3IodGhpcy51cHBlckNhbnZhc0VsLCAnd2hlZWwnLCB0aGlzLl9vbk1vdXNlV2hlZWwpO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICdjb250ZXh0bWVudScsIHRoaXMuX29uQ29udGV4dE1lbnUpO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2spO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Nb3VzZURvd24sIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICBmdW5jdG9yKHRoaXMudXBwZXJDYW52YXNFbCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICdkcmFnb3ZlcicsIHRoaXMuX29uRHJhZ092ZXIpO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICdkcmFnZW50ZXInLCB0aGlzLl9vbkRyYWdFbnRlcik7XG4gICAgICBmdW5jdG9yKHRoaXMudXBwZXJDYW52YXNFbCwgJ2RyYWdsZWF2ZScsIHRoaXMuX29uRHJhZ0xlYXZlKTtcbiAgICAgIGZ1bmN0b3IodGhpcy51cHBlckNhbnZhc0VsLCAnZHJvcCcsIHRoaXMuX29uRHJvcCk7XG4gICAgICBpZiAodHlwZW9mIGV2ZW50anMgIT09ICd1bmRlZmluZWQnICYmIGV2ZW50anNGdW5jdG9yIGluIGV2ZW50anMpIHtcbiAgICAgICAgZXZlbnRqc1tldmVudGpzRnVuY3Rvcl0odGhpcy51cHBlckNhbnZhc0VsLCAnZ2VzdHVyZScsIHRoaXMuX29uR2VzdHVyZSk7XG4gICAgICAgIGV2ZW50anNbZXZlbnRqc0Z1bmN0b3JdKHRoaXMudXBwZXJDYW52YXNFbCwgJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXSh0aGlzLnVwcGVyQ2FudmFzRWwsICdvcmllbnRhdGlvbicsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UpO1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXSh0aGlzLnVwcGVyQ2FudmFzRWwsICdzaGFrZScsIHRoaXMuX29uU2hha2UpO1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXSh0aGlzLnVwcGVyQ2FudmFzRWwsICdsb25ncHJlc3MnLCB0aGlzLl9vbkxvbmdQcmVzcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuICAgIHJlbW92ZUxpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmFkZE9yUmVtb3ZlKHJlbW92ZUxpc3RlbmVyLCAncmVtb3ZlJyk7XG4gICAgICAvLyBpZiB5b3UgZGlzcG9zZSBvbiBhIG1vdXNlRG93biwgYmVmb3JlIG1vdXNlIHVwLCB5b3UgbmVlZCB0byBjbGVhbiBkb2N1bWVudCB0by4uLlxuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uTW91c2VVcCwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2JpbmRFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZXZlbnRzQm91bmQpIHtcbiAgICAgICAgLy8gZm9yIGFueSByZWFzb24gd2UgcGFzcyBoZXJlIHR3aWNlIHdlIGRvIG5vdCB3YW50IHRvIGJpbmQgZXZlbnRzIHR3aWNlLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9vbk1vdXNlRG93biA9IHRoaXMuX29uTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlTW92ZSA9IHRoaXMuX29uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlVXAgPSB0aGlzLl9vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uUmVzaXplID0gdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uR2VzdHVyZSA9IHRoaXMuX29uR2VzdHVyZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25EcmFnID0gdGhpcy5fb25EcmFnLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vblNoYWtlID0gdGhpcy5fb25TaGFrZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Mb25nUHJlc3MgPSB0aGlzLl9vbkxvbmdQcmVzcy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSA9IHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VXaGVlbCA9IHRoaXMuX29uTW91c2VXaGVlbC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Nb3VzZU91dCA9IHRoaXMuX29uTW91c2VPdXQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VFbnRlciA9IHRoaXMuX29uTW91c2VFbnRlci5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Db250ZXh0TWVudSA9IHRoaXMuX29uQ29udGV4dE1lbnUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uRG91YmxlQ2xpY2sgPSB0aGlzLl9vbkRvdWJsZUNsaWNrLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkRyYWdPdmVyID0gdGhpcy5fb25EcmFnT3Zlci5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25EcmFnRW50ZXIgPSB0aGlzLl9zaW1wbGVFdmVudEhhbmRsZXIuYmluZCh0aGlzLCAnZHJhZ2VudGVyJyk7XG4gICAgICB0aGlzLl9vbkRyYWdMZWF2ZSA9IHRoaXMuX3NpbXBsZUV2ZW50SGFuZGxlci5iaW5kKHRoaXMsICdkcmFnbGVhdmUnKTtcbiAgICAgIHRoaXMuX29uRHJvcCA9IHRoaXMuX3NpbXBsZUV2ZW50SGFuZGxlci5iaW5kKHRoaXMsICdkcm9wJyk7XG4gICAgICB0aGlzLmV2ZW50c0JvdW5kID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIGdlc3R1cmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbc2VsZl0gSW5uZXIgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX29uR2VzdHVyZTogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uVHJhbnNmb3JtR2VzdHVyZSAmJiB0aGlzLl9fb25UcmFuc2Zvcm1HZXN0dXJlKGUsIHNlbGYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gRXZlbnQuanMgZHJhZ1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25EcmFnOiBmdW5jdGlvbihlLCBzZWxmKSB7XG4gICAgICB0aGlzLl9fb25EcmFnICYmIHRoaXMuX19vbkRyYWcoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiB3aGVlbCBldmVudFxuICAgICAqL1xuICAgIF9vbk1vdXNlV2hlZWw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuX19vbk1vdXNlV2hlZWwoZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uTW91c2VPdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9ob3ZlcmVkVGFyZ2V0O1xuICAgICAgdGhpcy5maXJlKCdtb3VzZTpvdXQnLCB7IHRhcmdldDogdGFyZ2V0LCBlOiBlIH0pO1xuICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IG51bGw7XG4gICAgICB0YXJnZXQgJiYgdGFyZ2V0LmZpcmUoJ21vdXNlb3V0JywgeyBlOiBlIH0pO1xuICAgICAgaWYgKHRoaXMuX2lUZXh0SW5zdGFuY2VzKSB7XG4gICAgICAgIHRoaXMuX2lUZXh0SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgaWYgKG9iai5pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgIG9iai5oaWRkZW5UZXh0YXJlYS5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2VlbnRlclxuICAgICAqL1xuICAgIF9vbk1vdXNlRW50ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghdGhpcy5maW5kVGFyZ2V0KGUpKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnbW91c2U6b3ZlcicsIHsgdGFyZ2V0OiBudWxsLCBlOiBlIH0pO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIG9yaWVudGF0aW9uIGNoYW5nZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25PcmllbnRhdGlvbkNoYW5nZTogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uT3JpZW50YXRpb25DaGFuZ2UgJiYgdGhpcy5fX29uT3JpZW50YXRpb25DaGFuZ2UoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBzaGFrZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25TaGFrZTogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uU2hha2UgJiYgdGhpcy5fX29uU2hha2UoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBzaGFrZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25Mb25nUHJlc3M6IGZ1bmN0aW9uKGUsIHNlbGYpIHtcbiAgICAgIHRoaXMuX19vbkxvbmdQcmVzcyAmJiB0aGlzLl9fb25Mb25nUHJlc3MoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHByZXZlbnQgZGVmYXVsdCB0byBhbGxvdyBkcm9wIGV2ZW50IHRvIGJlIGZpcmVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIHNoYWtlXG4gICAgICovXG4gICAgX29uRHJhZ092ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9zaW1wbGVFdmVudEhhbmRsZXIoJ2RyYWdvdmVyJywgZSk7XG4gICAgICB0aGlzLl9maXJlRW50ZXJMZWF2ZUV2ZW50cyh0YXJnZXQsIGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9vbkNvbnRleHRNZW51OiBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHRoaXMuc3RvcENvbnRleHRNZW51KSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Eb3VibGVDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2RibGNsaWNrJyk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9fb25Nb3VzZURvd24oZSk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgICAgYWRkTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vbk1vdXNlVXAsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICBhZGRMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcblxuICAgICAgcmVtb3ZlTGlzdGVuZXIodGhpcy51cHBlckNhbnZhc0VsLCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICByZW1vdmVMaXN0ZW5lcih0aGlzLnVwcGVyQ2FudmFzRWwsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcblxuICAgICAgaWYgKGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgIC8vIFVuYmluZCBtb3VzZWRvd24gdG8gcHJldmVudCBkb3VibGUgdHJpZ2dlcnMgZnJvbSB0b3VjaCBkZXZpY2VzXG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKHRoaXMudXBwZXJDYW52YXNFbCwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBhZGRMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICAgICAgYWRkTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9fb25Nb3VzZVVwKGUpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vbk1vdXNlVXAsIGFkZEV2ZW50T3B0aW9ucyk7XG5cbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG5cbiAgICAgIGFkZExpc3RlbmVyKHRoaXMudXBwZXJDYW52YXNFbCwgJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgYWRkTGlzdGVuZXIodGhpcy51cHBlckNhbnZhc0VsLCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG5cbiAgICAgIGlmIChlLnR5cGUgPT09ICd0b3VjaGVuZCcpIHtcbiAgICAgICAgLy8gV2FpdCA0MDBtcyBiZWZvcmUgcmViaW5kaW5nIG1vdXNlZG93biB0byBwcmV2ZW50IGRvdWJsZSB0cmlnZ2Vyc1xuICAgICAgICAvLyBmcm9tIHRvdWNoIGRldmljZXNcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBhZGRMaXN0ZW5lcihfdGhpcy51cHBlckNhbnZhc0VsLCAnbW91c2Vkb3duJywgX3RoaXMuX29uTW91c2VEb3duKTtcbiAgICAgICAgfSwgNDAwKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKi9cbiAgICBfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAhdGhpcy5hbGxvd1RvdWNoU2Nyb2xsaW5nICYmIGUucHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5fX29uTW91c2VNb3ZlKGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vblJlc2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYWxjT2Zmc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2lkZXMgd2hldGhlciB0aGUgY2FudmFzIHNob3VsZCBiZSByZWRyYXduIGluIG1vdXNldXAgYW5kIG1vdXNlZG93biBldmVudHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICAgKi9cbiAgICBfc2hvdWxkUmVuZGVyOiBmdW5jdGlvbih0YXJnZXQsIHBvaW50ZXIpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG5cbiAgICAgIGlmIChhY3RpdmVPYmplY3QgJiYgYWN0aXZlT2JqZWN0LmlzRWRpdGluZyAmJiB0YXJnZXQgPT09IGFjdGl2ZU9iamVjdCkge1xuICAgICAgICAvLyBpZiB3ZSBtb3VzZSB1cC9kb3duIG92ZXIgYSBlZGl0aW5nIHRleHRib3ggYSBjdXJzb3IgY2hhbmdlLFxuICAgICAgICAvLyB0aGVyZSBpcyBubyBuZWVkIHRvIHJlIHJlbmRlclxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gISEoXG4gICAgICAgICh0YXJnZXQgJiYgKFxuICAgICAgICAgIHRhcmdldC5pc01vdmluZyB8fFxuICAgICAgICAgIHRhcmdldCAhPT0gYWN0aXZlT2JqZWN0KSlcbiAgICAgICAgfHxcbiAgICAgICAgKCF0YXJnZXQgJiYgISFhY3RpdmVPYmplY3QpXG4gICAgICAgIHx8XG4gICAgICAgICghdGFyZ2V0ICYmICFhY3RpdmVPYmplY3QgJiYgIXRoaXMuX2dyb3VwU2VsZWN0b3IpXG4gICAgICAgIHx8XG4gICAgICAgIChwb2ludGVyICYmXG4gICAgICAgICAgdGhpcy5fcHJldmlvdXNQb2ludGVyICYmXG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb24gJiYgKFxuICAgICAgICAgICAgcG9pbnRlci54ICE9PSB0aGlzLl9wcmV2aW91c1BvaW50ZXIueCB8fFxuICAgICAgICAgIHBvaW50ZXIueSAhPT0gdGhpcy5fcHJldmlvdXNQb2ludGVyLnkpKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGVmaW5lcyB0aGUgYWN0aW9ucyB3aGVuIG1vdXNlIGlzIHJlbGVhc2VkIG9uIGNhbnZhcy5cbiAgICAgKiBUaGUgbWV0aG9kIHJlc2V0cyB0aGUgY3VycmVudFRyYW5zZm9ybSBwYXJhbWV0ZXJzLCBzdG9yZSB0aGUgaW1hZ2UgY29ybmVyXG4gICAgICogcG9zaXRpb24gaW4gdGhlIGltYWdlIG9iamVjdCBhbmQgcmVuZGVyIHRoZSBjYW52YXMgb24gdG9wLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9fb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHRhcmdldCwgdHJhbnNmb3JtID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybSxcbiAgICAgICAgICBncm91cFNlbGVjdG9yID0gdGhpcy5fZ3JvdXBTZWxlY3RvcixcbiAgICAgICAgICBpc0NsaWNrID0gKCFncm91cFNlbGVjdG9yIHx8IChncm91cFNlbGVjdG9yLmxlZnQgPT09IDAgJiYgZ3JvdXBTZWxlY3Rvci50b3AgPT09IDApKTtcbiAgICAgIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgICAgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0O1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3VwOmJlZm9yZScpO1xuICAgICAgLy8gaWYgcmlnaHQvbWlkZGxlIGNsaWNrIGp1c3QgZmlyZSBldmVudHMgYW5kIHJldHVyblxuICAgICAgLy8gdGFyZ2V0IHVuZGVmaW5lZCB3aWxsIG1ha2UgdGhlIF9oYW5kbGVFdmVudCBzZWFyY2ggdGhlIHRhcmdldFxuICAgICAgaWYgKGNoZWNrQ2xpY2soZSwgUklHSFRfQ0xJQ0spKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcmVSaWdodENsaWNrKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3VwJywgUklHSFRfQ0xJQ0ssIGlzQ2xpY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoZWNrQ2xpY2soZSwgTUlERExFX0NMSUNLKSkge1xuICAgICAgICBpZiAodGhpcy5maXJlTWlkZGxlQ2xpY2spIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAndXAnLCBNSURETEVfQ0xJQ0ssIGlzQ2xpY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNEcmF3aW5nTW9kZSAmJiB0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcpIHtcbiAgICAgICAgdGhpcy5fb25Nb3VzZVVwSW5EcmF3aW5nTW9kZShlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMuX2ZpbmFsaXplQ3VycmVudFRyYW5zZm9ybShlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNob3VsZFJlbmRlciA9IHRoaXMuX3Nob3VsZFJlbmRlcih0YXJnZXQsIHRoaXMuX2Fic29sdXRlUG9pbnRlcik7XG5cbiAgICAgIGlmICh0YXJnZXQgfHwgIWlzQ2xpY2spIHtcbiAgICAgICAgdGhpcy5fbWF5YmVHcm91cE9iamVjdHMoZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldC5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0Q3Vyc29yRnJvbUV2ZW50KGUsIHRhcmdldCk7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAndXAnLCBMRUZUX0NMSUNLLCBpc0NsaWNrKTtcbiAgICAgIHRoaXMuX2dyb3VwU2VsZWN0b3IgPSBudWxsO1xuICAgICAgdGhpcy5fY3VycmVudFRyYW5zZm9ybSA9IG51bGw7XG4gICAgICB0YXJnZXQgJiYgKHRhcmdldC5fX2Nvcm5lciA9IDApO1xuICAgICAgc2hvdWxkUmVuZGVyICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEhhbmRsZSBldmVudCBmaXJpbmcgZm9yIHRhcmdldCBhbmQgc3VidGFyZ2V0c1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgZXZlbnQgZnJvbSBtb3VzZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgZXZlbnQgdG8gZmlyZSAodXAsIGRvd24gb3IgbW92ZSlcbiAgICAgKiBAcmV0dXJuIHtGYWJyaWMuT2JqZWN0fSB0YXJnZXQgcmV0dXJuIHRoZSB0aGUgdGFyZ2V0IGZvdW5kLCBmb3IgaW50ZXJuYWwgcmVhc29ucy5cbiAgICAgKi9cbiAgICBfc2ltcGxlRXZlbnRIYW5kbGVyOiBmdW5jdGlvbihldmVudFR5cGUsIGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmZpbmRUYXJnZXQoZSksXG4gICAgICAgICAgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cyxcbiAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgc3ViVGFyZ2V0czogdGFyZ2V0cyxcbiAgICAgICAgICB9O1xuICAgICAgdGhpcy5maXJlKGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICB0YXJnZXQgJiYgdGFyZ2V0LmZpcmUoZXZlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgIGlmICghdGFyZ2V0cykge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRhcmdldHNbaV0uZmlyZShldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBIYW5kbGUgZXZlbnQgZmlyaW5nIGZvciB0YXJnZXQgYW5kIHN1YnRhcmdldHNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIGV2ZW50IGZyb20gbW91c2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIGV2ZW50IHRvIGZpcmUgKHVwLCBkb3duIG9yIG1vdmUpXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRPYmogcmVjZWl2aW5nIGV2ZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtidXR0b25dIGJ1dHRvbiB1c2VkIGluIHRoZSBldmVudCAxID0gbGVmdCwgMiA9IG1pZGRsZSwgMyA9IHJpZ2h0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc0NsaWNrIGZvciBsZWZ0IGJ1dHRvbiBvbmx5LCBpbmRpY2F0ZXMgdGhhdCB0aGUgbW91c2UgdXAgaGFwcGVuZWQgd2l0aG91dCBtb3ZlLlxuICAgICAqL1xuICAgIF9oYW5kbGVFdmVudDogZnVuY3Rpb24oZSwgZXZlbnRUeXBlLCBidXR0b24sIGlzQ2xpY2spIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQsXG4gICAgICAgICAgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cyB8fCBbXSxcbiAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgc3ViVGFyZ2V0czogdGFyZ2V0cyxcbiAgICAgICAgICAgIGJ1dHRvbjogYnV0dG9uIHx8IExFRlRfQ0xJQ0ssXG4gICAgICAgICAgICBpc0NsaWNrOiBpc0NsaWNrIHx8IGZhbHNlLFxuICAgICAgICAgICAgcG9pbnRlcjogdGhpcy5fcG9pbnRlcixcbiAgICAgICAgICAgIGFic29sdXRlUG9pbnRlcjogdGhpcy5fYWJzb2x1dGVQb2ludGVyLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9jdXJyZW50VHJhbnNmb3JtXG4gICAgICAgICAgfTtcbiAgICAgIHRoaXMuZmlyZSgnbW91c2U6JyArIGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICB0YXJnZXQgJiYgdGFyZ2V0LmZpcmUoJ21vdXNlJyArIGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGFyZ2V0c1tpXS5maXJlKCdtb3VzZScgKyBldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgc2VuZCB0aGUgbW91c2UgZXZlbnQgdGhhdCBnZW5lcmF0ZSB0aGUgZmluYWxpemUgZG93biwgc28gaXQgY2FuIGJlIHVzZWQgaW4gdGhlIGV2ZW50XG4gICAgICovXG4gICAgX2ZpbmFsaXplQ3VycmVudFRyYW5zZm9ybTogZnVuY3Rpb24oZSkge1xuXG4gICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybSxcbiAgICAgICAgICB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICAgICAgfTtcblxuICAgICAgaWYgKHRhcmdldC5fc2NhbGluZykge1xuICAgICAgICB0YXJnZXQuX3NjYWxpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LnNldENvb3JkcygpO1xuXG4gICAgICBpZiAodHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCB8fCAodGhpcy5zdGF0ZWZ1bCAmJiB0YXJnZXQuaGFzU3RhdGVDaGFuZ2VkKCkpKSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkKSB7XG4gICAgICAgICAgZXZlbnROYW1lID0gdGhpcy5fYWRkRXZlbnRPcHRpb25zKG9wdGlvbnMsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgdGhpcy5fZmlyZShldmVudE5hbWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZpcmUoJ21vZGlmaWVkJywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11dGF0ZSBvcHRpb24gb2JqZWN0IGluIG9yZGVyIHRvIGFkZCBieSBwcm9wZXJ0eSBhbmQgZ2l2ZSBiYWNrIHRoZSBldmVudCBuYW1lLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdG8gbXV0YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSB0byBpbnNwZWN0IGFjdGlvbiBmcm9tXG4gICAgICovXG4gICAgX2FkZEV2ZW50T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucywgdHJhbnNmb3JtKSB7XG4gICAgICAvLyB3ZSBjYW4gcHJvYmFibHkgYWRkIG1vcmUgZGV0YWlscyBhdCBsb3cgY29zdFxuICAgICAgLy8gc2NhbGUgY2hhbmdlLCByb3RhdGlvbiBjaGFuZ2VzLCB0cmFuc2xhdGlvbiBjaGFuZ2VzXG4gICAgICB2YXIgZXZlbnROYW1lLCBieTtcbiAgICAgIHN3aXRjaCAodHJhbnNmb3JtLmFjdGlvbikge1xuICAgICAgICBjYXNlICdzY2FsZVgnOlxuICAgICAgICAgIGV2ZW50TmFtZSA9ICdzY2FsZWQnO1xuICAgICAgICAgIGJ5ID0gJ3gnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzY2FsZVknOlxuICAgICAgICAgIGV2ZW50TmFtZSA9ICdzY2FsZWQnO1xuICAgICAgICAgIGJ5ID0gJ3knO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdza2V3WCc6XG4gICAgICAgICAgZXZlbnROYW1lID0gJ3NrZXdlZCc7XG4gICAgICAgICAgYnkgPSAneCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NrZXdZJzpcbiAgICAgICAgICBldmVudE5hbWUgPSAnc2tld2VkJztcbiAgICAgICAgICBieSA9ICd5JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2NhbGUnOlxuICAgICAgICAgIGV2ZW50TmFtZSA9ICdzY2FsZWQnO1xuICAgICAgICAgIGJ5ID0gJ2VxdWFsbHknO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyb3RhdGUnOlxuICAgICAgICAgIGV2ZW50TmFtZSA9ICdyb3RhdGVkJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZHJhZyc6XG4gICAgICAgICAgZXZlbnROYW1lID0gJ21vdmVkJztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuYnkgPSBieTtcbiAgICAgIHJldHVybiBldmVudE5hbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uTW91c2VEb3duSW5EcmF3aW5nTW9kZTogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5faXNDdXJyZW50bHlEcmF3aW5nID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLmdldEFjdGl2ZU9iamVjdCgpKSB7XG4gICAgICAgIHRoaXMuZGlzY2FyZEFjdGl2ZU9iamVjdChlKS5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jbGlwVG8pIHtcbiAgICAgICAgZmFicmljLnV0aWwuY2xpcENvbnRleHQodGhpcywgdGhpcy5jb250ZXh0VG9wKTtcbiAgICAgIH1cbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUpO1xuICAgICAgdGhpcy5mcmVlRHJhd2luZ0JydXNoLm9uTW91c2VEb3duKHBvaW50ZXIpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2Rvd24nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKi9cbiAgICBfb25Nb3VzZU1vdmVJbkRyYXdpbmdNb2RlOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAodGhpcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUpO1xuICAgICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2gub25Nb3VzZU1vdmUocG9pbnRlcik7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEN1cnNvcih0aGlzLmZyZWVEcmF3aW5nQ3Vyc29yKTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdtb3ZlJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9vbk1vdXNlVXBJbkRyYXdpbmdNb2RlOiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmNsaXBUbykge1xuICAgICAgICB0aGlzLmNvbnRleHRUb3AucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmVlRHJhd2luZ0JydXNoLm9uTW91c2VVcCgpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3VwJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGRlZmluZXMgdGhlIGFjdGlvbnMgd2hlbiBtb3VzZSBpcyBjbGlja2VkIG9uIGNhbnZhcy5cbiAgICAgKiBUaGUgbWV0aG9kIGluaXRzIHRoZSBjdXJyZW50VHJhbnNmb3JtIHBhcmFtZXRlcnMgYW5kIHJlbmRlcnMgYWxsIHRoZVxuICAgICAqIGNhbnZhcyBzbyB0aGUgY3VycmVudCBpbWFnZSBjYW4gYmUgcGxhY2VkIG9uIHRoZSB0b3AgY2FudmFzIGFuZCB0aGUgcmVzdFxuICAgICAqIGluIG9uIHRoZSBjb250YWluZXIgb25lLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX19vbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2Rvd246YmVmb3JlJyk7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0O1xuICAgICAgLy8gaWYgcmlnaHQgY2xpY2sganVzdCBmaXJlIGV2ZW50c1xuICAgICAgaWYgKGNoZWNrQ2xpY2soZSwgUklHSFRfQ0xJQ0spKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcmVSaWdodENsaWNrKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2Rvd24nLCBSSUdIVF9DTElDSyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tDbGljayhlLCBNSURETEVfQ0xJQ0spKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcmVNaWRkbGVDbGljaykge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdkb3duJywgTUlERExFX0NMSUNLKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzRHJhd2luZ01vZGUpIHtcbiAgICAgICAgdGhpcy5fb25Nb3VzZURvd25JbkRyYXdpbmdNb2RlKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGlnbm9yZSBpZiBzb21lIG9iamVjdCBpcyBiZWluZyB0cmFuc2Zvcm1lZCBhdCB0aGlzIG1vbWVudFxuICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuX3BvaW50ZXI7XG4gICAgICAvLyBzYXZlIHBvaW50ZXIgZm9yIGNoZWNrIGluIF9fb25Nb3VzZVVwIGV2ZW50XG4gICAgICB0aGlzLl9wcmV2aW91c1BvaW50ZXIgPSBwb2ludGVyO1xuICAgICAgdmFyIHNob3VsZFJlbmRlciA9IHRoaXMuX3Nob3VsZFJlbmRlcih0YXJnZXQsIHBvaW50ZXIpLFxuICAgICAgICAgIHNob3VsZEdyb3VwID0gdGhpcy5fc2hvdWxkR3JvdXAoZSwgdGFyZ2V0KTtcbiAgICAgIGlmICh0aGlzLl9zaG91bGRDbGVhclNlbGVjdGlvbihlLCB0YXJnZXQpKSB7XG4gICAgICAgIHRoaXMuZGlzY2FyZEFjdGl2ZU9iamVjdChlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNob3VsZEdyb3VwKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUdyb3VwaW5nKGUsIHRhcmdldCk7XG4gICAgICAgIHRhcmdldCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uICYmICghdGFyZ2V0IHx8XG4gICAgICAgICghdGFyZ2V0LnNlbGVjdGFibGUgJiYgIXRhcmdldC5pc0VkaXRpbmcgJiYgdGFyZ2V0ICE9PSB0aGlzLl9hY3RpdmVPYmplY3QpKSkge1xuICAgICAgICB0aGlzLl9ncm91cFNlbGVjdG9yID0ge1xuICAgICAgICAgIGV4OiBwb2ludGVyLngsXG4gICAgICAgICAgZXk6IHBvaW50ZXIueSxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQuc2VsZWN0YWJsZSkge1xuICAgICAgICAgIHRoaXMuc2V0QWN0aXZlT2JqZWN0KHRhcmdldCwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdGhpcy5fYWN0aXZlT2JqZWN0ICYmICh0YXJnZXQuX19jb3JuZXIgfHwgIXNob3VsZEdyb3VwKSkge1xuICAgICAgICAgIHRoaXMuX3NldHVwQ3VycmVudFRyYW5zZm9ybShlLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnZG93bicpO1xuICAgICAgLy8gd2UgbXVzdCByZW5kZXJBbGwgc28gdGhhdCB3ZSB1cGRhdGUgdGhlIHZpc3VhbHNcbiAgICAgIHNob3VsZFJlbmRlciAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVzZXQgY2FjaGUgZm9ybSBjb21tb24gaW5mb3JtYXRpb24gbmVlZGVkIGR1cmluZyBldmVudCBwcm9jZXNzaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzZXRUcmFuc2Zvcm1FdmVudERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fdGFyZ2V0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3BvaW50ZXIgPSBudWxsO1xuICAgICAgdGhpcy5fYWJzb2x1dGVQb2ludGVyID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FjaGUgY29tbW9uIGluZm9ybWF0aW9uIG5lZWRlZCBkdXJpbmcgZXZlbnQgcHJvY2Vzc2luZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gZXZlbnRcbiAgICAgKi9cbiAgICBfY2FjaGVUcmFuc2Zvcm1FdmVudERhdGE6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIC8vIHJlc2V0IGluIG9yZGVyIHRvIGF2b2lkIHN0YWxlIGNhY2hpbmdcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgICB0aGlzLl9wb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUsIHRydWUpO1xuICAgICAgdGhpcy5fYWJzb2x1dGVQb2ludGVyID0gdGhpcy5yZXN0b3JlUG9pbnRlclZwdCh0aGlzLl9wb2ludGVyKTtcbiAgICAgIHRoaXMuX3RhcmdldCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gPyB0aGlzLl9jdXJyZW50VHJhbnNmb3JtLnRhcmdldCA6IHRoaXMuZmluZFRhcmdldChlKSB8fCBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9iZWZvcmVUcmFuc2Zvcm06IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybTtcbiAgICAgIHRoaXMuc3RhdGVmdWwgJiYgdC50YXJnZXQuc2F2ZVN0YXRlKCk7XG4gICAgICB0aGlzLmZpcmUoJ2JlZm9yZTp0cmFuc2Zvcm0nLCB7XG4gICAgICAgIGU6IGUsXG4gICAgICAgIHRyYW5zZm9ybTogdCxcbiAgICAgIH0pO1xuICAgICAgLy8gZGV0ZXJtaW5lIGlmIGl0J3MgYSBkcmFnIG9yIHJvdGF0ZSBjYXNlXG4gICAgICBpZiAodC5jb3JuZXIpIHtcbiAgICAgICAgdGhpcy5vbkJlZm9yZVNjYWxlUm90YXRlKHQudGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGVmaW5lcyB0aGUgYWN0aW9ucyB3aGVuIG1vdXNlIGlzIGhvdmVyaW5nIHRoZSBjYW52YXMuXG4gICAgICogVGhlIGN1cnJlbnRUcmFuc2Zvcm0gcGFyYW1ldGVyIHdpbGwgZGVmaW5kZSB3aGV0aGVyIHRoZSB1c2VyIGlzIHJvdGF0aW5nL3NjYWxpbmcvdHJhbnNsYXRpbmdcbiAgICAgKiBhbiBpbWFnZSBvciBuZWl0aGVyIG9mIHRoZW0gKG9ubHkgaG92ZXJpbmcpLiBBIGdyb3VwIHNlbGVjdGlvbiBpcyBhbHNvIHBvc3NpYmxlIGFuZCB3b3VsZCBjYW5jZWxcbiAgICAgKiBhbGwgYW55IG90aGVyIHR5cGUgb2YgYWN0aW9uLlxuICAgICAqIEluIGNhc2Ugb2YgYW4gaW1hZ2UgdHJhbnNmb3JtYXRpb24gb25seSB0aGUgdG9wIGNhbnZhcyB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vtb3ZlXG4gICAgICovXG4gICAgX19vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdtb3ZlOmJlZm9yZScpO1xuICAgICAgdGhpcy5fY2FjaGVUcmFuc2Zvcm1FdmVudERhdGEoZSk7XG4gICAgICB2YXIgdGFyZ2V0LCBwb2ludGVyO1xuXG4gICAgICBpZiAodGhpcy5pc0RyYXdpbmdNb2RlKSB7XG4gICAgICAgIHRoaXMuX29uTW91c2VNb3ZlSW5EcmF3aW5nTW9kZShlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlLnRvdWNoZXMgIT09ICd1bmRlZmluZWQnICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGdyb3VwU2VsZWN0b3IgPSB0aGlzLl9ncm91cFNlbGVjdG9yO1xuXG4gICAgICAvLyBXZSBpbml0aWFsbHkgY2xpY2tlZCBpbiBhbiBlbXB0eSBhcmVhLCBzbyB3ZSBkcmF3IGEgYm94IGZvciBtdWx0aXBsZSBzZWxlY3Rpb25cbiAgICAgIGlmIChncm91cFNlbGVjdG9yKSB7XG4gICAgICAgIHBvaW50ZXIgPSB0aGlzLl9wb2ludGVyO1xuXG4gICAgICAgIGdyb3VwU2VsZWN0b3IubGVmdCA9IHBvaW50ZXIueCAtIGdyb3VwU2VsZWN0b3IuZXg7XG4gICAgICAgIGdyb3VwU2VsZWN0b3IudG9wID0gcG9pbnRlci55IC0gZ3JvdXBTZWxlY3Rvci5leTtcblxuICAgICAgICB0aGlzLnJlbmRlclRvcCgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIXRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy5maW5kVGFyZ2V0KGUpIHx8IG51bGw7XG4gICAgICAgIHRoaXMuX3NldEN1cnNvckZyb21FdmVudChlLCB0YXJnZXQpO1xuICAgICAgICB0aGlzLl9maXJlT3Zlck91dEV2ZW50cyh0YXJnZXQsIGUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybU9iamVjdChlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdtb3ZlJyk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYW5hZ2UgdGhlIG1vdXNlb3V0LCBtb3VzZW92ZXIgZXZlbnRzIGZvciB0aGUgZmFicmljIG9iamVjdCBvbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtGYWJyaWMuT2JqZWN0fSB0YXJnZXQgdGhlIHRhcmdldCB3aGVyZSB0aGUgdGFyZ2V0IGZyb20gdGhlIG1vdXNlbW92ZSBldmVudFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlbW92ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVPdmVyT3V0RXZlbnRzOiBmdW5jdGlvbih0YXJnZXQsIGUpIHtcbiAgICAgIHRoaXMuZmlyZVN5bnRldGljSW5PdXRFdmVudHModGFyZ2V0LCBlLCB7XG4gICAgICAgIHRhcmdldE5hbWU6ICdfaG92ZXJlZFRhcmdldCcsXG4gICAgICAgIGNhbnZhc0V2dE91dDogJ21vdXNlOm91dCcsXG4gICAgICAgIGV2dE91dDogJ21vdXNlb3V0JyxcbiAgICAgICAgY2FudmFzRXZ0SW46ICdtb3VzZTpvdmVyJyxcbiAgICAgICAgZXZ0SW46ICdtb3VzZW92ZXInLFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1hbmFnZSB0aGUgZHJhZ0VudGVyLCBkcmFnTGVhdmUgZXZlbnRzIGZvciB0aGUgZmFicmljIG9iamVjdHMgb24gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7RmFicmljLk9iamVjdH0gdGFyZ2V0IHRoZSB0YXJnZXQgd2hlcmUgdGhlIHRhcmdldCBmcm9tIHRoZSBvbkRyYWcgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBvbmRyYWdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlRW50ZXJMZWF2ZUV2ZW50czogZnVuY3Rpb24odGFyZ2V0LCBlKSB7XG4gICAgICB0aGlzLmZpcmVTeW50ZXRpY0luT3V0RXZlbnRzKHRhcmdldCwgZSwge1xuICAgICAgICB0YXJnZXROYW1lOiAnX2RyYWdnZWRvdmVyVGFyZ2V0JyxcbiAgICAgICAgZXZ0T3V0OiAnZHJhZ2xlYXZlJyxcbiAgICAgICAgZXZ0SW46ICdkcmFnZW50ZXInLFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1hbmFnZSB0aGUgc3ludGV0aWMgaW4vb3V0IGV2ZW50cyBmb3IgdGhlIGZhYnJpYyBvYmplY3RzIG9uIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0ZhYnJpYy5PYmplY3R9IHRhcmdldCB0aGUgdGFyZ2V0IHdoZXJlIHRoZSB0YXJnZXQgZnJvbSB0aGUgc3VwcG9ydGVkIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBjb25maWd1cmF0aW9uIGZvciB0aGUgZnVuY3Rpb24gdG8gd29ya1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcudGFyZ2V0TmFtZSBwcm9wZXJ0eSBvbiB0aGUgY2FudmFzIHdoZXJlIHRoZSBvbGQgdGFyZ2V0IGlzIHN0b3JlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmNhbnZhc0V2dE91dF0gbmFtZSBvZiB0aGUgZXZlbnQgdG8gZmlyZSBhdCBjYW52YXMgbGV2ZWwgZm9yIG91dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZXZ0T3V0IG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpcmUgZm9yIG91dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmNhbnZhc0V2dEluXSBuYW1lIG9mIHRoZSBldmVudCB0byBmaXJlIGF0IGNhbnZhcyBsZXZlbCBmb3IgaW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmV2dEluIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpcmUgZm9yIGluXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmaXJlU3ludGV0aWNJbk91dEV2ZW50czogZnVuY3Rpb24odGFyZ2V0LCBlLCBjb25maWcpIHtcbiAgICAgIHZhciBpbk9wdCwgb3V0T3B0LCBvbGRUYXJnZXQgPSB0aGlzW2NvbmZpZy50YXJnZXROYW1lXSwgb3V0RmlyZXMsIGluRmlyZXMsXG4gICAgICAgICAgdGFyZ2V0Q2hhbmdlZCA9IG9sZFRhcmdldCAhPT0gdGFyZ2V0LCBjYW52YXNFdnRJbiA9IGNvbmZpZy5jYW52YXNFdnRJbiwgY2FudmFzRXZ0T3V0ID0gY29uZmlnLmNhbnZhc0V2dE91dDtcbiAgICAgIGlmICh0YXJnZXRDaGFuZ2VkKSB7XG4gICAgICAgIGluT3B0ID0geyBlOiBlLCB0YXJnZXQ6IHRhcmdldCwgcHJldmlvdXNUYXJnZXQ6IG9sZFRhcmdldCB9O1xuICAgICAgICBvdXRPcHQgPSB7IGU6IGUsIHRhcmdldDogb2xkVGFyZ2V0LCBuZXh0VGFyZ2V0OiB0YXJnZXQgfTtcbiAgICAgICAgdGhpc1tjb25maWcudGFyZ2V0TmFtZV0gPSB0YXJnZXQ7XG4gICAgICB9XG4gICAgICBpbkZpcmVzID0gdGFyZ2V0ICYmIHRhcmdldENoYW5nZWQ7XG4gICAgICBvdXRGaXJlcyA9IG9sZFRhcmdldCAmJiB0YXJnZXRDaGFuZ2VkO1xuICAgICAgaWYgKG91dEZpcmVzKSB7XG4gICAgICAgIGNhbnZhc0V2dE91dCAmJiB0aGlzLmZpcmUoY2FudmFzRXZ0T3V0LCBvdXRPcHQpO1xuICAgICAgICBvbGRUYXJnZXQuZmlyZShjb25maWcuZXZ0T3V0LCBvdXRPcHQpO1xuICAgICAgfVxuICAgICAgaWYgKGluRmlyZXMpIHtcbiAgICAgICAgY2FudmFzRXZ0SW4gJiYgdGhpcy5maXJlKGNhbnZhc0V2dEluLCBpbk9wdCk7XG4gICAgICAgIHRhcmdldC5maXJlKGNvbmZpZy5ldnRJbiwgaW5PcHQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBkZWZpbmVzIGFjdGlvbnMgd2hlbiBhbiBFdmVudCBNb3VzZSBXaGVlbFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNldXBcbiAgICAgKi9cbiAgICBfX29uTW91c2VXaGVlbDogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5fY2FjaGVUcmFuc2Zvcm1FdmVudERhdGEoZSk7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnd2hlZWwnKTtcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKi9cbiAgICBfdHJhbnNmb3JtT2JqZWN0OiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlKSxcbiAgICAgICAgICB0cmFuc2Zvcm0gPSB0aGlzLl9jdXJyZW50VHJhbnNmb3JtO1xuXG4gICAgICB0cmFuc2Zvcm0ucmVzZXQgPSBmYWxzZTtcbiAgICAgIHRyYW5zZm9ybS50YXJnZXQuaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgdHJhbnNmb3JtLnNoaWZ0S2V5ID0gZS5zaGlmdEtleTtcbiAgICAgIHRyYW5zZm9ybS5hbHRLZXkgPSBlW3RoaXMuY2VudGVyZWRLZXldO1xuXG4gICAgICB0aGlzLl9iZWZvcmVTY2FsZVRyYW5zZm9ybShlLCB0cmFuc2Zvcm0pO1xuICAgICAgdGhpcy5fcGVyZm9ybVRyYW5zZm9ybUFjdGlvbihlLCB0cmFuc2Zvcm0sIHBvaW50ZXIpO1xuXG4gICAgICB0cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wZXJmb3JtVHJhbnNmb3JtQWN0aW9uOiBmdW5jdGlvbihlLCB0cmFuc2Zvcm0sIHBvaW50ZXIpIHtcbiAgICAgIHZhciB4ID0gcG9pbnRlci54LFxuICAgICAgICAgIHkgPSBwb2ludGVyLnksXG4gICAgICAgICAgYWN0aW9uID0gdHJhbnNmb3JtLmFjdGlvbixcbiAgICAgICAgICBhY3Rpb25QZXJmb3JtZWQgPSBmYWxzZSxcbiAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgdGFyZ2V0OiB0cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgICAgICAgcG9pbnRlcjogcG9pbnRlclxuICAgICAgICAgIH07XG5cbiAgICAgIGlmIChhY3Rpb24gPT09ICdyb3RhdGUnKSB7XG4gICAgICAgIChhY3Rpb25QZXJmb3JtZWQgPSB0aGlzLl9yb3RhdGVPYmplY3QoeCwgeSkpICYmIHRoaXMuX2ZpcmUoJ3JvdGF0aW5nJywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdzY2FsZScpIHtcbiAgICAgICAgKGFjdGlvblBlcmZvcm1lZCA9IHRoaXMuX29uU2NhbGUoZSwgdHJhbnNmb3JtLCB4LCB5KSkgJiYgdGhpcy5fZmlyZSgnc2NhbGluZycsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnc2NhbGVYJykge1xuICAgICAgICAoYWN0aW9uUGVyZm9ybWVkID0gdGhpcy5fc2NhbGVPYmplY3QoeCwgeSwgJ3gnKSkgJiYgdGhpcy5fZmlyZSgnc2NhbGluZycsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnc2NhbGVZJykge1xuICAgICAgICAoYWN0aW9uUGVyZm9ybWVkID0gdGhpcy5fc2NhbGVPYmplY3QoeCwgeSwgJ3knKSkgJiYgdGhpcy5fZmlyZSgnc2NhbGluZycsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnc2tld1gnKSB7XG4gICAgICAgIChhY3Rpb25QZXJmb3JtZWQgPSB0aGlzLl9za2V3T2JqZWN0KHgsIHksICd4JykpICYmIHRoaXMuX2ZpcmUoJ3NrZXdpbmcnLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ3NrZXdZJykge1xuICAgICAgICAoYWN0aW9uUGVyZm9ybWVkID0gdGhpcy5fc2tld09iamVjdCh4LCB5LCAneScpKSAmJiB0aGlzLl9maXJlKCdza2V3aW5nJywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYWN0aW9uUGVyZm9ybWVkID0gdGhpcy5fdHJhbnNsYXRlT2JqZWN0KHgsIHkpO1xuICAgICAgICBpZiAoYWN0aW9uUGVyZm9ybWVkKSB7XG4gICAgICAgICAgdGhpcy5fZmlyZSgnbW92aW5nJywgb3B0aW9ucyk7XG4gICAgICAgICAgdGhpcy5zZXRDdXJzb3Iob3B0aW9ucy50YXJnZXQubW92ZUN1cnNvciB8fCB0aGlzLm1vdmVDdXJzb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkID0gdHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCB8fCBhY3Rpb25QZXJmb3JtZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgb3B0aW9ucykge1xuICAgICAgdGhpcy5maXJlKCdvYmplY3Q6JyArIGV2ZW50TmFtZSwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLnRhcmdldC5maXJlKGV2ZW50TmFtZSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2JlZm9yZVNjYWxlVHJhbnNmb3JtOiBmdW5jdGlvbihlLCB0cmFuc2Zvcm0pIHtcbiAgICAgIGlmICh0cmFuc2Zvcm0uYWN0aW9uID09PSAnc2NhbGUnIHx8IHRyYW5zZm9ybS5hY3Rpb24gPT09ICdzY2FsZVgnIHx8IHRyYW5zZm9ybS5hY3Rpb24gPT09ICdzY2FsZVknKSB7XG4gICAgICAgIHZhciBjZW50ZXJUcmFuc2Zvcm0gPSB0aGlzLl9zaG91bGRDZW50ZXJUcmFuc2Zvcm0odHJhbnNmb3JtLnRhcmdldCk7XG5cbiAgICAgICAgLy8gU3dpdGNoIGZyb20gYSBub3JtYWwgcmVzaXplIHRvIGNlbnRlci1iYXNlZFxuICAgICAgICBpZiAoKGNlbnRlclRyYW5zZm9ybSAmJiAodHJhbnNmb3JtLm9yaWdpblggIT09ICdjZW50ZXInIHx8IHRyYW5zZm9ybS5vcmlnaW5ZICE9PSAnY2VudGVyJykpIHx8XG4gICAgICAgICAgIC8vIFN3aXRjaCBmcm9tIGNlbnRlci1iYXNlZCByZXNpemUgdG8gbm9ybWFsIG9uZVxuICAgICAgICAgICAoIWNlbnRlclRyYW5zZm9ybSAmJiB0cmFuc2Zvcm0ub3JpZ2luWCA9PT0gJ2NlbnRlcicgJiYgdHJhbnNmb3JtLm9yaWdpblkgPT09ICdjZW50ZXInKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLl9yZXNldEN1cnJlbnRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICB0cmFuc2Zvcm0ucmVzZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGN1cnJlbnQgdHJhbmZvcm1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBtb3VzZSBwb3NpdGlvbiB4IGZyb20gb3JpZ2luXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgbW91c2UgcG9pc3Rpb24geSBmcm9tIG9yaWdpblxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNjYWxpbmcgb2NjdXJyZWRcbiAgICAgKi9cbiAgICBfb25TY2FsZTogZnVuY3Rpb24oZSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgICBpZiAodGhpcy5faXNVbmlzY2FsZVBvc3NpYmxlKGUsIHRyYW5zZm9ybS50YXJnZXQpKSB7XG4gICAgICAgIHRyYW5zZm9ybS5jdXJyZW50QWN0aW9uID0gJ3NjYWxlJztcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlT2JqZWN0KHgsIHkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIFN3aXRjaCBmcm9tIGEgbm9ybWFsIHJlc2l6ZSB0byBwcm9wb3J0aW9uYWxcbiAgICAgICAgaWYgKCF0cmFuc2Zvcm0ucmVzZXQgJiYgdHJhbnNmb3JtLmN1cnJlbnRBY3Rpb24gPT09ICdzY2FsZScpIHtcbiAgICAgICAgICB0aGlzLl9yZXNldEN1cnJlbnRUcmFuc2Zvcm0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zZm9ybS5jdXJyZW50QWN0aW9uID0gJ3NjYWxlRXF1YWxseSc7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2FsZU9iamVjdCh4LCB5LCAnZXF1YWxseScpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXQgY3VycmVudCB0YXJnZXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHVucHJvcG9ydGlvbmFsIHNjYWxpbmcgaXMgcG9zc2libGVcbiAgICAgKi9cbiAgICBfaXNVbmlzY2FsZVBvc3NpYmxlOiBmdW5jdGlvbihlLCB0YXJnZXQpIHtcbiAgICAgIHJldHVybiAoZVt0aGlzLnVuaVNjYWxlS2V5XSB8fCB0aGlzLnVuaVNjYWxlVHJhbnNmb3JtKSAmJiAhdGFyZ2V0LmdldCgnbG9ja1VuaVNjYWxpbmcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3Vyc29yIGRlcGVuZGluZyBvbiB3aGVyZSB0aGUgY2FudmFzIGlzIGJlaW5nIGhvdmVyZWQuXG4gICAgICogTm90ZTogdmVyeSBidWdneSBpbiBPcGVyYVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBPYmplY3QgdGhhdCB0aGUgbW91c2UgaXMgaG92ZXJpbmcsIGlmIHNvLlxuICAgICAqL1xuICAgIF9zZXRDdXJzb3JGcm9tRXZlbnQ6IGZ1bmN0aW9uIChlLCB0YXJnZXQpIHtcbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMuZGVmYXVsdEN1cnNvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhvdmVyQ3Vyc29yID0gdGFyZ2V0LmhvdmVyQ3Vyc29yIHx8IHRoaXMuaG92ZXJDdXJzb3IsXG4gICAgICAgICAgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0ICYmIHRoaXMuX2FjdGl2ZU9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJyA/XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVPYmplY3QgOiBudWxsLFxuICAgICAgICAgIC8vIG9ubHkgc2hvdyBwcm9wZXIgY29ybmVyIHdoZW4gZ3JvdXAgc2VsZWN0aW9uIGlzIG5vdCBhY3RpdmVcbiAgICAgICAgICBjb3JuZXIgPSAoIWFjdGl2ZVNlbGVjdGlvbiB8fCAhYWN0aXZlU2VsZWN0aW9uLmNvbnRhaW5zKHRhcmdldCkpXG4gICAgICAgICAgICAgICAgICAgICYmIHRhcmdldC5fZmluZFRhcmdldENvcm5lcih0aGlzLmdldFBvaW50ZXIoZSwgdHJ1ZSkpO1xuXG4gICAgICBpZiAoIWNvcm5lcikge1xuICAgICAgICB0aGlzLnNldEN1cnNvcihob3ZlckN1cnNvcik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRDdXJzb3IodGhpcy5nZXRDb3JuZXJDdXJzb3IoY29ybmVyLCB0YXJnZXQsIGUpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRDb3JuZXJDdXJzb3I6IGZ1bmN0aW9uKGNvcm5lciwgdGFyZ2V0LCBlKSB7XG4gICAgICBpZiAodGhpcy5hY3Rpb25Jc0Rpc2FibGVkKGNvcm5lciwgdGFyZ2V0LCBlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3RBbGxvd2VkQ3Vyc29yO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY29ybmVyIGluIGN1cnNvck9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Um90YXRlZENvcm5lckN1cnNvcihjb3JuZXIsIHRhcmdldCwgZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb3JuZXIgPT09ICdtdHInICYmIHRhcmdldC5oYXNSb3RhdGluZ1BvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdGF0aW9uQ3Vyc29yO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRDdXJzb3I7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFjdGlvbklzRGlzYWJsZWQ6IGZ1bmN0aW9uKGNvcm5lciwgdGFyZ2V0LCBlKSB7XG4gICAgICBpZiAoY29ybmVyID09PSAnbXQnIHx8IGNvcm5lciA9PT0gJ21iJykge1xuICAgICAgICByZXR1cm4gZVt0aGlzLmFsdEFjdGlvbktleV0gPyB0YXJnZXQubG9ja1NrZXdpbmdYIDogdGFyZ2V0LmxvY2tTY2FsaW5nWTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNvcm5lciA9PT0gJ21sJyB8fCBjb3JuZXIgPT09ICdtcicpIHtcbiAgICAgICAgcmV0dXJuIGVbdGhpcy5hbHRBY3Rpb25LZXldID8gdGFyZ2V0LmxvY2tTa2V3aW5nWSA6IHRhcmdldC5sb2NrU2NhbGluZ1g7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb3JuZXIgPT09ICdtdHInKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQubG9ja1JvdGF0aW9uO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VuaXNjYWxlUG9zc2libGUoZSwgdGFyZ2V0KSA/XG4gICAgICAgICAgdGFyZ2V0LmxvY2tTY2FsaW5nWCAmJiB0YXJnZXQubG9ja1NjYWxpbmdZIDogdGFyZ2V0LmxvY2tTY2FsaW5nWCB8fCB0YXJnZXQubG9ja1NjYWxpbmdZO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRSb3RhdGVkQ29ybmVyQ3Vyc29yOiBmdW5jdGlvbihjb3JuZXIsIHRhcmdldCwgZSkge1xuICAgICAgdmFyIG4gPSBNYXRoLnJvdW5kKCh0YXJnZXQuYW5nbGUgJSAzNjApIC8gNDUpO1xuXG4gICAgICBpZiAobiA8IDApIHtcbiAgICAgICAgbiArPSA4OyAvLyBmdWxsIGNpcmNsZSBhaGVhZFxuICAgICAgfVxuICAgICAgbiArPSBjdXJzb3JPZmZzZXRbY29ybmVyXTtcbiAgICAgIGlmIChlW3RoaXMuYWx0QWN0aW9uS2V5XSAmJiBjdXJzb3JPZmZzZXRbY29ybmVyXSAlIDIgPT09IDApIHtcbiAgICAgICAgLy9pZiB3ZSBhcmUgaG9sZGluZyBzaGlmdCBhbmQgd2UgYXJlIG9uIGEgbXggY29ybmVyLi4uXG4gICAgICAgIG4gKz0gMjtcbiAgICAgIH1cbiAgICAgIC8vIG5vcm1hbGl6ZSBuIHRvIGJlIGZyb20gMCB0byA3XG4gICAgICBuICU9IDg7XG5cbiAgICAgIHJldHVybiB0aGlzLmN1cnNvck1hcFtuXTtcbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIG1pbiA9IE1hdGgubWluLFxuICAgICAgbWF4ID0gTWF0aC5tYXg7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuQ2FudmFzLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIF9zaG91bGRHcm91cDogZnVuY3Rpb24oZSwgdGFyZ2V0KSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuXG4gICAgICByZXR1cm4gYWN0aXZlT2JqZWN0ICYmIHRoaXMuX2lzU2VsZWN0aW9uS2V5UHJlc3NlZChlKSAmJiB0YXJnZXQgJiYgdGFyZ2V0LnNlbGVjdGFibGUgJiYgdGhpcy5zZWxlY3Rpb24gJiZcbiAgICAgICAgICAgIChhY3RpdmVPYmplY3QgIT09IHRhcmdldCB8fCBhY3RpdmVPYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfaGFuZGxlR3JvdXBpbmc6IGZ1bmN0aW9uIChlLCB0YXJnZXQpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICBpZiAoYWN0aXZlT2JqZWN0Ll9fY29ybmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXQgPT09IGFjdGl2ZU9iamVjdCkge1xuICAgICAgICAvLyBpZiBpdCdzIGEgZ3JvdXAsIGZpbmQgdGFyZ2V0IGFnYWluLCB1c2luZyBhY3RpdmVHcm91cCBvYmplY3RzXG4gICAgICAgIHRhcmdldCA9IHRoaXMuZmluZFRhcmdldChlLCB0cnVlKTtcbiAgICAgICAgLy8gaWYgZXZlbiBvYmplY3QgaXMgbm90IGZvdW5kIG9yIHdlIGFyZSBvbiBhY3RpdmVPYmplY3RDb3JuZXIsIGJhaWwgb3V0XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlT2JqZWN0ICYmIGFjdGl2ZU9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgICB0aGlzLl91cGRhdGVBY3RpdmVTZWxlY3Rpb24odGFyZ2V0LCBlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9jcmVhdGVBY3RpdmVTZWxlY3Rpb24odGFyZ2V0LCBlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlQWN0aXZlU2VsZWN0aW9uOiBmdW5jdGlvbih0YXJnZXQsIGUpIHtcbiAgICAgIHZhciBhY3RpdmVTZWxlY3Rpb24gPSB0aGlzLl9hY3RpdmVPYmplY3QsXG4gICAgICAgICAgY3VycmVudEFjdGl2ZU9iamVjdHMgPSBhY3RpdmVTZWxlY3Rpb24uX29iamVjdHMuc2xpY2UoMCk7XG4gICAgICBpZiAoYWN0aXZlU2VsZWN0aW9uLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgYWN0aXZlU2VsZWN0aW9uLnJlbW92ZVdpdGhVcGRhdGUodGFyZ2V0KTtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgaWYgKGFjdGl2ZVNlbGVjdGlvbi5zaXplKCkgPT09IDEpIHtcbiAgICAgICAgICAvLyBhY3RpdmF0ZSBsYXN0IHJlbWFpbmluZyBvYmplY3RcbiAgICAgICAgICB0aGlzLl9zZXRBY3RpdmVPYmplY3QoYWN0aXZlU2VsZWN0aW9uLml0ZW0oMCksIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYWN0aXZlU2VsZWN0aW9uLmFkZFdpdGhVcGRhdGUodGFyZ2V0KTtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IGFjdGl2ZVNlbGVjdGlvbjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25FdmVudHMoY3VycmVudEFjdGl2ZU9iamVjdHMsIGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVBY3RpdmVTZWxlY3Rpb246IGZ1bmN0aW9uKHRhcmdldCwgZSkge1xuICAgICAgdmFyIGN1cnJlbnRBY3RpdmVzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCksIGdyb3VwID0gdGhpcy5fY3JlYXRlR3JvdXAodGFyZ2V0KTtcbiAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSBncm91cDtcbiAgICAgIHRoaXMuX3NldEFjdGl2ZU9iamVjdChncm91cCwgZSk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uRXZlbnRzKGN1cnJlbnRBY3RpdmVzLCBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgX2NyZWF0ZUdyb3VwOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5nZXRPYmplY3RzKCksXG4gICAgICAgICAgaXNBY3RpdmVMb3dlciA9IG9iamVjdHMuaW5kZXhPZih0aGlzLl9hY3RpdmVPYmplY3QpIDwgb2JqZWN0cy5pbmRleE9mKHRhcmdldCksXG4gICAgICAgICAgZ3JvdXBPYmplY3RzID0gaXNBY3RpdmVMb3dlclxuICAgICAgICAgICAgPyBbdGhpcy5fYWN0aXZlT2JqZWN0LCB0YXJnZXRdXG4gICAgICAgICAgICA6IFt0YXJnZXQsIHRoaXMuX2FjdGl2ZU9iamVjdF07XG4gICAgICB0aGlzLl9hY3RpdmVPYmplY3QuaXNFZGl0aW5nICYmIHRoaXMuX2FjdGl2ZU9iamVjdC5leGl0RWRpdGluZygpO1xuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uKGdyb3VwT2JqZWN0cywge1xuICAgICAgICBjYW52YXM6IHRoaXNcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKi9cbiAgICBfZ3JvdXBTZWxlY3RlZE9iamVjdHM6IGZ1bmN0aW9uIChlKSB7XG5cbiAgICAgIHZhciBncm91cCA9IHRoaXMuX2NvbGxlY3RPYmplY3RzKCksXG4gICAgICAgICAgYUdyb3VwO1xuXG4gICAgICAvLyBkbyBub3QgY3JlYXRlIGdyb3VwIGZvciAxIGVsZW1lbnQgb25seVxuICAgICAgaWYgKGdyb3VwLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLnNldEFjdGl2ZU9iamVjdChncm91cFswXSwgZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChncm91cC5sZW5ndGggPiAxKSB7XG4gICAgICAgIGFHcm91cCA9IG5ldyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uKGdyb3VwLnJldmVyc2UoKSwge1xuICAgICAgICAgIGNhbnZhczogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRBY3RpdmVPYmplY3QoYUdyb3VwLCBlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY29sbGVjdE9iamVjdHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGdyb3VwID0gW10sXG4gICAgICAgICAgY3VycmVudE9iamVjdCxcbiAgICAgICAgICB4MSA9IHRoaXMuX2dyb3VwU2VsZWN0b3IuZXgsXG4gICAgICAgICAgeTEgPSB0aGlzLl9ncm91cFNlbGVjdG9yLmV5LFxuICAgICAgICAgIHgyID0geDEgKyB0aGlzLl9ncm91cFNlbGVjdG9yLmxlZnQsXG4gICAgICAgICAgeTIgPSB5MSArIHRoaXMuX2dyb3VwU2VsZWN0b3IudG9wLFxuICAgICAgICAgIHNlbGVjdGlvblgxWTEgPSBuZXcgZmFicmljLlBvaW50KG1pbih4MSwgeDIpLCBtaW4oeTEsIHkyKSksXG4gICAgICAgICAgc2VsZWN0aW9uWDJZMiA9IG5ldyBmYWJyaWMuUG9pbnQobWF4KHgxLCB4MiksIG1heCh5MSwgeTIpKSxcbiAgICAgICAgICBhbGxvd0ludGVyc2VjdCA9ICF0aGlzLnNlbGVjdGlvbkZ1bGx5Q29udGFpbmVkLFxuICAgICAgICAgIGlzQ2xpY2sgPSB4MSA9PT0geDIgJiYgeTEgPT09IHkyO1xuICAgICAgLy8gd2UgaXRlcmF0ZSByZXZlcnNlIG9yZGVyIHRvIGNvbGxlY3QgdG9wIGZpcnN0IGluIGNhc2Ugb2YgY2xpY2suXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgIGN1cnJlbnRPYmplY3QgPSB0aGlzLl9vYmplY3RzW2ldO1xuXG4gICAgICAgIGlmICghY3VycmVudE9iamVjdCB8fCAhY3VycmVudE9iamVjdC5zZWxlY3RhYmxlIHx8ICFjdXJyZW50T2JqZWN0LnZpc2libGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoYWxsb3dJbnRlcnNlY3QgJiYgY3VycmVudE9iamVjdC5pbnRlcnNlY3RzV2l0aFJlY3Qoc2VsZWN0aW9uWDFZMSwgc2VsZWN0aW9uWDJZMikpIHx8XG4gICAgICAgICAgICBjdXJyZW50T2JqZWN0LmlzQ29udGFpbmVkV2l0aGluUmVjdChzZWxlY3Rpb25YMVkxLCBzZWxlY3Rpb25YMlkyKSB8fFxuICAgICAgICAgICAgKGFsbG93SW50ZXJzZWN0ICYmIGN1cnJlbnRPYmplY3QuY29udGFpbnNQb2ludChzZWxlY3Rpb25YMVkxKSkgfHxcbiAgICAgICAgICAgIChhbGxvd0ludGVyc2VjdCAmJiBjdXJyZW50T2JqZWN0LmNvbnRhaW5zUG9pbnQoc2VsZWN0aW9uWDJZMikpXG4gICAgICAgICkge1xuICAgICAgICAgIGdyb3VwLnB1c2goY3VycmVudE9iamVjdCk7XG5cbiAgICAgICAgICAvLyBvbmx5IGFkZCBvbmUgb2JqZWN0IGlmIGl0J3MgYSBjbGlja1xuICAgICAgICAgIGlmIChpc0NsaWNrKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYXliZUdyb3VwT2JqZWN0czogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uICYmIHRoaXMuX2dyb3VwU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5fZ3JvdXBTZWxlY3RlZE9iamVjdHMoZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEN1cnNvcih0aGlzLmRlZmF1bHRDdXJzb3IpO1xuICAgICAgLy8gY2xlYXIgc2VsZWN0aW9uIGFuZCBjdXJyZW50IHRyYW5zZm9ybWF0aW9uXG4gICAgICB0aGlzLl9ncm91cFNlbGVjdG9yID0gbnVsbDtcbiAgICB9XG4gIH0pO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHN1cHBvcnRRdWFsaXR5ID0gZmFicmljLlN0YXRpY0NhbnZhcy5zdXBwb3J0cygndG9EYXRhVVJMV2l0aFF1YWxpdHknKTtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgY2FudmFzIGVsZW1lbnQgdG8gYSBkYXRhdXJsIGltYWdlLiBOb3RlIHRoYXQgd2hlbiBtdWx0aXBsaWVyIGlzIHVzZWQsIGNyb3BwaW5nIGlzIHNjYWxlZCBhcHByb3ByaWF0ZWx5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5mb3JtYXQ9cG5nXSBUaGUgZm9ybWF0IG9mIHRoZSBvdXRwdXQgaW1hZ2UuIEVpdGhlciBcImpwZWdcIiBvciBcInBuZ1wiXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnF1YWxpdHk9MV0gUXVhbGl0eSBsZXZlbCAoMC4uMSkuIE9ubHkgdXNlZCBmb3IganBlZy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubXVsdGlwbGllcj0xXSBNdWx0aXBsaWVyIHRvIHNjYWxlIGJ5LCB0byBoYXZlIGNvbnNpc3RlbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGVmdF0gQ3JvcHBpbmcgbGVmdCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50b3BdIENyb3BwaW5nIHRvcCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gQ3JvcHBpbmcgd2lkdGguIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHRdIENyb3BwaW5nIGhlaWdodC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5lbmFibGVSZXRpbmFTY2FsaW5nXSBFbmFibGUgcmV0aW5hIHNjYWxpbmcgZm9yIGNsb25lIGltYWdlLiBJbnRyb2R1Y2UgaW4gMi4wLjBcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFJldHVybnMgYSBkYXRhOiBVUkwgY29udGFpbmluZyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QgaW4gdGhlIGZvcm1hdCBzcGVjaWZpZWQgYnkgb3B0aW9ucy5mb3JtYXRcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL05mWlZiL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkdlbmVyYXRlIGpwZWcgZGF0YVVSTCB3aXRoIGxvd2VyIHF1YWxpdHk8L2NhcHRpb24+XG4gICAgICogdmFyIGRhdGFVUkwgPSBjYW52YXMudG9EYXRhVVJMKHtcbiAgICAgKiAgIGZvcm1hdDogJ2pwZWcnLFxuICAgICAqICAgcXVhbGl0eTogMC44XG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+R2VuZXJhdGUgY3JvcHBlZCBwbmcgZGF0YVVSTCAoY2xpcHBpbmcgb2YgY2FudmFzKTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgZGF0YVVSTCA9IGNhbnZhcy50b0RhdGFVUkwoe1xuICAgICAqICAgZm9ybWF0OiAncG5nJyxcbiAgICAgKiAgIGxlZnQ6IDEwMCxcbiAgICAgKiAgIHRvcDogMTAwLFxuICAgICAqICAgd2lkdGg6IDIwMCxcbiAgICAgKiAgIGhlaWdodDogMjAwXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+R2VuZXJhdGUgZG91YmxlIHNjYWxlZCBwbmcgZGF0YVVSTDwvY2FwdGlvbj5cbiAgICAgKiB2YXIgZGF0YVVSTCA9IGNhbnZhcy50b0RhdGFVUkwoe1xuICAgICAqICAgZm9ybWF0OiAncG5nJyxcbiAgICAgKiAgIG11bHRpcGxpZXI6IDJcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICB0b0RhdGFVUkw6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdmFyIGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8ICdwbmcnLFxuICAgICAgICAgIHF1YWxpdHkgPSBvcHRpb25zLnF1YWxpdHkgfHwgMSxcbiAgICAgICAgICBtdWx0aXBsaWVyID0gKG9wdGlvbnMubXVsdGlwbGllciB8fCAxKSAqIChvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmcgPyAxIDogMSAvIHRoaXMuZ2V0UmV0aW5hU2NhbGluZygpKSxcbiAgICAgICAgICBjcm9wcGluZyA9IHtcbiAgICAgICAgICAgIGxlZnQ6IG9wdGlvbnMubGVmdCB8fCAwLFxuICAgICAgICAgICAgdG9wOiBvcHRpb25zLnRvcCB8fCAwLFxuICAgICAgICAgICAgd2lkdGg6IG9wdGlvbnMud2lkdGggfHwgMCxcbiAgICAgICAgICAgIGhlaWdodDogb3B0aW9ucy5oZWlnaHQgfHwgMCxcbiAgICAgICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMuX190b0RhdGFVUkxXaXRoTXVsdGlwbGllcihmb3JtYXQsIHF1YWxpdHksIGNyb3BwaW5nLCBtdWx0aXBsaWVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfX3RvRGF0YVVSTFdpdGhNdWx0aXBsaWVyOiBmdW5jdGlvbihmb3JtYXQsIHF1YWxpdHksIGNyb3BwaW5nLCBtdWx0aXBsaWVyKSB7XG5cbiAgICAgIHZhciBvcmlnV2lkdGggPSB0aGlzLndpZHRoLFxuICAgICAgICAgIG9yaWdIZWlnaHQgPSB0aGlzLmhlaWdodCxcbiAgICAgICAgICBzY2FsZWRXaWR0aCA9IChjcm9wcGluZy53aWR0aCB8fCB0aGlzLndpZHRoKSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgc2NhbGVkSGVpZ2h0ID0gKGNyb3BwaW5nLmhlaWdodCB8fCB0aGlzLmhlaWdodCkgKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIHpvb20gPSB0aGlzLmdldFpvb20oKSxcbiAgICAgICAgICBuZXdab29tID0gem9vbSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgdnAgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLFxuICAgICAgICAgIHRyYW5zbGF0ZVggPSAodnBbNF0gLSBjcm9wcGluZy5sZWZ0KSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgdHJhbnNsYXRlWSA9ICh2cFs1XSAtIGNyb3BwaW5nLnRvcCkgKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIG5ld1ZwID0gW25ld1pvb20sIDAsIDAsIG5ld1pvb20sIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVldLFxuICAgICAgICAgIG9yaWdpbmFsSW50ZXJhY3RpdmUgPSB0aGlzLmludGVyYWN0aXZlLFxuICAgICAgICAgIG9yaWdpbmFsU2tpcE9mZlNjcmVlbiA9IHRoaXMuc2tpcE9mZnNjcmVlbixcbiAgICAgICAgICBuZWVkc1Jlc2l6ZSA9IG9yaWdXaWR0aCAhPT0gc2NhbGVkV2lkdGggfHwgb3JpZ0hlaWdodCAhPT0gc2NhbGVkSGVpZ2h0O1xuXG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gbmV3VnA7XG4gICAgICB0aGlzLnNraXBPZmZzY3JlZW4gPSBmYWxzZTtcbiAgICAgIC8vIHNldHRpbmcgaW50ZXJhY3RpdmUgdG8gZmFsc2UgYXZvaWQgZXhwb3J0aW5nIGNvbnRyb2xzXG4gICAgICB0aGlzLmludGVyYWN0aXZlID0gZmFsc2U7XG4gICAgICBpZiAobmVlZHNSZXNpemUpIHtcbiAgICAgICAgdGhpcy5zZXREaW1lbnNpb25zKHsgd2lkdGg6IHNjYWxlZFdpZHRoLCBoZWlnaHQ6IHNjYWxlZEhlaWdodCB9LCB7IGJhY2tzdG9yZU9ubHk6IHRydWUgfSk7XG4gICAgICB9XG4gICAgICAvLyBjYWxsIGEgcmVuZGVyQWxsIHRvIGZvcmNlIHN5bmMgdXBkYXRlLiBUaGlzIHdpbGwgY2FuY2VsIHRoZSBzY2hlZHVsZWQgcmVxdWVzdFJlbmRlckFsbFxuICAgICAgLy8gZnJvbSBzZXREaW1lbnNpb25zXG4gICAgICB0aGlzLnJlbmRlckFsbCgpO1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fdG9EYXRhVVJMKGZvcm1hdCwgcXVhbGl0eSwgY3JvcHBpbmcpO1xuICAgICAgdGhpcy5pbnRlcmFjdGl2ZSA9IG9yaWdpbmFsSW50ZXJhY3RpdmU7XG4gICAgICB0aGlzLnNraXBPZmZzY3JlZW4gPSBvcmlnaW5hbFNraXBPZmZTY3JlZW47XG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gdnA7XG4gICAgICAvL3NldERpbWVuc2lvbnMgd2l0aCBubyBvcHRpb24gb2JqZWN0IGlzIHRha2luZyBjYXJlIG9mOlxuICAgICAgLy90aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKClcbiAgICAgIGlmIChuZWVkc1Jlc2l6ZSkge1xuICAgICAgICB0aGlzLnNldERpbWVuc2lvbnMoeyB3aWR0aDogb3JpZ1dpZHRoLCBoZWlnaHQ6IG9yaWdIZWlnaHQgfSwgeyBiYWNrc3RvcmVPbmx5OiB0cnVlIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9fdG9EYXRhVVJMOiBmdW5jdGlvbihmb3JtYXQsIHF1YWxpdHkpIHtcblxuICAgICAgdmFyIGNhbnZhc0VsID0gdGhpcy5jb250ZXh0Q29udGFpbmVyLmNhbnZhcztcbiAgICAgIC8vIHRvIGF2b2lkIGNvbW1vbiBjb25mdXNpb24gaHR0cHM6Ly9naXRodWIuY29tL2thbmdheC9mYWJyaWMuanMvaXNzdWVzLzgwNlxuICAgICAgaWYgKGZvcm1hdCA9PT0gJ2pwZycpIHtcbiAgICAgICAgZm9ybWF0ID0gJ2pwZWcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF0YSA9IHN1cHBvcnRRdWFsaXR5XG4gICAgICAgID8gY2FudmFzRWwudG9EYXRhVVJMKCdpbWFnZS8nICsgZm9ybWF0LCBxdWFsaXR5KVxuICAgICAgICA6IGNhbnZhc0VsLnRvRGF0YVVSTCgnaW1hZ2UvJyArIGZvcm1hdCk7XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG4gIH0pO1xuXG59KSgpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBQb3B1bGF0ZXMgY2FudmFzIHdpdGggZGF0YSBmcm9tIHRoZSBzcGVjaWZpZWQgZGF0YWxlc3MgSlNPTi5cbiAgICogSlNPTiBmb3JtYXQgbXVzdCBjb25mb3JtIHRvIHRoZSBvbmUgb2Yge0BsaW5rIGZhYnJpYy5DYW52YXMjdG9EYXRhbGVzc0pTT059XG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDEuMi4yXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ganNvbiBKU09OIHN0cmluZyBvciBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2ssIGludm9rZWQgd2hlbiBqc29uIGlzIHBhcnNlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgY29ycmVzcG9uZGluZyBvYmplY3RzIChlLmc6IHtAbGluayBmYWJyaWMuSW1hZ2V9KVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgaW5pdGlhbGl6ZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIEpTT04gZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICogQGNoYWluYWJsZVxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNkZXNlcmlhbGl6YXRpb259XG4gICAqL1xuICBsb2FkRnJvbURhdGFsZXNzSlNPTjogZnVuY3Rpb24gKGpzb24sIGNhbGxiYWNrLCByZXZpdmVyKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZEZyb21KU09OKGpzb24sIGNhbGxiYWNrLCByZXZpdmVyKTtcbiAgfSxcblxuICAvKipcbiAgICogUG9wdWxhdGVzIGNhbnZhcyB3aXRoIGRhdGEgZnJvbSB0aGUgc3BlY2lmaWVkIEpTT04uXG4gICAqIEpTT04gZm9ybWF0IG11c3QgY29uZm9ybSB0byB0aGUgb25lIG9mIHtAbGluayBmYWJyaWMuQ2FudmFzI3RvSlNPTn1cbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBqc29uIEpTT04gc3RyaW5nIG9yIG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjaywgaW52b2tlZCB3aGVuIGpzb24gaXMgcGFyc2VkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBjb3JyZXNwb25kaW5nIG9iamVjdHMgKGUuZzoge0BsaW5rIGZhYnJpYy5JbWFnZX0pXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBpbml0aWFsaXplZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgSlNPTiBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgKiBAY2hhaW5hYmxlXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0zI2Rlc2VyaWFsaXphdGlvbn1cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9mbWdYdC98anNGaWRkbGUgZGVtb31cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+bG9hZEZyb21KU09OPC9jYXB0aW9uPlxuICAgKiBjYW52YXMubG9hZEZyb21KU09OKGpzb24sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+bG9hZEZyb21KU09OIHdpdGggcmV2aXZlcjwvY2FwdGlvbj5cbiAgICogY2FudmFzLmxvYWRGcm9tSlNPTihqc29uLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwgZnVuY3Rpb24obywgb2JqZWN0KSB7XG4gICAqICAgLy8gYG9gID0ganNvbiBvYmplY3RcbiAgICogICAvLyBgb2JqZWN0YCA9IGZhYnJpYy5PYmplY3QgaW5zdGFuY2VcbiAgICogICAvLyAuLi4gZG8gc29tZSBzdHVmZiAuLi5cbiAgICogfSk7XG4gICAqL1xuICBsb2FkRnJvbUpTT046IGZ1bmN0aW9uIChqc29uLCBjYWxsYmFjaywgcmV2aXZlcikge1xuICAgIGlmICghanNvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNlcmlhbGl6ZSBpZiBpdCB3YXNuJ3QgYWxyZWFkeVxuICAgIHZhciBzZXJpYWxpemVkID0gKHR5cGVvZiBqc29uID09PSAnc3RyaW5nJylcbiAgICAgID8gSlNPTi5wYXJzZShqc29uKVxuICAgICAgOiBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUoanNvbik7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICByZW5kZXJPbkFkZFJlbW92ZSA9IHRoaXMucmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5fZW5saXZlbk9iamVjdHMoc2VyaWFsaXplZC5vYmplY3RzLCBmdW5jdGlvbiAoZW5saXZlbmVkT2JqZWN0cykge1xuICAgICAgX3RoaXMuY2xlYXIoKTtcbiAgICAgIF90aGlzLl9zZXRCZ092ZXJsYXkoc2VyaWFsaXplZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbmxpdmVuZWRPYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqLCBpbmRleCkge1xuICAgICAgICAgIC8vIHdlIHNwbGljZSB0aGUgYXJyYXkganVzdCBpbiBjYXNlIHNvbWUgY3VzdG9tIGNsYXNzZXMgcmVzdG9yZWQgZnJvbSBKU09OXG4gICAgICAgICAgLy8gd2lsbCBhZGQgbW9yZSBvYmplY3QgdG8gY2FudmFzIGF0IGNhbnZhcyBpbml0LlxuICAgICAgICAgIF90aGlzLmluc2VydEF0KG9iaiwgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMucmVuZGVyT25BZGRSZW1vdmUgPSByZW5kZXJPbkFkZFJlbW92ZTtcbiAgICAgICAgLy8gcmVtb3ZlIHBhcnRzIGkgY2Fubm90IHNldCBhcyBvcHRpb25zXG4gICAgICAgIGRlbGV0ZSBzZXJpYWxpemVkLm9iamVjdHM7XG4gICAgICAgIGRlbGV0ZSBzZXJpYWxpemVkLmJhY2tncm91bmRJbWFnZTtcbiAgICAgICAgZGVsZXRlIHNlcmlhbGl6ZWQub3ZlcmxheUltYWdlO1xuICAgICAgICBkZWxldGUgc2VyaWFsaXplZC5iYWNrZ3JvdW5kO1xuICAgICAgICBkZWxldGUgc2VyaWFsaXplZC5vdmVybGF5O1xuICAgICAgICAvLyB0aGlzLl9pbml0T3B0aW9ucyBkb2VzIHRvbyBtYW55IHRoaW5ncyB0byBqdXN0XG4gICAgICAgIC8vIGNhbGwgaXQuIE5vcm1hbGx5IGxvYWRpbmcgYW4gT2JqZWN0IGZyb20gSlNPTlxuICAgICAgICAvLyBjcmVhdGUgdGhlIE9iamVjdCBpbnN0YW5jZS4gSGVyZSB0aGUgQ2FudmFzIGlzXG4gICAgICAgIC8vIGFscmVhZHkgYW4gaW5zdGFuY2UgYW5kIHdlIGFyZSBqdXN0IGxvYWRpbmcgdGhpbmdzIG92ZXIgaXRcbiAgICAgICAgX3RoaXMuX3NldE9wdGlvbnMoc2VyaWFsaXplZCk7XG4gICAgICAgIF90aGlzLnJlbmRlckFsbCgpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfSwgcmV2aXZlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXJpYWxpemVkIE9iamVjdCB3aXRoIGJhY2tncm91bmQgYW5kIG92ZXJsYXkgaW5mb3JtYXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgSW52b2tlZCBhZnRlciBhbGwgYmFja2dyb3VuZCBhbmQgb3ZlcmxheSBpbWFnZXMvcGF0dGVybnMgbG9hZGVkXG4gICAqL1xuICBfc2V0QmdPdmVybGF5OiBmdW5jdGlvbihzZXJpYWxpemVkLCBjYWxsYmFjaykge1xuICAgIHZhciBsb2FkZWQgPSB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGZhbHNlLFxuICAgICAgb3ZlcmxheUNvbG9yOiBmYWxzZSxcbiAgICAgIGJhY2tncm91bmRJbWFnZTogZmFsc2UsXG4gICAgICBvdmVybGF5SW1hZ2U6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmICghc2VyaWFsaXplZC5iYWNrZ3JvdW5kSW1hZ2UgJiYgIXNlcmlhbGl6ZWQub3ZlcmxheUltYWdlICYmICFzZXJpYWxpemVkLmJhY2tncm91bmQgJiYgIXNlcmlhbGl6ZWQub3ZlcmxheSkge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2JJZkxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChsb2FkZWQuYmFja2dyb3VuZEltYWdlICYmIGxvYWRlZC5vdmVybGF5SW1hZ2UgJiYgbG9hZGVkLmJhY2tncm91bmRDb2xvciAmJiBsb2FkZWQub3ZlcmxheUNvbG9yKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuX19zZXRCZ092ZXJsYXkoJ2JhY2tncm91bmRJbWFnZScsIHNlcmlhbGl6ZWQuYmFja2dyb3VuZEltYWdlLCBsb2FkZWQsIGNiSWZMb2FkZWQpO1xuICAgIHRoaXMuX19zZXRCZ092ZXJsYXkoJ292ZXJsYXlJbWFnZScsIHNlcmlhbGl6ZWQub3ZlcmxheUltYWdlLCBsb2FkZWQsIGNiSWZMb2FkZWQpO1xuICAgIHRoaXMuX19zZXRCZ092ZXJsYXkoJ2JhY2tncm91bmRDb2xvcicsIHNlcmlhbGl6ZWQuYmFja2dyb3VuZCwgbG9hZGVkLCBjYklmTG9hZGVkKTtcbiAgICB0aGlzLl9fc2V0QmdPdmVybGF5KCdvdmVybGF5Q29sb3InLCBzZXJpYWxpemVkLm92ZXJsYXksIGxvYWRlZCwgY2JJZkxvYWRlZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBzZXQgKGJhY2tncm91bmRJbWFnZSwgb3ZlcmxheUltYWdlLCBiYWNrZ3JvdW5kQ29sb3IsIG92ZXJsYXlDb2xvcilcbiAgICogQHBhcmFtIHsoT2JqZWN0fFN0cmluZyl9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgKiBAcGFyYW0ge09iamVjdH0gbG9hZGVkIFNldCBsb2FkZWQgcHJvcGVydHkgdG8gdHJ1ZSBpZiBwcm9wZXJ0eSBpcyBzZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZSBhZnRlciBwcm9wZXJ0eSBpcyBzZXRcbiAgICovXG4gIF9fc2V0QmdPdmVybGF5OiBmdW5jdGlvbihwcm9wZXJ0eSwgdmFsdWUsIGxvYWRlZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgbG9hZGVkW3Byb3BlcnR5XSA9IHRydWU7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2JhY2tncm91bmRJbWFnZScgfHwgcHJvcGVydHkgPT09ICdvdmVybGF5SW1hZ2UnKSB7XG4gICAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhbdmFsdWVdLCBmdW5jdGlvbihlbmxpdmVkT2JqZWN0KXtcbiAgICAgICAgX3RoaXNbcHJvcGVydHldID0gZW5saXZlZE9iamVjdFswXTtcbiAgICAgICAgbG9hZGVkW3Byb3BlcnR5XSA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzWydzZXQnICsgZmFicmljLnV0aWwuc3RyaW5nLmNhcGl0YWxpemUocHJvcGVydHksIHRydWUpXSh2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGxvYWRlZFtwcm9wZXJ0eV0gPSB0cnVlO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXVxuICAgKi9cbiAgX2VubGl2ZW5PYmplY3RzOiBmdW5jdGlvbiAob2JqZWN0cywgY2FsbGJhY2ssIHJldml2ZXIpIHtcbiAgICBpZiAoIW9iamVjdHMgfHwgb2JqZWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKFtdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhvYmplY3RzLCBmdW5jdGlvbihlbmxpdmVuZWRPYmplY3RzKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzKTtcbiAgICB9LCBudWxsLCByZXZpdmVyKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgX3RvRGF0YVVSTDogZnVuY3Rpb24gKGZvcm1hdCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmNsb25lKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgY2FsbGJhY2soY2xvbmUudG9EYXRhVVJMKGZvcm1hdCkpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtdWx0aXBsaWVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBfdG9EYXRhVVJMV2l0aE11bHRpcGxpZXI6IGZ1bmN0aW9uIChmb3JtYXQsIG11bHRpcGxpZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jbG9uZShmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgIGNhbGxiYWNrKGNsb25lLnRvRGF0YVVSTFdpdGhNdWx0aXBsaWVyKGZvcm1hdCwgbXVsdGlwbGllcikpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZXMgY2FudmFzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tdIFJlY2VpdmVzIGNsb25lZCBpbnN0YW5jZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzXSBBcnJheSBvZiBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgaW4gdGhlIGNsb25lZCBjYW52YXMgYW5kIGNoaWxkcmVuXG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24gKGNhbGxiYWNrLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIGRhdGEgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTihwcm9wZXJ0aWVzKSk7XG4gICAgdGhpcy5jbG9uZVdpdGhvdXREYXRhKGZ1bmN0aW9uKGNsb25lKSB7XG4gICAgICBjbG9uZS5sb2FkRnJvbUpTT04oZGF0YSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNsb25lKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZXMgY2FudmFzIGluc3RhbmNlIHdpdGhvdXQgY2xvbmluZyBleGlzdGluZyBkYXRhLlxuICAgKiBUaGlzIGVzc2VudGlhbGx5IGNvcGllcyBjYW52YXMgZGltZW5zaW9ucywgY2xpcHBpbmcgcHJvcGVydGllcywgZXRjLlxuICAgKiBidXQgbGVhdmVzIGRhdGEgZW1wdHkgKHNvIHRoYXQgeW91IGNhbiBwb3B1bGF0ZSBpdCB3aXRoIHlvdXIgb3duKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrXSBSZWNlaXZlcyBjbG9uZWQgaW5zdGFuY2UgYXMgYSBmaXJzdCBhcmd1bWVudFxuICAgKi9cbiAgY2xvbmVXaXRob3V0RGF0YTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgZWwgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICBlbC53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgZWwuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICB2YXIgY2xvbmUgPSBuZXcgZmFicmljLkNhbnZhcyhlbCk7XG4gICAgY2xvbmUuY2xpcFRvID0gdGhpcy5jbGlwVG87XG4gICAgaWYgKHRoaXMuYmFja2dyb3VuZEltYWdlKSB7XG4gICAgICBjbG9uZS5zZXRCYWNrZ3JvdW5kSW1hZ2UodGhpcy5iYWNrZ3JvdW5kSW1hZ2Uuc3JjLCBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xvbmUucmVuZGVyQWxsKCk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNsb25lKTtcbiAgICAgIH0pO1xuICAgICAgY2xvbmUuYmFja2dyb3VuZEltYWdlT3BhY2l0eSA9IHRoaXMuYmFja2dyb3VuZEltYWdlT3BhY2l0eTtcbiAgICAgIGNsb25lLmJhY2tncm91bmRJbWFnZVN0cmV0Y2ggPSB0aGlzLmJhY2tncm91bmRJbWFnZVN0cmV0Y2g7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soY2xvbmUpO1xuICAgIH1cbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUsXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgIGNhcGl0YWxpemUgPSBmYWJyaWMudXRpbC5zdHJpbmcuY2FwaXRhbGl6ZSxcbiAgICAgIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zLFxuICAgICAgc3VwcG9ydHNMaW5lRGFzaCA9IGZhYnJpYy5TdGF0aWNDYW52YXMuc3VwcG9ydHMoJ3NldExpbmVEYXNoJyksXG4gICAgICBvYmplY3RDYWNoaW5nID0gIWZhYnJpYy5pc0xpa2VseU5vZGUsXG4gICAgICBBTElBU0lOR19MSU1JVCA9IDI7XG5cbiAgaWYgKGZhYnJpYy5PYmplY3QpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUm9vdCBvYmplY3QgY2xhc3MgZnJvbSB3aGljaCBhbGwgMmQgc2hhcGUgY2xhc3NlcyBpbmhlcml0IGZyb21cbiAgICogQGNsYXNzIGZhYnJpYy5PYmplY3RcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTEjb2JqZWN0c31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLk9iamVjdCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKlxuICAgKiBAZmlyZXMgYWRkZWRcbiAgICogQGZpcmVzIHJlbW92ZWRcbiAgICpcbiAgICogQGZpcmVzIHNlbGVjdGVkXG4gICAqIEBmaXJlcyBkZXNlbGVjdGVkXG4gICAqIEBmaXJlcyBtb2RpZmllZFxuICAgKiBAZmlyZXMgbW9kaWZpZWRcbiAgICogQGZpcmVzIG1vdmVkXG4gICAqIEBmaXJlcyBzY2FsZWRcbiAgICogQGZpcmVzIHJvdGF0ZWRcbiAgICogQGZpcmVzIHNrZXdlZFxuICAgKlxuICAgKiBAZmlyZXMgcm90YXRpbmdcbiAgICogQGZpcmVzIHNjYWxpbmdcbiAgICogQGZpcmVzIG1vdmluZ1xuICAgKiBAZmlyZXMgc2tld2luZ1xuICAgKlxuICAgKiBAZmlyZXMgbW91c2Vkb3duXG4gICAqIEBmaXJlcyBtb3VzZXVwXG4gICAqIEBmaXJlcyBtb3VzZW92ZXJcbiAgICogQGZpcmVzIG1vdXNlb3V0XG4gICAqIEBmaXJlcyBtb3VzZXdoZWVsXG4gICAqIEBmaXJlcyBtb3VzZWRibGNsaWNrXG4gICAqXG4gICAqIEBmaXJlcyBkcmFnb3ZlclxuICAgKiBAZmlyZXMgZHJhZ2VudGVyXG4gICAqIEBmaXJlcyBkcmFnbGVhdmVcbiAgICogQGZpcmVzIGRyb3BcbiAgICovXG4gIGZhYnJpYy5PYmplY3QgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQ29tbW9uTWV0aG9kcywgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdCAocmVjdCwgY2lyY2xlLCBwYXRoLCBldGMuKS5cbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyBtZWFudCB0byBiZSByZWFkLW9ubHkgYW5kIG5vdCBtZWFudCB0byBiZSBtb2RpZmllZC5cbiAgICAgKiBJZiB5b3UgbW9kaWZ5LCBjZXJ0YWluIHBhcnRzIG9mIEZhYnJpYyAoc3VjaCBhcyBKU09OIGxvYWRpbmcpIHdvbid0IHdvcmsgY29ycmVjdGx5LlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogICAgICAgICAgICAgICAgICAgICAnb2JqZWN0JyxcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uIG9mIGFuIG9iamVjdCAob25lIG9mIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiY2VudGVyXCIpXG4gICAgICogU2VlIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvMW93MDJnZWEvMjQ0LyBvbiBob3cgb3JpZ2luWC9vcmlnaW5ZIGFmZmVjdCBvYmplY3RzIGluIGdyb3Vwc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3JpZ2luWDogICAgICAgICAgICAgICAgICAnbGVmdCcsXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb24gb2YgYW4gb2JqZWN0IChvbmUgb2YgXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJjZW50ZXJcIilcbiAgICAgKiBTZWUgaHR0cDovL2pzZmlkZGxlLm5ldC8xb3cwMmdlYS8yNDQvIG9uIGhvdyBvcmlnaW5YL29yaWdpblkgYWZmZWN0IG9iamVjdHMgaW4gZ3JvdXBzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvcmlnaW5ZOiAgICAgICAgICAgICAgICAgICd0b3AnLFxuXG4gICAgLyoqXG4gICAgICogVG9wIHBvc2l0aW9uIG9mIGFuIG9iamVjdC4gTm90ZSB0aGF0IGJ5IGRlZmF1bHQgaXQncyByZWxhdGl2ZSB0byBvYmplY3QgdG9wLiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJ5IHNldHRpbmcgb3JpZ2luWT17dG9wL2NlbnRlci9ib3R0b219XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0b3A6ICAgICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBMZWZ0IHBvc2l0aW9uIG9mIGFuIG9iamVjdC4gTm90ZSB0aGF0IGJ5IGRlZmF1bHQgaXQncyByZWxhdGl2ZSB0byBvYmplY3QgbGVmdC4gWW91IGNhbiBjaGFuZ2UgdGhpcyBieSBzZXR0aW5nIG9yaWdpblg9e2xlZnQvY2VudGVyL3JpZ2h0fVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbGVmdDogICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHdpZHRoXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB3aWR0aDogICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBPYmplY3QgaGVpZ2h0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBoZWlnaHQ6ICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBPYmplY3Qgc2NhbGUgZmFjdG9yIChob3Jpem9udGFsKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2NhbGVYOiAgICAgICAgICAgICAgICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHNjYWxlIGZhY3RvciAodmVydGljYWwpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzY2FsZVk6ICAgICAgICAgICAgICAgICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGFuIG9iamVjdCBpcyByZW5kZXJlZCBhcyBmbGlwcGVkIGhvcml6b250YWxseVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZsaXBYOiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGFuIG9iamVjdCBpcyByZW5kZXJlZCBhcyBmbGlwcGVkIHZlcnRpY2FsbHlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmbGlwWTogICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogT3BhY2l0eSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9wYWNpdHk6ICAgICAgICAgICAgICAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIG9mIHJvdGF0aW9uIG9mIGFuIG9iamVjdCAoaW4gZGVncmVlcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFuZ2xlOiAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIG9mIHNrZXcgb24geCBheGVzIG9mIGFuIG9iamVjdCAoaW4gZGVncmVlcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNrZXdYOiAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIG9mIHNrZXcgb24geSBheGVzIG9mIGFuIG9iamVjdCAoaW4gZGVncmVlcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNrZXdZOiAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIFNpemUgb2Ygb2JqZWN0J3MgY29udHJvbGxpbmcgY29ybmVycyAoaW4gcGl4ZWxzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29ybmVyU2l6ZTogICAgICAgICAgICAgICAxMyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgb2JqZWN0J3MgY29udHJvbGxpbmcgY29ybmVycyBhcmUgcmVuZGVyZWQgYXMgdHJhbnNwYXJlbnQgaW5zaWRlIChpLmUuIHN0cm9rZSBpbnN0ZWFkIG9mIGZpbGwpXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHJhbnNwYXJlbnRDb3JuZXJzOiAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCB3aGVuIGhvdmVyaW5nIG92ZXIgdGhpcyBvYmplY3Qgb24gY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBob3ZlckN1cnNvcjogICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGN1cnNvciB2YWx1ZSB1c2VkIHdoZW4gbW92aW5nIHRoaXMgb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbW92ZUN1cnNvcjogICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogUGFkZGluZyBiZXR3ZWVuIG9iamVjdCBhbmQgaXRzIGNvbnRyb2xsaW5nIGJvcmRlcnMgKGluIHBpeGVscylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhZGRpbmc6ICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIGNvbnRyb2xsaW5nIGJvcmRlcnMgb2YgYW4gb2JqZWN0ICh3aGVuIGl0J3MgYWN0aXZlKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYm9yZGVyQ29sb3I6ICAgICAgICAgICAgICAncmdiYSgxMDIsMTUzLDI1NSwwLjc1KScsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBzcGVjaWZ5aW5nIGRhc2ggcGF0dGVybiBvZiBhbiBvYmplY3QncyBib3JkZXJzIChoYXNCb3JkZXIgbXVzdCBiZSB0cnVlKVxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgYm9yZGVyRGFzaEFycmF5OiAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgY29udHJvbGxpbmcgY29ybmVycyBvZiBhbiBvYmplY3QgKHdoZW4gaXQncyBhY3RpdmUpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb3JuZXJDb2xvcjogICAgICAgICAgICAgICdyZ2JhKDEwMiwxNTMsMjU1LDAuNSknLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgY29udHJvbGxpbmcgY29ybmVycyBvZiBhbiBvYmplY3QgKHdoZW4gaXQncyBhY3RpdmUgYW5kIHRyYW5zcGFyZW50Q29ybmVycyBmYWxzZSlcbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNvcm5lclN0cm9rZUNvbG9yOiAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgc3R5bGUgb2YgY29udHJvbCwgJ3JlY3QnIG9yICdjaXJjbGUnXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgY29ybmVyU3R5bGU6ICAgICAgICAgICdyZWN0JyxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IHNwZWNpZnlpbmcgZGFzaCBwYXR0ZXJuIG9mIGFuIG9iamVjdCdzIGNvbnRyb2wgKGhhc0JvcmRlciBtdXN0IGJlIHRydWUpXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBjb3JuZXJEYXNoQXJyYXk6ICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRoaXMgb2JqZWN0IHdpbGwgdXNlIGNlbnRlciBwb2ludCBhcyB0aGUgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uXG4gICAgICogd2hlbiBiZWluZyBzY2FsZWQgdmlhIHRoZSBjb250cm9scy5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHJlcGxhY2VzIFwiY2VudGVyVHJhbnNmb3JtXCIgKEJvb2xlYW4pLlxuICAgICAqIEBzaW5jZSAxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkU2NhbGluZzogICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRoaXMgb2JqZWN0IHdpbGwgdXNlIGNlbnRlciBwb2ludCBhcyB0aGUgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uXG4gICAgICogd2hlbiBiZWluZyByb3RhdGVkIHZpYSB0aGUgY29udHJvbHMuXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSByZXBsYWNlcyBcImNlbnRlclRyYW5zZm9ybVwiIChCb29sZWFuKS5cbiAgICAgKiBAc2luY2UgMS4zLjRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjZW50ZXJlZFJvdGF0aW9uOiAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiBvYmplY3QncyBmaWxsXG4gICAgICogdGFrZXMgY3NzIGNvbG9ycyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLWNvbG9yLTMvXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmaWxsOiAgICAgICAgICAgICAgICAgICAgICdyZ2IoMCwwLDApJyxcblxuICAgIC8qKlxuICAgICAqIEZpbGwgcnVsZSB1c2VkIHRvIGZpbGwgYW4gb2JqZWN0XG4gICAgICogYWNjZXB0ZWQgdmFsdWVzIGFyZSBub256ZXJvLCBldmVub2RkXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSB3YXMgdXNlZCBmb3Igc2V0dGluZyBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gdW50aWwgdjEuNC4xMiAodXNlIGBmYWJyaWMuT2JqZWN0I2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbmAgaW5zdGVhZClcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZpbGxSdWxlOiAgICAgICAgICAgICAgICAgJ25vbnplcm8nLFxuXG4gICAgLyoqXG4gICAgICogQ29tcG9zaXRlIHJ1bGUgdXNlZCBmb3IgY2FudmFzIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uOiAnc291cmNlLW92ZXInLFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBvZiBhbiBvYmplY3QuXG4gICAgICogdGFrZXMgY3NzIGNvbG9ycyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLWNvbG9yLTMvXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICAgICAgICAgICcnLFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0aW9uIEJhY2tncm91bmQgY29sb3Igb2YgYW4gb2JqZWN0LiBjb2xvcmVkIGxheWVyIGJlaGluZCB0aGUgb2JqZWN0IHdoZW4gaXQgaXMgYWN0aXZlLlxuICAgICAqIGRvZXMgbm90IG1peCBnb29kIHdpdGggZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIG1ldGhvZHMuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3I6ICAgICAgICAgICcnLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBkZWZpbmVkLCBhbiBvYmplY3QgaXMgcmVuZGVyZWQgdmlhIHN0cm9rZSBhbmQgdGhpcyBwcm9wZXJ0eSBzcGVjaWZpZXMgaXRzIGNvbG9yXG4gICAgICogdGFrZXMgY3NzIGNvbG9ycyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLWNvbG9yLTMvXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2U6ICAgICAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBhIHN0cm9rZSB1c2VkIHRvIHJlbmRlciB0aGlzIG9iamVjdFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlV2lkdGg6ICAgICAgICAgICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgc3BlY2lmeWluZyBkYXNoIHBhdHRlcm4gb2YgYW4gb2JqZWN0J3Mgc3Ryb2tlIChzdHJva2UgbXVzdCBiZSBkZWZpbmVkKVxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc3Ryb2tlRGFzaEFycmF5OiAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogTGluZSBlbmRpbmdzIHN0eWxlIG9mIGFuIG9iamVjdCdzIHN0cm9rZSAob25lIG9mIFwiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCIpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VMaW5lQ2FwOiAgICAgICAgICAgICdidXR0JyxcblxuICAgIC8qKlxuICAgICAqIENvcm5lciBzdHlsZSBvZiBhbiBvYmplY3QncyBzdHJva2UgKG9uZSBvZiBcImJldmlsXCIsIFwicm91bmRcIiwgXCJtaXRlclwiKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlTGluZUpvaW46ICAgICAgICAgICAnbWl0ZXInLFxuXG4gICAgLyoqXG4gICAgICogTWF4aW11bSBtaXRlciBsZW5ndGggKHVzZWQgZm9yIHN0cm9rZUxpbmVKb2luID0gXCJtaXRlclwiKSBvZiBhbiBvYmplY3QncyBzdHJva2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZU1pdGVyTGltaXQ6ICAgICAgICAgNCxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBvYmplY3QgcmVwcmVzZW50aW5nIHNoYWRvdyBvZiB0aGlzIHNoYXBlXG4gICAgICogQHR5cGUgZmFicmljLlNoYWRvd1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2hhZG93OiAgICAgICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogT3BhY2l0eSBvZiBvYmplY3QncyBjb250cm9sbGluZyBib3JkZXJzIHdoZW4gb2JqZWN0IGlzIGFjdGl2ZSBhbmQgbW92aW5nXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBib3JkZXJPcGFjaXR5V2hlbk1vdmluZzogIDAuNCxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIGZhY3RvciBvZiBvYmplY3QncyBjb250cm9sbGluZyBib3JkZXJzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBib3JkZXJTY2FsZUZhY3RvcjogICAgICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gbWF0cml4IChzaW1pbGFyIHRvIFNWRydzIHRyYW5zZm9ybSBtYXRyaXgpXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1NYXRyaXg6ICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGFsbG93ZWQgc2NhbGUgdmFsdWUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtaW5TY2FsZUxpbWl0OiAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgLCBhbiBvYmplY3QgY2FuIG5vdCBiZSBzZWxlY3RlZCBmb3IgbW9kaWZpY2F0aW9uICh1c2luZyBlaXRoZXIgcG9pbnQtY2xpY2stYmFzZWQgb3IgZ3JvdXAtYmFzZWQgc2VsZWN0aW9uKS5cbiAgICAgKiBCdXQgZXZlbnRzIHN0aWxsIGZpcmUgb24gaXQuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0YWJsZTogICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgYW4gb2JqZWN0IGNhbiBub3QgYmUgYSB0YXJnZXQgb2YgZXZlbnRzLiBBbGwgZXZlbnRzIHByb3BhZ2F0ZSB0aHJvdWdoIGl0LiBJbnRyb2R1Y2VkIGluIHYxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGV2ZW50ZWQ6ICAgICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIGFuIG9iamVjdCBpcyBub3QgcmVuZGVyZWQgb24gY2FudmFzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdmlzaWJsZTogICAgICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgb2JqZWN0J3MgY29udHJvbHMgYXJlIG5vdCBkaXNwbGF5ZWQgYW5kIGNhbiBub3QgYmUgdXNlZCB0byBtYW5pcHVsYXRlIG9iamVjdFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhhc0NvbnRyb2xzOiAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIG9iamVjdCdzIGNvbnRyb2xsaW5nIGJvcmRlcnMgYXJlIG5vdCByZW5kZXJlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhhc0JvcmRlcnM6ICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIG9iamVjdCdzIGNvbnRyb2xsaW5nIHJvdGF0aW5nIHBvaW50IHdpbGwgbm90IGJlIHZpc2libGUgb3Igc2VsZWN0YWJsZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhhc1JvdGF0aW5nUG9pbnQ6ICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIE9mZnNldCBmb3Igb2JqZWN0J3MgY29udHJvbGxpbmcgcm90YXRpbmcgcG9pbnQgKHdoZW4gZW5hYmxlZCB2aWEgYGhhc1JvdGF0aW5nUG9pbnRgKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcm90YXRpbmdQb2ludE9mZnNldDogICAgICA0MCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgb2JqZWN0cyBhcmUgXCJmb3VuZFwiIG9uIGNhbnZhcyBvbiBwZXItcGl4ZWwgYmFzaXMgcmF0aGVyIHRoYW4gYWNjb3JkaW5nIHRvIGJvdW5kaW5nIGJveFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBlclBpeGVsVGFyZ2V0RmluZDogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGBmYWxzZWAsIGRlZmF1bHQgb2JqZWN0J3MgdmFsdWVzIGFyZSBub3QgaW5jbHVkZWQgaW4gaXRzIHNlcmlhbGl6YXRpb25cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbmNsdWRlRGVmYXVsdFZhbHVlczogICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IGRldGVybWluZXMgY2xpcHBpbmcgb2YgYW4gb2JqZWN0IChjb250ZXh0IGlzIHBhc3NlZCBhcyBhIGZpcnN0IGFyZ3VtZW50KVxuICAgICAqIE5vdGUgdGhhdCBjb250ZXh0IG9yaWdpbiBpcyBhdCB0aGUgb2JqZWN0J3MgY2VudGVyIHBvaW50IChub3QgbGVmdC90b3AgY29ybmVyKVxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIDIuMC4wXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKi9cbiAgICBjbGlwVG86ICAgICAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IGhvcml6b250YWwgbW92ZW1lbnQgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja01vdmVtZW50WDogICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgdmVydGljYWwgbW92ZW1lbnQgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja01vdmVtZW50WTogICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3Qgcm90YXRpb24gaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1JvdGF0aW9uOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaG9yaXpvbnRhbCBzY2FsaW5nIGlzIGxvY2tlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxvY2tTY2FsaW5nWDogICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IHZlcnRpY2FsIHNjYWxpbmcgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdZOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3Qgbm9uLXVuaWZvcm0gc2NhbGluZyBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrVW5pU2NhbGluZzogICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBob3Jpem9udGFsIHNrZXdpbmcgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NrZXdpbmdYOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgdmVydGljYWwgc2tld2luZyBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrU2tld2luZ1k6ICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBjYW5ub3QgYmUgZmxpcHBlZCBieSBzY2FsaW5nIGludG8gbmVnYXRpdmUgdmFsdWVzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdGbGlwOiAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaXMgbm90IGV4cG9ydGVkIGluIE9CSkVDVC9KU09OXG4gICAgICogc2luY2UgMS42LjNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBleGNsdWRlRnJvbUV4cG9ydDogICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBpcyBjYWNoZWQgb24gYW4gYWRkaXRpb25hbCBjYW52YXMuXG4gICAgICogZGVmYXVsdCB0byB0cnVlXG4gICAgICogc2luY2UgMS43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIG9iamVjdENhY2hpbmc6ICAgICAgICAgICAgb2JqZWN0Q2FjaGluZyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgY2hlY2tlZCBmb3IgY2FjaGUgaW52YWxpZGF0aW9uLiBJbiBzb21lIHBhcnRpY3VsYXJcbiAgICAgKiBzaXR1YXRpb24geW91IG1heSB3YW50IHRoaXMgdG8gYmUgZGlzYWJsZWQgKCBzcHJheSBicnVzaCwgdmVyeSBiaWcsIGdyb3VwcylcbiAgICAgKiBvciBpZiB5b3VyIGFwcGxpY2F0aW9uIGRvZXMgbm90IGFsbG93IHlvdSB0byBtb2RpZnkgcHJvcGVydGllcyBmb3IgZ3JvdXBzIGNoaWxkIHlvdSB3YW50XG4gICAgICogdG8gZGlzYWJsZSBpdCBmb3IgZ3JvdXBzLlxuICAgICAqIGRlZmF1bHQgdG8gZmFsc2VcbiAgICAgKiBzaW5jZSAxLjcuMFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHN0YXRlZnVsbENhY2hlOiAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIGNhY2hlIGRvZXMgbm90IGdldCB1cGRhdGVkIGR1cmluZyBzY2FsaW5nLiBUaGUgcGljdHVyZSB3aWxsIGdldCBibG9ja3kgaWYgc2NhbGVkXG4gICAgICogdG9vIG11Y2ggYW5kIHdpbGwgYmUgcmVkcmF3biB3aXRoIGNvcnJlY3QgZGV0YWlscyBhdCB0aGUgZW5kIG9mIHNjYWxpbmcuXG4gICAgICogdGhpcyBzZXR0aW5nIGlzIHBlcmZvcm1hbmNlIGFuZCBhcHBsaWNhdGlvbiBkZXBlbmRhbnQuXG4gICAgICogZGVmYXVsdCB0byB0cnVlXG4gICAgICogc2luY2UgMS43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIG5vU2NhbGVDYWNoZTogICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgdHJ1ZWAsIG9iamVjdCdzIGNhY2hlIHdpbGwgYmUgcmVyZW5kZXJlZCBuZXh0IHJlbmRlciBjYWxsLlxuICAgICAqIHNpbmNlIDEuNy4wXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBkaXJ0eTogICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIGtlZXBzIHRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBob3ZlcmVkIGNvbmVyIGR1cmluZyBtb3VzZSBtb3ZlLlxuICAgICAqIDAgaXMgbm8gY29ybmVyLCBvciAnbXQnLCAnbWwnLCAnbXRyJyBldGMuLlxuICAgICAqIEl0IHNob3VsZCBiZSBwcml2YXRlLCBidXQgdGhlcmUgaXMgbm8gaGFybSBpbiB1c2luZyBpdCBhc1xuICAgICAqIGEgcmVhZC1vbmx5IHByb3BlcnR5LlxuICAgICAqIEB0eXBlIG51bWJlcnxzdHJpbmd8YW55XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIF9fY29ybmVyOiAwLFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5zIGlmIHRoZSBmaWxsIG9yIHRoZSBzdHJva2UgaXMgZHJhd24gZmlyc3QgKG9uZSBvZiBcImZpbGxcIiBvciBcInN0cm9rZVwiKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGFpbnRGaXJzdDogICAgICAgICAgICdmaWxsJyxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmIHN0YXRlXG4gICAgICogb2YgYW4gb2JqZWN0IGlzIGNoYW5nZWQgKGZhYnJpYy5PYmplY3QjaGFzU3RhdGVDaGFuZ2VkKVxuICAgICAqIGFzIHdlbGwgYXMgZm9yIGhpc3RvcnkgKHVuZG8vcmVkbykgcHVycG9zZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0YXRlUHJvcGVydGllczogKFxuICAgICAgJ3RvcCBsZWZ0IHdpZHRoIGhlaWdodCBzY2FsZVggc2NhbGVZIGZsaXBYIGZsaXBZIG9yaWdpblggb3JpZ2luWSB0cmFuc2Zvcm1NYXRyaXggJyArXG4gICAgICAnc3Ryb2tlIHN0cm9rZVdpZHRoIHN0cm9rZURhc2hBcnJheSBzdHJva2VMaW5lQ2FwIHN0cm9rZUxpbmVKb2luIHN0cm9rZU1pdGVyTGltaXQgJyArXG4gICAgICAnYW5nbGUgb3BhY2l0eSBmaWxsIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBzaGFkb3cgY2xpcFRvIHZpc2libGUgYmFja2dyb3VuZENvbG9yICcgK1xuICAgICAgJ3NrZXdYIHNrZXdZIGZpbGxSdWxlIHBhaW50Rmlyc3QnXG4gICAgKS5zcGxpdCgnICcpLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWYgY2FjaGUgbmVlZHMgcmVmcmVzaFxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiAoXG4gICAgICAnZmlsbCBzdHJva2Ugc3Ryb2tlV2lkdGggc3Ryb2tlRGFzaEFycmF5IHdpZHRoIGhlaWdodCBwYWludEZpcnN0JyArXG4gICAgICAnIHN0cm9rZUxpbmVDYXAgc3Ryb2tlTGluZUpvaW4gc3Ryb2tlTWl0ZXJMaW1pdCBiYWNrZ3JvdW5kQ29sb3InXG4gICAgKS5zcGxpdCgnICcpLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB0aGUgY2FudmFzIHVzZWQgdG8ga2VlcCB0aGUgY2FjaGVkIGNvcHkgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUNhY2hlQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NhY2hlUHJvcGVydGllcyA9IHt9O1xuICAgICAgdGhpcy5fY2FjaGVDYW52YXMgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICB0aGlzLl9jYWNoZUNvbnRleHQgPSB0aGlzLl9jYWNoZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgdGhpcy5fdXBkYXRlQ2FjaGVDYW52YXMoKTtcbiAgICAgIC8vIGlmIGNhbnZhcyBnZXRzIGNyZWF0ZWQsIGlzIGVtcHR5LCBzbyBkaXJ0eS5cbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMaW1pdCB0aGUgY2FjaGUgZGltZW5zaW9ucyBzbyB0aGF0IFggKiBZIGRvIG5vdCBjcm9zcyBmYWJyaWMucGVyZkxpbWl0U2l6ZVRvdGFsXG4gICAgICogYW5kIGVhY2ggc2lkZSBkbyBub3QgY3Jvc3MgZmFicmljLmNhY2hlU2lkZUxpbWl0XG4gICAgICogdGhvc2UgbnVtYmVycyBhcmUgY29uZmlndXJhYmxlIHNvIHRoYXQgeW91IGNhbiBnZXQgYXMgbXVjaCBkZXRhaWwgYXMgeW91IHdhbnRcbiAgICAgKiBtYWtpbmcgYmFyZ2FpbiB3aXRoIHBlcmZvcm1hbmNlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW1zLndpZHRoIHdpZHRoIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW1zLmhlaWdodCBoZWlnaHQgb2YgY2FudmFzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbXMuem9vbVggem9vbVggem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltcy56b29tWSB6b29tWSB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0ud2lkdGggd2lkdGggb2YgY2FudmFzXG4gICAgICogQHJldHVybiB7T2JqZWN0fS5oZWlnaHQgaGVpZ2h0IG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uem9vbVggem9vbVggem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21ZIHpvb21ZIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICovXG4gICAgX2xpbWl0Q2FjaGVTaXplOiBmdW5jdGlvbihkaW1zKSB7XG4gICAgICB2YXIgcGVyZkxpbWl0U2l6ZVRvdGFsID0gZmFicmljLnBlcmZMaW1pdFNpemVUb3RhbCxcbiAgICAgICAgICB3aWR0aCA9IGRpbXMud2lkdGgsIGhlaWdodCA9IGRpbXMuaGVpZ2h0LFxuICAgICAgICAgIG1heCA9IGZhYnJpYy5tYXhDYWNoZVNpZGVMaW1pdCwgbWluID0gZmFicmljLm1pbkNhY2hlU2lkZUxpbWl0O1xuICAgICAgaWYgKHdpZHRoIDw9IG1heCAmJiBoZWlnaHQgPD0gbWF4ICYmIHdpZHRoICogaGVpZ2h0IDw9IHBlcmZMaW1pdFNpemVUb3RhbCkge1xuICAgICAgICBpZiAod2lkdGggPCBtaW4pIHtcbiAgICAgICAgICBkaW1zLndpZHRoID0gbWluO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHQgPCBtaW4pIHtcbiAgICAgICAgICBkaW1zLmhlaWdodCA9IG1pbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGltcztcbiAgICAgIH1cbiAgICAgIHZhciBhciA9IHdpZHRoIC8gaGVpZ2h0LCBsaW1pdGVkRGltcyA9IGZhYnJpYy51dGlsLmxpbWl0RGltc0J5QXJlYShhciwgcGVyZkxpbWl0U2l6ZVRvdGFsKSxcbiAgICAgICAgICBjYXBWYWx1ZSA9IGZhYnJpYy51dGlsLmNhcFZhbHVlLFxuICAgICAgICAgIHggPSBjYXBWYWx1ZShtaW4sIGxpbWl0ZWREaW1zLngsIG1heCksXG4gICAgICAgICAgeSA9IGNhcFZhbHVlKG1pbiwgbGltaXRlZERpbXMueSwgbWF4KTtcbiAgICAgIGlmICh3aWR0aCA+IHgpIHtcbiAgICAgICAgZGltcy56b29tWCAvPSB3aWR0aCAvIHg7XG4gICAgICAgIGRpbXMud2lkdGggPSB4O1xuICAgICAgICBkaW1zLmNhcHBlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0ID4geSkge1xuICAgICAgICBkaW1zLnpvb21ZIC89IGhlaWdodCAvIHk7XG4gICAgICAgIGRpbXMuaGVpZ2h0ID0geTtcbiAgICAgICAgZGltcy5jYXBwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZGltZW5zaW9uIGFuZCB0aGUgem9vbSBsZXZlbCBuZWVkZWQgdG8gY3JlYXRlIGEgY2FjaGUgY2FudmFzXG4gICAgICogYmlnIGVub3VnaCB0byBob3N0IHRoZSBvYmplY3QgdG8gYmUgY2FjaGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbS54IHdpZHRoIG9mIG9iamVjdCB0byBiZSBjYWNoZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltLnkgaGVpZ2h0IG9mIG9iamVjdCB0byBiZSBjYWNoZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LndpZHRoIHdpZHRoIG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uaGVpZ2h0IGhlaWdodCBvZiBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21YIHpvb21YIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICogQHJldHVybiB7T2JqZWN0fS56b29tWSB6b29tWSB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqL1xuICAgIF9nZXRDYWNoZUNhbnZhc0RpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHpvb20gPSB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5nZXRab29tKCkgfHwgMSxcbiAgICAgICAgICBvYmplY3RTY2FsZSA9IHRoaXMuZ2V0T2JqZWN0U2NhbGluZygpLFxuICAgICAgICAgIHJldGluYSA9IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLl9pc1JldGluYVNjYWxpbmcoKSA/IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvIDogMSxcbiAgICAgICAgICBkaW0gPSB0aGlzLl9nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnMoKSxcbiAgICAgICAgICB6b29tWCA9IG9iamVjdFNjYWxlLnNjYWxlWCAqIHpvb20gKiByZXRpbmEsXG4gICAgICAgICAgem9vbVkgPSBvYmplY3RTY2FsZS5zY2FsZVkgKiB6b29tICogcmV0aW5hLFxuICAgICAgICAgIHdpZHRoID0gZGltLnggKiB6b29tWCxcbiAgICAgICAgICBoZWlnaHQgPSBkaW0ueSAqIHpvb21ZO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gZm9yIHN1cmUgdGhpcyBBTElBU0lOR19MSU1JVCBpcyBzbGlnaHRseSBjcmF0aW5nIHByb2JsZW1cbiAgICAgICAgLy8gaW4gc2l0dWF0aW9uIGluIHdpY2ggdGhlIGNhY2hlIGNhbnZhcyBnZXRzIGFuIHVwcGVyIGxpbWl0XG4gICAgICAgIHdpZHRoOiB3aWR0aCArIEFMSUFTSU5HX0xJTUlULFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCArIEFMSUFTSU5HX0xJTUlULFxuICAgICAgICB6b29tWDogem9vbVgsXG4gICAgICAgIHpvb21ZOiB6b29tWSxcbiAgICAgICAgeDogZGltLngsXG4gICAgICAgIHk6IGRpbS55XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgY2FudmFzIGZvciBjYWNoZVxuICAgICAqIHJldHVybnMgdHJ1ZSBvciBmYWxzZSBpZiBjYW52YXMgbmVlZGVkIHJlc2l6ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGNhbnZhcyBoYXMgYmVlbiByZXNpemVkXG4gICAgICovXG4gICAgX3VwZGF0ZUNhY2hlQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLm5vU2NhbGVDYWNoZSAmJiB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5fY3VycmVudFRyYW5zZm9ybSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5jYW52YXMuX2N1cnJlbnRUcmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICAgICAgYWN0aW9uID0gdGhpcy5jYW52YXMuX2N1cnJlbnRUcmFuc2Zvcm0uYWN0aW9uO1xuICAgICAgICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIGFjdGlvbi5zbGljZSAmJiBhY3Rpb24uc2xpY2UoMCwgNSkgPT09ICdzY2FsZScpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9jYWNoZUNhbnZhcyxcbiAgICAgICAgICBkaW1zID0gdGhpcy5fbGltaXRDYWNoZVNpemUodGhpcy5fZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zKCkpLFxuICAgICAgICAgIG1pbkNhY2hlU2l6ZSA9IGZhYnJpYy5taW5DYWNoZVNpZGVMaW1pdCxcbiAgICAgICAgICB3aWR0aCA9IGRpbXMud2lkdGgsIGhlaWdodCA9IGRpbXMuaGVpZ2h0LCBkcmF3aW5nV2lkdGgsIGRyYXdpbmdIZWlnaHQsXG4gICAgICAgICAgem9vbVggPSBkaW1zLnpvb21YLCB6b29tWSA9IGRpbXMuem9vbVksXG4gICAgICAgICAgZGltZW5zaW9uc0NoYW5nZWQgPSB3aWR0aCAhPT0gdGhpcy5jYWNoZVdpZHRoIHx8IGhlaWdodCAhPT0gdGhpcy5jYWNoZUhlaWdodCxcbiAgICAgICAgICB6b29tQ2hhbmdlZCA9IHRoaXMuem9vbVggIT09IHpvb21YIHx8IHRoaXMuem9vbVkgIT09IHpvb21ZLFxuICAgICAgICAgIHNob3VsZFJlZHJhdyA9IGRpbWVuc2lvbnNDaGFuZ2VkIHx8IHpvb21DaGFuZ2VkLFxuICAgICAgICAgIGFkZGl0aW9uYWxXaWR0aCA9IDAsIGFkZGl0aW9uYWxIZWlnaHQgPSAwLCBzaG91bGRSZXNpemVDYW52YXMgPSBmYWxzZTtcbiAgICAgIGlmIChkaW1lbnNpb25zQ2hhbmdlZCkge1xuICAgICAgICB2YXIgY2FudmFzV2lkdGggPSB0aGlzLl9jYWNoZUNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgIGNhbnZhc0hlaWdodCA9IHRoaXMuX2NhY2hlQ2FudmFzLmhlaWdodCxcbiAgICAgICAgICAgIHNpemVHcm93aW5nID0gd2lkdGggPiBjYW52YXNXaWR0aCB8fCBoZWlnaHQgPiBjYW52YXNIZWlnaHQsXG4gICAgICAgICAgICBzaXplU2hyaW5raW5nID0gKHdpZHRoIDwgY2FudmFzV2lkdGggKiAwLjkgfHwgaGVpZ2h0IDwgY2FudmFzSGVpZ2h0ICogMC45KSAmJlxuICAgICAgICAgICAgICBjYW52YXNXaWR0aCA+IG1pbkNhY2hlU2l6ZSAmJiBjYW52YXNIZWlnaHQgPiBtaW5DYWNoZVNpemU7XG4gICAgICAgIHNob3VsZFJlc2l6ZUNhbnZhcyA9IHNpemVHcm93aW5nIHx8IHNpemVTaHJpbmtpbmc7XG4gICAgICAgIGlmIChzaXplR3Jvd2luZyAmJiAhZGltcy5jYXBwZWQgJiYgKHdpZHRoID4gbWluQ2FjaGVTaXplIHx8IGhlaWdodCA+IG1pbkNhY2hlU2l6ZSkpIHtcbiAgICAgICAgICBhZGRpdGlvbmFsV2lkdGggPSB3aWR0aCAqIDAuMTtcbiAgICAgICAgICBhZGRpdGlvbmFsSGVpZ2h0ID0gaGVpZ2h0ICogMC4xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmVkcmF3KSB7XG4gICAgICAgIGlmIChzaG91bGRSZXNpemVDYW52YXMpIHtcbiAgICAgICAgICBjYW52YXMud2lkdGggPSBNYXRoLmNlaWwod2lkdGggKyBhZGRpdGlvbmFsV2lkdGgpO1xuICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICsgYWRkaXRpb25hbEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5fY2FjaGVDb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZHJhd2luZ1dpZHRoID0gZGltcy54ICogem9vbVggLyAyO1xuICAgICAgICBkcmF3aW5nSGVpZ2h0ID0gZGltcy55ICogem9vbVkgLyAyO1xuICAgICAgICB0aGlzLmNhY2hlVHJhbnNsYXRpb25YID0gTWF0aC5yb3VuZChjYW52YXMud2lkdGggLyAyIC0gZHJhd2luZ1dpZHRoKSArIGRyYXdpbmdXaWR0aDtcbiAgICAgICAgdGhpcy5jYWNoZVRyYW5zbGF0aW9uWSA9IE1hdGgucm91bmQoY2FudmFzLmhlaWdodCAvIDIgLSBkcmF3aW5nSGVpZ2h0KSArIGRyYXdpbmdIZWlnaHQ7XG4gICAgICAgIHRoaXMuY2FjaGVXaWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmNhY2hlSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQudHJhbnNsYXRlKHRoaXMuY2FjaGVUcmFuc2xhdGlvblgsIHRoaXMuY2FjaGVUcmFuc2xhdGlvblkpO1xuICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuc2NhbGUoem9vbVgsIHpvb21ZKTtcbiAgICAgICAgdGhpcy56b29tWCA9IHpvb21YO1xuICAgICAgICB0aGlzLnpvb21ZID0gem9vbVk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIHByb3BlcnRpZXMgZnJvbSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX3NldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0R3JhZGllbnQob3B0aW9ucy5maWxsLCAnZmlsbCcpO1xuICAgICAgdGhpcy5faW5pdEdyYWRpZW50KG9wdGlvbnMuc3Ryb2tlLCAnc3Ryb2tlJyk7XG4gICAgICB0aGlzLl9pbml0Q2xpcHBpbmcob3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0UGF0dGVybihvcHRpb25zLmZpbGwsICdmaWxsJyk7XG4gICAgICB0aGlzLl9pbml0UGF0dGVybihvcHRpb25zLnN0cm9rZSwgJ3N0cm9rZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGNvbnRleHQgd2hlbiByZW5kZXJpbmcgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0XG4gICAgICovXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBtO1xuICAgICAgaWYgKHRoaXMuZ3JvdXAgJiYgIXRoaXMuZ3JvdXAuX3RyYW5zZm9ybURvbmUpIHtcbiAgICAgICAgbSA9IHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG0gPSB0aGlzLmNhbGNPd25NYXRyaXgoKTtcbiAgICAgIH1cbiAgICAgIGN0eC50cmFuc2Zvcm0obVswXSwgbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTLFxuXG4gICAgICAgICAgb2JqZWN0ID0ge1xuICAgICAgICAgICAgdHlwZTogICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUsXG4gICAgICAgICAgICB2ZXJzaW9uOiAgICAgICAgICAgICAgICAgIGZhYnJpYy52ZXJzaW9uLFxuICAgICAgICAgICAgb3JpZ2luWDogICAgICAgICAgICAgICAgICB0aGlzLm9yaWdpblgsXG4gICAgICAgICAgICBvcmlnaW5ZOiAgICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luWSxcbiAgICAgICAgICAgIGxlZnQ6ICAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmxlZnQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgdG9wOiAgICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMudG9wLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHdpZHRoOiAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLndpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIGhlaWdodDogICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBmaWxsOiAgICAgICAgICAgICAgICAgICAgICh0aGlzLmZpbGwgJiYgdGhpcy5maWxsLnRvT2JqZWN0KSA/IHRoaXMuZmlsbC50b09iamVjdCgpIDogdGhpcy5maWxsLFxuICAgICAgICAgICAgc3Ryb2tlOiAgICAgICAgICAgICAgICAgICAodGhpcy5zdHJva2UgJiYgdGhpcy5zdHJva2UudG9PYmplY3QpID8gdGhpcy5zdHJva2UudG9PYmplY3QoKSA6IHRoaXMuc3Ryb2tlLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6ICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc3Ryb2tlV2lkdGgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc3Ryb2tlRGFzaEFycmF5OiAgICAgICAgICB0aGlzLnN0cm9rZURhc2hBcnJheSA/IHRoaXMuc3Ryb2tlRGFzaEFycmF5LmNvbmNhdCgpIDogdGhpcy5zdHJva2VEYXNoQXJyYXksXG4gICAgICAgICAgICBzdHJva2VMaW5lQ2FwOiAgICAgICAgICAgIHRoaXMuc3Ryb2tlTGluZUNhcCxcbiAgICAgICAgICAgIHN0cm9rZUxpbmVKb2luOiAgICAgICAgICAgdGhpcy5zdHJva2VMaW5lSm9pbixcbiAgICAgICAgICAgIHN0cm9rZU1pdGVyTGltaXQ6ICAgICAgICAgdG9GaXhlZCh0aGlzLnN0cm9rZU1pdGVyTGltaXQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc2NhbGVYOiAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc2NhbGVYLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHNjYWxlWTogICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnNjYWxlWSwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBhbmdsZTogICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5hbmdsZSwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBmbGlwWDogICAgICAgICAgICAgICAgICAgIHRoaXMuZmxpcFgsXG4gICAgICAgICAgICBmbGlwWTogICAgICAgICAgICAgICAgICAgIHRoaXMuZmxpcFksXG4gICAgICAgICAgICBvcGFjaXR5OiAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5vcGFjaXR5LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHNoYWRvdzogICAgICAgICAgICAgICAgICAgKHRoaXMuc2hhZG93ICYmIHRoaXMuc2hhZG93LnRvT2JqZWN0KSA/IHRoaXMuc2hhZG93LnRvT2JqZWN0KCkgOiB0aGlzLnNoYWRvdyxcbiAgICAgICAgICAgIHZpc2libGU6ICAgICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlLFxuICAgICAgICAgICAgY2xpcFRvOiAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBUbyAmJiBTdHJpbmcodGhpcy5jbGlwVG8pLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAgICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGZpbGxSdWxlOiAgICAgICAgICAgICAgICAgdGhpcy5maWxsUnVsZSxcbiAgICAgICAgICAgIHBhaW50Rmlyc3Q6ICAgICAgICAgICAgICAgdGhpcy5wYWludEZpcnN0LFxuICAgICAgICAgICAgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uOiB0aGlzLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbixcbiAgICAgICAgICAgIHRyYW5zZm9ybU1hdHJpeDogICAgICAgICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPyB0aGlzLnRyYW5zZm9ybU1hdHJpeC5jb25jYXQoKSA6IG51bGwsXG4gICAgICAgICAgICBza2V3WDogICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5za2V3WCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBza2V3WTogICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5za2V3WSwgTlVNX0ZSQUNUSU9OX0RJR0lUUylcbiAgICAgICAgICB9O1xuXG4gICAgICBmYWJyaWMudXRpbC5wb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzKHRoaXMsIG9iamVjdCwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBpZiAoIXRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5fcmVtb3ZlRGVmYXVsdFZhbHVlcyhvYmplY3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIChkYXRhbGVzcykgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgLy8gd2lsbCBiZSBvdmVyd3JpdHRlbiBieSBzdWJjbGFzc2VzXG4gICAgICByZXR1cm4gdGhpcy50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICovXG4gICAgX3JlbW92ZURlZmF1bHRWYWx1ZXM6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHByb3RvdHlwZSA9IGZhYnJpYy51dGlsLmdldEtsYXNzKG9iamVjdC50eXBlKS5wcm90b3R5cGUsXG4gICAgICAgICAgc3RhdGVQcm9wZXJ0aWVzID0gcHJvdG90eXBlLnN0YXRlUHJvcGVydGllcztcbiAgICAgIHN0YXRlUHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgaWYgKG9iamVjdFtwcm9wXSA9PT0gcHJvdG90eXBlW3Byb3BdKSB7XG4gICAgICAgICAgZGVsZXRlIG9iamVjdFtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNBcnJheSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3RbcHJvcF0pID09PSAnW29iamVjdCBBcnJheV0nICYmXG4gICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb3RvdHlwZVtwcm9wXSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cbiAgICAgICAgLy8gYmFzaWNhbGx5IGEgY2hlY2sgZm9yIFtdID09PSBbXVxuICAgICAgICBpZiAoaXNBcnJheSAmJiBvYmplY3RbcHJvcF0ubGVuZ3RoID09PSAwICYmIHByb3RvdHlwZVtwcm9wXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLicgKyBjYXBpdGFsaXplKHRoaXMudHlwZSkgKyAnPic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgb2JqZWN0IHNjYWxlIGZhY3RvciBjb3VudGluZyBhbHNvIHRoZSBncm91cCBzY2FsaW5nXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBzY2FsZVggYW5kIHNjYWxlWSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ2V0T2JqZWN0U2NhbGluZzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2NhbGVYID0gdGhpcy5zY2FsZVgsIHNjYWxlWSA9IHRoaXMuc2NhbGVZO1xuICAgICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgICAgdmFyIHNjYWxpbmcgPSB0aGlzLmdyb3VwLmdldE9iamVjdFNjYWxpbmcoKTtcbiAgICAgICAgc2NhbGVYICo9IHNjYWxpbmcuc2NhbGVYO1xuICAgICAgICBzY2FsZVkgKj0gc2NhbGluZy5zY2FsZVk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzY2FsZVg6IHNjYWxlWCwgc2NhbGVZOiBzY2FsZVkgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBvYmplY3Qgb3BhY2l0eSBjb3VudGluZyBhbHNvIHRoZSBncm91cCBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRPYmplY3RPcGFjaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuICAgICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgICAgb3BhY2l0eSAqPSB0aGlzLmdyb3VwLmdldE9iamVjdE9wYWNpdHkoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcGFjaXR5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBzaG91bGRDb25zdHJhaW5WYWx1ZSA9IChrZXkgPT09ICdzY2FsZVgnIHx8IGtleSA9PT0gJ3NjYWxlWScpLFxuICAgICAgICAgIGlzQ2hhbmdlZCA9IHRoaXNba2V5XSAhPT0gdmFsdWUsIGdyb3VwTmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgaWYgKHNob3VsZENvbnN0cmFpblZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5fY29uc3RyYWluU2NhbGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NjYWxlWCcgJiYgdmFsdWUgPCAwKSB7XG4gICAgICAgIHRoaXMuZmxpcFggPSAhdGhpcy5mbGlwWDtcbiAgICAgICAgdmFsdWUgKj0gLTE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChrZXkgPT09ICdzY2FsZVknICYmIHZhbHVlIDwgMCkge1xuICAgICAgICB0aGlzLmZsaXBZID0gIXRoaXMuZmxpcFk7XG4gICAgICAgIHZhbHVlICo9IC0xO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc2hhZG93JyAmJiB2YWx1ZSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgZmFicmljLlNoYWRvdykpIHtcbiAgICAgICAgdmFsdWUgPSBuZXcgZmFicmljLlNoYWRvdyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChrZXkgPT09ICdkaXJ0eScgJiYgdGhpcy5ncm91cCkge1xuICAgICAgICB0aGlzLmdyb3VwLnNldCgnZGlydHknLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoaXNDaGFuZ2VkKSB7XG4gICAgICAgIGdyb3VwTmVlZHNVcGRhdGUgPSB0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAuaXNPbkFDYWNoZSgpO1xuICAgICAgICBpZiAodGhpcy5jYWNoZVByb3BlcnRpZXMuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICBncm91cE5lZWRzVXBkYXRlICYmIHRoaXMuZ3JvdXAuc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGdyb3VwTmVlZHNVcGRhdGUgJiYgdGhpcy5zdGF0ZVByb3BlcnRpZXMuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICB0aGlzLmdyb3VwLnNldCgnZGlydHknLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgdGhlIHBhcmVudCBncm91cCBvZiBhbiBvYmplY3QgZXZlcnlcbiAgICAgKiB0aW1lIGEgbm9uLWRlbGVnYXRlZCBwcm9wZXJ0eSBjaGFuZ2VzIG9uIHRoZSBncm91cC4gSXQgaXMgcGFzc2VkIHRoZSBrZXlcbiAgICAgKiBhbmQgdmFsdWUgYXMgcGFyYW1ldGVycy4gTm90IGFkZGluZyBpbiB0aGlzIGZ1bmN0aW9uJ3Mgc2lnbmF0dXJlIHRvIGF2b2lkXG4gICAgICogVHJhdmlzIGJ1aWxkIGVycm9yIGFib3V0IHVudXNlZCB2YXJpYWJsZXMuXG4gICAgICovXG4gICAgc2V0T25Hcm91cDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBpbXBsZW1lbnRlZCBieSBzdWItY2xhc3NlcywgYXMgbmVlZGVkLlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdmlld3BvcnRUcmFuc2Zvcm0gZnJvbSBPYmplY3QncyBjYW52YXMgaWYgcG9zc2libGVcbiAgICAgKiBAbWV0aG9kIGdldFZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXRWaWV3cG9ydFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhYnJpYy5pTWF0cml4LmNvbmNhdCgpO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogcmV0dXJuIGlmIHRoZSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpbiByZW5kZXJpbmdcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzTm90VmlzaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcGFjaXR5ID09PSAwIHx8ICh0aGlzLndpZHRoID09PSAwICYmIHRoaXMuaGVpZ2h0ID09PSAwKSB8fCAhdGhpcy52aXNpYmxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGFuIG9iamVjdCBvbiBhIHNwZWNpZmllZCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICAvLyBkbyBub3QgcmVuZGVyIGlmIHdpZHRoL2hlaWdodCBhcmUgemVyb3Mgb3Igb2JqZWN0IGlzIG5vdCB2aXNpYmxlXG4gICAgICBpZiAodGhpcy5pc05vdFZpc2libGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuc2tpcE9mZnNjcmVlbiAmJiAhdGhpcy5ncm91cCAmJiAhdGhpcy5pc09uU2NyZWVuKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX3NldHVwQ29tcG9zaXRlT3BlcmF0aW9uKGN0eCk7XG4gICAgICB0aGlzLmRyYXdTZWxlY3Rpb25CYWNrZ3JvdW5kKGN0eCk7XG4gICAgICB0aGlzLnRyYW5zZm9ybShjdHgpO1xuICAgICAgdGhpcy5fc2V0T3BhY2l0eShjdHgpO1xuICAgICAgdGhpcy5fc2V0U2hhZG93KGN0eCwgdGhpcyk7XG4gICAgICBpZiAodGhpcy50cmFuc2Zvcm1NYXRyaXgpIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIHRoaXMudHJhbnNmb3JtTWF0cml4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xpcFRvICYmIGZhYnJpYy51dGlsLmNsaXBDb250ZXh0KHRoaXMsIGN0eCk7XG4gICAgICBpZiAodGhpcy5zaG91bGRDYWNoZSgpKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGVDYW52YXMpIHtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVDYWNoZUNhbnZhcygpO1xuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNDYWNoZURpcnR5KCkpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlZnVsbENhY2hlICYmIHRoaXMuc2F2ZVN0YXRlKHsgcHJvcGVydHlTZXQ6ICdjYWNoZVByb3BlcnRpZXMnIH0pO1xuICAgICAgICAgIHRoaXMuZHJhd09iamVjdCh0aGlzLl9jYWNoZUNvbnRleHQpO1xuICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYXdDYWNoZU9uQ2FudmFzKGN0eCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlQ2FjaGVDYW52YXMoKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRyYXdPYmplY3QoY3R4KTtcbiAgICAgICAgaWYgKHRoaXMub2JqZWN0Q2FjaGluZyAmJiB0aGlzLnN0YXRlZnVsbENhY2hlKSB7XG4gICAgICAgICAgdGhpcy5zYXZlU3RhdGUoeyBwcm9wZXJ0eVNldDogJ2NhY2hlUHJvcGVydGllcycgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuY2xpcFRvICYmIGN0eC5yZXN0b3JlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgY2FjaGVDYW52YXMgYW5kIGl0cyBkaW1lbnNpb25zIGZyb20gdGhlIG9iamVjdHNcbiAgICAgKi9cbiAgICBfcmVtb3ZlQ2FjaGVDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY2FjaGVDYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy5jYWNoZVdpZHRoID0gMDtcbiAgICAgIHRoaXMuY2FjaGVIZWlnaHQgPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgdHJ1ZWAsIGZvcmNlIHRoZSBvYmplY3QgdG8gaGF2ZSBpdHMgb3duIGNhY2hlLCBldmVuIGlmIGl0IGlzIGluc2lkZSBhIGdyb3VwXG4gICAgICogaXQgbWF5IGJlIG5lZWRlZCB3aGVuIHlvdXIgb2JqZWN0IGJlaGF2ZSBpbiBhIHBhcnRpY3VsYXIgd2F5IG9uIHRoZSBjYWNoZSBhbmQgYWx3YXlzIG5lZWRzXG4gICAgICogaXRzIG93biBpc29sYXRlZCBjYW52YXMgdG8gcmVuZGVyIGNvcnJlY3RseS5cbiAgICAgKiBDcmVhdGVkIHRvIGJlIG92ZXJyaWRkZW5cbiAgICAgKiBzaW5jZSAxLjcuMTJcbiAgICAgKiBAcmV0dXJucyBmYWxzZVxuICAgICAqL1xuICAgIG5lZWRzSXRzT3duQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucGFpbnRGaXJzdCA9PT0gJ3N0cm9rZScgJiYgdHlwZW9mIHRoaXMuc2hhZG93ID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjaWRlIGlmIHRoZSBvYmplY3Qgc2hvdWxkIGNhY2hlIG9yIG5vdC4gQ3JlYXRlIGl0cyBvd24gY2FjaGUgbGV2ZWxcbiAgICAgKiBvYmplY3RDYWNoaW5nIGlzIGEgZ2xvYmFsIGZsYWcsIHdpbnMgb3ZlciBldmVyeXRoaW5nXG4gICAgICogbmVlZHNJdHNPd25DYWNoZSBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBvYmplY3QgZHJhd2luZyBtZXRob2QgcmVxdWlyZXNcbiAgICAgKiBhIGNhY2hlIHN0ZXAuIE5vbmUgb2YgdGhlIGZhYnJpYyBjbGFzc2VzIHJlcXVpcmVzIGl0LlxuICAgICAqIEdlbmVyYWxseSB5b3UgZG8gbm90IGNhY2hlIG9iamVjdHMgaW4gZ3JvdXBzIGJlY2F1c2UgdGhlIGdyb3VwIG91dHNpZGUgaXMgY2FjaGVkLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2hvdWxkQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5vd25DYWNoaW5nID0gdGhpcy5vYmplY3RDYWNoaW5nICYmXG4gICAgICAoIXRoaXMuZ3JvdXAgfHwgdGhpcy5uZWVkc0l0c093bkNhY2hlKCkgfHwgIXRoaXMuZ3JvdXAuaXNPbkFDYWNoZSgpKTtcbiAgICAgIHJldHVybiB0aGlzLm93bkNhY2hpbmc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IG9yIGEgY2hpbGQgb2JqZWN0IHdpbGwgY2FzdCBhIHNoYWRvd1xuICAgICAqIHVzZWQgYnkgR3JvdXAuc2hvdWxkQ2FjaGUgdG8ga25vdyBpZiBjaGlsZCBoYXMgYSBzaGFkb3cgcmVjdXJzaXZlbHlcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHdpbGxEcmF3U2hhZG93OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuc2hhZG93ICYmICh0aGlzLnNoYWRvdy5vZmZzZXRYICE9PSAwIHx8IHRoaXMuc2hhZG93Lm9mZnNldFkgIT09IDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBkcmF3aW5nIG9wZXJhdGlvbiBmb3IgYW4gb2JqZWN0IG9uIGEgc3BlY2lmaWVkIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgZHJhd09iamVjdDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kKGN0eCk7XG4gICAgICB0aGlzLl9zZXRTdHJva2VTdHlsZXMoY3R4LCB0aGlzKTtcbiAgICAgIHRoaXMuX3NldEZpbGxTdHlsZXMoY3R4LCB0aGlzKTtcbiAgICAgIHRoaXMuX3JlbmRlcihjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYWludCB0aGUgY2FjaGVkIGNvcHkgb2YgdGhlIG9iamVjdCBvbiB0aGUgdGFyZ2V0IGNvbnRleHQuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIGRyYXdDYWNoZU9uQ2FudmFzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGN0eC5zY2FsZSgxIC8gdGhpcy56b29tWCwgMSAvIHRoaXMuem9vbVkpO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLl9jYWNoZUNhbnZhcywgLXRoaXMuY2FjaGVUcmFuc2xhdGlvblgsIC10aGlzLmNhY2hlVHJhbnNsYXRpb25ZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgY2FjaGUgaXMgZGlydHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBDYW52YXMgc2tpcCBjYW52YXMgY2hlY2tzIGJlY2F1c2UgdGhpcyBvYmplY3QgaXMgcGFpbnRlZFxuICAgICAqIG9uIHBhcmVudCBjYW52YXMuXG4gICAgICovXG4gICAgaXNDYWNoZURpcnR5OiBmdW5jdGlvbihza2lwQ2FudmFzKSB7XG4gICAgICBpZiAodGhpcy5pc05vdFZpc2libGUoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fY2FjaGVDYW52YXMgJiYgIXNraXBDYW52YXMgJiYgdGhpcy5fdXBkYXRlQ2FjaGVDYW52YXMoKSkge1xuICAgICAgICAvLyBpbiB0aGlzIGNhc2UgdGhlIGNvbnRleHQgaXMgYWxyZWFkeSBjbGVhcmVkLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSB8fCAodGhpcy5zdGF0ZWZ1bGxDYWNoZSAmJiB0aGlzLmhhc1N0YXRlQ2hhbmdlZCgnY2FjaGVQcm9wZXJ0aWVzJykpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NhY2hlQ2FudmFzICYmICFza2lwQ2FudmFzKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmNhY2hlV2lkdGggLyB0aGlzLnpvb21YO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuY2FjaGVIZWlnaHQgLyB0aGlzLnpvb21ZO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVDb250ZXh0LmNsZWFyUmVjdCgtd2lkdGggLyAyLCAtaGVpZ2h0IC8gMiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGEgYmFja2dyb3VuZCBmb3IgdGhlIG9iamVjdCBiaWcgYXMgaXRzIHVudHJhc2Zvcm1lZCBkaW1lbnNpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckJhY2tncm91bmQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZGltID0gdGhpcy5fZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgLWRpbS54IC8gMixcbiAgICAgICAgLWRpbS55IC8gMixcbiAgICAgICAgZGltLngsXG4gICAgICAgIGRpbS55XG4gICAgICApO1xuICAgICAgLy8gaWYgdGhlcmUgaXMgYmFja2dyb3VuZCBjb2xvciBubyBvdGhlciBzaGFkb3dzXG4gICAgICAvLyBzaG91bGQgYmUgY2FzdGVkXG4gICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3NldE9wYWNpdHk6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKHRoaXMuZ3JvdXAgJiYgIXRoaXMuZ3JvdXAuX3RyYW5zZm9ybURvbmUpIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5nZXRPYmplY3RPcGFjaXR5KCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhICo9IHRoaXMub3BhY2l0eTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldFN0cm9rZVN0eWxlczogZnVuY3Rpb24oY3R4LCBkZWNsKSB7XG4gICAgICBpZiAoZGVjbC5zdHJva2UpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGRlY2wuc3Ryb2tlV2lkdGg7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gZGVjbC5zdHJva2VMaW5lQ2FwO1xuICAgICAgICBjdHgubGluZUpvaW4gPSBkZWNsLnN0cm9rZUxpbmVKb2luO1xuICAgICAgICBjdHgubWl0ZXJMaW1pdCA9IGRlY2wuc3Ryb2tlTWl0ZXJMaW1pdDtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZGVjbC5zdHJva2UudG9MaXZlXG4gICAgICAgICAgPyBkZWNsLnN0cm9rZS50b0xpdmUoY3R4LCB0aGlzKVxuICAgICAgICAgIDogZGVjbC5zdHJva2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9zZXRGaWxsU3R5bGVzOiBmdW5jdGlvbihjdHgsIGRlY2wpIHtcbiAgICAgIGlmIChkZWNsLmZpbGwpIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGRlY2wuZmlsbC50b0xpdmVcbiAgICAgICAgICA/IGRlY2wuZmlsbC50b0xpdmUoY3R4LCB0aGlzKVxuICAgICAgICAgIDogZGVjbC5maWxsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFNldHMgbGluZSBkYXNoXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHNldCB0aGUgZGFzaCBsaW5lIG9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGFzaEFycmF5IGFycmF5IHJlcHJlc2VudGluZyBkYXNoZXNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhbHRlcm5hdGl2ZSBmdW5jdGlvbiB0byBjYWxsIGlmIGJyb3dhc2VyIGRvZXMgbm90IHN1cHBvcnQgbGluZURhc2hcbiAgICAgKi9cbiAgICBfc2V0TGluZURhc2g6IGZ1bmN0aW9uKGN0eCwgZGFzaEFycmF5LCBhbHRlcm5hdGl2ZSkge1xuICAgICAgaWYgKCFkYXNoQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gU3BlYyByZXF1aXJlcyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0d28gY29waWVzIHRoZSBkYXNoIGxpc3Qgd2hlbiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGlzIG9kZFxuICAgICAgaWYgKDEgJiBkYXNoQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGRhc2hBcnJheS5wdXNoLmFwcGx5KGRhc2hBcnJheSwgZGFzaEFycmF5KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0c0xpbmVEYXNoKSB7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoQXJyYXkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGFsdGVybmF0aXZlICYmIGFsdGVybmF0aXZlKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgY29udHJvbHMgYW5kIGJvcmRlcnMgZm9yIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZU92ZXJyaWRlXSBwcm9wZXJ0aWVzIHRvIG92ZXJyaWRlIHRoZSBvYmplY3Qgc3R5bGVcbiAgICAgKi9cbiAgICBfcmVuZGVyQ29udHJvbHM6IGZ1bmN0aW9uKGN0eCwgc3R5bGVPdmVycmlkZSkge1xuICAgICAgdmFyIHZwdCA9IHRoaXMuZ2V0Vmlld3BvcnRUcmFuc2Zvcm0oKSxcbiAgICAgICAgICBtYXRyaXggPSB0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgICBvcHRpb25zLCBkcmF3Qm9yZGVycywgZHJhd0NvbnRyb2xzO1xuICAgICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwgeyB9O1xuICAgICAgZHJhd0JvcmRlcnMgPSB0eXBlb2Ygc3R5bGVPdmVycmlkZS5oYXNCb3JkZXJzICE9PSAndW5kZWZpbmVkJyA/IHN0eWxlT3ZlcnJpZGUuaGFzQm9yZGVycyA6IHRoaXMuaGFzQm9yZGVycztcbiAgICAgIGRyYXdDb250cm9scyA9IHR5cGVvZiBzdHlsZU92ZXJyaWRlLmhhc0NvbnRyb2xzICE9PSAndW5kZWZpbmVkJyA/IHN0eWxlT3ZlcnJpZGUuaGFzQ29udHJvbHMgOiB0aGlzLmhhc0NvbnRyb2xzO1xuICAgICAgbWF0cml4ID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyh2cHQsIG1hdHJpeCk7XG4gICAgICBvcHRpb25zID0gZmFicmljLnV0aWwucXJEZWNvbXBvc2UobWF0cml4KTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKG9wdGlvbnMudHJhbnNsYXRlWCwgb3B0aW9ucy50cmFuc2xhdGVZKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSAxICogdGhpcy5ib3JkZXJTY2FsZUZhY3RvcjtcbiAgICAgIGlmICghdGhpcy5ncm91cCkge1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmlzTW92aW5nID8gdGhpcy5ib3JkZXJPcGFjaXR5V2hlbk1vdmluZyA6IDE7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVPdmVycmlkZS5mb3JBY3RpdmVTZWxlY3Rpb24pIHtcbiAgICAgICAgY3R4LnJvdGF0ZShkZWdyZWVzVG9SYWRpYW5zKG9wdGlvbnMuYW5nbGUpKTtcbiAgICAgICAgZHJhd0JvcmRlcnMgJiYgdGhpcy5kcmF3Qm9yZGVyc0luR3JvdXAoY3R4LCBvcHRpb25zLCBzdHlsZU92ZXJyaWRlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHgucm90YXRlKGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSkpO1xuICAgICAgICBkcmF3Qm9yZGVycyAmJiB0aGlzLmRyYXdCb3JkZXJzKGN0eCwgc3R5bGVPdmVycmlkZSk7XG4gICAgICB9XG4gICAgICBkcmF3Q29udHJvbHMgJiYgdGhpcy5kcmF3Q29udHJvbHMoY3R4LCBzdHlsZU92ZXJyaWRlKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9zZXRTaGFkb3c6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnNoYWRvdykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBtdWx0WCA9ICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybVswXSkgfHwgMSxcbiAgICAgICAgICBtdWx0WSA9ICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybVszXSkgfHwgMSxcbiAgICAgICAgICBzY2FsaW5nID0gdGhpcy5nZXRPYmplY3RTY2FsaW5nKCk7XG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuX2lzUmV0aW5hU2NhbGluZygpKSB7XG4gICAgICAgIG11bHRYICo9IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICBtdWx0WSAqPSBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgIH1cbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHRoaXMuc2hhZG93LmNvbG9yO1xuICAgICAgY3R4LnNoYWRvd0JsdXIgPSB0aGlzLnNoYWRvdy5ibHVyICogZmFicmljLmJyb3dzZXJTaGFkb3dCbHVyQ29uc3RhbnQgKlxuICAgICAgICAobXVsdFggKyBtdWx0WSkgKiAoc2NhbGluZy5zY2FsZVggKyBzY2FsaW5nLnNjYWxlWSkgLyA0O1xuICAgICAgY3R4LnNoYWRvd09mZnNldFggPSB0aGlzLnNoYWRvdy5vZmZzZXRYICogbXVsdFggKiBzY2FsaW5nLnNjYWxlWDtcbiAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gdGhpcy5zaGFkb3cub2Zmc2V0WSAqIG11bHRZICogc2NhbGluZy5zY2FsZVk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW1vdmVTaGFkb3c6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnNoYWRvdykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICcnO1xuICAgICAgY3R4LnNoYWRvd0JsdXIgPSBjdHguc2hhZG93T2Zmc2V0WCA9IGN0eC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZpbGxlciBmYWJyaWMuUGF0dGVybiBvciBmYWJyaWMuR3JhZGllbnRcbiAgICAgKi9cbiAgICBfYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm06IGZ1bmN0aW9uKGN0eCwgZmlsbGVyKSB7XG4gICAgICBpZiAoIWZpbGxlciB8fCAhZmlsbGVyLnRvTGl2ZSkge1xuICAgICAgICByZXR1cm4geyBvZmZzZXRYOiAwLCBvZmZzZXRZOiAwIH07XG4gICAgICB9XG4gICAgICB2YXIgdCA9IGZpbGxlci5ncmFkaWVudFRyYW5zZm9ybSB8fCBmaWxsZXIucGF0dGVyblRyYW5zZm9ybTtcbiAgICAgIHZhciBvZmZzZXRYID0gLXRoaXMud2lkdGggLyAyICsgZmlsbGVyLm9mZnNldFggfHwgMCxcbiAgICAgICAgICBvZmZzZXRZID0gLXRoaXMuaGVpZ2h0IC8gMiArIGZpbGxlci5vZmZzZXRZIHx8IDA7XG4gICAgICBjdHgudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSh0WzBdLCB0WzFdLCB0WzJdLCB0WzNdLCB0WzRdLCB0WzVdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG9mZnNldFg6IG9mZnNldFgsIG9mZnNldFk6IG9mZnNldFkgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclBhaW50SW5PcmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAodGhpcy5wYWludEZpcnN0ID09PSAnc3Ryb2tlJykge1xuICAgICAgICB0aGlzLl9yZW5kZXJTdHJva2UoY3R4KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyRmlsbChjdHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckZpbGwoY3R4KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyU3Ryb2tlKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJGaWxsOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5maWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtKGN0eCwgdGhpcy5maWxsKTtcbiAgICAgIGlmICh0aGlzLmZpbGxSdWxlID09PSAnZXZlbm9kZCcpIHtcbiAgICAgICAgY3R4LmZpbGwoJ2V2ZW5vZGQnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgX3JlbmRlclN0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuc3Ryb2tlIHx8IHRoaXMuc3Ryb2tlV2lkdGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaGFkb3cgJiYgIXRoaXMuc2hhZG93LmFmZmVjdFN0cm9rZSkge1xuICAgICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX3NldExpbmVEYXNoKGN0eCwgdGhpcy5zdHJva2VEYXNoQXJyYXksIHRoaXMuX3JlbmRlckRhc2hlZFN0cm9rZSk7XG4gICAgICB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybShjdHgsIHRoaXMuc3Ryb2tlKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYW4gaGVscGVyIGZvciBzdmcgaW1wb3J0LiBpdCByZXR1cm5zIHRoZSBjZW50ZXIgb2YgdGhlIG9iamVjdCBpbiB0aGUgc3ZnXG4gICAgICogdW50cmFuc2Zvcm1lZCBjb29yZGluYXRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgcG9pbnQgZnJvbSBlbGVtZW50IGNvb3JkaW5hdGVzXG4gICAgICovXG4gICAgX2ZpbmRDZW50ZXJGcm9tRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4geyB4OiB0aGlzLmxlZnQgKyB0aGlzLndpZHRoIC8gMiwgeTogdGhpcy50b3AgKyB0aGlzLmhlaWdodCAvIDIgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhbiBoZWxwZXIgZm9yIHN2ZyBpbXBvcnQuIGl0IGRlY29vbXBvc2UgdGhlIHRyYW5zZm9ybU1hdHJpeFxuICAgICAqIGFuZCBhc3NpZ24gcHJvcGVydGllcyB0byBvYmplY3QuXG4gICAgICogdW50cmFuc2Zvcm1lZCBjb29yZGluYXRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIF9hc3NpZ25UcmFuc2Zvcm1NYXRyaXhQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy50cmFuc2Zvcm1NYXRyaXgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5xckRlY29tcG9zZSh0aGlzLnRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICAgIHRoaXMuZmxpcFggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mbGlwWSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNldCgnc2NhbGVYJywgb3B0aW9ucy5zY2FsZVgpO1xuICAgICAgICB0aGlzLnNldCgnc2NhbGVZJywgb3B0aW9ucy5zY2FsZVkpO1xuICAgICAgICB0aGlzLmFuZ2xlID0gb3B0aW9ucy5hbmdsZTtcbiAgICAgICAgdGhpcy5za2V3WCA9IG9wdGlvbnMuc2tld1g7XG4gICAgICAgIHRoaXMuc2tld1kgPSAwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFuIGhlbHBlciBmb3Igc3ZnIGltcG9ydC4gaXQgcmVtb3ZlcyB0aGUgdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqIGFuZCBzZXQgdG8gb2JqZWN0IHByb3BlcnRpZXMgdGhhdCBmYWJyaWNqcyBjYW4gaGFuZGxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHt0aGlzQXJnfVxuICAgICAqL1xuICAgIF9yZW1vdmVUcmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uKHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zKSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5fZmluZENlbnRlckZyb21FbGVtZW50KCk7XG4gICAgICBpZiAodGhpcy50cmFuc2Zvcm1NYXRyaXgpIHtcbiAgICAgICAgdGhpcy5fYXNzaWduVHJhbnNmb3JtTWF0cml4UHJvcHMoKTtcbiAgICAgICAgY2VudGVyID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoY2VudGVyLCB0aGlzLnRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IG51bGw7XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zY2FsZVggKj0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMuc2NhbGVYO1xuICAgICAgICB0aGlzLnNjYWxlWSAqPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5zY2FsZVk7XG4gICAgICAgIHRoaXMuY3JvcFggPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5jcm9wWDtcbiAgICAgICAgdGhpcy5jcm9wWSA9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zLmNyb3BZO1xuICAgICAgICBjZW50ZXIueCArPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5vZmZzZXRMZWZ0O1xuICAgICAgICBjZW50ZXIueSArPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5vZmZzZXRUb3A7XG4gICAgICAgIHRoaXMud2lkdGggPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5oZWlnaHQ7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFBvc2l0aW9uQnlPcmlnaW4oY2VudGVyLCAnY2VudGVyJywgJ2NlbnRlcicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbG9uZXMgYW4gaW5zdGFuY2UsIHVzaW5nIGEgY2FsbGJhY2sgbWV0aG9kIHdpbGwgd29yayBmb3IgZXZlcnkgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGlzIGludm9rZWQgd2l0aCBhIGNsb25lIGFzIGEgZmlyc3QgYXJndW1lbnRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgb2JqZWN0Rm9ybSA9IHRoaXMudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5mcm9tT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuZnJvbU9iamVjdChvYmplY3RGb3JtLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnT2JqZWN0Jywgb2JqZWN0Rm9ybSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZSBvdXQgb2YgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2ssIGludm9rZWQgd2l0aCBhbiBpbnN0YW5jZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBmb3IgY2xvbmUgYXMgaW1hZ2UsIHBhc3NlZCB0byB0b0RhdGFVUkxcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmddIGVuYWJsZSByZXRpbmEgc2NhbGluZyBmb3IgdGhlIGNsb25lZCBpbWFnZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBjbG9uZUFzSW1hZ2U6IGZ1bmN0aW9uKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZGF0YVVybCA9IHRoaXMudG9EYXRhVVJMKG9wdGlvbnMpO1xuICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlKGRhdGFVcmwsIGZ1bmN0aW9uKGltZykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhuZXcgZmFicmljLkltYWdlKGltZykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIGRhdGEtdXJsLWxpa2Ugc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZm9ybWF0PXBuZ10gVGhlIGZvcm1hdCBvZiB0aGUgb3V0cHV0IGltYWdlLiBFaXRoZXIgXCJqcGVnXCIgb3IgXCJwbmdcIlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5xdWFsaXR5PTFdIFF1YWxpdHkgbGV2ZWwgKDAuLjEpLiBPbmx5IHVzZWQgZm9yIGpwZWcuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm11bHRpcGxpZXI9MV0gTXVsdGlwbGllciB0byBzY2FsZSBieVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSBDcm9wcGluZyB3aWR0aC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmddIEVuYWJsZSByZXRpbmEgc2NhbGluZyBmb3IgY2xvbmUgaW1hZ2UuIEludHJvZHVjZSBpbiAxLjYuNFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBhIGRhdGE6IFVSTCBjb250YWluaW5nIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSBvcHRpb25zLmZvcm1hdFxuICAgICAqL1xuICAgIHRvRGF0YVVSTDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHZhciBlbCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSxcbiAgICAgICAgICBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuXG4gICAgICBlbC53aWR0aCA9IGJvdW5kaW5nUmVjdC53aWR0aDtcbiAgICAgIGVsLmhlaWdodCA9IGJvdW5kaW5nUmVjdC5oZWlnaHQ7XG4gICAgICBmYWJyaWMudXRpbC53cmFwRWxlbWVudChlbCwgJ2RpdicpO1xuICAgICAgdmFyIGNhbnZhcyA9IG5ldyBmYWJyaWMuU3RhdGljQ2FudmFzKGVsLCB7XG4gICAgICAgIGVuYWJsZVJldGluYVNjYWxpbmc6IG9wdGlvbnMuZW5hYmxlUmV0aW5hU2NhbGluZyxcbiAgICAgICAgcmVuZGVyT25BZGRSZW1vdmU6IGZhbHNlLFxuICAgICAgICBza2lwT2Zmc2NyZWVuOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgICAgLy8gdG8gYXZvaWQgY29tbW9uIGNvbmZ1c2lvbiBodHRwczovL2dpdGh1Yi5jb20va2FuZ2F4L2ZhYnJpYy5qcy9pc3N1ZXMvODA2XG4gICAgICBpZiAob3B0aW9ucy5mb3JtYXQgPT09ICdqcGcnKSB7XG4gICAgICAgIG9wdGlvbnMuZm9ybWF0ID0gJ2pwZWcnO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5mb3JtYXQgPT09ICdqcGVnJykge1xuICAgICAgICBjYW52YXMuYmFja2dyb3VuZENvbG9yID0gJyNmZmYnO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3JpZ1BhcmFtcyA9IHtcbiAgICAgICAgbGVmdDogdGhpcy5sZWZ0LFxuICAgICAgICB0b3A6IHRoaXMudG9wXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnNldFBvc2l0aW9uQnlPcmlnaW4obmV3IGZhYnJpYy5Qb2ludChjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMiksICdjZW50ZXInLCAnY2VudGVyJyk7XG5cbiAgICAgIHZhciBvcmlnaW5hbENhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgY2FudmFzLmFkZCh0aGlzKTtcbiAgICAgIHZhciBkYXRhID0gY2FudmFzLnRvRGF0YVVSTChvcHRpb25zKTtcbiAgICAgIHRoaXMuc2V0KG9yaWdQYXJhbXMpLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5jYW52YXMgPSBvcmlnaW5hbENhbnZhcztcbiAgICAgIC8vIGNhbnZhcy5kaXNwb3NlIHdpbGwgY2FsbCBpbWFnZS5kaXNwb3NlIHRoYXQgd2lsbCBudWxsaWZ5IHRoZSBlbGVtZW50c1xuICAgICAgLy8gc2luY2UgdGhpcyBjYW52YXMgaXMgYSBzaW1wbGUgZWxlbWVudCBmb3IgdGhlIHByb2Nlc3MsIHdlIHJlbW92ZSByZWZlcmVuY2VzXG4gICAgICAvLyB0byBvYmplY3RzIGluIHRoaXMgd2F5IGluIG9yZGVyIHRvIGF2b2lkIG9iamVjdCB0cmFzaGluZy5cbiAgICAgIGNhbnZhcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgY2FudmFzLmRpc3Bvc2UoKTtcbiAgICAgIGNhbnZhcyA9IG51bGw7XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgc3BlY2lmaWVkIHR5cGUgaXMgaWRlbnRpY2FsIHRvIHRoZSB0eXBlIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSB0byBjaGVjayBhZ2FpbnN0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1R5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29tcGxleGl0eSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eSBvZiB0aGlzIGluc3RhbmNlIChpcyAxIHVubGVzcyBzdWJjbGFzc2VkKVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gSlNPTlxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgLy8gZGVsZWdhdGUsIG5vdCBhbGlhc1xuICAgICAgcmV0dXJuIHRoaXMudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgZ3JhZGllbnQgKGZpbGwgb3Igc3Ryb2tlKSBvZiBhbiBvYmplY3RcbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIG1ldGhvZCB3YXMgbmFtZWQgXCJzZXRHcmFkaWVudEZpbGxcIiB1bnRpbCB2MS4xLjBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZSAnc3Ryb2tlJyBvciAnZmlsbCdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnR5cGVdIFR5cGUgb2YgZ3JhZGllbnQgJ3JhZGlhbCcgb3IgJ2xpbmVhcidcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMueDE9MF0geC1jb29yZGluYXRlIG9mIHN0YXJ0IHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnkxPTBdIHktY29vcmRpbmF0ZSBvZiBzdGFydCBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy54Mj0wXSB4LWNvb3JkaW5hdGUgb2YgZW5kIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnkyPTBdIHktY29vcmRpbmF0ZSBvZiBlbmQgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucjE9MF0gUmFkaXVzIG9mIHN0YXJ0IHBvaW50IChvbmx5IGZvciByYWRpYWwgZ3JhZGllbnRzKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yMj0wXSBSYWRpdXMgb2YgZW5kIHBvaW50IChvbmx5IGZvciByYWRpYWwgZ3JhZGllbnRzKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5jb2xvclN0b3BzXSBDb2xvciBzdG9wcyBvYmplY3QgZWcuIHswOiAnZmYwMDAwJywgMTogJzAwMDAwMCd9XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmdyYWRpZW50VHJhbnNmb3JtXSB0cmFuc2Zvck1hdHJpeCBmb3IgZ3JhZGllbnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvNTh5OGIvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U2V0IGxpbmVhciBncmFkaWVudDwvY2FwdGlvbj5cbiAgICAgKiBvYmplY3Quc2V0R3JhZGllbnQoJ2ZpbGwnLCB7XG4gICAgICogICB0eXBlOiAnbGluZWFyJyxcbiAgICAgKiAgIHgxOiAtb2JqZWN0LndpZHRoIC8gMixcbiAgICAgKiAgIHkxOiAwLFxuICAgICAqICAgeDI6IG9iamVjdC53aWR0aCAvIDIsXG4gICAgICogICB5MjogMCxcbiAgICAgKiAgIGNvbG9yU3RvcHM6IHtcbiAgICAgKiAgICAgMDogJ3JlZCcsXG4gICAgICogICAgIDAuNTogJyMwMDU1NTUnLFxuICAgICAqICAgICAxOiAncmdiYSgwLDAsMjU1LDAuNSknXG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNldCByYWRpYWwgZ3JhZGllbnQ8L2NhcHRpb24+XG4gICAgICogb2JqZWN0LnNldEdyYWRpZW50KCdmaWxsJywge1xuICAgICAqICAgdHlwZTogJ3JhZGlhbCcsXG4gICAgICogICB4MTogMCxcbiAgICAgKiAgIHkxOiAwLFxuICAgICAqICAgeDI6IDAsXG4gICAgICogICB5MjogMCxcbiAgICAgKiAgIHIxOiBvYmplY3Qud2lkdGggLyAyLFxuICAgICAqICAgcjI6IDEwLFxuICAgICAqICAgY29sb3JTdG9wczoge1xuICAgICAqICAgICAwOiAncmVkJyxcbiAgICAgKiAgICAgMC41OiAnIzAwNTU1NScsXG4gICAgICogICAgIDE6ICdyZ2JhKDAsMCwyNTUsMC41KSdcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAgICovXG4gICAgc2V0R3JhZGllbnQ6IGZ1bmN0aW9uKHByb3BlcnR5LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdmFyIGdyYWRpZW50ID0geyBjb2xvclN0b3BzOiBbXSB9O1xuXG4gICAgICBncmFkaWVudC50eXBlID0gb3B0aW9ucy50eXBlIHx8IChvcHRpb25zLnIxIHx8IG9wdGlvbnMucjIgPyAncmFkaWFsJyA6ICdsaW5lYXInKTtcbiAgICAgIGdyYWRpZW50LmNvb3JkcyA9IHtcbiAgICAgICAgeDE6IG9wdGlvbnMueDEsXG4gICAgICAgIHkxOiBvcHRpb25zLnkxLFxuICAgICAgICB4Mjogb3B0aW9ucy54MixcbiAgICAgICAgeTI6IG9wdGlvbnMueTJcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zLnIxIHx8IG9wdGlvbnMucjIpIHtcbiAgICAgICAgZ3JhZGllbnQuY29vcmRzLnIxID0gb3B0aW9ucy5yMTtcbiAgICAgICAgZ3JhZGllbnQuY29vcmRzLnIyID0gb3B0aW9ucy5yMjtcbiAgICAgIH1cblxuICAgICAgZ3JhZGllbnQuZ3JhZGllbnRUcmFuc2Zvcm0gPSBvcHRpb25zLmdyYWRpZW50VHJhbnNmb3JtO1xuICAgICAgZmFicmljLkdyYWRpZW50LnByb3RvdHlwZS5hZGRDb2xvclN0b3AuY2FsbChncmFkaWVudCwgb3B0aW9ucy5jb2xvclN0b3BzKTtcblxuICAgICAgcmV0dXJuIHRoaXMuc2V0KHByb3BlcnR5LCBmYWJyaWMuR3JhZGllbnQuZm9yT2JqZWN0KHRoaXMsIGdyYWRpZW50KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgcGF0dGVybiBmaWxsIG9mIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHsoU3RyaW5nfEhUTUxJbWFnZUVsZW1lbnQpfSBvcHRpb25zLnNvdXJjZSBQYXR0ZXJuIHNvdXJjZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZXBlYXQ9cmVwZWF0XSBSZXBlYXQgcHJvcGVydHkgb2YgYSBwYXR0ZXJuIChvbmUgb2YgcmVwZWF0LCByZXBlYXQteCwgcmVwZWF0LXkgb3Igbm8tcmVwZWF0KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXRYPTBdIFBhdHRlcm4gaG9yaXpvbnRhbCBvZmZzZXQgZnJvbSBvYmplY3QncyBsZWZ0L3RvcCBjb3JuZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0WT0wXSBQYXR0ZXJuIHZlcnRpY2FsIG9mZnNldCBmcm9tIG9iamVjdCdzIGxlZnQvdG9wIGNvcm5lclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9RVDNwYS98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TZXQgcGF0dGVybjwvY2FwdGlvbj5cbiAgICAgKiBmYWJyaWMudXRpbC5sb2FkSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2VzY2hlcmVzcXVlX3N0ZS5wbmcnLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgKiAgIG9iamVjdC5zZXRQYXR0ZXJuRmlsbCh7XG4gICAgICogICAgIHNvdXJjZTogaW1nLFxuICAgICAqICAgICByZXBlYXQ6ICdyZXBlYXQnXG4gICAgICogICB9KTtcbiAgICAgKiAgIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXRQYXR0ZXJuRmlsbDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KCdmaWxsJywgbmV3IGZhYnJpYy5QYXR0ZXJuKG9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB7QGxpbmsgZmFicmljLk9iamVjdCNzaGFkb3d8c2hhZG93fSBvZiBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCBvciBzdHJpbmcgKGUuZy4gXCIycHggMnB4IDEwcHggcmdiYSgwLDAsMCwwLjIpXCIpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbG9yPXJnYigwLDAsMCldIFNoYWRvdyBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5ibHVyPTBdIFNoYWRvdyBibHVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFg9MF0gU2hhZG93IGhvcml6b250YWwgb2Zmc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFk9MF0gU2hhZG93IHZlcnRpY2FsIG9mZnNldFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy83Z3ZKRy98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TZXQgc2hhZG93IHdpdGggc3RyaW5nIG5vdGF0aW9uPC9jYXB0aW9uPlxuICAgICAqIG9iamVjdC5zZXRTaGFkb3coJzJweCAycHggMTBweCByZ2JhKDAsMCwwLDAuMiknKTtcbiAgICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U2V0IHNoYWRvdyB3aXRoIG9iamVjdCBub3RhdGlvbjwvY2FwdGlvbj5cbiAgICAgKiBvYmplY3Quc2V0U2hhZG93KHtcbiAgICAgKiAgIGNvbG9yOiAncmVkJyxcbiAgICAgKiAgIGJsdXI6IDEwLFxuICAgICAqICAgb2Zmc2V0WDogMjAsXG4gICAgICogICBvZmZzZXRZOiAyMFxuICAgICAqIH0pO1xuICAgICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICAgKi9cbiAgICBzZXRTaGFkb3c6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldCgnc2hhZG93Jywgb3B0aW9ucyA/IG5ldyBmYWJyaWMuU2hhZG93KG9wdGlvbnMpIDogbnVsbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgXCJjb2xvclwiIG9mIGFuIGluc3RhbmNlIChhbGlhcyBvZiBgc2V0KCdmaWxsJywgJmhlbGxpcDspYClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENvbG9yOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgdGhpcy5zZXQoJ2ZpbGwnLCBjb2xvcik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBcImFuZ2xlXCIgb2YgYW4gaW5zdGFuY2Ugd2l0aCBjZW50ZXJlZCByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSBBbmdsZSB2YWx1ZSAoaW4gZGVncmVlcylcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgIHZhciBzaG91bGRDZW50ZXJPcmlnaW4gPSAodGhpcy5vcmlnaW5YICE9PSAnY2VudGVyJyB8fCB0aGlzLm9yaWdpblkgIT09ICdjZW50ZXInKSAmJiB0aGlzLmNlbnRlcmVkUm90YXRpb247XG5cbiAgICAgIGlmIChzaG91bGRDZW50ZXJPcmlnaW4pIHtcbiAgICAgICAgdGhpcy5fc2V0T3JpZ2luVG9DZW50ZXIoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXQoJ2FuZ2xlJywgYW5nbGUpO1xuXG4gICAgICBpZiAoc2hvdWxkQ2VudGVyT3JpZ2luKSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0T3JpZ2luKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgb24gY2FudmFzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBsYXN0LlxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjZW50ZXJIOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jZW50ZXJPYmplY3RIKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IGhvcml6b250YWxseSBvbiBjdXJyZW50IHZpZXdwb3J0IG9mIGNhbnZhcyB0byB3aGljaCBpdCB3YXMgYWRkZWQgbGFzdC5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXJIOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy52aWV3cG9ydENlbnRlck9iamVjdEgodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBvbiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlclY6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmNlbnRlck9iamVjdFYodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBvbiBjdXJyZW50IHZpZXdwb3J0IG9mIGNhbnZhcyB0byB3aGljaCBpdCB3YXMgYWRkZWQgbGFzdC5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXJWOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy52aWV3cG9ydENlbnRlck9iamVjdFYodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5IG9uIGNhbnZhcyB0byB3aGljaCBpcyB3YXMgYWRkZWQgbGFzdFxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmNlbnRlck9iamVjdCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBvbiBjdXJyZW50IHZpZXdwb3J0IG9mIGNhbnZhcyB0byB3aGljaCBpdCB3YXMgYWRkZWQgbGFzdC5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnZpZXdwb3J0Q2VudGVyT2JqZWN0KHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29vcmRpbmF0ZXMgb2YgYSBwb2ludGVyIHJlbGF0aXZlIHRvIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgdG8gb3BlcmF0ZSB1cG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwb2ludGVyXSBQb2ludGVyIHRvIG9wZXJhdGUgdXBvbiAoaW5zdGVhZCBvZiBldmVudClcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIGEgcG9pbnRlciAoeCwgeSlcbiAgICAgKi9cbiAgICBnZXRMb2NhbFBvaW50ZXI6IGZ1bmN0aW9uKGUsIHBvaW50ZXIpIHtcbiAgICAgIHBvaW50ZXIgPSBwb2ludGVyIHx8IHRoaXMuY2FudmFzLmdldFBvaW50ZXIoZSk7XG4gICAgICB2YXIgcENsaWNrZWQgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCwgcG9pbnRlci55KSxcbiAgICAgICAgICBvYmplY3RMZWZ0VG9wID0gdGhpcy5fZ2V0TGVmdFRvcENvb3JkcygpO1xuICAgICAgaWYgKHRoaXMuYW5nbGUpIHtcbiAgICAgICAgcENsaWNrZWQgPSBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChcbiAgICAgICAgICBwQ2xpY2tlZCwgb2JqZWN0TGVmdFRvcCwgZGVncmVlc1RvUmFkaWFucygtdGhpcy5hbmdsZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcENsaWNrZWQueCAtIG9iamVjdExlZnRUb3AueCxcbiAgICAgICAgeTogcENsaWNrZWQueSAtIG9iamVjdExlZnRUb3AueVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBjYW52YXMgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIGZvciBzcGVjaWZpYyBvYmplY3RcbiAgICAgKiBjdXN0b20gY29tcG9zaXRpb24gb3BlcmF0aW9uIGZvciB0aGUgcGFydGljdWxhciBvYmplY3QgY2FuIGJlIHNwZWNpZmVkIHVzaW5nIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggUmVuZGVyaW5nIGNhbnZhcyBjb250ZXh0XG4gICAgICovXG4gICAgX3NldHVwQ29tcG9zaXRlT3BlcmF0aW9uOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICBpZiAodGhpcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24pIHtcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgZmFicmljLnV0aWwuY3JlYXRlQWNjZXNzb3JzICYmIGZhYnJpYy51dGlsLmNyZWF0ZUFjY2Vzc29ycyhmYWJyaWMuT2JqZWN0KTtcblxuICBleHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIGZhYnJpYy5PYnNlcnZhYmxlKTtcblxuICAvKipcbiAgICogRGVmaW5lcyB0aGUgbnVtYmVyIG9mIGZyYWN0aW9uIGRpZ2l0cyB0byB1c2Ugd2hlbiBzZXJpYWxpemluZyBvYmplY3QgdmFsdWVzLlxuICAgKiBZb3UgY2FuIHVzZSBpdCB0byBpbmNyZWFzZS9kZWNyZWFzZSBwcmVjaXNpb24gb2Ygc3VjaCB2YWx1ZXMgbGlrZSBsZWZ0LCB0b3AsIHNjYWxlWCwgc2NhbGVZLCBldGMuXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3RcbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIE51bWJlclxuICAgKi9cbiAgZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTID0gMjtcblxuICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0ID0gZnVuY3Rpb24oY2xhc3NOYW1lLCBvYmplY3QsIGNhbGxiYWNrLCBleHRyYVBhcmFtKSB7XG4gICAgdmFyIGtsYXNzID0gZmFicmljW2NsYXNzTmFtZV07XG4gICAgb2JqZWN0ID0gY2xvbmUob2JqZWN0LCB0cnVlKTtcbiAgICBmYWJyaWMudXRpbC5lbmxpdmVuUGF0dGVybnMoW29iamVjdC5maWxsLCBvYmplY3Quc3Ryb2tlXSwgZnVuY3Rpb24ocGF0dGVybnMpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0dGVybnNbMF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9iamVjdC5maWxsID0gcGF0dGVybnNbMF07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBhdHRlcm5zWzFdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvYmplY3Quc3Ryb2tlID0gcGF0dGVybnNbMV07XG4gICAgICB9XG4gICAgICB2YXIgaW5zdGFuY2UgPSBleHRyYVBhcmFtID8gbmV3IGtsYXNzKG9iamVjdFtleHRyYVBhcmFtXSwgb2JqZWN0KSA6IG5ldyBrbGFzcyhvYmplY3QpO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soaW5zdGFuY2UpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbmlxdWUgaWQgdXNlZCBpbnRlcm5hbGx5IHdoZW4gY3JlYXRpbmcgU1ZHIGVsZW1lbnRzXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3RcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBmYWJyaWMuT2JqZWN0Ll9fdWlkID0gMDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICBvcmlnaW5YT2Zmc2V0ID0ge1xuICAgICAgICBsZWZ0OiAtMC41LFxuICAgICAgICBjZW50ZXI6IDAsXG4gICAgICAgIHJpZ2h0OiAwLjVcbiAgICAgIH0sXG4gICAgICBvcmlnaW5ZT2Zmc2V0ID0ge1xuICAgICAgICB0b3A6IC0wLjUsXG4gICAgICAgIGNlbnRlcjogMCxcbiAgICAgICAgYm90dG9tOiAwLjVcbiAgICAgIH07XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBjb29yZGluYXRlcyBmcm9tIGEgc2V0IG9mIG9yaWdpbiB0byBhbm90aGVyIChiYXNlZCBvbiB0aGUgb2JqZWN0J3MgZGltZW5zaW9ucylcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHdoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSBvcmlnaW5YIGFuZCBvcmlnaW5ZIHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tT3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZyb21PcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRvT3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRvT3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICB0cmFuc2xhdGVUb0dpdmVuT3JpZ2luOiBmdW5jdGlvbihwb2ludCwgZnJvbU9yaWdpblgsIGZyb21PcmlnaW5ZLCB0b09yaWdpblgsIHRvT3JpZ2luWSkge1xuICAgICAgdmFyIHggPSBwb2ludC54LFxuICAgICAgICAgIHkgPSBwb2ludC55LFxuICAgICAgICAgIG9mZnNldFgsIG9mZnNldFksIGRpbTtcblxuICAgICAgaWYgKHR5cGVvZiBmcm9tT3JpZ2luWCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZnJvbU9yaWdpblggPSBvcmlnaW5YT2Zmc2V0W2Zyb21PcmlnaW5YXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmcm9tT3JpZ2luWCAtPSAwLjU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdG9PcmlnaW5YID09PSAnc3RyaW5nJykge1xuICAgICAgICB0b09yaWdpblggPSBvcmlnaW5YT2Zmc2V0W3RvT3JpZ2luWF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdG9PcmlnaW5YIC09IDAuNTtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0WCA9IHRvT3JpZ2luWCAtIGZyb21PcmlnaW5YO1xuXG4gICAgICBpZiAodHlwZW9mIGZyb21PcmlnaW5ZID09PSAnc3RyaW5nJykge1xuICAgICAgICBmcm9tT3JpZ2luWSA9IG9yaWdpbllPZmZzZXRbZnJvbU9yaWdpblldO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZyb21PcmlnaW5ZIC09IDAuNTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0b09yaWdpblkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRvT3JpZ2luWSA9IG9yaWdpbllPZmZzZXRbdG9PcmlnaW5ZXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0b09yaWdpblkgLT0gMC41O1xuICAgICAgfVxuXG4gICAgICBvZmZzZXRZID0gdG9PcmlnaW5ZIC0gZnJvbU9yaWdpblk7XG5cbiAgICAgIGlmIChvZmZzZXRYIHx8IG9mZnNldFkpIHtcbiAgICAgICAgZGltID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCk7XG4gICAgICAgIHggPSBwb2ludC54ICsgb2Zmc2V0WCAqIGRpbS54O1xuICAgICAgICB5ID0gcG9pbnQueSArIG9mZnNldFkgKiBkaW0ueTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQoeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIGNvb3JkaW5hdGVzIGZyb20gb3JpZ2luIHRvIGNlbnRlciBjb29yZGluYXRlcyAoYmFzZWQgb24gdGhlIG9iamVjdCdzIGRpbWVuc2lvbnMpXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCB3aGljaCBjb3JyZXNwb25kcyB0byB0aGUgb3JpZ2luWCBhbmQgb3JpZ2luWSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgdHJhbnNsYXRlVG9DZW50ZXJQb2ludDogZnVuY3Rpb24ocG9pbnQsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBwID0gdGhpcy50cmFuc2xhdGVUb0dpdmVuT3JpZ2luKHBvaW50LCBvcmlnaW5YLCBvcmlnaW5ZLCAnY2VudGVyJywgJ2NlbnRlcicpO1xuICAgICAgaWYgKHRoaXMuYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnJvdGF0ZVBvaW50KHAsIHBvaW50LCBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBjb29yZGluYXRlcyBmcm9tIGNlbnRlciB0byBvcmlnaW4gY29vcmRpbmF0ZXMgKGJhc2VkIG9uIHRoZSBvYmplY3QncyBkaW1lbnNpb25zKVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBjZW50ZXIgVGhlIHBvaW50IHdoaWNoIGNvcnJlc3BvbmRzIHRvIGNlbnRlciBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQ6IGZ1bmN0aW9uKGNlbnRlciwgb3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIHAgPSB0aGlzLnRyYW5zbGF0ZVRvR2l2ZW5PcmlnaW4oY2VudGVyLCAnY2VudGVyJywgJ2NlbnRlcicsIG9yaWdpblgsIG9yaWdpblkpO1xuICAgICAgaWYgKHRoaXMuYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnJvdGF0ZVBvaW50KHAsIGNlbnRlciwgZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVhbCBjZW50ZXIgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVmdFRvcCA9IG5ldyBmYWJyaWMuUG9pbnQodGhpcy5sZWZ0LCB0aGlzLnRvcCk7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVUb0NlbnRlclBvaW50KGxlZnRUb3AsIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBiYXNlZCBvbiBjZW50ZXIgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHdoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSBvcmlnaW5YIGFuZCBvcmlnaW5ZIHBhcmFtc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICAvLyBnZXRPcmlnaW5Qb2ludDogZnVuY3Rpb24oY2VudGVyKSB7XG4gICAgLy8gICByZXR1cm4gdGhpcy50cmFuc2xhdGVUb09yaWdpblBvaW50KGNlbnRlciwgdGhpcy5vcmlnaW5YLCB0aGlzLm9yaWdpblkpO1xuICAgIC8vIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGFzIGlmIGl0IGhhcyBhIGRpZmZlcmVudCBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgZ2V0UG9pbnRCeU9yaWdpbjogZnVuY3Rpb24ob3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQoY2VudGVyLCBvcmlnaW5YLCBvcmlnaW5ZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9pbnQgaW4gbG9jYWwgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBnbG9iYWwgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgdG9Mb2NhbFBvaW50OiBmdW5jdGlvbihwb2ludCwgb3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSxcbiAgICAgICAgICBwLCBwMjtcblxuICAgICAgaWYgKHR5cGVvZiBvcmlnaW5YICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3JpZ2luWSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgIHAgPSB0aGlzLnRyYW5zbGF0ZVRvR2l2ZW5PcmlnaW4oY2VudGVyLCAnY2VudGVyJywgJ2NlbnRlcicsIG9yaWdpblgsIG9yaWdpblkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHAgPSBuZXcgZmFicmljLlBvaW50KHRoaXMubGVmdCwgdGhpcy50b3ApO1xuICAgICAgfVxuXG4gICAgICBwMiA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICBpZiAodGhpcy5hbmdsZSkge1xuICAgICAgICBwMiA9IGZhYnJpYy51dGlsLnJvdGF0ZVBvaW50KHAyLCBjZW50ZXIsIC1kZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwMi5zdWJ0cmFjdEVxdWFscyhwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9pbnQgaW4gZ2xvYmFsIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgLy8gdG9HbG9iYWxQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAvLyAgIHJldHVybiBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChwb2ludCwgdGhpcy5nZXRDZW50ZXJQb2ludCgpLCBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKS5hZGRFcXVhbHMobmV3IGZhYnJpYy5Qb2ludCh0aGlzLmxlZnQsIHRoaXMudG9wKSk7XG4gICAgLy8gfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBvYmplY3QgdGFraW5nIGludG8gY29uc2lkZXJhdGlvbiB0aGUgb2JqZWN0J3Mgb3JpZ2luXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvcyBUaGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIHNldFBvc2l0aW9uQnlPcmlnaW46IGZ1bmN0aW9uKHBvcywgb3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMudHJhbnNsYXRlVG9DZW50ZXJQb2ludChwb3MsIG9yaWdpblgsIG9yaWdpblkpLFxuICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy50cmFuc2xhdGVUb09yaWdpblBvaW50KGNlbnRlciwgdGhpcy5vcmlnaW5YLCB0aGlzLm9yaWdpblkpO1xuICAgICAgdGhpcy5zZXQoJ2xlZnQnLCBwb3NpdGlvbi54KTtcbiAgICAgIHRoaXMuc2V0KCd0b3AnLCBwb3NpdGlvbi55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRvIE9uZSBvZiAnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXG4gICAgICovXG4gICAgYWRqdXN0UG9zaXRpb246IGZ1bmN0aW9uKHRvKSB7XG4gICAgICB2YXIgYW5nbGUgPSBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpLFxuICAgICAgICAgIGh5cG90RnVsbCA9IHRoaXMuZ2V0U2NhbGVkV2lkdGgoKSxcbiAgICAgICAgICB4RnVsbCA9IGZhYnJpYy51dGlsLmNvcyhhbmdsZSkgKiBoeXBvdEZ1bGwsXG4gICAgICAgICAgeUZ1bGwgPSBmYWJyaWMudXRpbC5zaW4oYW5nbGUpICogaHlwb3RGdWxsLFxuICAgICAgICAgIG9mZnNldEZyb20sIG9mZnNldFRvO1xuXG4gICAgICAvL1RPRE86IHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY29uc2lkZXIgbWl4ZWQgc2l0dWF0aW9uIGxpa2UgdG9wLCBjZW50ZXIuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3JpZ2luWCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2Zmc2V0RnJvbSA9IG9yaWdpblhPZmZzZXRbdGhpcy5vcmlnaW5YXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvZmZzZXRGcm9tID0gdGhpcy5vcmlnaW5YIC0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0byA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2Zmc2V0VG8gPSBvcmlnaW5YT2Zmc2V0W3RvXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvZmZzZXRUbyA9IHRvIC0gMC41O1xuICAgICAgfVxuICAgICAgdGhpcy5sZWZ0ICs9IHhGdWxsICogKG9mZnNldFRvIC0gb2Zmc2V0RnJvbSk7XG4gICAgICB0aGlzLnRvcCArPSB5RnVsbCAqIChvZmZzZXRUbyAtIG9mZnNldEZyb20pO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMub3JpZ2luWCA9IHRvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBvcmlnaW4vcG9zaXRpb24gb2YgdGhlIG9iamVjdCB0byBpdCdzIGNlbnRlciBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBfc2V0T3JpZ2luVG9DZW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5YID0gdGhpcy5vcmlnaW5YO1xuICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5ZID0gdGhpcy5vcmlnaW5ZO1xuXG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXJQb2ludCgpO1xuXG4gICAgICB0aGlzLm9yaWdpblggPSAnY2VudGVyJztcbiAgICAgIHRoaXMub3JpZ2luWSA9ICdjZW50ZXInO1xuXG4gICAgICB0aGlzLmxlZnQgPSBjZW50ZXIueDtcbiAgICAgIHRoaXMudG9wID0gY2VudGVyLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgb3JpZ2luL3Bvc2l0aW9uIG9mIHRoZSBvYmplY3QgdG8gaXQncyBvcmlnaW5hbCBvcmlnaW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgX3Jlc2V0T3JpZ2luOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcmlnaW5Qb2ludCA9IHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChcbiAgICAgICAgdGhpcy5nZXRDZW50ZXJQb2ludCgpLFxuICAgICAgICB0aGlzLl9vcmlnaW5hbE9yaWdpblgsXG4gICAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWSk7XG5cbiAgICAgIHRoaXMub3JpZ2luWCA9IHRoaXMuX29yaWdpbmFsT3JpZ2luWDtcbiAgICAgIHRoaXMub3JpZ2luWSA9IHRoaXMuX29yaWdpbmFsT3JpZ2luWTtcblxuICAgICAgdGhpcy5sZWZ0ID0gb3JpZ2luUG9pbnQueDtcbiAgICAgIHRoaXMudG9wID0gb3JpZ2luUG9pbnQueTtcblxuICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5YID0gbnVsbDtcbiAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWSA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExlZnRUb3BDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludCh0aGlzLmdldENlbnRlclBvaW50KCksICdsZWZ0JywgJ3RvcCcpO1xuICAgIH0sXG4gIH0pO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBnZXRDb29yZHMoY29vcmRzKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLnRsLngsIGNvb3Jkcy50bC55KSxcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLnRyLngsIGNvb3Jkcy50ci55KSxcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLmJyLngsIGNvb3Jkcy5ici55KSxcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLmJsLngsIGNvb3Jkcy5ibC55KVxuICAgIF07XG4gIH1cblxuICB2YXIgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICBtdWx0aXBseU1hdHJpY2VzID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyxcbiAgICAgIHRyYW5zZm9ybVBvaW50ID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQ7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSBvYmplY3QncyBjb3JuZXIgcG9zaXRpb24gaW4gY2FudmFzIGVsZW1lbnQgY29vcmRpbmF0ZXMuXG4gICAgICogcHJvcGVydGllcyBhcmUgdGwsbXQsdHIsbWwsbXIsYmwsbWIsYnIsbXRyIGZvciB0aGUgbWFpbiBjb250cm9scy5cbiAgICAgKiBlYWNoIHByb3BlcnR5IGlzIGFuIG9iamVjdCB3aXRoIHgsIHkgYW5kIGNvcm5lci5cbiAgICAgKiBUaGUgYGNvcm5lcmAgcHJvcGVydHkgY29udGFpbnMgaW4gYSBzaW1pbGFyIG1hbm5lciB0aGUgNCBwb2ludHMgb2YgdGhlXG4gICAgICogaW50ZXJhY3RpdmUgYXJlYSBvZiB0aGUgY29ybmVyLlxuICAgICAqIFRoZSBjb29yZGluYXRlcyBkZXBlbmRzIGZyb20gdGhpcyBwcm9wZXJ0aWVzOiB3aWR0aCwgaGVpZ2h0LCBzY2FsZVgsIHNjYWxlWVxuICAgICAqIHNrZXdYLCBza2V3WSwgYW5nbGUsIHN0cm9rZVdpZHRoLCB2aWV3cG9ydFRyYW5zZm9ybSwgdG9wLCBsZWZ0LCBwYWRkaW5nLlxuICAgICAqIFRoZSBjb29yZGluYXRlcyBnZXQgdXBkYXRlZCB3aXRoIEBtZXRob2Qgc2V0Q29vcmRzLlxuICAgICAqIFlvdSBjYW4gY2FsY3VsYXRlIHRoZW0gd2l0aG91dCB1cGRhdGluZyB3aXRoIEBtZXRob2QgY2FsY0Nvb3JkcztcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBvQ29vcmRzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgb2JqZWN0J3MgY29ybmVyIHBvc2l0aW9uIGluIGNhbnZhcyBvYmplY3QgYWJzb2x1dGUgY29vcmRpbmF0ZXNcbiAgICAgKiBwcm9wZXJ0aWVzIGFyZSB0bCx0cixibCxiciBhbmQgZGVzY3JpYmUgdGhlIGZvdXIgbWFpbiBjb3JuZXIuXG4gICAgICogZWFjaCBwcm9wZXJ0eSBpcyBhbiBvYmplY3Qgd2l0aCB4LCB5LCBpbnN0YW5jZSBvZiBGYWJyaWMuUG9pbnQuXG4gICAgICogVGhlIGNvb3JkaW5hdGVzIGRlcGVuZHMgZnJvbSB0aGlzIHByb3BlcnRpZXM6IHdpZHRoLCBoZWlnaHQsIHNjYWxlWCwgc2NhbGVZXG4gICAgICogc2tld1gsIHNrZXdZLCBhbmdsZSwgc3Ryb2tlV2lkdGgsIHRvcCwgbGVmdC5cbiAgICAgKiBUaG9zZSBjb29yZGluYXRlcyBhcmUgdXNlZnVsbCB0byB1bmRlcnN0YW5kIHdoZXJlIGFuIG9iamVjdCBpcy4gVGhleSBnZXQgdXBkYXRlZFxuICAgICAqIHdpdGggb0Nvb3JkcyBidXQgdGhleSBkbyBub3QgbmVlZCB0byBiZSB1cGRhdGVkIHdoZW4gem9vbSBvciBwYW5uaW5nIGNoYW5nZS5cbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgZ2V0IHVwZGF0ZWQgd2l0aCBAbWV0aG9kIHNldENvb3Jkcy5cbiAgICAgKiBZb3UgY2FuIGNhbGN1bGF0ZSB0aGVtIHdpdGhvdXQgdXBkYXRpbmcgd2l0aCBAbWV0aG9kIGNhbGNDb29yZHModHJ1ZSk7XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICovXG4gICAgYUNvb3JkczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIHN0b3JhZ2UgZm9yIG9iamVjdCB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICovXG4gICAgb3duTWF0cml4Q2FjaGU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBzdG9yYWdlIGZvciBvYmplY3QgZnVsbCB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICovXG4gICAgbWF0cml4Q2FjaGU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gY29ycmVjdCBzZXQgb2YgY29vcmRpbmF0ZXMgZm9yIGludGVyc2VjdGlvblxuICAgICAqL1xuICAgIGdldENvb3JkczogZnVuY3Rpb24oYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgaWYgKCF0aGlzLm9Db29yZHMpIHtcbiAgICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb29yZHMgPSBhYnNvbHV0ZSA/IHRoaXMuYUNvb3JkcyA6IHRoaXMub0Nvb3JkcztcbiAgICAgIHJldHVybiBnZXRDb29yZHMoY2FsY3VsYXRlID8gdGhpcy5jYWxjQ29vcmRzKGFic29sdXRlKSA6IGNvb3Jkcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaW50ZXJzZWN0cyB3aXRoIGFuIGFyZWEgZm9ybWVkIGJ5IDIgcG9pbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50VEwgdG9wLWxlZnQgcG9pbnQgb2YgYXJlYVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludEJSIGJvdHRvbS1yaWdodCBwb2ludCBvZiBhcmVhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWJzb2x1dGVdIHVzZSBjb29yZGluYXRlcyB3aXRob3V0IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaW50ZXJzZWN0cyB3aXRoIGFuIGFyZWEgZm9ybWVkIGJ5IDIgcG9pbnRzXG4gICAgICovXG4gICAgaW50ZXJzZWN0c1dpdGhSZWN0OiBmdW5jdGlvbihwb2ludFRMLCBwb2ludEJSLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICB2YXIgY29vcmRzID0gdGhpcy5nZXRDb29yZHMoYWJzb2x1dGUsIGNhbGN1bGF0ZSksXG4gICAgICAgICAgaW50ZXJzZWN0aW9uID0gZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RQb2x5Z29uUmVjdGFuZ2xlKFxuICAgICAgICAgICAgY29vcmRzLFxuICAgICAgICAgICAgcG9pbnRUTCxcbiAgICAgICAgICAgIHBvaW50QlJcbiAgICAgICAgICApO1xuICAgICAgcmV0dXJuIGludGVyc2VjdGlvbi5zdGF0dXMgPT09ICdJbnRlcnNlY3Rpb24nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGludGVyc2VjdHMgd2l0aCBhbm90aGVyIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBPYmplY3QgdG8gdGVzdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Fic29sdXRlXSB1c2UgY29vcmRpbmF0ZXMgd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3Jkc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb2JqZWN0IGludGVyc2VjdHMgd2l0aCBhbm90aGVyIG9iamVjdFxuICAgICAqL1xuICAgIGludGVyc2VjdHNXaXRoT2JqZWN0OiBmdW5jdGlvbihvdGhlciwgYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0UG9seWdvblBvbHlnb24oXG4gICAgICAgIHRoaXMuZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpLFxuICAgICAgICBvdGhlci5nZXRDb29yZHMoYWJzb2x1dGUsIGNhbGN1bGF0ZSlcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb24uc3RhdHVzID09PSAnSW50ZXJzZWN0aW9uJ1xuICAgICAgICB8fCBvdGhlci5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdCh0aGlzLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKVxuICAgICAgICB8fCB0aGlzLmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KG90aGVyLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpcyBmdWxseSBjb250YWluZWQgd2l0aGluIGFyZWEgb2YgYW5vdGhlciBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgT2JqZWN0IHRvIHRlc3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthYnNvbHV0ZV0gdXNlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpcyBmdWxseSBjb250YWluZWQgd2l0aGluIGFyZWEgb2YgYW5vdGhlciBvYmplY3RcbiAgICAgKi9cbiAgICBpc0NvbnRhaW5lZFdpdGhpbk9iamVjdDogZnVuY3Rpb24ob3RoZXIsIGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldENvb3JkcyhhYnNvbHV0ZSwgY2FsY3VsYXRlKSxcbiAgICAgICAgICBpID0gMCwgbGluZXMgPSBvdGhlci5fZ2V0SW1hZ2VMaW5lcyhcbiAgICAgICAgICAgIGNhbGN1bGF0ZSA/IG90aGVyLmNhbGNDb29yZHMoYWJzb2x1dGUpIDogYWJzb2x1dGUgPyBvdGhlci5hQ29vcmRzIDogb3RoZXIub0Nvb3Jkc1xuICAgICAgICAgICk7XG4gICAgICBmb3IgKDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBpZiAoIW90aGVyLmNvbnRhaW5zUG9pbnQocG9pbnRzW2ldLCBsaW5lcykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGlzIGZ1bGx5IGNvbnRhaW5lZCB3aXRoaW4gYXJlYSBmb3JtZWQgYnkgMiBwb2ludHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRUTCB0b3AtbGVmdCBwb2ludCBvZiBhcmVhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50QlIgYm90dG9tLXJpZ2h0IHBvaW50IG9mIGFyZWFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthYnNvbHV0ZV0gdXNlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpcyBmdWxseSBjb250YWluZWQgd2l0aGluIGFyZWEgZm9ybWVkIGJ5IDIgcG9pbnRzXG4gICAgICovXG4gICAgaXNDb250YWluZWRXaXRoaW5SZWN0OiBmdW5jdGlvbihwb2ludFRMLCBwb2ludEJSLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICB2YXIgYm91bmRpbmdSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoYWJzb2x1dGUsIGNhbGN1bGF0ZSk7XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIGJvdW5kaW5nUmVjdC5sZWZ0ID49IHBvaW50VEwueCAmJlxuICAgICAgICBib3VuZGluZ1JlY3QubGVmdCArIGJvdW5kaW5nUmVjdC53aWR0aCA8PSBwb2ludEJSLnggJiZcbiAgICAgICAgYm91bmRpbmdSZWN0LnRvcCA+PSBwb2ludFRMLnkgJiZcbiAgICAgICAgYm91bmRpbmdSZWN0LnRvcCArIGJvdW5kaW5nUmVjdC5oZWlnaHQgPD0gcG9pbnRCUi55XG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgcG9pbnQgaXMgaW5zaWRlIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgUG9pbnQgdG8gY2hlY2sgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbbGluZXNdIG9iamVjdCByZXR1cm5lZCBmcm9tIEBtZXRob2QgX2dldEltYWdlTGluZXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthYnNvbHV0ZV0gdXNlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHBvaW50IGlzIGluc2lkZSB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24ocG9pbnQsIGxpbmVzLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICB2YXIgbGluZXMgPSBsaW5lcyB8fCB0aGlzLl9nZXRJbWFnZUxpbmVzKFxuICAgICAgICAgICAgY2FsY3VsYXRlID8gdGhpcy5jYWxjQ29vcmRzKGFic29sdXRlKSA6IGFic29sdXRlID8gdGhpcy5hQ29vcmRzIDogdGhpcy5vQ29vcmRzXG4gICAgICAgICAgKSxcbiAgICAgICAgICB4UG9pbnRzID0gdGhpcy5fZmluZENyb3NzUG9pbnRzKHBvaW50LCBsaW5lcyk7XG5cbiAgICAgIC8vIGlmIHhQb2ludHMgaXMgb2RkIHRoZW4gcG9pbnQgaXMgaW5zaWRlIHRoZSBvYmplY3RcbiAgICAgIHJldHVybiAoeFBvaW50cyAhPT0gMCAmJiB4UG9pbnRzICUgMiA9PT0gMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaXMgY29udGFpbmVkIHdpdGhpbiB0aGUgY2FudmFzIHdpdGggY3VycmVudCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIHRoZSBjaGVjayBpcyBkb25lIHN0b3BwaW5nIGF0IGZpcnN0IHBvaW50IHRoYXQgYXBwZWFycyBvbiBzY3JlZW5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpcyBmdWxseSBvciBwYXJ0aWFsbHkgY29udGFpbmVkIHdpdGhpbiBjYW52YXNcbiAgICAgKi9cbiAgICBpc09uU2NyZWVuOiBmdW5jdGlvbihjYWxjdWxhdGUpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHBvaW50VEwgPSB0aGlzLmNhbnZhcy52cHRDb29yZHMudGwsIHBvaW50QlIgPSB0aGlzLmNhbnZhcy52cHRDb29yZHMuYnI7XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5nZXRDb29yZHModHJ1ZSwgY2FsY3VsYXRlKSwgcG9pbnQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgaWYgKHBvaW50LnggPD0gcG9pbnRCUi54ICYmIHBvaW50LnggPj0gcG9pbnRUTC54ICYmIHBvaW50LnkgPD0gcG9pbnRCUi55ICYmIHBvaW50LnkgPj0gcG9pbnRUTC55KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIG5vIHBvaW50cyBvbiBzY3JlZW4sIGNoZWNrIGludGVyc2VjdGlvbiB3aXRoIGFic29sdXRlIGNvb3JkaW5hdGVzXG4gICAgICBpZiAodGhpcy5pbnRlcnNlY3RzV2l0aFJlY3QocG9pbnRUTCwgcG9pbnRCUiwgdHJ1ZSwgY2FsY3VsYXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9jb250YWluc0NlbnRlck9mQ2FudmFzKHBvaW50VEwsIHBvaW50QlIsIGNhbGN1bGF0ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBtaWRwb2ludCBiZXR3ZWVuIGNhbnZhcyBleHRyZW1pdGllc1xuICAgICAqIERvZXMgbm90IG1ha2Ugc2Vuc2Ugb3V0c2lkZSB0aGUgY29udGV4dCBvZiBpc09uU2NyZWVuIGFuZCBpc1BhcnRpYWxseU9uU2NyZWVuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0ZhYnJpYy5Qb2ludH0gcG9pbnRUTCBUb3AgTGVmdCBwb2ludFxuICAgICAqIEBwYXJhbSB7RmFicmljLlBvaW50fSBwb2ludEJSIFRvcCBSaWdodCBwb2ludFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FsY3VsYXRlIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBvYmplY3RzIGNvbnRhaW5lIHRoZSBwb2ludFxuICAgICAqL1xuICAgIF9jb250YWluc0NlbnRlck9mQ2FudmFzOiBmdW5jdGlvbihwb2ludFRMLCBwb2ludEJSLCBjYWxjdWxhdGUpIHtcbiAgICAgIC8vIHdvcnN0IGNhc2Ugc2NlbmFyaW8gdGhlIG9iamVjdCBpcyBzbyBiaWcgdGhhdCBjb250YWlucyB0aGUgc2NyZWVuXG4gICAgICB2YXIgY2VudGVyUG9pbnQgPSB7IHg6IChwb2ludFRMLnggKyBwb2ludEJSLngpIC8gMiwgeTogKHBvaW50VEwueSArIHBvaW50QlIueSkgLyAyIH07XG4gICAgICBpZiAodGhpcy5jb250YWluc1BvaW50KGNlbnRlclBvaW50LCBudWxsLCB0cnVlLCBjYWxjdWxhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGlzIHBhcnRpYWxseSBjb250YWluZWQgd2l0aGluIHRoZSBjYW52YXMgd2l0aCBjdXJyZW50IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaXMgcGFydGlhbGx5IGNvbnRhaW5lZCB3aXRoaW4gY2FudmFzXG4gICAgICovXG4gICAgaXNQYXJ0aWFsbHlPblNjcmVlbjogZnVuY3Rpb24oY2FsY3VsYXRlKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwb2ludFRMID0gdGhpcy5jYW52YXMudnB0Q29vcmRzLnRsLCBwb2ludEJSID0gdGhpcy5jYW52YXMudnB0Q29vcmRzLmJyO1xuICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0c1dpdGhSZWN0KHBvaW50VEwsIHBvaW50QlIsIHRydWUsIGNhbGN1bGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fY29udGFpbnNDZW50ZXJPZkNhbnZhcyhwb2ludFRMLCBwb2ludEJSLCBjYWxjdWxhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBvYmplY3QgZWRnZXMgaW4gaXQsIGdpdmVuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgY29ybmVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9Db29yZHMgQ29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBjb3JuZXJzXG4gICAgICovXG4gICAgX2dldEltYWdlTGluZXM6IGZ1bmN0aW9uKG9Db29yZHMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcGxpbmU6IHtcbiAgICAgICAgICBvOiBvQ29vcmRzLnRsLFxuICAgICAgICAgIGQ6IG9Db29yZHMudHJcbiAgICAgICAgfSxcbiAgICAgICAgcmlnaHRsaW5lOiB7XG4gICAgICAgICAgbzogb0Nvb3Jkcy50cixcbiAgICAgICAgICBkOiBvQ29vcmRzLmJyXG4gICAgICAgIH0sXG4gICAgICAgIGJvdHRvbWxpbmU6IHtcbiAgICAgICAgICBvOiBvQ29vcmRzLmJyLFxuICAgICAgICAgIGQ6IG9Db29yZHMuYmxcbiAgICAgICAgfSxcbiAgICAgICAgbGVmdGxpbmU6IHtcbiAgICAgICAgICBvOiBvQ29vcmRzLmJsLFxuICAgICAgICAgIGQ6IG9Db29yZHMudGxcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBkZXRlcm1pbmUgaG93IG1hbnkgY3Jvc3MgcG9pbnRzIGFyZSBiZXR3ZWVuIHRoZSA0IG9iamVjdCBlZGdlc1xuICAgICAqIGFuZCB0aGUgaG9yaXpvbnRhbCBsaW5lIGRldGVybWluZWQgYnkgYSBwb2ludCBvbiBjYW52YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBQb2ludCB0byBjaGVja1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsaW5lcyBDb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGJlaW5nIGV2YWx1YXRlZFxuICAgICAqL1xuICAgIC8vIHJlbW92ZSB5aSwgbm90IHVzZWQgYnV0IGxlZnQgY29kZSBoZXJlIGp1c3QgaW4gY2FzZS5cbiAgICBfZmluZENyb3NzUG9pbnRzOiBmdW5jdGlvbihwb2ludCwgbGluZXMpIHtcbiAgICAgIHZhciBiMSwgYjIsIGExLCBhMiwgeGksIC8vIHlpLFxuICAgICAgICAgIHhjb3VudCA9IDAsXG4gICAgICAgICAgaUxpbmU7XG5cbiAgICAgIGZvciAodmFyIGxpbmVLZXkgaW4gbGluZXMpIHtcbiAgICAgICAgaUxpbmUgPSBsaW5lc1tsaW5lS2V5XTtcbiAgICAgICAgLy8gb3B0aW1pc2F0aW9uIDE6IGxpbmUgYmVsb3cgcG9pbnQuIG5vIGNyb3NzXG4gICAgICAgIGlmICgoaUxpbmUuby55IDwgcG9pbnQueSkgJiYgKGlMaW5lLmQueSA8IHBvaW50LnkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3B0aW1pc2F0aW9uIDI6IGxpbmUgYWJvdmUgcG9pbnQuIG5vIGNyb3NzXG4gICAgICAgIGlmICgoaUxpbmUuby55ID49IHBvaW50LnkpICYmIChpTGluZS5kLnkgPj0gcG9pbnQueSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvcHRpbWlzYXRpb24gMzogdmVydGljYWwgbGluZSBjYXNlXG4gICAgICAgIGlmICgoaUxpbmUuby54ID09PSBpTGluZS5kLngpICYmIChpTGluZS5vLnggPj0gcG9pbnQueCkpIHtcbiAgICAgICAgICB4aSA9IGlMaW5lLm8ueDtcbiAgICAgICAgICAvLyB5aSA9IHBvaW50Lnk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYjEgPSAwO1xuICAgICAgICAgIGIyID0gKGlMaW5lLmQueSAtIGlMaW5lLm8ueSkgLyAoaUxpbmUuZC54IC0gaUxpbmUuby54KTtcbiAgICAgICAgICBhMSA9IHBvaW50LnkgLSBiMSAqIHBvaW50Lng7XG4gICAgICAgICAgYTIgPSBpTGluZS5vLnkgLSBiMiAqIGlMaW5lLm8ueDtcblxuICAgICAgICAgIHhpID0gLShhMSAtIGEyKSAvIChiMSAtIGIyKTtcbiAgICAgICAgICAvLyB5aSA9IGExICsgYjEgKiB4aTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkb250IGNvdW50IHhpIDwgcG9pbnQueCBjYXNlc1xuICAgICAgICBpZiAoeGkgPj0gcG9pbnQueCkge1xuICAgICAgICAgIHhjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9wdGltaXNhdGlvbiA0OiBzcGVjaWZpYyBmb3Igc3F1YXJlIGltYWdlc1xuICAgICAgICBpZiAoeGNvdW50ID09PSAyKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB4Y291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29vcmRpbmF0ZXMgb2Ygb2JqZWN0J3MgYm91bmRpbmcgcmVjdGFuZ2xlIChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpXG4gICAgICogdGhlIGJveCBpcyBpbnRlbnRlZCBhcyBhbGlnbmVkIHRvIGF4aXMgb2YgY2FudmFzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Fic29sdXRlXSB1c2UgY29vcmRpbmF0ZXMgd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3JkcyAvIC5hQ29vcmRzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24oYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpO1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLm1ha2VCb3VuZGluZ0JveEZyb21Qb2ludHMoY29vcmRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aWR0aCBvZiBhbiBvYmplY3QgYm91bmRpbmcgYm94IGNvdW50aW5nIHRyYW5zZm9ybWF0aW9uc1xuICAgICAqIGJlZm9yZSAyLjAgaXQgd2FzIG5hbWVkIGdldFdpZHRoKCk7XG4gICAgICogQHJldHVybiB7TnVtYmVyfSB3aWR0aCB2YWx1ZVxuICAgICAqL1xuICAgIGdldFNjYWxlZFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKS54O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGhlaWdodCBvZiBhbiBvYmplY3QgYm91bmRpbmcgYm94IGNvdW50aW5nIHRyYW5zZm9ybWF0aW9uc1xuICAgICAqIGJlZm9yZSAyLjAgaXQgd2FzIG5hbWVkIGdldEhlaWdodCgpO1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gaGVpZ2h0IHZhbHVlXG4gICAgICovXG4gICAgZ2V0U2NhbGVkSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKS55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBzdXJlIHRoZSBzY2FsZSBpcyB2YWxpZCBhbmQgbW9kaWZpZXMgaXQgaWYgbmVjZXNzYXJ5XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgX2NvbnN0cmFpblNjYWxlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKE1hdGguYWJzKHZhbHVlKSA8IHRoaXMubWluU2NhbGVMaW1pdCkge1xuICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIC10aGlzLm1pblNjYWxlTGltaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWluU2NhbGVMaW1pdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDAuMDAwMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIGFuIG9iamVjdCAoZXF1YWxseSBieSB4IGFuZCB5KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBTY2FsZSBmYWN0b3JcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNjYWxlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0KCdzY2FsZVgnLCB2YWx1ZSk7XG4gICAgICB0aGlzLl9zZXQoJ3NjYWxlWScsIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzLnNldENvb3JkcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgYW4gb2JqZWN0IHRvIGEgZ2l2ZW4gd2lkdGgsIHdpdGggcmVzcGVjdCB0byBib3VuZGluZyBib3ggKHNjYWxpbmcgYnkgeC95IGVxdWFsbHkpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIE5ldyB3aWR0aCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWJzb2x1dGUgaWdub3JlIHZpZXdwb3J0XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsZVRvV2lkdGg6IGZ1bmN0aW9uKHZhbHVlLCBhYnNvbHV0ZSkge1xuICAgICAgLy8gYWRqdXN0IHRvIGJvdW5kaW5nIHJlY3QgZmFjdG9yIHNvIHRoYXQgcm90YXRlZCBzaGFwZXMgd291bGQgZml0IGFzIHdlbGxcbiAgICAgIHZhciBib3VuZGluZ1JlY3RGYWN0b3IgPSB0aGlzLmdldEJvdW5kaW5nUmVjdChhYnNvbHV0ZSkud2lkdGggLyB0aGlzLmdldFNjYWxlZFdpZHRoKCk7XG4gICAgICByZXR1cm4gdGhpcy5zY2FsZSh2YWx1ZSAvIHRoaXMud2lkdGggLyBib3VuZGluZ1JlY3RGYWN0b3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgYW4gb2JqZWN0IHRvIGEgZ2l2ZW4gaGVpZ2h0LCB3aXRoIHJlc3BlY3QgdG8gYm91bmRpbmcgYm94IChzY2FsaW5nIGJ5IHgveSBlcXVhbGx5KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBOZXcgaGVpZ2h0IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhYnNvbHV0ZSBpZ25vcmUgdmlld3BvcnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNjYWxlVG9IZWlnaHQ6IGZ1bmN0aW9uKHZhbHVlLCBhYnNvbHV0ZSkge1xuICAgICAgLy8gYWRqdXN0IHRvIGJvdW5kaW5nIHJlY3QgZmFjdG9yIHNvIHRoYXQgcm90YXRlZCBzaGFwZXMgd291bGQgZml0IGFzIHdlbGxcbiAgICAgIHZhciBib3VuZGluZ1JlY3RGYWN0b3IgPSB0aGlzLmdldEJvdW5kaW5nUmVjdChhYnNvbHV0ZSkuaGVpZ2h0IC8gdGhpcy5nZXRTY2FsZWRIZWlnaHQoKTtcbiAgICAgIHJldHVybiB0aGlzLnNjYWxlKHZhbHVlIC8gdGhpcy5oZWlnaHQgLyBib3VuZGluZ1JlY3RGYWN0b3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgYW5kIHJldHVybnMgdGhlIC5jb29yZHMgb2YgYW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggdGwsIHRyLCBiciwgYmwgLi4uLlxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjYWxjQ29vcmRzOiBmdW5jdGlvbihhYnNvbHV0ZSkge1xuICAgICAgdmFyIHJvdGF0ZU1hdHJpeCA9IHRoaXMuX2NhbGNSb3RhdGVNYXRyaXgoKSxcbiAgICAgICAgICB0cmFuc2xhdGVNYXRyaXggPSB0aGlzLl9jYWxjVHJhbnNsYXRlTWF0cml4KCksXG4gICAgICAgICAgc3RhcnRNYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKHRyYW5zbGF0ZU1hdHJpeCwgcm90YXRlTWF0cml4KSxcbiAgICAgICAgICB2cHQgPSB0aGlzLmdldFZpZXdwb3J0VHJhbnNmb3JtKCksXG4gICAgICAgICAgZmluYWxNYXRyaXggPSBhYnNvbHV0ZSA/IHN0YXJ0TWF0cml4IDogbXVsdGlwbHlNYXRyaWNlcyh2cHQsIHN0YXJ0TWF0cml4KSxcbiAgICAgICAgICBkaW0gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKSxcbiAgICAgICAgICB3ID0gZGltLnggLyAyLCBoID0gZGltLnkgLyAyLFxuICAgICAgICAgIHRsID0gdHJhbnNmb3JtUG9pbnQoeyB4OiAtdywgeTogLWggfSwgZmluYWxNYXRyaXgpLFxuICAgICAgICAgIHRyID0gdHJhbnNmb3JtUG9pbnQoeyB4OiB3LCB5OiAtaCB9LCBmaW5hbE1hdHJpeCksXG4gICAgICAgICAgYmwgPSB0cmFuc2Zvcm1Qb2ludCh7IHg6IC13LCB5OiBoIH0sIGZpbmFsTWF0cml4KSxcbiAgICAgICAgICBiciA9IHRyYW5zZm9ybVBvaW50KHsgeDogdywgeTogaCB9LCBmaW5hbE1hdHJpeCk7XG4gICAgICBpZiAoIWFic29sdXRlKSB7XG4gICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5wYWRkaW5nLCBhbmdsZSA9IGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSksXG4gICAgICAgICAgICBjb3MgPSBmYWJyaWMudXRpbC5jb3MoYW5nbGUpLCBzaW4gPSBmYWJyaWMudXRpbC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgY29zUCA9IGNvcyAqIHBhZGRpbmcsIHNpblAgPSBzaW4gKiBwYWRkaW5nLCBjb3NQU2luUCA9IGNvc1AgKyBzaW5QLFxuICAgICAgICAgICAgY29zUE1pbnVzU2luUCA9IGNvc1AgLSBzaW5QO1xuICAgICAgICBpZiAocGFkZGluZykge1xuICAgICAgICAgIHRsLnggLT0gY29zUE1pbnVzU2luUDtcbiAgICAgICAgICB0bC55IC09IGNvc1BTaW5QO1xuICAgICAgICAgIHRyLnggKz0gY29zUFNpblA7XG4gICAgICAgICAgdHIueSAtPSBjb3NQTWludXNTaW5QO1xuICAgICAgICAgIGJsLnggLT0gY29zUFNpblA7XG4gICAgICAgICAgYmwueSArPSBjb3NQTWludXNTaW5QO1xuICAgICAgICAgIGJyLnggKz0gY29zUE1pbnVzU2luUDtcbiAgICAgICAgICBici55ICs9IGNvc1BTaW5QO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtbCAgPSBuZXcgZmFicmljLlBvaW50KCh0bC54ICsgYmwueCkgLyAyLCAodGwueSArIGJsLnkpIC8gMiksXG4gICAgICAgICAgICBtdCAgPSBuZXcgZmFicmljLlBvaW50KCh0ci54ICsgdGwueCkgLyAyLCAodHIueSArIHRsLnkpIC8gMiksXG4gICAgICAgICAgICBtciAgPSBuZXcgZmFicmljLlBvaW50KChici54ICsgdHIueCkgLyAyLCAoYnIueSArIHRyLnkpIC8gMiksXG4gICAgICAgICAgICBtYiAgPSBuZXcgZmFicmljLlBvaW50KChici54ICsgYmwueCkgLyAyLCAoYnIueSArIGJsLnkpIC8gMiksXG4gICAgICAgICAgICBtdHIgPSBuZXcgZmFicmljLlBvaW50KG10LnggKyBzaW4gKiB0aGlzLnJvdGF0aW5nUG9pbnRPZmZzZXQsIG10LnkgLSBjb3MgKiB0aGlzLnJvdGF0aW5nUG9pbnRPZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiAoIWFic29sdXRlKSB7XG4gICAgICAvLyAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIC8vICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIC8vICAgICBjYW52YXMuY29udGV4dFRvcC5jbGVhclJlY3QoMCwgMCwgNzAwLCA3MDApO1xuICAgICAgLy8gICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxTdHlsZSA9ICdncmVlbic7XG4gICAgICAvLyAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobWIueCwgbWIueSwgMywgMyk7XG4gICAgICAvLyAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QoYmwueCwgYmwueSwgMywgMyk7XG4gICAgICAvLyAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QoYnIueCwgYnIueSwgMywgMyk7XG4gICAgICAvLyAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QodGwueCwgdGwueSwgMywgMyk7XG4gICAgICAvLyAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QodHIueCwgdHIueSwgMywgMyk7XG4gICAgICAvLyAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobWwueCwgbWwueSwgMywgMyk7XG4gICAgICAvLyAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobXIueCwgbXIueSwgMywgMyk7XG4gICAgICAvLyAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobXQueCwgbXQueSwgMywgMyk7XG4gICAgICAvLyAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobXRyLngsIG10ci55LCAzLCAzKTtcbiAgICAgIC8vICAgfSwgNTApO1xuICAgICAgLy8gfVxuXG4gICAgICB2YXIgY29vcmRzID0ge1xuICAgICAgICAvLyBjb3JuZXJzXG4gICAgICAgIHRsOiB0bCwgdHI6IHRyLCBicjogYnIsIGJsOiBibCxcbiAgICAgIH07XG4gICAgICBpZiAoIWFic29sdXRlKSB7XG4gICAgICAgIC8vIG1pZGRsZVxuICAgICAgICBjb29yZHMubWwgPSBtbDtcbiAgICAgICAgY29vcmRzLm10ID0gbXQ7XG4gICAgICAgIGNvb3Jkcy5tciA9IG1yO1xuICAgICAgICBjb29yZHMubWIgPSBtYjtcbiAgICAgICAgLy8gcm90YXRpbmcgcG9pbnRcbiAgICAgICAgY29vcmRzLm10ciA9IG10cjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb29yZHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY29ybmVyIHBvc2l0aW9uIGNvb3JkaW5hdGVzIGJhc2VkIG9uIGN1cnJlbnQgYW5nbGUsIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2thbmdheC9mYWJyaWMuanMvd2lraS9XaGVuLXRvLWNhbGwtc2V0Q29vcmRzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaWdub3JlWm9vbV0gc2V0IG9Db29yZHMgd2l0aCBvciB3aXRob3V0IHRoZSB2aWV3cG9ydCB0cmFuc2Zvcm0uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2tpcEFic29sdXRlXSBza2lwIGNhbGN1bGF0aW9uIG9mIGFDb29yZHMsIHVzZWZ1bGwgaW4gc2V0Vmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENvb3JkczogZnVuY3Rpb24oaWdub3JlWm9vbSwgc2tpcEFic29sdXRlKSB7XG4gICAgICB0aGlzLm9Db29yZHMgPSB0aGlzLmNhbGNDb29yZHMoaWdub3JlWm9vbSk7XG4gICAgICBpZiAoIXNraXBBYnNvbHV0ZSkge1xuICAgICAgICB0aGlzLmFDb29yZHMgPSB0aGlzLmNhbGNDb29yZHModHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBjb29yZGluYXRlcyBvZiB0aGUgZHJhZ2dhYmxlIGJveGVzIGluIHRoZSBjb3JuZXJzIHVzZWQgdG8gc2NhbGUvcm90YXRlIHRoZSBpbWFnZVxuICAgICAgaWdub3JlWm9vbSB8fCAodGhpcy5fc2V0Q29ybmVyQ29vcmRzICYmIHRoaXMuX3NldENvcm5lckNvb3JkcygpKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSByb3RhdGlvbiBtYXRyaXggb2YgYW4gb2JqZWN0XG4gICAgICogQHJldHVybiB7QXJyYXl9IHJvdGF0aW9uIG1hdHJpeCBmb3IgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIF9jYWxjUm90YXRlTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHZhciB0aGV0YSA9IGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSksIGNvcyA9IGZhYnJpYy51dGlsLmNvcyh0aGV0YSksIHNpbiA9IGZhYnJpYy51dGlsLnNpbih0aGV0YSk7XG4gICAgICAgIHJldHVybiBbY29zLCBzaW4sIC1zaW4sIGNvcywgMCwgMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFicmljLmlNYXRyaXguY29uY2F0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSB0aGUgdHJhbnNsYXRpb24gbWF0cml4IGZvciBhbiBvYmplY3QgdHJhbnNmb3JtXG4gICAgICogQHJldHVybiB7QXJyYXl9IHJvdGF0aW9uIG1hdHJpeCBmb3IgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIF9jYWxjVHJhbnNsYXRlTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCk7XG4gICAgICByZXR1cm4gWzEsIDAsIDAsIDEsIGNlbnRlci54LCBjZW50ZXIueV07XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybU1hdHJpeEtleTogZnVuY3Rpb24oc2tpcEdyb3VwKSB7XG4gICAgICB2YXIgc2VwID0gJ18nLCBwcmVmaXggPSAnJztcbiAgICAgIGlmICghc2tpcEdyb3VwICYmIHRoaXMuZ3JvdXApIHtcbiAgICAgICAgcHJlZml4ID0gdGhpcy5ncm91cC50cmFuc2Zvcm1NYXRyaXhLZXkoc2tpcEdyb3VwKSArIHNlcDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcHJlZml4ICsgdGhpcy50b3AgKyBzZXAgKyB0aGlzLmxlZnQgKyBzZXAgKyB0aGlzLnNjYWxlWCArIHNlcCArIHRoaXMuc2NhbGVZICtcbiAgICAgICAgc2VwICsgdGhpcy5za2V3WCArIHNlcCArIHRoaXMuc2tld1kgKyBzZXAgKyB0aGlzLmFuZ2xlICsgc2VwICsgdGhpcy5vcmlnaW5YICsgc2VwICsgdGhpcy5vcmlnaW5ZICtcbiAgICAgICAgc2VwICsgdGhpcy53aWR0aCArIHNlcCArIHRoaXMuaGVpZ2h0ICsgc2VwICsgdGhpcy5zdHJva2VXaWR0aCArIHRoaXMuZmxpcFggKyB0aGlzLmZsaXBZO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgdHJhc2Zvcm0gTWF0cml4IHRoYXQgcmVwcmVzZW50IGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gZnJvbVxuICAgICAqIG9iamVjdCBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBHcm91cF0gcmV0dXJuIHRyYW5zZm9ybU1hdHJpeCBmb3Igb2JqZWN0IGFuZCBub3QgZ28gdXB3YXJkIHdpdGggcGFyZW50c1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBtYXRyaXggVHJhbnNmb3JtIE1hdHJpeCBmb3IgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNhbGNUcmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uKHNraXBHcm91cCkge1xuICAgICAgaWYgKHNraXBHcm91cCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxjT3duTWF0cml4KCk7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdGhpcy50cmFuc2Zvcm1NYXRyaXhLZXkoKSwgY2FjaGUgPSB0aGlzLm1hdHJpeENhY2hlIHx8ICh0aGlzLm1hdHJpeENhY2hlID0ge30pO1xuICAgICAgaWYgKGNhY2hlLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiBjYWNoZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLmNhbGNPd25NYXRyaXgoKTtcbiAgICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICAgIG1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXModGhpcy5ncm91cC5jYWxjVHJhbnNmb3JtTWF0cml4KCksIG1hdHJpeCk7XG4gICAgICB9XG4gICAgICBjYWNoZS5rZXkgPSBrZXk7XG4gICAgICBjYWNoZS52YWx1ZSA9IG1hdHJpeDtcbiAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfSxcblxuICAgIGNhbGNPd25NYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGtleSA9IHRoaXMudHJhbnNmb3JtTWF0cml4S2V5KHRydWUpLCBjYWNoZSA9IHRoaXMub3duTWF0cml4Q2FjaGUgfHwgKHRoaXMub3duTWF0cml4Q2FjaGUgPSB7fSk7XG4gICAgICBpZiAoY2FjaGUua2V5ID09PSBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLnZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuX2NhbGNUcmFuc2xhdGVNYXRyaXgoKSxcbiAgICAgICAgICByb3RhdGVNYXRyaXgsXG4gICAgICAgICAgZGltZW5zaW9uTWF0cml4ID0gdGhpcy5fY2FsY0RpbWVuc2lvbnNUcmFuc2Zvcm1NYXRyaXgodGhpcy5za2V3WCwgdGhpcy5za2V3WSwgdHJ1ZSk7XG4gICAgICBpZiAodGhpcy5hbmdsZSkge1xuICAgICAgICByb3RhdGVNYXRyaXggPSB0aGlzLl9jYWxjUm90YXRlTWF0cml4KCk7XG4gICAgICAgIG1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXMobWF0cml4LCByb3RhdGVNYXRyaXgpO1xuICAgICAgfVxuICAgICAgbWF0cml4ID0gbXVsdGlwbHlNYXRyaWNlcyhtYXRyaXgsIGRpbWVuc2lvbk1hdHJpeCk7XG4gICAgICBjYWNoZS5rZXkgPSBrZXk7XG4gICAgICBjYWNoZS52YWx1ZSA9IG1hdHJpeDtcbiAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfSxcblxuICAgIF9jYWxjRGltZW5zaW9uc1RyYW5zZm9ybU1hdHJpeDogZnVuY3Rpb24oc2tld1gsIHNrZXdZLCBmbGlwcGluZykge1xuICAgICAgdmFyIHNrZXdNYXRyaXgsXG4gICAgICAgICAgc2NhbGVYID0gdGhpcy5zY2FsZVggKiAoZmxpcHBpbmcgJiYgdGhpcy5mbGlwWCA/IC0xIDogMSksXG4gICAgICAgICAgc2NhbGVZID0gdGhpcy5zY2FsZVkgKiAoZmxpcHBpbmcgJiYgdGhpcy5mbGlwWSA/IC0xIDogMSksXG4gICAgICAgICAgc2NhbGVNYXRyaXggPSBbc2NhbGVYLCAwLCAwLCBzY2FsZVksIDAsIDBdO1xuICAgICAgaWYgKHNrZXdYKSB7XG4gICAgICAgIHNrZXdNYXRyaXggPSBbMSwgMCwgTWF0aC50YW4oZGVncmVlc1RvUmFkaWFucyhza2V3WCkpLCAxXTtcbiAgICAgICAgc2NhbGVNYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKHNjYWxlTWF0cml4LCBza2V3TWF0cml4LCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChza2V3WSkge1xuICAgICAgICBza2V3TWF0cml4ID0gWzEsIE1hdGgudGFuKGRlZ3JlZXNUb1JhZGlhbnMoc2tld1kpKSwgMCwgMV07XG4gICAgICAgIHNjYWxlTWF0cml4ID0gbXVsdGlwbHlNYXRyaWNlcyhzY2FsZU1hdHJpeCwgc2tld01hdHJpeCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NhbGVNYXRyaXg7XG4gICAgfSxcblxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGRpbWVuc2lvbnMgZnJvbSBpdHMgcHJvcGVydGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueCB3aWR0aCBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC55IGhlaWdodCBkaW1lbnNpb25cbiAgICAgKi9cbiAgICBfZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGggKyBzdHJva2VXaWR0aCxcbiAgICAgICAgICBoID0gdGhpcy5oZWlnaHQgKyBzdHJva2VXaWR0aDtcbiAgICAgIHJldHVybiB7IHg6IHcsIHk6IGggfTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGJvdW5kaW5nIGJveGRpbWVuc2lvbnMgZnJvbSBpdHMgcHJvcGVydGllcyBzY2FsZSwgc2tldy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLnggd2lkdGggZGltZW5zaW9uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueSBoZWlnaHQgZGltZW5zaW9uXG4gICAgICovXG4gICAgX2dldFRyYW5zZm9ybWVkRGltZW5zaW9uczogZnVuY3Rpb24oc2tld1gsIHNrZXdZKSB7XG4gICAgICBpZiAodHlwZW9mIHNrZXdYID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBza2V3WCA9IHRoaXMuc2tld1g7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHNrZXdZID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBza2V3WSA9IHRoaXMuc2tld1k7XG4gICAgICB9XG4gICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICAgICAgaWYgKHNrZXdYID09PSAwICYmIHNrZXdZID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHg6IGRpbWVuc2lvbnMueCAqIHRoaXMuc2NhbGVYLCB5OiBkaW1lbnNpb25zLnkgKiB0aGlzLnNjYWxlWSB9O1xuICAgICAgfVxuICAgICAgdmFyIGRpbVggPSBkaW1lbnNpb25zLnggLyAyLCBkaW1ZID0gZGltZW5zaW9ucy55IC8gMixcbiAgICAgICAgICBwb2ludHMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IC1kaW1YLFxuICAgICAgICAgICAgICB5OiAtZGltWVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogZGltWCxcbiAgICAgICAgICAgICAgeTogLWRpbVlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IC1kaW1YLFxuICAgICAgICAgICAgICB5OiBkaW1ZXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiBkaW1YLFxuICAgICAgICAgICAgICB5OiBkaW1ZXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICBpLCB0cmFuc2Zvcm1NYXRyaXggPSB0aGlzLl9jYWxjRGltZW5zaW9uc1RyYW5zZm9ybU1hdHJpeChza2V3WCwgc2tld1ksIGZhbHNlKSxcbiAgICAgICAgICBiYm94O1xuICAgICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb2ludHNbaV0gPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwb2ludHNbaV0sIHRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICB9XG4gICAgICBiYm94ID0gZmFicmljLnV0aWwubWFrZUJvdW5kaW5nQm94RnJvbVBvaW50cyhwb2ludHMpO1xuICAgICAgcmV0dXJuIHsgeDogYmJveC53aWR0aCwgeTogYmJveC5oZWlnaHQgfTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGRpbWVuc2lvbnMgZm9yIGNvbnRyb2xzLiBpbmNsdWRlIHBhZGRpbmcgYW5kIGNhbnZhcyB6b29tXG4gICAgICogcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVDdXJyZW50RGltZW5zaW9uczogZnVuY3Rpb24oKSAge1xuICAgICAgdmFyIHZwdCA9IHRoaXMuZ2V0Vmlld3BvcnRUcmFuc2Zvcm0oKSxcbiAgICAgICAgICBkaW0gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKSxcbiAgICAgICAgICBwID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoZGltLCB2cHQsIHRydWUpO1xuXG4gICAgICByZXR1cm4gcC5zY2FsYXJBZGQoMiAqIHRoaXMucGFkZGluZyk7XG4gICAgfSxcbiAgfSk7XG59KSgpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgdG8gdGhlIGJvdHRvbSBvZiB0aGUgc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHNlbmRUb0JhY2s6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5zZW5kVG9CYWNrLmNhbGwodGhpcy5ncm91cCwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXMuc2VuZFRvQmFjayh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgYnJpbmdUb0Zyb250OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuYnJpbmdUb0Zyb250LmNhbGwodGhpcy5ncm91cCwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXMuYnJpbmdUb0Zyb250KHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgYW4gb2JqZWN0IGRvd24gaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgYmVoaW5kIG5leHQgbG93ZXIgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHNlbmRCYWNrd2FyZHM6IGZ1bmN0aW9uKGludGVyc2VjdGluZykge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5zZW5kQmFja3dhcmRzLmNhbGwodGhpcy5ncm91cCwgdGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmNhbnZhcy5zZW5kQmFja3dhcmRzKHRoaXMsIGludGVyc2VjdGluZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgdXAgaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgaW4gZnJvbnQgb2YgbmV4dCB1cHBlciBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgYnJpbmdGb3J3YXJkOiBmdW5jdGlvbihpbnRlcnNlY3RpbmcpIHtcbiAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuYnJpbmdGb3J3YXJkLmNhbGwodGhpcy5ncm91cCwgdGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmNhbnZhcy5icmluZ0ZvcndhcmQodGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIG9iamVjdCB0byBzcGVjaWZpZWQgbGV2ZWwgaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggTmV3IHBvc2l0aW9uIG9mIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIG1vdmVUbzogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICBpZiAodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLnR5cGUgIT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5tb3ZlVG8uY2FsbCh0aGlzLmdyb3VwLCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXMubW92ZVRvKHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG5cbi8qIF9UT19TVkdfU1RBUlRfICovXG4oZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGdldFN2Z0NvbG9yU3RyaW5nKHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHByb3AgKyAnOiBub25lOyAnO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZS50b0xpdmUpIHtcbiAgICAgIHJldHVybiBwcm9wICsgJzogdXJsKCNTVkdJRF8nICsgdmFsdWUuaWQgKyAnKTsgJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHZhbHVlKSxcbiAgICAgICAgICBzdHIgPSBwcm9wICsgJzogJyArIGNvbG9yLnRvUmdiKCkgKyAnOyAnLFxuICAgICAgICAgIG9wYWNpdHkgPSBjb2xvci5nZXRBbHBoYSgpO1xuICAgICAgaWYgKG9wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgLy9jaGFuZ2UgdGhlIGNvbG9yIGluIHJnYiArIG9wYWNpdHlcbiAgICAgICAgc3RyICs9IHByb3AgKyAnLW9wYWNpdHk6ICcgKyBvcGFjaXR5LnRvU3RyaW5nKCkgKyAnOyAnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH1cblxuICB2YXIgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHlsZXMtc3RyaW5nIGZvciBzdmctZXhwb3J0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBza2lwU2hhZG93IGEgYm9vbGVhbiB0byBza2lwIHNoYWRvdyBmaWx0ZXIgb3V0cHV0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1N0eWxlczogZnVuY3Rpb24oc2tpcFNoYWRvdykge1xuXG4gICAgICB2YXIgZmlsbFJ1bGUgPSB0aGlzLmZpbGxSdWxlLFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gdGhpcy5zdHJva2VXaWR0aCA/IHRoaXMuc3Ryb2tlV2lkdGggOiAnMCcsXG4gICAgICAgICAgc3Ryb2tlRGFzaEFycmF5ID0gdGhpcy5zdHJva2VEYXNoQXJyYXkgPyB0aGlzLnN0cm9rZURhc2hBcnJheS5qb2luKCcgJykgOiAnbm9uZScsXG4gICAgICAgICAgc3Ryb2tlTGluZUNhcCA9IHRoaXMuc3Ryb2tlTGluZUNhcCA/IHRoaXMuc3Ryb2tlTGluZUNhcCA6ICdidXR0JyxcbiAgICAgICAgICBzdHJva2VMaW5lSm9pbiA9IHRoaXMuc3Ryb2tlTGluZUpvaW4gPyB0aGlzLnN0cm9rZUxpbmVKb2luIDogJ21pdGVyJyxcbiAgICAgICAgICBzdHJva2VNaXRlckxpbWl0ID0gdGhpcy5zdHJva2VNaXRlckxpbWl0ID8gdGhpcy5zdHJva2VNaXRlckxpbWl0IDogJzQnLFxuICAgICAgICAgIG9wYWNpdHkgPSB0eXBlb2YgdGhpcy5vcGFjaXR5ICE9PSAndW5kZWZpbmVkJyA/IHRoaXMub3BhY2l0eSA6ICcxJyxcbiAgICAgICAgICB2aXNpYmlsaXR5ID0gdGhpcy52aXNpYmxlID8gJycgOiAnIHZpc2liaWxpdHk6IGhpZGRlbjsnLFxuICAgICAgICAgIGZpbHRlciA9IHNraXBTaGFkb3cgPyAnJyA6IHRoaXMuZ2V0U3ZnRmlsdGVyKCksXG4gICAgICAgICAgZmlsbCA9IGdldFN2Z0NvbG9yU3RyaW5nKCdmaWxsJywgdGhpcy5maWxsKSxcbiAgICAgICAgICBzdHJva2UgPSBnZXRTdmdDb2xvclN0cmluZygnc3Ryb2tlJywgdGhpcy5zdHJva2UpO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzdHJva2UsXG4gICAgICAgICdzdHJva2Utd2lkdGg6ICcsIHN0cm9rZVdpZHRoLCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheTogJywgc3Ryb2tlRGFzaEFycmF5LCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLWxpbmVjYXA6ICcsIHN0cm9rZUxpbmVDYXAsICc7ICcsXG4gICAgICAgICdzdHJva2UtbGluZWpvaW46ICcsIHN0cm9rZUxpbmVKb2luLCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLW1pdGVybGltaXQ6ICcsIHN0cm9rZU1pdGVyTGltaXQsICc7ICcsXG4gICAgICAgIGZpbGwsXG4gICAgICAgICdmaWxsLXJ1bGU6ICcsIGZpbGxSdWxlLCAnOyAnLFxuICAgICAgICAnb3BhY2l0eTogJywgb3BhY2l0eSwgJzsnLFxuICAgICAgICBmaWx0ZXIsXG4gICAgICAgIHZpc2liaWxpdHlcbiAgICAgIF0uam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3R5bGVzLXN0cmluZyBmb3Igc3ZnLWV4cG9ydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSB0aGUgb2JqZWN0IGZyb20gd2hpY2ggdG8gcmV0cmlldmUgc3R5bGUgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlV2hpdGVTcGFjZSBhIGJvb2xlYW4gdG8gaW5jbHVkZSBhbiBhZGRpdGlvbmFsIGF0dHJpYnV0ZSBpbiB0aGUgc3R5bGUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1NwYW5TdHlsZXM6IGZ1bmN0aW9uKHN0eWxlLCB1c2VXaGl0ZVNwYWNlKSB7XG4gICAgICB2YXIgdGVybSA9ICc7ICc7XG4gICAgICB2YXIgZm9udEZhbWlseSA9IHN0eWxlLmZvbnRGYW1pbHkgP1xuICAgICAgICAnZm9udC1mYW1pbHk6ICcgKyAoKChzdHlsZS5mb250RmFtaWx5LmluZGV4T2YoJ1xcJycpID09PSAtMSAmJiBzdHlsZS5mb250RmFtaWx5LmluZGV4T2YoJ1wiJykgPT09IC0xKSA/XG4gICAgICAgICAgJ1xcJycgKyBzdHlsZS5mb250RmFtaWx5ICArICdcXCcnIDogc3R5bGUuZm9udEZhbWlseSkpICsgdGVybSA6ICcnO1xuICAgICAgdmFyIHN0cm9rZVdpZHRoID0gc3R5bGUuc3Ryb2tlV2lkdGggPyAnc3Ryb2tlLXdpZHRoOiAnICsgc3R5bGUuc3Ryb2tlV2lkdGggKyB0ZXJtIDogJycsXG4gICAgICAgICAgZm9udEZhbWlseSA9IGZvbnRGYW1pbHksXG4gICAgICAgICAgZm9udFNpemUgPSBzdHlsZS5mb250U2l6ZSA/ICdmb250LXNpemU6ICcgKyBzdHlsZS5mb250U2l6ZSArICdweCcgKyB0ZXJtIDogJycsXG4gICAgICAgICAgZm9udFN0eWxlID0gc3R5bGUuZm9udFN0eWxlID8gJ2ZvbnQtc3R5bGU6ICcgKyBzdHlsZS5mb250U3R5bGUgKyB0ZXJtIDogJycsXG4gICAgICAgICAgZm9udFdlaWdodCA9IHN0eWxlLmZvbnRXZWlnaHQgPyAnZm9udC13ZWlnaHQ6ICcgKyBzdHlsZS5mb250V2VpZ2h0ICsgdGVybSA6ICcnLFxuICAgICAgICAgIGZpbGwgPSBzdHlsZS5maWxsID8gZ2V0U3ZnQ29sb3JTdHJpbmcoJ2ZpbGwnLCBzdHlsZS5maWxsKSA6ICcnLFxuICAgICAgICAgIHN0cm9rZSA9IHN0eWxlLnN0cm9rZSA/IGdldFN2Z0NvbG9yU3RyaW5nKCdzdHJva2UnLCBzdHlsZS5zdHJva2UpIDogJycsXG4gICAgICAgICAgdGV4dERlY29yYXRpb24gPSB0aGlzLmdldFN2Z1RleHREZWNvcmF0aW9uKHN0eWxlKSxcbiAgICAgICAgICBkZWx0YVkgPSBzdHlsZS5kZWx0YVkgPyAnYmFzZWxpbmUtc2hpZnQ6ICcgKyAoLXN0eWxlLmRlbHRhWSkgKyAnOyAnIDogJyc7XG4gICAgICBpZiAodGV4dERlY29yYXRpb24pIHtcbiAgICAgICAgdGV4dERlY29yYXRpb24gPSAndGV4dC1kZWNvcmF0aW9uOiAnICsgdGV4dERlY29yYXRpb24gKyB0ZXJtO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICBmb250RmFtaWx5LFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgZm9udFN0eWxlLFxuICAgICAgICBmb250V2VpZ2h0LFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbixcbiAgICAgICAgZmlsbCxcbiAgICAgICAgZGVsdGFZLFxuICAgICAgICB1c2VXaGl0ZVNwYWNlID8gJ3doaXRlLXNwYWNlOiBwcmU7ICcgOiAnJ1xuICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0ZXh0LWRlY29yYXRpb24gcHJvcGVydHkgZm9yIHN2Zy1leHBvcnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGUgdGhlIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJldHJpZXZlIHN0eWxlIHByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnVGV4dERlY29yYXRpb246IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICBpZiAoJ292ZXJsaW5lJyBpbiBzdHlsZSB8fCAndW5kZXJsaW5lJyBpbiBzdHlsZSB8fCAnbGluZXRocm91Z2gnIGluIHN0eWxlKSB7XG4gICAgICAgIHJldHVybiAoc3R5bGUub3ZlcmxpbmUgPyAnb3ZlcmxpbmUgJyA6ICcnKSArXG4gICAgICAgICAgKHN0eWxlLnVuZGVybGluZSA/ICd1bmRlcmxpbmUgJyA6ICcnKSArIChzdHlsZS5saW5ldGhyb3VnaCA/ICdsaW5lLXRocm91Z2ggJyA6ICcnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmaWx0ZXIgZm9yIHN2ZyBzaGFkb3dcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnRmlsdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNoYWRvdyA/ICdmaWx0ZXI6IHVybCgjU1ZHSURfJyArIHRoaXMuc2hhZG93LmlkICsgJyk7JyA6ICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlkIGF0dHJpYnV0ZSBmb3Igc3ZnIG91dHB1dFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdJZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5pZCA/ICdpZD1cIicgKyB0aGlzLmlkICsgJ1wiICcgOiAnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cmFuc2Zvcm0tc3RyaW5nIGZvciBzdmctZXhwb3J0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1RyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYW5nbGUgPSB0aGlzLmFuZ2xlLFxuICAgICAgICAgIHNrZXdYID0gKHRoaXMuc2tld1ggJSAzNjApLFxuICAgICAgICAgIHNrZXdZID0gKHRoaXMuc2tld1kgJSAzNjApLFxuICAgICAgICAgIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSxcblxuICAgICAgICAgIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFMsXG5cbiAgICAgICAgICB0cmFuc2xhdGVQYXJ0ID0gJ3RyYW5zbGF0ZSgnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKGNlbnRlci54LCBOVU1fRlJBQ1RJT05fRElHSVRTKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKGNlbnRlci55LCBOVU1fRlJBQ1RJT05fRElHSVRTKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICcpJyxcblxuICAgICAgICAgIGFuZ2xlUGFydCA9IGFuZ2xlICE9PSAwXG4gICAgICAgICAgICA/ICgnIHJvdGF0ZSgnICsgdG9GaXhlZChhbmdsZSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnKScpXG4gICAgICAgICAgICA6ICcnLFxuXG4gICAgICAgICAgc2NhbGVQYXJ0ID0gKHRoaXMuc2NhbGVYID09PSAxICYmIHRoaXMuc2NhbGVZID09PSAxKVxuICAgICAgICAgICAgPyAnJyA6XG4gICAgICAgICAgICAoJyBzY2FsZSgnICtcbiAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnNjYWxlWCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgK1xuICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc2NhbGVZLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArXG4gICAgICAgICAgICAnKScpLFxuXG4gICAgICAgICAgc2tld1hQYXJ0ID0gc2tld1ggIT09IDAgPyAnIHNrZXdYKCcgKyB0b0ZpeGVkKHNrZXdYLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICcpJyA6ICcnLFxuXG4gICAgICAgICAgc2tld1lQYXJ0ID0gc2tld1kgIT09IDAgPyAnIHNrZXdZKCcgKyB0b0ZpeGVkKHNrZXdZLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICcpJyA6ICcnLFxuXG4gICAgICAgICAgZmxpcFhQYXJ0ID0gdGhpcy5mbGlwWCA/ICcgbWF0cml4KC0xIDAgMCAxIDAgMCkgJyA6ICcnLFxuXG4gICAgICAgICAgZmxpcFlQYXJ0ID0gdGhpcy5mbGlwWSA/ICcgbWF0cml4KDEgMCAwIC0xIDAgMCknIDogJyc7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHRyYW5zbGF0ZVBhcnQsIGFuZ2xlUGFydCwgc2NhbGVQYXJ0LCBmbGlwWFBhcnQsIGZsaXBZUGFydCwgc2tld1hQYXJ0LCBza2V3WVBhcnRcbiAgICAgIF0uam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJhbnNmb3JtLXN0cmluZyBmb3Igc3ZnLWV4cG9ydCBmcm9tIHRoZSB0cmFuc2Zvcm0gbWF0cml4IG9mIHNpbmdsZSBlbGVtZW50c1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdUcmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtTWF0cml4ID8gJyBtYXRyaXgoJyArIHRoaXMudHJhbnNmb3JtTWF0cml4LmpvaW4oJyAnKSArICcpICcgOiAnJztcbiAgICB9LFxuXG4gICAgX3NldFNWR0JnOiBmdW5jdGlvbih0ZXh0QmdSZWN0cykge1xuICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHZhciBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuICAgICAgICB0ZXh0QmdSZWN0cy5wdXNoKFxuICAgICAgICAgICdcXHRcXHQ8cmVjdCAnLFxuICAgICAgICAgIHRoaXMuX2dldEZpbGxBdHRyaWJ1dGVzKHRoaXMuYmFja2dyb3VuZENvbG9yKSxcbiAgICAgICAgICAnIHg9XCInLFxuICAgICAgICAgIHRvRml4ZWQoLXRoaXMud2lkdGggLyAyLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAnXCIgeT1cIicsXG4gICAgICAgICAgdG9GaXhlZCgtdGhpcy5oZWlnaHQgLyAyLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAnXCIgd2lkdGg9XCInLFxuICAgICAgICAgIHRvRml4ZWQodGhpcy53aWR0aCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgJ1wiIGhlaWdodD1cIicsXG4gICAgICAgICAgdG9GaXhlZCh0aGlzLmhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgJ1wiPjwvcmVjdD5cXG4nKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQmFzZVNWR01hcmt1cDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFya3VwID0gW107XG5cbiAgICAgIGlmICh0aGlzLmZpbGwgJiYgdGhpcy5maWxsLnRvTGl2ZSkge1xuICAgICAgICBtYXJrdXAucHVzaCh0aGlzLmZpbGwudG9TVkcodGhpcywgZmFsc2UpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cm9rZSAmJiB0aGlzLnN0cm9rZS50b0xpdmUpIHtcbiAgICAgICAgbWFya3VwLnB1c2godGhpcy5zdHJva2UudG9TVkcodGhpcywgZmFsc2UpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNoYWRvdykge1xuICAgICAgICBtYXJrdXAucHVzaCh0aGlzLnNoYWRvdy50b1NWRyh0aGlzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFya3VwO1xuICAgIH0sXG5cbiAgICBhZGRQYWludE9yZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhaW50Rmlyc3QgIT09ICdmaWxsJyA/ICcgcGFpbnQtb3JkZXI9XCInICsgdGhpcy5wYWludEZpcnN0ICsgJ1wiICcgOiAnJztcbiAgICB9XG4gIH0pO1xufSkoKTtcbi8qIF9UT19TVkdfRU5EXyAqL1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIG9yaWdpbmFsU2V0ID0gJ3N0YXRlUHJvcGVydGllcyc7XG5cbiAgLypcbiAgICBEZXBlbmRzIG9uIGBzdGF0ZVByb3BlcnRpZXNgXG4gICovXG4gIGZ1bmN0aW9uIHNhdmVQcm9wcyhvcmlnaW4sIGRlc3RpbmF0aW9uLCBwcm9wcykge1xuICAgIHZhciB0bXBPYmogPSB7IH0sIGRlZXAgPSB0cnVlO1xuICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgdG1wT2JqW3Byb3BdID0gb3JpZ2luW3Byb3BdO1xuICAgIH0pO1xuICAgIGV4dGVuZChvcmlnaW5bZGVzdGluYXRpb25dLCB0bXBPYmosIGRlZXApO1xuICB9XG5cbiAgZnVuY3Rpb24gX2lzRXF1YWwob3JpZ1ZhbHVlLCBjdXJyZW50VmFsdWUsIGZpcnN0UGFzcykge1xuICAgIGlmIChvcmlnVmFsdWUgPT09IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgLy8gaWYgdGhlIG9iamVjdHMgYXJlIGlkZW50aWNhbCwgcmV0dXJuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcmlnVmFsdWUpKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY3VycmVudFZhbHVlKSB8fCBvcmlnVmFsdWUubGVuZ3RoICE9PSBjdXJyZW50VmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvcmlnVmFsdWUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCFfaXNFcXVhbChvcmlnVmFsdWVbaV0sIGN1cnJlbnRWYWx1ZVtpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcmlnVmFsdWUgJiYgdHlwZW9mIG9yaWdWYWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3JpZ1ZhbHVlKSwga2V5O1xuICAgICAgaWYgKCFjdXJyZW50VmFsdWUgfHxcbiAgICAgICAgICB0eXBlb2YgY3VycmVudFZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICghZmlyc3RQYXNzICYmIGtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhjdXJyZW50VmFsdWUpLmxlbmd0aClcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoIV9pc0VxdWFsKG9yaWdWYWx1ZVtrZXldLCBjdXJyZW50VmFsdWVba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IHN0YXRlIChvbmUgb2YgaXRzIHN0YXRlIHByb3BlcnRpZXMpIHdhcyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eVNldF0gb3B0aW9uYWwgbmFtZSBmb3IgdGhlIHNldCBvZiBwcm9wZXJ0eSB3ZSB3YW50IHRvIHNhdmVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGluc3RhbmNlJyBzdGF0ZSBoYXMgY2hhbmdlZCBzaW5jZSBge0BsaW5rIGZhYnJpYy5PYmplY3Qjc2F2ZVN0YXRlfWAgd2FzIGNhbGxlZFxuICAgICAqL1xuICAgIGhhc1N0YXRlQ2hhbmdlZDogZnVuY3Rpb24ocHJvcGVydHlTZXQpIHtcbiAgICAgIHByb3BlcnR5U2V0ID0gcHJvcGVydHlTZXQgfHwgb3JpZ2luYWxTZXQ7XG4gICAgICB2YXIgZGFzaGVkUHJvcGVydHlTZXQgPSAnXycgKyBwcm9wZXJ0eVNldDtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzW2Rhc2hlZFByb3BlcnR5U2V0XSkubGVuZ3RoIDwgdGhpc1twcm9wZXJ0eVNldF0ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFfaXNFcXVhbCh0aGlzW2Rhc2hlZFByb3BlcnR5U2V0XSwgdGhpcywgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNhdmVzIHN0YXRlIG9mIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IHdpdGggYWRkaXRpb25hbCBgc3RhdGVQcm9wZXJ0aWVzYCBhcnJheSB0byBpbmNsdWRlIHdoZW4gc2F2aW5nIHN0YXRlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHNhdmVTdGF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHByb3BlcnR5U2V0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnByb3BlcnR5U2V0IHx8IG9yaWdpbmFsU2V0LFxuICAgICAgICAgIGRlc3RpbmF0aW9uID0gJ18nICsgcHJvcGVydHlTZXQ7XG4gICAgICBpZiAoIXRoaXNbZGVzdGluYXRpb25dKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldHVwU3RhdGUob3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBzYXZlUHJvcHModGhpcywgZGVzdGluYXRpb24sIHRoaXNbcHJvcGVydHlTZXRdKTtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc3RhdGVQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHNhdmVQcm9wcyh0aGlzLCBkZXN0aW5hdGlvbiwgb3B0aW9ucy5zdGF0ZVByb3BlcnRpZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHVwcyBzdGF0ZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9iamVjdCB3aXRoIGFkZGl0aW9uYWwgYHN0YXRlUHJvcGVydGllc2AgYXJyYXkgdG8gaW5jbHVkZSB3aGVuIHNhdmluZyBzdGF0ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBzZXR1cFN0YXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgICB2YXIgcHJvcGVydHlTZXQgPSBvcHRpb25zLnByb3BlcnR5U2V0IHx8IG9yaWdpbmFsU2V0O1xuICAgICAgb3B0aW9ucy5wcm9wZXJ0eVNldCA9IHByb3BlcnR5U2V0O1xuICAgICAgdGhpc1snXycgKyBwcm9wZXJ0eVNldF0gPSB7IH07XG4gICAgICB0aGlzLnNhdmVTdGF0ZShvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnM7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2JqZWN0IGludGVyYWN0aXZpdHkgY29udHJvbHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY29udHJvbHNWaXNpYmlsaXR5OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGljaCBjb3JuZXIgaGFzIGJlZW4gY2xpY2tlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXIgVGhlIHBvaW50ZXIgaW5kaWNhdGluZyB0aGUgbW91c2UgcG9zaXRpb25cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd8Qm9vbGVhbn0gY29ybmVyIGNvZGUgKHRsLCB0ciwgYmwsIGJyLCBldGMuKSwgb3IgZmFsc2UgaWYgbm90aGluZyBpcyBmb3VuZFxuICAgICAqL1xuICAgIF9maW5kVGFyZ2V0Q29ybmVyOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICAvLyBvYmplY3RzIGluIGdyb3VwLCBhbnlraW5kLCBhcmUgbm90IHNlbGYgbW9kaWZpY2FibGUsXG4gICAgICAvLyBtdXN0IG5vdCByZXR1cm4gYW4gaG92ZXJlZCBjb3JuZXIuXG4gICAgICBpZiAoIXRoaXMuaGFzQ29udHJvbHMgfHwgdGhpcy5ncm91cCB8fCAoIXRoaXMuY2FudmFzIHx8IHRoaXMuY2FudmFzLl9hY3RpdmVPYmplY3QgIT09IHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV4ID0gcG9pbnRlci54LFxuICAgICAgICAgIGV5ID0gcG9pbnRlci55LFxuICAgICAgICAgIHhQb2ludHMsXG4gICAgICAgICAgbGluZXM7XG4gICAgICB0aGlzLl9fY29ybmVyID0gMDtcbiAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5vQ29vcmRzKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzQ29udHJvbFZpc2libGUoaSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID09PSAnbXRyJyAmJiAhdGhpcy5oYXNSb3RhdGluZ1BvaW50KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5nZXQoJ2xvY2tVbmlTY2FsaW5nJykgJiZcbiAgICAgICAgICAgKGkgPT09ICdtdCcgfHwgaSA9PT0gJ21yJyB8fCBpID09PSAnbWInIHx8IGkgPT09ICdtbCcpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lcyA9IHRoaXMuX2dldEltYWdlTGluZXModGhpcy5vQ29vcmRzW2ldLmNvcm5lcik7XG5cbiAgICAgICAgLy8gZGVidWdnaW5nXG5cbiAgICAgICAgLy8gY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMuYm90dG9tbGluZS5kLngsIGxpbmVzLmJvdHRvbWxpbmUuZC55LCAyLCAyKTtcbiAgICAgICAgLy8gY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMuYm90dG9tbGluZS5vLngsIGxpbmVzLmJvdHRvbWxpbmUuby55LCAyLCAyKTtcblxuICAgICAgICAvLyBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5sZWZ0bGluZS5kLngsIGxpbmVzLmxlZnRsaW5lLmQueSwgMiwgMik7XG4gICAgICAgIC8vIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmxlZnRsaW5lLm8ueCwgbGluZXMubGVmdGxpbmUuby55LCAyLCAyKTtcblxuICAgICAgICAvLyBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy50b3BsaW5lLmQueCwgbGluZXMudG9wbGluZS5kLnksIDIsIDIpO1xuICAgICAgICAvLyBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy50b3BsaW5lLm8ueCwgbGluZXMudG9wbGluZS5vLnksIDIsIDIpO1xuXG4gICAgICAgIC8vIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnJpZ2h0bGluZS5kLngsIGxpbmVzLnJpZ2h0bGluZS5kLnksIDIsIDIpO1xuICAgICAgICAvLyBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5yaWdodGxpbmUuby54LCBsaW5lcy5yaWdodGxpbmUuby55LCAyLCAyKTtcblxuICAgICAgICB4UG9pbnRzID0gdGhpcy5fZmluZENyb3NzUG9pbnRzKHsgeDogZXgsIHk6IGV5IH0sIGxpbmVzKTtcbiAgICAgICAgaWYgKHhQb2ludHMgIT09IDAgJiYgeFBvaW50cyAlIDIgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLl9fY29ybmVyID0gaTtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgZHJhZ2dhYmxlIGJveGVzIGluIHRoZSBjb3JuZXJzIG9mXG4gICAgICogdGhlIGltYWdlIHVzZWQgdG8gc2NhbGUvcm90YXRlIGl0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldENvcm5lckNvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29vcmRzID0gdGhpcy5vQ29vcmRzLFxuICAgICAgICAgIG5ld1RoZXRhID0gZGVncmVlc1RvUmFkaWFucyg0NSAtIHRoaXMuYW5nbGUpLFxuICAgICAgICAgIC8qIE1hdGguc3FydCgyICogTWF0aC5wb3codGhpcy5jb3JuZXJTaXplLCAyKSkgLyAyLCAqL1xuICAgICAgICAgIC8qIDAuNzA3MTA2IHN0YW5kcyBmb3Igc3FydCgyKS8yICovXG4gICAgICAgICAgY29ybmVySHlwb3RlbnVzZSA9IHRoaXMuY29ybmVyU2l6ZSAqIDAuNzA3MTA2LFxuICAgICAgICAgIGNvc0hhbGZPZmZzZXQgPSBjb3JuZXJIeXBvdGVudXNlICogZmFicmljLnV0aWwuY29zKG5ld1RoZXRhKSxcbiAgICAgICAgICBzaW5IYWxmT2Zmc2V0ID0gY29ybmVySHlwb3RlbnVzZSAqIGZhYnJpYy51dGlsLnNpbihuZXdUaGV0YSksXG4gICAgICAgICAgeCwgeTtcblxuICAgICAgZm9yICh2YXIgcG9pbnQgaW4gY29vcmRzKSB7XG4gICAgICAgIHggPSBjb29yZHNbcG9pbnRdLng7XG4gICAgICAgIHkgPSBjb29yZHNbcG9pbnRdLnk7XG4gICAgICAgIGNvb3Jkc1twb2ludF0uY29ybmVyID0ge1xuICAgICAgICAgIHRsOiB7XG4gICAgICAgICAgICB4OiB4IC0gc2luSGFsZk9mZnNldCxcbiAgICAgICAgICAgIHk6IHkgLSBjb3NIYWxmT2Zmc2V0XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cjoge1xuICAgICAgICAgICAgeDogeCArIGNvc0hhbGZPZmZzZXQsXG4gICAgICAgICAgICB5OiB5IC0gc2luSGFsZk9mZnNldFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYmw6IHtcbiAgICAgICAgICAgIHg6IHggLSBjb3NIYWxmT2Zmc2V0LFxuICAgICAgICAgICAgeTogeSArIHNpbkhhbGZPZmZzZXRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJyOiB7XG4gICAgICAgICAgICB4OiB4ICsgc2luSGFsZk9mZnNldCxcbiAgICAgICAgICAgIHk6IHkgKyBjb3NIYWxmT2Zmc2V0XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIGNvbG9yZWQgbGF5ZXIgYmVoaW5kIHRoZSBvYmplY3QsIGluc2lkZSBpdHMgc2VsZWN0aW9uIGJvcmRlcnMuXG4gICAgICogUmVxdWlyZXMgcHVibGljIG9wdGlvbnM6IHBhZGRpbmcsIHNlbGVjdGlvbkJhY2tncm91bmRDb2xvclxuICAgICAqIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gdGhlIGNvbnRleHQgaXMgdHJhbnNmb3JtZWRcbiAgICAgKiBoYXMgY2hlY2tzIHRvIGJlIHNraXBwZWQgd2hlbiB0aGUgb2JqZWN0IGlzIG9uIGEgc3RhdGljQ2FudmFzXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRyYXdTZWxlY3Rpb25CYWNrZ3JvdW5kOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3IgfHxcbiAgICAgICAgKHRoaXMuY2FudmFzICYmICF0aGlzLmNhbnZhcy5pbnRlcmFjdGl2ZSkgfHxcbiAgICAgICAgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLl9hY3RpdmVPYmplY3QgIT09IHRoaXMpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSwgd2ggPSB0aGlzLl9jYWxjdWxhdGVDdXJyZW50RGltZW5zaW9ucygpLFxuICAgICAgICAgIHZwdCA9IHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgY3R4LnRyYW5zbGF0ZShjZW50ZXIueCwgY2VudGVyLnkpO1xuICAgICAgY3R4LnNjYWxlKDEgLyB2cHRbMF0sIDEgLyB2cHRbM10pO1xuICAgICAgY3R4LnJvdGF0ZShkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnNlbGVjdGlvbkJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdCgtd2gueCAvIDIsIC13aC55IC8gMiwgd2gueCwgd2gueSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGJvcmRlcnMgb2YgYW4gb2JqZWN0J3MgYm91bmRpbmcgYm94LlxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBwcm9wZXJ0aWVzOiB3aWR0aCwgaGVpZ2h0XG4gICAgICogUmVxdWlyZXMgcHVibGljIG9wdGlvbnM6IHBhZGRpbmcsIGJvcmRlckNvbG9yXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVPdmVycmlkZSBvYmplY3QgdG8gb3ZlcnJpZGUgdGhlIG9iamVjdCBzdHlsZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZHJhd0JvcmRlcnM6IGZ1bmN0aW9uKGN0eCwgc3R5bGVPdmVycmlkZSkge1xuICAgICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgICB2YXIgd2ggPSB0aGlzLl9jYWxjdWxhdGVDdXJyZW50RGltZW5zaW9ucygpLFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gMSAvIHRoaXMuYm9yZGVyU2NhbGVGYWN0b3IsXG4gICAgICAgICAgd2lkdGggPSB3aC54ICsgc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gd2gueSArIHN0cm9rZVdpZHRoLFxuICAgICAgICAgIGRyYXdSb3RhdGluZ1BvaW50ID0gdHlwZW9mIHN0eWxlT3ZlcnJpZGUuaGFzUm90YXRpbmdQb2ludCAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICAgICAgc3R5bGVPdmVycmlkZS5oYXNSb3RhdGluZ1BvaW50IDogdGhpcy5oYXNSb3RhdGluZ1BvaW50LFxuICAgICAgICAgIGhhc0NvbnRyb2xzID0gdHlwZW9mIHN0eWxlT3ZlcnJpZGUuaGFzQ29udHJvbHMgIT09ICd1bmRlZmluZWQnID9cbiAgICAgICAgICAgIHN0eWxlT3ZlcnJpZGUuaGFzQ29udHJvbHMgOiB0aGlzLmhhc0NvbnRyb2xzLFxuICAgICAgICAgIHJvdGF0aW5nUG9pbnRPZmZzZXQgPSB0eXBlb2Ygc3R5bGVPdmVycmlkZS5yb3RhdGluZ1BvaW50T2Zmc2V0ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgICBzdHlsZU92ZXJyaWRlLnJvdGF0aW5nUG9pbnRPZmZzZXQgOiB0aGlzLnJvdGF0aW5nUG9pbnRPZmZzZXQ7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmJvcmRlckNvbG9yIHx8IHRoaXMuYm9yZGVyQ29sb3I7XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHN0eWxlT3ZlcnJpZGUuYm9yZGVyRGFzaEFycmF5IHx8IHRoaXMuYm9yZGVyRGFzaEFycmF5LCBudWxsKTtcblxuICAgICAgY3R4LnN0cm9rZVJlY3QoXG4gICAgICAgIC13aWR0aCAvIDIsXG4gICAgICAgIC1oZWlnaHQgLyAyLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICApO1xuXG4gICAgICBpZiAoZHJhd1JvdGF0aW5nUG9pbnQgJiYgdGhpcy5pc0NvbnRyb2xWaXNpYmxlKCdtdHInKSAmJiBoYXNDb250cm9scykge1xuXG4gICAgICAgIHZhciByb3RhdGVIZWlnaHQgPSAtaGVpZ2h0IC8gMjtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oMCwgcm90YXRlSGVpZ2h0KTtcbiAgICAgICAgY3R4LmxpbmVUbygwLCByb3RhdGVIZWlnaHQgLSByb3RhdGluZ1BvaW50T2Zmc2V0KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGJvcmRlcnMgb2YgYW4gb2JqZWN0J3MgYm91bmRpbmcgYm94IHdoZW4gaXQgaXMgaW5zaWRlIGEgZ3JvdXAuXG4gICAgICogUmVxdWlyZXMgcHVibGljIHByb3BlcnRpZXM6IHdpZHRoLCBoZWlnaHRcbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgb3B0aW9uczogcGFkZGluZywgYm9yZGVyQ29sb3JcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gZHJhdyBvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIG9iamVjdCByZXByZXNlbnRpbmcgY3VycmVudCBvYmplY3QgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZU92ZXJyaWRlIG9iamVjdCB0byBvdmVycmlkZSB0aGUgb2JqZWN0IHN0eWxlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkcmF3Qm9yZGVyc0luR3JvdXA6IGZ1bmN0aW9uKGN0eCwgb3B0aW9ucywgc3R5bGVPdmVycmlkZSkge1xuICAgICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgICB2YXIgcCA9IHRoaXMuX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucygpLFxuICAgICAgICAgIG1hdHJpeCA9IGZhYnJpYy51dGlsLmN1c3RvbVRyYW5zZm9ybU1hdHJpeChvcHRpb25zLnNjYWxlWCwgb3B0aW9ucy5zY2FsZVksIG9wdGlvbnMuc2tld1gpLFxuICAgICAgICAgIHdoID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQocCwgbWF0cml4KSxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IDEgLyB0aGlzLmJvcmRlclNjYWxlRmFjdG9yLFxuICAgICAgICAgIHdpZHRoID0gd2gueCArIHN0cm9rZVdpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IHdoLnkgKyBzdHJva2VXaWR0aDtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX3NldExpbmVEYXNoKGN0eCwgc3R5bGVPdmVycmlkZS5ib3JkZXJEYXNoQXJyYXkgfHwgdGhpcy5ib3JkZXJEYXNoQXJyYXksIG51bGwpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGVPdmVycmlkZS5ib3JkZXJDb2xvciB8fCB0aGlzLmJvcmRlckNvbG9yO1xuXG4gICAgICBjdHguc3Ryb2tlUmVjdChcbiAgICAgICAgLXdpZHRoIC8gMixcbiAgICAgICAgLWhlaWdodCAvIDIsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgICk7XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgY29ybmVycyBvZiBhbiBvYmplY3QncyBib3VuZGluZyBib3guXG4gICAgICogUmVxdWlyZXMgcHVibGljIHByb3BlcnRpZXM6IHdpZHRoLCBoZWlnaHRcbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgb3B0aW9uczogY29ybmVyU2l6ZSwgcGFkZGluZ1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBkcmF3IG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlT3ZlcnJpZGUgb2JqZWN0IHRvIG92ZXJyaWRlIHRoZSBvYmplY3Qgc3R5bGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRyYXdDb250cm9sczogZnVuY3Rpb24oY3R4LCBzdHlsZU92ZXJyaWRlKSB7XG4gICAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7fTtcbiAgICAgIHZhciB3aCA9IHRoaXMuX2NhbGN1bGF0ZUN1cnJlbnREaW1lbnNpb25zKCksXG4gICAgICAgICAgd2lkdGggPSB3aC54LFxuICAgICAgICAgIGhlaWdodCA9IHdoLnksXG4gICAgICAgICAgc2NhbGVPZmZzZXQgPSBzdHlsZU92ZXJyaWRlLmNvcm5lclNpemUgfHwgdGhpcy5jb3JuZXJTaXplLFxuICAgICAgICAgIGxlZnQgPSAtKHdpZHRoICsgc2NhbGVPZmZzZXQpIC8gMixcbiAgICAgICAgICB0b3AgPSAtKGhlaWdodCArIHNjYWxlT2Zmc2V0KSAvIDIsXG4gICAgICAgICAgdHJhbnNwYXJlbnRDb3JuZXJzID0gdHlwZW9mIHN0eWxlT3ZlcnJpZGUudHJhbnNwYXJlbnRDb3JuZXJzICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgICBzdHlsZU92ZXJyaWRlLnRyYW5zcGFyZW50Q29ybmVycyA6IHRoaXMudHJhbnNwYXJlbnRDb3JuZXJzLFxuICAgICAgICAgIGhhc1JvdGF0aW5nUG9pbnQgPSB0eXBlb2Ygc3R5bGVPdmVycmlkZS5oYXNSb3RhdGluZ1BvaW50ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgICBzdHlsZU92ZXJyaWRlLmhhc1JvdGF0aW5nUG9pbnQgOiB0aGlzLmhhc1JvdGF0aW5nUG9pbnQsXG4gICAgICAgICAgbWV0aG9kTmFtZSA9IHRyYW5zcGFyZW50Q29ybmVycyA/ICdzdHJva2UnIDogJ2ZpbGwnO1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZSA9IHN0eWxlT3ZlcnJpZGUuY29ybmVyQ29sb3IgfHwgdGhpcy5jb3JuZXJDb2xvcjtcbiAgICAgIGlmICghdGhpcy50cmFuc3BhcmVudENvcm5lcnMpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGVPdmVycmlkZS5jb3JuZXJTdHJva2VDb2xvciB8fCB0aGlzLmNvcm5lclN0cm9rZUNvbG9yO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0TGluZURhc2goY3R4LCBzdHlsZU92ZXJyaWRlLmNvcm5lckRhc2hBcnJheSB8fCB0aGlzLmNvcm5lckRhc2hBcnJheSwgbnVsbCk7XG5cbiAgICAgIC8vIHRvcC1sZWZ0XG4gICAgICB0aGlzLl9kcmF3Q29udHJvbCgndGwnLCBjdHgsIG1ldGhvZE5hbWUsXG4gICAgICAgIGxlZnQsXG4gICAgICAgIHRvcCwgc3R5bGVPdmVycmlkZSk7XG5cbiAgICAgIC8vIHRvcC1yaWdodFxuICAgICAgdGhpcy5fZHJhd0NvbnRyb2woJ3RyJywgY3R4LCBtZXRob2ROYW1lLFxuICAgICAgICBsZWZ0ICsgd2lkdGgsXG4gICAgICAgIHRvcCwgc3R5bGVPdmVycmlkZSk7XG5cbiAgICAgIC8vIGJvdHRvbS1sZWZ0XG4gICAgICB0aGlzLl9kcmF3Q29udHJvbCgnYmwnLCBjdHgsIG1ldGhvZE5hbWUsXG4gICAgICAgIGxlZnQsXG4gICAgICAgIHRvcCArIGhlaWdodCwgc3R5bGVPdmVycmlkZSk7XG5cbiAgICAgIC8vIGJvdHRvbS1yaWdodFxuICAgICAgdGhpcy5fZHJhd0NvbnRyb2woJ2JyJywgY3R4LCBtZXRob2ROYW1lLFxuICAgICAgICBsZWZ0ICsgd2lkdGgsXG4gICAgICAgIHRvcCArIGhlaWdodCwgc3R5bGVPdmVycmlkZSk7XG5cbiAgICAgIGlmICghdGhpcy5nZXQoJ2xvY2tVbmlTY2FsaW5nJykpIHtcblxuICAgICAgICAvLyBtaWRkbGUtdG9wXG4gICAgICAgIHRoaXMuX2RyYXdDb250cm9sKCdtdCcsIGN0eCwgbWV0aG9kTmFtZSxcbiAgICAgICAgICBsZWZ0ICsgd2lkdGggLyAyLFxuICAgICAgICAgIHRvcCwgc3R5bGVPdmVycmlkZSk7XG5cbiAgICAgICAgLy8gbWlkZGxlLWJvdHRvbVxuICAgICAgICB0aGlzLl9kcmF3Q29udHJvbCgnbWInLCBjdHgsIG1ldGhvZE5hbWUsXG4gICAgICAgICAgbGVmdCArIHdpZHRoIC8gMixcbiAgICAgICAgICB0b3AgKyBoZWlnaHQsIHN0eWxlT3ZlcnJpZGUpO1xuXG4gICAgICAgIC8vIG1pZGRsZS1yaWdodFxuICAgICAgICB0aGlzLl9kcmF3Q29udHJvbCgnbXInLCBjdHgsIG1ldGhvZE5hbWUsXG4gICAgICAgICAgbGVmdCArIHdpZHRoLFxuICAgICAgICAgIHRvcCArIGhlaWdodCAvIDIsIHN0eWxlT3ZlcnJpZGUpO1xuXG4gICAgICAgIC8vIG1pZGRsZS1sZWZ0XG4gICAgICAgIHRoaXMuX2RyYXdDb250cm9sKCdtbCcsIGN0eCwgbWV0aG9kTmFtZSxcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIHRvcCArIGhlaWdodCAvIDIsIHN0eWxlT3ZlcnJpZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBtaWRkbGUtdG9wLXJvdGF0ZVxuICAgICAgaWYgKGhhc1JvdGF0aW5nUG9pbnQpIHtcbiAgICAgICAgdGhpcy5fZHJhd0NvbnRyb2woJ210cicsIGN0eCwgbWV0aG9kTmFtZSxcbiAgICAgICAgICBsZWZ0ICsgd2lkdGggLyAyLFxuICAgICAgICAgIHRvcCAtIHRoaXMucm90YXRpbmdQb2ludE9mZnNldCwgc3R5bGVPdmVycmlkZSk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kcmF3Q29udHJvbDogZnVuY3Rpb24oY29udHJvbCwgY3R4LCBtZXRob2ROYW1lLCBsZWZ0LCB0b3AsIHN0eWxlT3ZlcnJpZGUpIHtcbiAgICAgIHN0eWxlT3ZlcnJpZGUgPSBzdHlsZU92ZXJyaWRlIHx8IHt9O1xuICAgICAgaWYgKCF0aGlzLmlzQ29udHJvbFZpc2libGUoY29udHJvbCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHNpemUgPSB0aGlzLmNvcm5lclNpemUsIHN0cm9rZSA9ICF0aGlzLnRyYW5zcGFyZW50Q29ybmVycyAmJiB0aGlzLmNvcm5lclN0cm9rZUNvbG9yO1xuICAgICAgc3dpdGNoIChzdHlsZU92ZXJyaWRlLmNvcm5lclN0eWxlIHx8IHRoaXMuY29ybmVyU3R5bGUpIHtcbiAgICAgICAgY2FzZSAnY2lyY2xlJzpcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4LmFyYyhsZWZ0ICsgc2l6ZSAvIDIsIHRvcCArIHNpemUgLyAyLCBzaXplIC8gMiwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICBjdHhbbWV0aG9kTmFtZV0oKTtcbiAgICAgICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRoaXMudHJhbnNwYXJlbnRDb3JuZXJzIHx8IGN0eC5jbGVhclJlY3QobGVmdCwgdG9wLCBzaXplLCBzaXplKTtcbiAgICAgICAgICBjdHhbbWV0aG9kTmFtZSArICdSZWN0J10obGVmdCwgdG9wLCBzaXplLCBzaXplKTtcbiAgICAgICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgICAgICBjdHguc3Ryb2tlUmVjdChsZWZ0LCB0b3AsIHNpemUsIHNpemUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgY29udHJvbCBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnRyb2xOYW1lIFRoZSBuYW1lIG9mIHRoZSBjb250cm9sLiBQb3NzaWJsZSB2YWx1ZXMgYXJlICd0bCcsICd0cicsICdicicsICdibCcsICdtbCcsICdtdCcsICdtcicsICdtYicsICdtdHInLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgY29udHJvbCBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBpc0NvbnRyb2xWaXNpYmxlOiBmdW5jdGlvbihjb250cm9sTmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldENvbnRyb2xzVmlzaWJpbGl0eSgpW2NvbnRyb2xOYW1lXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgc3BlY2lmaWVkIGNvbnRyb2wuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnRyb2xOYW1lIFRoZSBuYW1lIG9mIHRoZSBjb250cm9sLiBQb3NzaWJsZSB2YWx1ZXMgYXJlICd0bCcsICd0cicsICdicicsICdibCcsICdtbCcsICdtdCcsICdtcicsICdtYicsICdtdHInLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSB0cnVlIHRvIHNldCB0aGUgc3BlY2lmaWVkIGNvbnRyb2wgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRDb250cm9sVmlzaWJsZTogZnVuY3Rpb24oY29udHJvbE5hbWUsIHZpc2libGUpIHtcbiAgICAgIHRoaXMuX2dldENvbnRyb2xzVmlzaWJpbGl0eSgpW2NvbnRyb2xOYW1lXSA9IHZpc2libGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBzdGF0ZSBvZiBvYmplY3QgY29udHJvbHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmxdIHRydWUgdG8gZW5hYmxlIHRoZSBib3R0b20tbGVmdCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5icl0gdHJ1ZSB0byBlbmFibGUgdGhlIGJvdHRvbS1yaWdodCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYl0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS1ib3R0b20gY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWxdIHRydWUgdG8gZW5hYmxlIHRoZSBtaWRkbGUtbGVmdCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tcl0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS1yaWdodCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tdF0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS10b3AgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGxdIHRydWUgdG8gZW5hYmxlIHRoZSB0b3AtbGVmdCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cl0gdHJ1ZSB0byBlbmFibGUgdGhlIHRvcC1yaWdodCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tdHJdIHRydWUgdG8gZW5hYmxlIHRoZSBtaWRkbGUtdG9wLXJvdGF0ZSBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRDb250cm9sc1Zpc2liaWxpdHk6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICBmb3IgKHZhciBwIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zZXRDb250cm9sVmlzaWJsZShwLCBvcHRpb25zW3BdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiB0aGUgY29udHJvbCB2aXNpYmlsaXR5IHNldCBmb3IgdGhpcyBvYmplY3QuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIF9nZXRDb250cm9sc1Zpc2liaWxpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9jb250cm9sc1Zpc2liaWxpdHkpIHtcbiAgICAgICAgdGhpcy5fY29udHJvbHNWaXNpYmlsaXR5ID0ge1xuICAgICAgICAgIHRsOiB0cnVlLFxuICAgICAgICAgIHRyOiB0cnVlLFxuICAgICAgICAgIGJyOiB0cnVlLFxuICAgICAgICAgIGJsOiB0cnVlLFxuICAgICAgICAgIG1sOiB0cnVlLFxuICAgICAgICAgIG10OiB0cnVlLFxuICAgICAgICAgIG1yOiB0cnVlLFxuICAgICAgICAgIG1iOiB0cnVlLFxuICAgICAgICAgIG10cjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRyb2xzVmlzaWJpbGl0eTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQgZXZlcnkgdGltZSBfZGlzY2FyZEFjdGl2ZU9iamVjdCBvciBfc2V0QWN0aXZlT2JqZWN0XG4gICAgICogdHJ5IHRvIHRvIGRlc2VsZWN0IHRoaXMgb2JqZWN0LiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlLCB0aGUgcHJvY2VzcyBpcyBjYW5jZWxsZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgc2VudCBmcm9tIHRoZSB1cHBlciBmdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbb3B0aW9ucy5lXSBldmVudCBpZiB0aGUgcHJvY2VzcyBpcyBnZW5lcmF0ZWQgYnkgYW4gZXZlbnRcbiAgICAgKi9cbiAgICBvbkRlc2VsZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGltcGxlbWVudGVkIGJ5IHN1Yi1jbGFzc2VzLCBhcyBuZWVkZWQuXG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQgZXZlcnkgdGltZSBfZGlzY2FyZEFjdGl2ZU9iamVjdCBvciBfc2V0QWN0aXZlT2JqZWN0XG4gICAgICogdHJ5IHRvIHRvIHNlbGVjdCB0aGlzIG9iamVjdC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgdGhlIHByb2Nlc3MgaXMgY2FuY2VsbGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25zIHNlbnQgZnJvbSB0aGUgdXBwZXIgZnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtFdmVudH0gW29wdGlvbnMuZV0gZXZlbnQgaWYgdGhlIHByb2Nlc3MgaXMgZ2VuZXJhdGVkIGJ5IGFuIGV2ZW50XG4gICAgICovXG4gICAgb25TZWxlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaW1wbGVtZW50ZWQgYnkgc3ViLWNsYXNzZXMsIGFzIG5lZWRlZC5cbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogQW5pbWF0aW9uIGR1cmF0aW9uIChpbiBtcykgZm9yIGZ4KiBtZXRob2RzXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgRlhfRFVSQVRJT046IDUwMCxcblxuICAvKipcbiAgICogQ2VudGVycyBvYmplY3QgaG9yaXpvbnRhbGx5IHdpdGggYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tzXSBDYWxsYmFja3Mgb2JqZWN0IHdpdGggb3B0aW9uYWwgXCJvbkNvbXBsZXRlXCIgYW5kL29yIFwib25DaGFuZ2VcIiBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25Db21wbGV0ZV0gSW52b2tlZCBvbiBjb21wbGV0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25DaGFuZ2VdIEludm9rZWQgb24gZXZlcnkgc3RlcCBvZiBhbmltYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmeENlbnRlck9iamVjdEg6IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcyB8fCB7IH07XG5cbiAgICB2YXIgZW1wdHkgPSBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgb25Db21wbGV0ZSA9IGNhbGxiYWNrcy5vbkNvbXBsZXRlIHx8IGVtcHR5LFxuICAgICAgICBvbkNoYW5nZSA9IGNhbGxiYWNrcy5vbkNoYW5nZSB8fCBlbXB0eSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgZmFicmljLnV0aWwuYW5pbWF0ZSh7XG4gICAgICBzdGFydFZhbHVlOiBvYmplY3QubGVmdCxcbiAgICAgIGVuZFZhbHVlOiB0aGlzLmdldENlbnRlcigpLmxlZnQsXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBvYmplY3Quc2V0KCdsZWZ0JywgdmFsdWUpO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIG9iamVjdC5zZXRDb29yZHMoKTtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgd2l0aCBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjYWxsYmFja3NdIENhbGxiYWNrcyBvYmplY3Qgd2l0aCBvcHRpb25hbCBcIm9uQ29tcGxldGVcIiBhbmQvb3IgXCJvbkNoYW5nZVwiIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNvbXBsZXRlXSBJbnZva2VkIG9uIGNvbXBsZXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNoYW5nZV0gSW52b2tlZCBvbiBldmVyeSBzdGVwIG9mIGFuaW1hdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGZ4Q2VudGVyT2JqZWN0VjogZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzIHx8IHsgfTtcblxuICAgIHZhciBlbXB0eSA9IGZ1bmN0aW9uKCkgeyB9LFxuICAgICAgICBvbkNvbXBsZXRlID0gY2FsbGJhY2tzLm9uQ29tcGxldGUgfHwgZW1wdHksXG4gICAgICAgIG9uQ2hhbmdlID0gY2FsbGJhY2tzLm9uQ2hhbmdlIHx8IGVtcHR5LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHN0YXJ0VmFsdWU6IG9iamVjdC50b3AsXG4gICAgICBlbmRWYWx1ZTogdGhpcy5nZXRDZW50ZXIoKS50b3AsXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBvYmplY3Quc2V0KCd0b3AnLCB2YWx1ZSk7XG4gICAgICAgIF90aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgb2JqZWN0LnNldENvb3JkcygpO1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyBgZmFicmljLkNhbnZhcyNyZW1vdmVgIGJ1dCBhbmltYXRlZFxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tzXSBDYWxsYmFja3Mgb2JqZWN0IHdpdGggb3B0aW9uYWwgXCJvbkNvbXBsZXRlXCIgYW5kL29yIFwib25DaGFuZ2VcIiBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25Db21wbGV0ZV0gSW52b2tlZCBvbiBjb21wbGV0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25DaGFuZ2VdIEludm9rZWQgb24gZXZlcnkgc3RlcCBvZiBhbmltYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmeFJlbW92ZTogZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzIHx8IHsgfTtcblxuICAgIHZhciBlbXB0eSA9IGZ1bmN0aW9uKCkgeyB9LFxuICAgICAgICBvbkNvbXBsZXRlID0gY2FsbGJhY2tzLm9uQ29tcGxldGUgfHwgZW1wdHksXG4gICAgICAgIG9uQ2hhbmdlID0gY2FsbGJhY2tzLm9uQ2hhbmdlIHx8IGVtcHR5LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHN0YXJ0VmFsdWU6IG9iamVjdC5vcGFjaXR5LFxuICAgICAgZW5kVmFsdWU6IDAsXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBvYmplY3Quc2V0KCdvcGFjaXR5JywgdmFsdWUpO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZW1vdmUob2JqZWN0KTtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcbiAgLyoqXG4gICAqIEFuaW1hdGVzIG9iamVjdCdzIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBhbmltYXRlIChpZiBzdHJpbmcpIG9yIHByb3BlcnRpZXMgdG8gYW5pbWF0ZSAoaWYgb2JqZWN0KVxuICAgKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IHZhbHVlIFZhbHVlIHRvIGFuaW1hdGUgcHJvcGVydHkgdG8gKGlmIHN0cmluZyB3YXMgZ2l2ZW4gZmlyc3QpIG9yIG9wdGlvbnMgb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIjYW5pbWF0aW9ufVxuICAgKiBAY2hhaW5hYmxlXG4gICAqXG4gICAqIEFzIG9iamVjdCDigJQgbXVsdGlwbGUgcHJvcGVydGllc1xuICAgKlxuICAgKiBvYmplY3QuYW5pbWF0ZSh7IGxlZnQ6IC4uLiwgdG9wOiAuLi4gfSk7XG4gICAqIG9iamVjdC5hbmltYXRlKHsgbGVmdDogLi4uLCB0b3A6IC4uLiB9LCB7IGR1cmF0aW9uOiAuLi4gfSk7XG4gICAqXG4gICAqIEFzIHN0cmluZyDigJQgb25lIHByb3BlcnR5XG4gICAqXG4gICAqIG9iamVjdC5hbmltYXRlKCdsZWZ0JywgLi4uKTtcbiAgICogb2JqZWN0LmFuaW1hdGUoJ2xlZnQnLCB7IGR1cmF0aW9uOiAuLi4gfSk7XG4gICAqXG4gICAqL1xuICBhbmltYXRlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgcHJvcHNUb0FuaW1hdGUgPSBbXSwgcHJvcCwgc2tpcENhbGxiYWNrcztcbiAgICAgIGZvciAocHJvcCBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgcHJvcHNUb0FuaW1hdGUucHVzaChwcm9wKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm9wc1RvQW5pbWF0ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwcm9wID0gcHJvcHNUb0FuaW1hdGVbaV07XG4gICAgICAgIHNraXBDYWxsYmFja3MgPSBpICE9PSBsZW4gLSAxO1xuICAgICAgICB0aGlzLl9hbmltYXRlKHByb3AsIGFyZ3VtZW50c1swXVtwcm9wXSwgYXJndW1lbnRzWzFdLCBza2lwQ2FsbGJhY2tzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9hbmltYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gYW5pbWF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdG8gVmFsdWUgdG8gYW5pbWF0ZSB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBDYWxsYmFja3NdIFdoZW4gdHJ1ZSwgY2FsbGJhY2tzIGxpa2Ugb25jaGFuZ2UgYW5kIG9uY29tcGxldGUgYXJlIG5vdCBpbnZva2VkXG4gICAqL1xuICBfYW5pbWF0ZTogZnVuY3Rpb24ocHJvcGVydHksIHRvLCBvcHRpb25zLCBza2lwQ2FsbGJhY2tzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcywgcHJvcFBhaXI7XG5cbiAgICB0byA9IHRvLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7IH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAofnByb3BlcnR5LmluZGV4T2YoJy4nKSkge1xuICAgICAgcHJvcFBhaXIgPSBwcm9wZXJ0eS5zcGxpdCgnLicpO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50VmFsdWUgPSBwcm9wUGFpclxuICAgICAgPyB0aGlzLmdldChwcm9wUGFpclswXSlbcHJvcFBhaXJbMV1dXG4gICAgICA6IHRoaXMuZ2V0KHByb3BlcnR5KTtcblxuICAgIGlmICghKCdmcm9tJyBpbiBvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucy5mcm9tID0gY3VycmVudFZhbHVlO1xuICAgIH1cblxuICAgIGlmICh+dG8uaW5kZXhPZignPScpKSB7XG4gICAgICB0byA9IGN1cnJlbnRWYWx1ZSArIHBhcnNlRmxvYXQodG8ucmVwbGFjZSgnPScsICcnKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdG8gPSBwYXJzZUZsb2F0KHRvKTtcbiAgICB9XG5cbiAgICBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHN0YXJ0VmFsdWU6IG9wdGlvbnMuZnJvbSxcbiAgICAgIGVuZFZhbHVlOiB0byxcbiAgICAgIGJ5VmFsdWU6IG9wdGlvbnMuYnksXG4gICAgICBlYXNpbmc6IG9wdGlvbnMuZWFzaW5nLFxuICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG4gICAgICBhYm9ydDogb3B0aW9ucy5hYm9ydCAmJiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuYWJvcnQuY2FsbChfdGhpcyk7XG4gICAgICB9LFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKHZhbHVlLCB2YWx1ZVByb2dyZXNzLCB0aW1lUHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHByb3BQYWlyKSB7XG4gICAgICAgICAgX3RoaXNbcHJvcFBhaXJbMF1dW3Byb3BQYWlyWzFdXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIF90aGlzLnNldChwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2lwQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMub25DaGFuZ2UgJiYgb3B0aW9ucy5vbkNoYW5nZSh2YWx1ZSwgdmFsdWVQcm9ncmVzcywgdGltZVByb2dyZXNzKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbih2YWx1ZSwgdmFsdWVQcm9ncmVzcywgdGltZVByb2dyZXNzKSB7XG4gICAgICAgIGlmIChza2lwQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuc2V0Q29vcmRzKCk7XG4gICAgICAgIG9wdGlvbnMub25Db21wbGV0ZSAmJiBvcHRpb25zLm9uQ29tcGxldGUodmFsdWUsIHZhbHVlUHJvZ3Jlc3MsIHRpbWVQcm9ncmVzcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lLFxuICAgICAgY29vcmRQcm9wcyA9IHsgeDE6IDEsIHgyOiAxLCB5MTogMSwgeTI6IDEgfSxcbiAgICAgIHN1cHBvcnRzTGluZURhc2ggPSBmYWJyaWMuU3RhdGljQ2FudmFzLnN1cHBvcnRzKCdzZXRMaW5lRGFzaCcpO1xuXG4gIGlmIChmYWJyaWMuTGluZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuTGluZSBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogTGluZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkxpbmVcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuTGluZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkxpbmUgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5MaW5lLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2xpbmUnLFxuXG4gICAgLyoqXG4gICAgICogeCB2YWx1ZSBvciBmaXJzdCBsaW5lIGVkZ2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHgxOiAwLFxuXG4gICAgLyoqXG4gICAgICogeSB2YWx1ZSBvciBmaXJzdCBsaW5lIGVkZ2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHkxOiAwLFxuXG4gICAgLyoqXG4gICAgICogeCB2YWx1ZSBvciBzZWNvbmQgbGluZSBlZGdlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB4MjogMCxcblxuICAgIC8qKlxuICAgICAqIHkgdmFsdWUgb3Igc2Vjb25kIGxpbmUgZWRnZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgeTI6IDAsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3gxJywgJ3gyJywgJ3kxJywgJ3kyJyksXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwb2ludHNdIEFycmF5IG9mIHBvaW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuTGluZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHBvaW50cywgb3B0aW9ucykge1xuICAgICAgaWYgKCFwb2ludHMpIHtcbiAgICAgICAgcG9pbnRzID0gWzAsIDAsIDAsIDBdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLnNldCgneDEnLCBwb2ludHNbMF0pO1xuICAgICAgdGhpcy5zZXQoJ3kxJywgcG9pbnRzWzFdKTtcbiAgICAgIHRoaXMuc2V0KCd4MicsIHBvaW50c1syXSk7XG4gICAgICB0aGlzLnNldCgneTInLCBwb2ludHNbM10pO1xuXG4gICAgICB0aGlzLl9zZXRXaWR0aEhlaWdodChvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnNcbiAgICAgKi9cbiAgICBfc2V0V2lkdGhIZWlnaHQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB0aGlzLndpZHRoID0gTWF0aC5hYnModGhpcy54MiAtIHRoaXMueDEpO1xuICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLmFicyh0aGlzLnkyIC0gdGhpcy55MSk7XG5cbiAgICAgIHRoaXMubGVmdCA9ICdsZWZ0JyBpbiBvcHRpb25zXG4gICAgICAgID8gb3B0aW9ucy5sZWZ0XG4gICAgICAgIDogdGhpcy5fZ2V0TGVmdFRvT3JpZ2luWCgpO1xuXG4gICAgICB0aGlzLnRvcCA9ICd0b3AnIGluIG9wdGlvbnNcbiAgICAgICAgPyBvcHRpb25zLnRvcFxuICAgICAgICA6IHRoaXMuX2dldFRvcFRvT3JpZ2luWSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICovXG4gICAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19zZXQnLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICh0eXBlb2YgY29vcmRQcm9wc1trZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLl9zZXRXaWR0aEhlaWdodCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBsZWZ0VG9PcmlnaW5YIERpc3RhbmNlIGZyb20gbGVmdCBlZGdlIG9mIGNhbnZhcyB0byBvcmlnaW5YIG9mIExpbmUuXG4gICAgICovXG4gICAgX2dldExlZnRUb09yaWdpblg6IG1ha2VFZGdlVG9PcmlnaW5HZXR0ZXIoXG4gICAgICB7IC8vIHByb3BlcnR5IG5hbWVzXG4gICAgICAgIG9yaWdpbjogJ29yaWdpblgnLFxuICAgICAgICBheGlzMTogJ3gxJyxcbiAgICAgICAgYXhpczI6ICd4MicsXG4gICAgICAgIGRpbWVuc2lvbjogJ3dpZHRoJ1xuICAgICAgfSxcbiAgICAgIHsgLy8gcG9zc2libGUgdmFsdWVzIG9mIG9yaWdpblxuICAgICAgICBuZWFyZXN0OiAnbGVmdCcsXG4gICAgICAgIGNlbnRlcjogJ2NlbnRlcicsXG4gICAgICAgIGZhcnRoZXN0OiAncmlnaHQnXG4gICAgICB9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSB0b3BUb09yaWdpblkgRGlzdGFuY2UgZnJvbSB0b3AgZWRnZSBvZiBjYW52YXMgdG8gb3JpZ2luWSBvZiBMaW5lLlxuICAgICAqL1xuICAgIF9nZXRUb3BUb09yaWdpblk6IG1ha2VFZGdlVG9PcmlnaW5HZXR0ZXIoXG4gICAgICB7IC8vIHByb3BlcnR5IG5hbWVzXG4gICAgICAgIG9yaWdpbjogJ29yaWdpblknLFxuICAgICAgICBheGlzMTogJ3kxJyxcbiAgICAgICAgYXhpczI6ICd5MicsXG4gICAgICAgIGRpbWVuc2lvbjogJ2hlaWdodCdcbiAgICAgIH0sXG4gICAgICB7IC8vIHBvc3NpYmxlIHZhbHVlcyBvZiBvcmlnaW5cbiAgICAgICAgbmVhcmVzdDogJ3RvcCcsXG4gICAgICAgIGNlbnRlcjogJ2NlbnRlcicsXG4gICAgICAgIGZhcnRoZXN0OiAnYm90dG9tJ1xuICAgICAgfVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgaWYgKCF0aGlzLnN0cm9rZURhc2hBcnJheSB8fCB0aGlzLnN0cm9rZURhc2hBcnJheSAmJiBzdXBwb3J0c0xpbmVEYXNoKSB7XG4gICAgICAgIC8vIG1vdmUgZnJvbSBjZW50ZXIgKG9mIHZpcnR1YWwgYm94KSB0byBpdHMgbGVmdC90b3AgY29ybmVyXG4gICAgICAgIC8vIHdlIGNhbid0IGFzc3VtZSB4MSwgeTEgaXMgdG9wIGxlZnQgYW5kIHgyLCB5MiBpcyBib3R0b20gcmlnaHRcbiAgICAgICAgdmFyIHAgPSB0aGlzLmNhbGNMaW5lUG9pbnRzKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8ocC54MSwgcC55MSk7XG4gICAgICAgIGN0eC5saW5lVG8ocC54MiwgcC55Mik7XG4gICAgICB9XG5cbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoO1xuXG4gICAgICAvLyBUT0RPOiB0ZXN0IHRoaXNcbiAgICAgIC8vIG1ha2Ugc3VyZSBzZXR0aW5nIFwiZmlsbFwiIGNoYW5nZXMgY29sb3Igb2YgYSBsaW5lXG4gICAgICAvLyAoYnkgY29weWluZyBmaWxsU3R5bGUgdG8gc3Ryb2tlU3R5bGUsIHNpbmNlIGxpbmUgaXMgc3Ryb2tlZCwgbm90IGZpbGxlZClcbiAgICAgIHZhciBvcmlnU3Ryb2tlU3R5bGUgPSBjdHguc3Ryb2tlU3R5bGU7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZSB8fCBjdHguZmlsbFN0eWxlO1xuICAgICAgdGhpcy5zdHJva2UgJiYgdGhpcy5fcmVuZGVyU3Ryb2tlKGN0eCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcmlnU3Ryb2tlU3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHAgPSB0aGlzLmNhbGNMaW5lUG9pbnRzKCk7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgcC54MSwgcC55MSwgcC54MiwgcC55MiwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFuIGhlbHBlciBmb3Igc3ZnIGltcG9ydC4gaXQgcmV0dXJucyB0aGUgY2VudGVyIG9mIHRoZSBvYmplY3QgaW4gdGhlIHN2Z1xuICAgICAqIHVudHJhbnNmb3JtZWQgY29vcmRpbmF0ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIHBvaW50IGZyb20gZWxlbWVudCBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIF9maW5kQ2VudGVyRnJvbUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogKHRoaXMueDEgKyB0aGlzLngyKSAvIDIsXG4gICAgICAgIHk6ICh0aGlzLnkxICsgdGhpcy55MikgLyAyLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAbWV0aGQgdG9PYmplY3RcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwgdGhpcy5jYWxjTGluZVBvaW50cygpKTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGRpbWVuc2lvbnMgZnJvbSBpdHMgcHJvcGVydGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGltID0gdGhpcy5jYWxsU3VwZXIoJ19nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnMnKTtcbiAgICAgIGlmICh0aGlzLnN0cm9rZUxpbmVDYXAgPT09ICdidXR0Jykge1xuICAgICAgICBpZiAodGhpcy53aWR0aCA9PT0gMCkge1xuICAgICAgICAgIGRpbS55IC09IHRoaXMuc3Ryb2tlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgZGltLnggLT0gdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRpbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVjYWxjdWxhdGVzIGxpbmUgcG9pbnRzIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNhbGNMaW5lUG9pbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB4TXVsdCA9IHRoaXMueDEgPD0gdGhpcy54MiA/IC0xIDogMSxcbiAgICAgICAgICB5TXVsdCA9IHRoaXMueTEgPD0gdGhpcy55MiA/IC0xIDogMSxcbiAgICAgICAgICB4MSA9ICh4TXVsdCAqIHRoaXMud2lkdGggKiAwLjUpLFxuICAgICAgICAgIHkxID0gKHlNdWx0ICogdGhpcy5oZWlnaHQgKiAwLjUpLFxuICAgICAgICAgIHgyID0gKHhNdWx0ICogdGhpcy53aWR0aCAqIC0wLjUpLFxuICAgICAgICAgIHkyID0gKHlNdWx0ICogdGhpcy5oZWlnaHQgKiAtMC41KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IHgxLFxuICAgICAgICB4MjogeDIsXG4gICAgICAgIHkxOiB5MSxcbiAgICAgICAgeTI6IHkyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICB2YXIgbWFya3VwID0gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cCgpLFxuICAgICAgICAgIHAgPSB0aGlzLmNhbGNMaW5lUG9pbnRzKCk7XG4gICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgJzxsaW5lICcsIHRoaXMuZ2V0U3ZnSWQoKSxcbiAgICAgICAgJ3gxPVwiJywgcC54MSxcbiAgICAgICAgJ1wiIHkxPVwiJywgcC55MSxcbiAgICAgICAgJ1wiIHgyPVwiJywgcC54MixcbiAgICAgICAgJ1wiIHkyPVwiJywgcC55MixcbiAgICAgICAgJ1wiIHN0eWxlPVwiJywgdGhpcy5nZXRTdmdTdHlsZXMoKSxcbiAgICAgICAgJ1wiIHRyYW5zZm9ybT1cIicsIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKCksXG4gICAgICAgIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtTWF0cml4KCksXG4gICAgICAgICdcIi8+XFxuJ1xuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHJldml2ZXIgPyByZXZpdmVyKG1hcmt1cC5qb2luKCcnKSkgOiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuTGluZS5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5MaW5lXG4gICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI0xpbmVFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuTGluZS5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCd4MSB5MSB4MiB5Micuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLkxpbmUgaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuTGluZVxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqL1xuICBmYWJyaWMuTGluZS5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuTGluZS5BVFRSSUJVVEVfTkFNRVMpLFxuICAgICAgICBwb2ludHMgPSBbXG4gICAgICAgICAgcGFyc2VkQXR0cmlidXRlcy54MSB8fCAwLFxuICAgICAgICAgIHBhcnNlZEF0dHJpYnV0ZXMueTEgfHwgMCxcbiAgICAgICAgICBwYXJzZWRBdHRyaWJ1dGVzLngyIHx8IDAsXG4gICAgICAgICAgcGFyc2VkQXR0cmlidXRlcy55MiB8fCAwXG4gICAgICAgIF07XG4gICAgY2FsbGJhY2sobmV3IGZhYnJpYy5MaW5lKHBvaW50cywgZXh0ZW5kKHBhcnNlZEF0dHJpYnV0ZXMsIG9wdGlvbnMpKSk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLkxpbmUgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkxpbmVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBpbnZva2VkIHdpdGggbmV3IGluc3RhbmNlIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAqL1xuICBmYWJyaWMuTGluZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGZ1bmN0aW9uIF9jYWxsYmFjayhpbnN0YW5jZSkge1xuICAgICAgZGVsZXRlIGluc3RhbmNlLnBvaW50cztcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGluc3RhbmNlKTtcbiAgICB9O1xuICAgIHZhciBvcHRpb25zID0gY2xvbmUob2JqZWN0LCB0cnVlKTtcbiAgICBvcHRpb25zLnBvaW50cyA9IFtvYmplY3QueDEsIG9iamVjdC55MSwgb2JqZWN0LngyLCBvYmplY3QueTJdO1xuICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ0xpbmUnLCBvcHRpb25zLCBfY2FsbGJhY2ssICdwb2ludHMnKTtcbiAgfTtcblxuICAvKipcbiAgICogUHJvZHVjZXMgYSBmdW5jdGlvbiB0aGF0IGNhbGN1bGF0ZXMgZGlzdGFuY2UgZnJvbSBjYW52YXMgZWRnZSB0byBMaW5lIG9yaWdpbi5cbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VFZGdlVG9PcmlnaW5HZXR0ZXIocHJvcGVydHlOYW1lcywgb3JpZ2luVmFsdWVzKSB7XG4gICAgdmFyIG9yaWdpbiA9IHByb3BlcnR5TmFtZXMub3JpZ2luLFxuICAgICAgICBheGlzMSA9IHByb3BlcnR5TmFtZXMuYXhpczEsXG4gICAgICAgIGF4aXMyID0gcHJvcGVydHlOYW1lcy5heGlzMixcbiAgICAgICAgZGltZW5zaW9uID0gcHJvcGVydHlOYW1lcy5kaW1lbnNpb24sXG4gICAgICAgIG5lYXJlc3QgPSBvcmlnaW5WYWx1ZXMubmVhcmVzdCxcbiAgICAgICAgY2VudGVyID0gb3JpZ2luVmFsdWVzLmNlbnRlcixcbiAgICAgICAgZmFydGhlc3QgPSBvcmlnaW5WYWx1ZXMuZmFydGhlc3Q7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuZ2V0KG9yaWdpbikpIHtcbiAgICAgICAgY2FzZSBuZWFyZXN0OlxuICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmdldChheGlzMSksIHRoaXMuZ2V0KGF4aXMyKSk7XG4gICAgICAgIGNhc2UgY2VudGVyOlxuICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmdldChheGlzMSksIHRoaXMuZ2V0KGF4aXMyKSkgKyAoMC41ICogdGhpcy5nZXQoZGltZW5zaW9uKSk7XG4gICAgICAgIGNhc2UgZmFydGhlc3Q6XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuZ2V0KGF4aXMxKSwgdGhpcy5nZXQoYXhpczIpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIH1cblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgcGkgPSBNYXRoLlBJO1xuXG4gIGlmIChmYWJyaWMuQ2lyY2xlKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5DaXJjbGUgaXMgYWxyZWFkeSBkZWZpbmVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaXJjbGUgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5DaXJjbGVcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuQ2lyY2xlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuQ2lyY2xlID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuQ2lyY2xlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2NpcmNsZScsXG5cbiAgICAvKipcbiAgICAgKiBSYWRpdXMgb2YgdGhpcyBjaXJjbGVcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJhZGl1czogMCxcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGFuZ2xlIG9mIHRoZSBjaXJjbGUsIG1vdmluZyBjbG9ja3dpc2VcbiAgICAgKiBkZXByZWN0YXRlZCB0eXBlLCB0aGlzIHNob3VsZCBiZSBpbiBkZWdyZWUsIHRoaXMgd2FzIGFuIG92ZXJzaWdodC5cbiAgICAgKiBwcm9iYWJseSB3aWxsIGNoYW5nZSB0byBkZWdyZWVzIGluIG5leHQgbWFqb3IgdmVyc2lvblxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBzdGFydEFuZ2xlOiAwLFxuXG4gICAgLyoqXG4gICAgICogRW5kIGFuZ2xlIG9mIHRoZSBjaXJjbGVcbiAgICAgKiBkZXByZWN0YXRlZCB0eXBlLCB0aGlzIHNob3VsZCBiZSBpbiBkZWdyZWUsIHRoaXMgd2FzIGFuIG92ZXJzaWdodC5cbiAgICAgKiBwcm9iYWJseSB3aWxsIGNoYW5nZSB0byBkZWdyZWVzIGluIG5leHQgbWFqb3IgdmVyc2lvblxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDJQaVxuICAgICAqL1xuICAgIGVuZEFuZ2xlOiBwaSAqIDIsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3JhZGl1cycsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJyksXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNpcmNsZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0Jywga2V5LCB2YWx1ZSk7XG5cbiAgICAgIGlmIChrZXkgPT09ICdyYWRpdXMnKSB7XG4gICAgICAgIHRoaXMuc2V0UmFkaXVzKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ3JhZGl1cycsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJ10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAoKSwgeCA9IDAsIHkgPSAwLFxuICAgICAgICAgIGFuZ2xlID0gKHRoaXMuZW5kQW5nbGUgLSB0aGlzLnN0YXJ0QW5nbGUpICUgKCAyICogcGkpO1xuXG4gICAgICBpZiAoYW5nbGUgPT09IDApIHtcbiAgICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICAgJzxjaXJjbGUgJywgdGhpcy5nZXRTdmdJZCgpLFxuICAgICAgICAgICdjeD1cIicgKyB4ICsgJ1wiIGN5PVwiJyArIHkgKyAnXCIgJyxcbiAgICAgICAgICAncj1cIicsIHRoaXMucmFkaXVzLFxuICAgICAgICAgICdcIiBzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKCksXG4gICAgICAgICAgJ1wiIHRyYW5zZm9ybT1cIicsIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKCksXG4gICAgICAgICAgJyAnLCB0aGlzLmdldFN2Z1RyYW5zZm9ybU1hdHJpeCgpLCAnXCInLFxuICAgICAgICAgIHRoaXMuYWRkUGFpbnRPcmRlcigpLFxuICAgICAgICAgICcvPlxcbidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgc3RhcnRYID0gZmFicmljLnV0aWwuY29zKHRoaXMuc3RhcnRBbmdsZSkgKiB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAgIHN0YXJ0WSA9IGZhYnJpYy51dGlsLnNpbih0aGlzLnN0YXJ0QW5nbGUpICogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICBlbmRYID0gZmFicmljLnV0aWwuY29zKHRoaXMuZW5kQW5nbGUpICogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICBlbmRZID0gZmFicmljLnV0aWwuc2luKHRoaXMuZW5kQW5nbGUpICogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICBsYXJnZUZsYWcgPSBhbmdsZSA+IHBpID8gJzEnIDogJzAnO1xuXG4gICAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAgICc8cGF0aCBkPVwiTSAnICsgc3RhcnRYICsgJyAnICsgc3RhcnRZLFxuICAgICAgICAgICcgQSAnICsgdGhpcy5yYWRpdXMgKyAnICcgKyB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAnIDAgJywgK2xhcmdlRmxhZyArICcgMScsICcgJyArIGVuZFggKyAnICcgKyBlbmRZLFxuICAgICAgICAgICdcIiBzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKCksXG4gICAgICAgICAgJ1wiIHRyYW5zZm9ybT1cIicsIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKCksXG4gICAgICAgICAgJyAnLCB0aGlzLmdldFN2Z1RyYW5zZm9ybU1hdHJpeCgpLCAnXCInLFxuICAgICAgICAgIHRoaXMuYWRkUGFpbnRPcmRlcigpLFxuICAgICAgICAgICdcIi8+XFxuJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIobWFya3VwLmpvaW4oJycpKSA6IG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLnJhZGl1cyxcbiAgICAgICAgdGhpcy5zdGFydEFuZ2xlLFxuICAgICAgICB0aGlzLmVuZEFuZ2xlLCBmYWxzZSk7XG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBob3Jpem9udGFsIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFjY29yZGluZyB0byBob3cgYW4gb2JqZWN0IGlzIHNjYWxlZClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0UmFkaXVzWDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoJ3JhZGl1cycpICogdGhpcy5nZXQoJ3NjYWxlWCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHZlcnRpY2FsIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFjY29yZGluZyB0byBob3cgYW4gb2JqZWN0IGlzIHNjYWxlZClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0UmFkaXVzWTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoJ3JhZGl1cycpICogdGhpcy5nZXQoJ3NjYWxlWScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFuZCB1cGRhdGVzIHdpZHRoIGFjY29yZGluZ2x5KVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DaXJjbGV9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBzZXRSYWRpdXM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLnJhZGl1cyA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KCd3aWR0aCcsIHZhbHVlICogMikuc2V0KCdoZWlnaHQnLCB2YWx1ZSAqIDIpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLkNpcmNsZS5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5DaXJjbGVcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI0NpcmNsZUVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5DaXJjbGUuQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdCgnY3ggY3kgcicuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5DaXJjbGV9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNpcmNsZVxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIE9wdGlvbnMgY2FsbGJhY2sgaW52b2tlZCBhZnRlciBwYXJzaW5nIGlzIGZpbmlzaGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHZhbHVlIG9mIGByYCBhdHRyaWJ1dGUgaXMgbWlzc2luZyBvciBpbnZhbGlkXG4gICAqL1xuICBmYWJyaWMuQ2lyY2xlLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLkNpcmNsZS5BVFRSSUJVVEVfTkFNRVMpO1xuXG4gICAgaWYgKCFpc1ZhbGlkUmFkaXVzKHBhcnNlZEF0dHJpYnV0ZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIG9mIGByYCBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgYW5kIGNhbiBub3QgYmUgbmVnYXRpdmUnKTtcbiAgICB9XG5cbiAgICBwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgPSAocGFyc2VkQXR0cmlidXRlcy5sZWZ0IHx8IDApIC0gcGFyc2VkQXR0cmlidXRlcy5yYWRpdXM7XG4gICAgcGFyc2VkQXR0cmlidXRlcy50b3AgPSAocGFyc2VkQXR0cmlidXRlcy50b3AgfHwgMCkgLSBwYXJzZWRBdHRyaWJ1dGVzLnJhZGl1cztcbiAgICBjYWxsYmFjayhuZXcgZmFicmljLkNpcmNsZShwYXJzZWRBdHRyaWJ1dGVzKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBpc1ZhbGlkUmFkaXVzKGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gKCgncmFkaXVzJyBpbiBhdHRyaWJ1dGVzKSAmJiAoYXR0cmlidXRlcy5yYWRpdXMgPj0gMCkpO1xuICB9XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5DaXJjbGV9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5DaXJjbGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBpbnZva2VkIHdpdGggbmV3IGluc3RhbmNlIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAqIEByZXR1cm4ge09iamVjdH0gSW5zdGFuY2Ugb2YgZmFicmljLkNpcmNsZVxuICAgKi9cbiAgZmFicmljLkNpcmNsZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdDaXJjbGUnLCBvYmplY3QsIGNhbGxiYWNrKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuVHJpYW5nbGUpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlRyaWFuZ2xlIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlhbmdsZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlRyaWFuZ2xlXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLlRyaWFuZ2xlfSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5UcmlhbmdsZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlRyaWFuZ2xlID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuVHJpYW5nbGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAndHJpYW5nbGUnLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggaXMgc2V0IHRvIDEwMCB0byBjb21wZW5zYXRlIHRoZSBvbGQgaW5pdGlhbGl6ZSBjb2RlIHRoYXQgd2FzIHNldHRpbmcgaXQgdG8gMTAwXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB3aWR0aDogMTAwLFxuXG4gICAgLyoqXG4gICAgICogSGVpZ2h0IGlzIHNldCB0byAxMDAgdG8gY29tcGVuc2F0ZSB0aGUgb2xkIGluaXRpYWxpemUgY29kZSB0aGF0IHdhcyBzZXR0aW5nIGl0IHRvIDEwMFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaGVpZ2h0OiAxMDAsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciB3aWR0aEJ5MiA9IHRoaXMud2lkdGggLyAyLFxuICAgICAgICAgIGhlaWdodEJ5MiA9IHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbygtd2lkdGhCeTIsIGhlaWdodEJ5Mik7XG4gICAgICBjdHgubGluZVRvKDAsIC1oZWlnaHRCeTIpO1xuICAgICAgY3R4LmxpbmVUbyh3aWR0aEJ5MiwgaGVpZ2h0QnkyKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHdpZHRoQnkyID0gdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgaGVpZ2h0QnkyID0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIC13aWR0aEJ5MiwgaGVpZ2h0QnkyLCAwLCAtaGVpZ2h0QnkyLCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIDAsIC1oZWlnaHRCeTIsIHdpZHRoQnkyLCBoZWlnaHRCeTIsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgd2lkdGhCeTIsIGhlaWdodEJ5MiwgLXdpZHRoQnkyLCBoZWlnaHRCeTIsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAoKSxcbiAgICAgICAgICB3aWR0aEJ5MiA9IHRoaXMud2lkdGggLyAyLFxuICAgICAgICAgIGhlaWdodEJ5MiA9IHRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgICBwb2ludHMgPSBbXG4gICAgICAgICAgICAtd2lkdGhCeTIgKyAnICcgKyBoZWlnaHRCeTIsXG4gICAgICAgICAgICAnMCAnICsgLWhlaWdodEJ5MixcbiAgICAgICAgICAgIHdpZHRoQnkyICsgJyAnICsgaGVpZ2h0QnkyXG4gICAgICAgICAgXVxuICAgICAgICAgICAgLmpvaW4oJywnKTtcblxuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8cG9seWdvbiAnLCB0aGlzLmdldFN2Z0lkKCksXG4gICAgICAgICdwb2ludHM9XCInLCBwb2ludHMsXG4gICAgICAgICdcIiBzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKCksXG4gICAgICAgICdcIiB0cmFuc2Zvcm09XCInLCB0aGlzLmdldFN2Z1RyYW5zZm9ybSgpLCAnXCInLFxuICAgICAgICB0aGlzLmFkZFBhaW50T3JkZXIoKSxcbiAgICAgICAgJy8+J1xuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHJldml2ZXIgPyByZXZpdmVyKG1hcmt1cC5qb2luKCcnKSkgOiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5UcmlhbmdsZX0gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlRyaWFuZ2xlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gaW52b2tlZCB3aXRoIG5ldyBpbnN0YW5jZSBhcyBmaXJzdCBhcmd1bWVudFxuICAgKi9cbiAgZmFicmljLlRyaWFuZ2xlLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1RyaWFuZ2xlJywgb2JqZWN0LCBjYWxsYmFjayk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIHBpQnkyICAgPSBNYXRoLlBJICogMjtcblxuICBpZiAoZmFicmljLkVsbGlwc2UpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkVsbGlwc2UgaXMgYWxyZWFkeSBkZWZpbmVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbGxpcHNlIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuRWxsaXBzZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5FbGxpcHNlfSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5FbGxpcHNlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuRWxsaXBzZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLkVsbGlwc2UucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnZWxsaXBzZScsXG5cbiAgICAvKipcbiAgICAgKiBIb3Jpem9udGFsIHJhZGl1c1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcng6ICAgMCxcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIHJhZGl1c1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcnk6ICAgMCxcblxuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgncngnLCAncnknKSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5FbGxpcHNlfSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc2V0KCdyeCcsIG9wdGlvbnMgJiYgb3B0aW9ucy5yeCB8fCAwKTtcbiAgICAgIHRoaXMuc2V0KCdyeScsIG9wdGlvbnMgJiYgb3B0aW9ucy5yeSB8fCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5FbGxpcHNlfSB0aGlzQXJnXG4gICAgICovXG4gICAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19zZXQnLCBrZXksIHZhbHVlKTtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG5cbiAgICAgICAgY2FzZSAncngnOlxuICAgICAgICAgIHRoaXMucnggPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNldCgnd2lkdGgnLCB2YWx1ZSAqIDIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3J5JzpcbiAgICAgICAgICB0aGlzLnJ5ID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5zZXQoJ2hlaWdodCcsIHZhbHVlICogMik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGhvcml6b250YWwgcmFkaXVzIG9mIGFuIG9iamVjdCAoYWNjb3JkaW5nIHRvIGhvdyBhbiBvYmplY3QgaXMgc2NhbGVkKVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSeDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoJ3J4JykgKiB0aGlzLmdldCgnc2NhbGVYJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgVmVydGljYWwgcmFkaXVzIG9mIGFuIG9iamVjdCAoYWNjb3JkaW5nIHRvIGhvdyBhbiBvYmplY3QgaXMgc2NhbGVkKVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSeTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoJ3J5JykgKiB0aGlzLmdldCgnc2NhbGVZJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ3J4JywgJ3J5J10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAoKTtcbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPGVsbGlwc2UgJywgdGhpcy5nZXRTdmdJZCgpLFxuICAgICAgICAnY3g9XCIwXCIgY3k9XCIwXCIgJyxcbiAgICAgICAgJ3J4PVwiJywgdGhpcy5yeCxcbiAgICAgICAgJ1wiIHJ5PVwiJywgdGhpcy5yeSxcbiAgICAgICAgJ1wiIHN0eWxlPVwiJywgdGhpcy5nZXRTdmdTdHlsZXMoKSxcbiAgICAgICAgJ1wiIHRyYW5zZm9ybT1cIicsIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKCksXG4gICAgICAgIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtTWF0cml4KCksICdcIicsXG4gICAgICAgIHRoaXMuYWRkUGFpbnRPcmRlcigpLFxuICAgICAgICAnLz5cXG4nXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIobWFya3VwLmpvaW4oJycpKSA6IG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSgxLCAwLCAwLCB0aGlzLnJ5IC8gdGhpcy5yeCwgMCwgMCk7XG4gICAgICBjdHguYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLnJ4LFxuICAgICAgICAwLFxuICAgICAgICBwaUJ5MixcbiAgICAgICAgZmFsc2UpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLkVsbGlwc2UuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuRWxsaXBzZVxuICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zaGFwZXMuaHRtbCNFbGxpcHNlRWxlbWVudFxuICAgKi9cbiAgZmFicmljLkVsbGlwc2UuQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdCgnY3ggY3kgcnggcnknLnNwbGl0KCcgJykpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuRWxsaXBzZX0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuRWxsaXBzZVxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIE9wdGlvbnMgY2FsbGJhY2sgaW52b2tlZCBhZnRlciBwYXJzaW5nIGlzIGZpbmlzaGVkXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5FbGxpcHNlfVxuICAgKi9cbiAgZmFicmljLkVsbGlwc2UuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaykge1xuXG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5FbGxpcHNlLkFUVFJJQlVURV9OQU1FUyk7XG5cbiAgICBwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgPSAocGFyc2VkQXR0cmlidXRlcy5sZWZ0IHx8IDApIC0gcGFyc2VkQXR0cmlidXRlcy5yeDtcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLnRvcCA9IChwYXJzZWRBdHRyaWJ1dGVzLnRvcCB8fCAwKSAtIHBhcnNlZEF0dHJpYnV0ZXMucnk7XG4gICAgY2FsbGJhY2sobmV3IGZhYnJpYy5FbGxpcHNlKHBhcnNlZEF0dHJpYnV0ZXMpKTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkVsbGlwc2V9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5FbGxpcHNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gaW52b2tlZCB3aXRoIG5ldyBpbnN0YW5jZSBhcyBmaXJzdCBhcmd1bWVudFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuRWxsaXBzZX1cbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ0VsbGlwc2UnLCBvYmplY3QsIGNhbGxiYWNrKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZDtcblxuICBpZiAoZmFicmljLlJlY3QpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlJlY3QgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY3RhbmdsZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlJlY3RcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuUmVjdH0gdGhpc0FyZ1xuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUmVjdCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlJlY3QgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5SZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZiBzdGF0ZSBvZiBhbiBvYmplY3QgaXMgY2hhbmdlZCAoe0BsaW5rIGZhYnJpYy5PYmplY3QjaGFzU3RhdGVDaGFuZ2VkfSlcbiAgICAgKiBhcyB3ZWxsIGFzIGZvciBoaXN0b3J5ICh1bmRvL3JlZG8pIHB1cnBvc2VzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBzdGF0ZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnN0YXRlUHJvcGVydGllcy5jb25jYXQoJ3J4JywgJ3J5JyksXG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3JlY3QnLFxuXG4gICAgLyoqXG4gICAgICogSG9yaXpvbnRhbCBib3JkZXIgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByeDogICAwLFxuXG4gICAgLyoqXG4gICAgICogVmVydGljYWwgYm9yZGVyIHJhZGl1c1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcnk6ICAgMCxcblxuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgncngnLCAncnknKSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0UnhSeSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyByeC9yeSBhdHRyaWJ1dGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdFJ4Unk6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucnggJiYgIXRoaXMucnkpIHtcbiAgICAgICAgdGhpcy5yeSA9IHRoaXMucng7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnJ5ICYmICF0aGlzLnJ4KSB7XG4gICAgICAgIHRoaXMucnggPSB0aGlzLnJ5O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcblxuICAgICAgLy8gb3B0aW1pemUgMXgxIGNhc2UgKHVzZWQgaW4gc3ByYXkgYnJ1c2gpXG4gICAgICBpZiAodGhpcy53aWR0aCA9PT0gMSAmJiB0aGlzLmhlaWdodCA9PT0gMSkge1xuICAgICAgICBjdHguZmlsbFJlY3QoLTAuNSwgLTAuNSwgMSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJ4ID0gdGhpcy5yeCA/IE1hdGgubWluKHRoaXMucngsIHRoaXMud2lkdGggLyAyKSA6IDAsXG4gICAgICAgICAgcnkgPSB0aGlzLnJ5ID8gTWF0aC5taW4odGhpcy5yeSwgdGhpcy5oZWlnaHQgLyAyKSA6IDAsXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGgsXG4gICAgICAgICAgaCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIHggPSAtdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgeSA9IC10aGlzLmhlaWdodCAvIDIsXG4gICAgICAgICAgaXNSb3VuZGVkID0gcnggIT09IDAgfHwgcnkgIT09IDAsXG4gICAgICAgICAgLyogXCJtYWdpYyBudW1iZXJcIiBmb3IgYmV6aWVyIGFwcHJveGltYXRpb25zIG9mIGFyY3MgKGh0dHA6Ly9pdGMua3R1Lmx0L2l0YzM1NC9SaXNrdXMzNTQucGRmKSAqL1xuICAgICAgICAgIGsgPSAxIC0gMC41NTIyODQ3NDk4O1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBjdHgubW92ZVRvKHggKyByeCwgeSk7XG5cbiAgICAgIGN0eC5saW5lVG8oeCArIHcgLSByeCwgeSk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCArIHcgLSBrICogcngsIHksIHggKyB3LCB5ICsgayAqIHJ5LCB4ICsgdywgeSArIHJ5KTtcblxuICAgICAgY3R4LmxpbmVUbyh4ICsgdywgeSArIGggLSByeSk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCArIHcsIHkgKyBoIC0gayAqIHJ5LCB4ICsgdyAtIGsgKiByeCwgeSArIGgsIHggKyB3IC0gcngsIHkgKyBoKTtcblxuICAgICAgY3R4LmxpbmVUbyh4ICsgcngsIHkgKyBoKTtcbiAgICAgIGlzUm91bmRlZCAmJiBjdHguYmV6aWVyQ3VydmVUbyh4ICsgayAqIHJ4LCB5ICsgaCwgeCwgeSArIGggLSBrICogcnksIHgsIHkgKyBoIC0gcnkpO1xuXG4gICAgICBjdHgubGluZVRvKHgsIHkgKyByeSk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCwgeSArIGsgKiByeSwgeCArIGsgKiByeCwgeSwgeCArIHJ4LCB5KTtcblxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckRhc2hlZFN0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgeCA9IC10aGlzLndpZHRoIC8gMixcbiAgICAgICAgICB5ID0gLXRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgICB3ID0gdGhpcy53aWR0aCxcbiAgICAgICAgICBoID0gdGhpcy5oZWlnaHQ7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgeCwgeSwgeCArIHcsIHksIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgeCArIHcsIHksIHggKyB3LCB5ICsgaCwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCB4ICsgdywgeSArIGgsIHgsIHkgKyBoLCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHgsIHkgKyBoLCB4LCB5LCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ3J4JywgJ3J5J10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAoKSwgeCA9IC10aGlzLndpZHRoIC8gMiwgeSA9IC10aGlzLmhlaWdodCAvIDI7XG4gICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgJzxyZWN0ICcsIHRoaXMuZ2V0U3ZnSWQoKSxcbiAgICAgICAgJ3g9XCInLCB4LCAnXCIgeT1cIicsIHksXG4gICAgICAgICdcIiByeD1cIicsIHRoaXMuZ2V0KCdyeCcpLCAnXCIgcnk9XCInLCB0aGlzLmdldCgncnknKSxcbiAgICAgICAgJ1wiIHdpZHRoPVwiJywgdGhpcy53aWR0aCwgJ1wiIGhlaWdodD1cIicsIHRoaXMuaGVpZ2h0LFxuICAgICAgICAnXCIgc3R5bGU9XCInLCB0aGlzLmdldFN2Z1N0eWxlcygpLFxuICAgICAgICAnXCIgdHJhbnNmb3JtPVwiJywgdGhpcy5nZXRTdmdUcmFuc2Zvcm0oKSxcbiAgICAgICAgdGhpcy5nZXRTdmdUcmFuc2Zvcm1NYXRyaXgoKSwgJ1wiJyxcbiAgICAgICAgdGhpcy5hZGRQYWludE9yZGVyKCksXG4gICAgICAgICcvPlxcbicpO1xuXG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIobWFya3VwLmpvaW4oJycpKSA6IG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkgYGZhYnJpYy5SZWN0LmZyb21FbGVtZW50YClcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlJlY3RcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI1JlY3RFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuUmVjdC5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCd4IHkgcnggcnkgd2lkdGggaGVpZ2h0Jy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlJlY3R9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlJlY3RcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5SZWN0LmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuXG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5SZWN0LkFUVFJJQlVURV9OQU1FUyk7XG5cbiAgICBwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgPSBwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgfHwgMDtcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLnRvcCAgPSBwYXJzZWRBdHRyaWJ1dGVzLnRvcCAgfHwgMDtcbiAgICB2YXIgcmVjdCA9IG5ldyBmYWJyaWMuUmVjdChleHRlbmQoKG9wdGlvbnMgPyBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob3B0aW9ucykgOiB7IH0pLCBwYXJzZWRBdHRyaWJ1dGVzKSk7XG4gICAgcmVjdC52aXNpYmxlID0gcmVjdC52aXNpYmxlICYmIHJlY3Qud2lkdGggPiAwICYmIHJlY3QuaGVpZ2h0ID4gMDtcbiAgICBjYWxsYmFjayhyZWN0KTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlJlY3R9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5SZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlJlY3QgaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlJlY3QuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnUmVjdCcsIG9iamVjdCwgY2FsbGJhY2spO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluLFxuICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4LFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgaWYgKGZhYnJpYy5Qb2x5bGluZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuUG9seWxpbmUgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvbHlsaW5lIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUG9seWxpbmVcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUG9seWxpbmUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5Qb2x5bGluZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLlBvbHlsaW5lLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3BvbHlsaW5lJyxcblxuICAgIC8qKlxuICAgICAqIFBvaW50cyBhcnJheVxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwb2ludHM6IG51bGwsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3BvaW50cycpLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgQXJyYXkgb2YgcG9pbnRzICh3aGVyZSBlYWNoIHBvaW50IGlzIGFuIG9iamVjdCB3aXRoIHggYW5kIHkpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2x5bGluZX0gdGhpc0FyZ1xuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHBvbHkgPSBuZXcgZmFicmljLlBvbHlsaW5lKFtcbiAgICAgKiAgICAgeyB4OiAxMCwgeTogMTAgfSxcbiAgICAgKiAgICAgeyB4OiA1MCwgeTogMzAgfSxcbiAgICAgKiAgICAgeyB4OiA0MCwgeTogNzAgfSxcbiAgICAgKiAgICAgeyB4OiA2MCwgeTogNTAgfSxcbiAgICAgKiAgICAgeyB4OiAxMDAsIHk6IDE1MCB9LFxuICAgICAqICAgICB7IHg6IDQwLCB5OiAxMDAgfVxuICAgICAqICAgXSwge1xuICAgICAqICAgc3Ryb2tlOiAncmVkJyxcbiAgICAgKiAgIGxlZnQ6IDEwMCxcbiAgICAgKiAgIHRvcDogMTAwXG4gICAgICogfSk7XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ocG9pbnRzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzIHx8IFtdO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHZhciBjYWxjRGltID0gdGhpcy5fY2FsY0RpbWVuc2lvbnMoKTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sZWZ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmxlZnQgPSBjYWxjRGltLmxlZnQ7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9wID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnRvcCA9IGNhbGNEaW0udG9wO1xuICAgICAgfVxuICAgICAgdGhpcy53aWR0aCA9IGNhbGNEaW0ud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGNhbGNEaW0uaGVpZ2h0O1xuICAgICAgdGhpcy5wYXRoT2Zmc2V0ID0ge1xuICAgICAgICB4OiBjYWxjRGltLmxlZnQgKyB0aGlzLndpZHRoIC8gMixcbiAgICAgICAgeTogY2FsY0RpbS50b3AgKyB0aGlzLmhlaWdodCAvIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcG9seWdvbiBtaW4gYW5kIG1heCBwb2ludCBmcm9tIHBvaW50cyBhcnJheSxcbiAgICAgKiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggbGVmdCwgdG9wLCB3aWRodCwgaGVpZ2h0IHRvIG1lYXN1cmUgdGhlXG4gICAgICogcG9seWdvbiBzaXplXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QubGVmdCBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvbHlnb24gbGVmdG1vc3QgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC50b3AgWSBjb29yZGluYXRlIG9mIHRoZSBwb2x5Z29uIHRvcG1vc3QgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC53aWR0aCBkaXN0YW5jZSBiZXR3ZWVuIFggY29vcmRpbmF0ZXMgb2YgdGhlIHBvbHlnb24gbGVmdG1vc3QgYW5kIHJpZ2h0bW9zdCBwb2ludFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0LmhlaWdodCBkaXN0YW5jZSBiZXR3ZWVuIFkgY29vcmRpbmF0ZXMgb2YgdGhlIHBvbHlnb24gdG9wbW9zdCBhbmQgYm90dG9tbW9zdCBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGNEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxuICAgICAgICAgIG1pblggPSBtaW4ocG9pbnRzLCAneCcpIHx8IDAsXG4gICAgICAgICAgbWluWSA9IG1pbihwb2ludHMsICd5JykgfHwgMCxcbiAgICAgICAgICBtYXhYID0gbWF4KHBvaW50cywgJ3gnKSB8fCAwLFxuICAgICAgICAgIG1heFkgPSBtYXgocG9pbnRzLCAneScpIHx8IDAsXG4gICAgICAgICAgd2lkdGggPSAobWF4WCAtIG1pblgpLFxuICAgICAgICAgIGhlaWdodCA9IChtYXhZIC0gbWluWSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IG1pblgsXG4gICAgICAgIHRvcDogbWluWSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwge1xuICAgICAgICBwb2ludHM6IHRoaXMucG9pbnRzLmNvbmNhdCgpXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIHBvaW50cyA9IFtdLCBkaWZmWCA9IHRoaXMucGF0aE9mZnNldC54LCBkaWZmWSA9IHRoaXMucGF0aE9mZnNldC55LFxuICAgICAgICAgIG1hcmt1cCA9IHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAoKSxcbiAgICAgICAgICBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcG9pbnRzLnB1c2goXG4gICAgICAgICAgdG9GaXhlZCh0aGlzLnBvaW50c1tpXS54IC0gZGlmZlgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLCAnLCcsXG4gICAgICAgICAgdG9GaXhlZCh0aGlzLnBvaW50c1tpXS55IC0gZGlmZlksIE5VTV9GUkFDVElPTl9ESUdJVFMpLCAnICdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPCcsIHRoaXMudHlwZSwgJyAnLCB0aGlzLmdldFN2Z0lkKCksXG4gICAgICAgICdwb2ludHM9XCInLCBwb2ludHMuam9pbignJyksXG4gICAgICAgICdcIiBzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKCksXG4gICAgICAgICdcIiB0cmFuc2Zvcm09XCInLCB0aGlzLmdldFN2Z1RyYW5zZm9ybSgpLFxuICAgICAgICAnICcsIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtTWF0cml4KCksICdcIicsXG4gICAgICAgIHRoaXMuYWRkUGFpbnRPcmRlcigpLFxuICAgICAgICAnLz5cXG4nXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIobWFya3VwLmpvaW4oJycpKSA6IG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBjb21tb25SZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHBvaW50LCBsZW4gPSB0aGlzLnBvaW50cy5sZW5ndGgsXG4gICAgICAgICAgeCA9IHRoaXMucGF0aE9mZnNldC54LFxuICAgICAgICAgIHkgPSB0aGlzLnBhdGhPZmZzZXQueTtcblxuICAgICAgaWYgKCFsZW4gfHwgaXNOYU4odGhpcy5wb2ludHNbbGVuIC0gMV0ueSkpIHtcbiAgICAgICAgLy8gZG8gbm90IGRyYXcgaWYgbm8gcG9pbnRzIG9yIG9kZCBwb2ludHNcbiAgICAgICAgLy8gTmFOIGNvbWVzIGZyb20gcGFyc2VGbG9hdCBvZiBhIGVtcHR5IHN0cmluZyBpbiBwYXJzZXJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyh0aGlzLnBvaW50c1swXS54IC0geCwgdGhpcy5wb2ludHNbMF0ueSAtIHkpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwb2ludCA9IHRoaXMucG9pbnRzW2ldO1xuICAgICAgICBjdHgubGluZVRvKHBvaW50LnggLSB4LCBwb2ludC55IC0geSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuY29tbW9uUmVuZGVyKGN0eCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHAxLCBwMjtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHAxID0gdGhpcy5wb2ludHNbaV07XG4gICAgICAgIHAyID0gdGhpcy5wb2ludHNbaSArIDFdIHx8IHAxO1xuICAgICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHAxLngsIHAxLnksIHAyLngsIHAyLnksIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb21wbGV4aXR5IG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5IG9mIHRoaXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncG9pbnRzJykubGVuZ3RoO1xuICAgIH1cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWxpbmVcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI1BvbHlsaW5lRWxlbWVudFxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoKTtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuUG9seWxpbmUgaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWxpbmVcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgYWZ0ZXIgcGFyc2luZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgIHZhciBwb2ludHMgPSBmYWJyaWMucGFyc2VQb2ludHNBdHRyaWJ1dGUoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpKSxcbiAgICAgICAgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLlBvbHlsaW5lLkFUVFJJQlVURV9OQU1FUyk7XG5cbiAgICBjYWxsYmFjayhuZXcgZmFicmljLlBvbHlsaW5lKHBvaW50cywgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChwYXJzZWRBdHRyaWJ1dGVzLCBvcHRpb25zKSkpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5Qb2x5bGluZSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWxpbmVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBmYWJyaWMuUGF0aCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuUG9seWxpbmUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnUG9seWxpbmUnLCBvYmplY3QsIGNhbGxiYWNrLCAncG9pbnRzJyk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQ7XG5cbiAgaWYgKGZhYnJpYy5Qb2x5Z29uKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5Qb2x5Z29uIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb2x5Z29uIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUG9seWdvblxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuUG9seWxpbmVcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlBvbHlnb24jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5Qb2x5Z29uID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLlBvbHlsaW5lLCAvKiogQGxlbmRzIGZhYnJpYy5Qb2x5Z29uLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3BvbHlnb24nLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuY29tbW9uUmVuZGVyKGN0eCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19yZW5kZXJEYXNoZWRTdHJva2UnLCBjdHgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSBgZmFicmljLlBvbHlnb24uZnJvbUVsZW1lbnRgKVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWdvblxuICAgKiBAc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjUG9seWdvbkVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5Qb2x5Z29uLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlBvbHlnb259IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlnb25cbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5Qb2x5Z29uLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG5cbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgIHZhciBwb2ludHMgPSBmYWJyaWMucGFyc2VQb2ludHNBdHRyaWJ1dGUoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpKSxcbiAgICAgICAgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLlBvbHlnb24uQVRUUklCVVRFX05BTUVTKTtcblxuICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuUG9seWdvbihwb2ludHMsIGV4dGVuZChwYXJzZWRBdHRyaWJ1dGVzLCBvcHRpb25zKSkpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5Qb2x5Z29uIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Qb2x5Z29uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlBvbHlnb24uZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnUG9seWdvbicsIG9iamVjdCwgY2FsbGJhY2ssICdwb2ludHMnKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluLFxuICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4LFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICBkcmF3QXJjID0gZmFicmljLnV0aWwuZHJhd0FyYyxcbiAgICAgIGNvbW1hbmRMZW5ndGhzID0ge1xuICAgICAgICBtOiAyLFxuICAgICAgICBsOiAyLFxuICAgICAgICBoOiAxLFxuICAgICAgICB2OiAxLFxuICAgICAgICBjOiA2LFxuICAgICAgICBzOiA0LFxuICAgICAgICBxOiA0LFxuICAgICAgICB0OiAyLFxuICAgICAgICBhOiA3XG4gICAgICB9LFxuICAgICAgcmVwZWF0ZWRDb21tYW5kcyA9IHtcbiAgICAgICAgbTogJ2wnLFxuICAgICAgICBNOiAnTCdcbiAgICAgIH07XG5cbiAgaWYgKGZhYnJpYy5QYXRoKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5QYXRoIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXRoIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUGF0aFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0xI3BhdGhfYW5kX3BhdGhncm91cH1cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlBhdGgjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5QYXRoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuUGF0aC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdwYXRoJyxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIHBhdGggcG9pbnRzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhdGg6IG51bGwsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3BhdGgnLCAnZmlsbFJ1bGUnKSxcblxuICAgIHN0YXRlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuc3RhdGVQcm9wZXJ0aWVzLmNvbmNhdCgncGF0aCcpLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gcGF0aCBQYXRoIGRhdGEgKHNlcXVlbmNlIG9mIGNvb3JkaW5hdGVzIGFuZCBjb3JyZXNwb25kaW5nIFwiY29tbWFuZFwiIHRva2VucylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBhdGh9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihwYXRoLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgcGF0aCA9IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnJvbUFycmF5ID0gX3RvU3RyaW5nLmNhbGwocGF0aCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cbiAgICAgIHRoaXMucGF0aCA9IGZyb21BcnJheVxuICAgICAgICA/IHBhdGhcbiAgICAgICAgLy8gb25lIG9mIGNvbW1hbmRzIChtLE0sbCxMLHEsUSxjLEMsZXRjLikgZm9sbG93ZWQgYnkgbm9uLWNvbW1hbmQgY2hhcmFjdGVycyAoaS5lLiBjb21tYW5kIHZhbHVlcylcbiAgICAgICAgOiBwYXRoLm1hdGNoICYmIHBhdGgubWF0Y2goL1ttemxodmNzcXRhXVtebXpsaHZjc3F0YV0qL2dpKTtcblxuICAgICAgaWYgKCF0aGlzLnBhdGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZyb21BcnJheSkge1xuICAgICAgICB0aGlzLnBhdGggPSB0aGlzLl9wYXJzZVBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0UG9zaXRpb25EaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX3NldFBvc2l0aW9uRGltZW5zaW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNhbGNEaW0gPSB0aGlzLl9wYXJzZURpbWVuc2lvbnMoKTtcblxuICAgICAgdGhpcy53aWR0aCA9IGNhbGNEaW0ud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGNhbGNEaW0uaGVpZ2h0O1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMubGVmdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0gY2FsY0RpbS5sZWZ0O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9wID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnRvcCA9IGNhbGNEaW0udG9wO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhdGhPZmZzZXQgPSB0aGlzLnBhdGhPZmZzZXQgfHwge1xuICAgICAgICB4OiBjYWxjRGltLmxlZnQgKyB0aGlzLndpZHRoIC8gMixcbiAgICAgICAgeTogY2FsY0RpbS50b3AgKyB0aGlzLmhlaWdodCAvIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBwYXRoIG9uXG4gICAgICovXG4gICAgX3JlbmRlclBhdGhDb21tYW5kczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgY3VycmVudCwgLy8gY3VycmVudCBpbnN0cnVjdGlvblxuICAgICAgICAgIHByZXZpb3VzID0gbnVsbCxcbiAgICAgICAgICBzdWJwYXRoU3RhcnRYID0gMCxcbiAgICAgICAgICBzdWJwYXRoU3RhcnRZID0gMCxcbiAgICAgICAgICB4ID0gMCwgLy8gY3VycmVudCB4XG4gICAgICAgICAgeSA9IDAsIC8vIGN1cnJlbnQgeVxuICAgICAgICAgIGNvbnRyb2xYID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHhcbiAgICAgICAgICBjb250cm9sWSA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB5XG4gICAgICAgICAgdGVtcFgsXG4gICAgICAgICAgdGVtcFksXG4gICAgICAgICAgbCA9IC10aGlzLnBhdGhPZmZzZXQueCxcbiAgICAgICAgICB0ID0gLXRoaXMucGF0aE9mZnNldC55O1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnBhdGgubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblxuICAgICAgICBjdXJyZW50ID0gdGhpcy5wYXRoW2ldO1xuXG4gICAgICAgIHN3aXRjaCAoY3VycmVudFswXSkgeyAvLyBmaXJzdCBsZXR0ZXJcblxuICAgICAgICAgIGNhc2UgJ2wnOiAvLyBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0wnOiAvLyBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdoJzogLy8gaG9yaXpvbnRhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0gnOiAvLyBob3Jpem9udGFsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd2JzogLy8gdmVydGljYWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgeSArPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdWJzogLy8gdmVyaWNhbCBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgICAgICB5ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbSc6IC8vIG1vdmVUbywgcmVsYXRpdmVcbiAgICAgICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgKz0gY3VycmVudFsyXTtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFggPSB4O1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WSA9IHk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ00nOiAvLyBtb3ZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WCA9IHg7XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRZID0geTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYyc6IC8vIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzVdO1xuICAgICAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs2XTtcbiAgICAgICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzRdO1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgIHggKyBjdXJyZW50WzFdICsgbCwgLy8geDFcbiAgICAgICAgICAgICAgeSArIGN1cnJlbnRbMl0gKyB0LCAvLyB5MVxuICAgICAgICAgICAgICBjb250cm9sWCArIGwsIC8vIHgyXG4gICAgICAgICAgICAgIGNvbnRyb2xZICsgdCwgLy8geTJcbiAgICAgICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0MnOiAvLyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgeCA9IGN1cnJlbnRbNV07XG4gICAgICAgICAgICB5ID0gY3VycmVudFs2XTtcbiAgICAgICAgICAgIGNvbnRyb2xYID0gY3VycmVudFszXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0gY3VycmVudFs0XTtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgICAgICB4ICsgbCxcbiAgICAgICAgICAgICAgeSArIHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3MnOiAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcblxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNF07XG5cbiAgICAgICAgICAgIGlmIChwcmV2aW91c1swXS5tYXRjaCgvW0NjU3NdLykgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgQywgYywgUywgb3IgcyxcbiAgICAgICAgICAgICAgLy8gdGhlIGNvbnRyb2wgcG9pbnQgaXMgY29pbmNpZGVudCB3aXRoIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgICAgIHggKyBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICAgICAgeSArIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vIHNldCBjb250cm9sIHBvaW50IHRvIDJuZCBvbmUgb2YgdGhpcyBjb21tYW5kXG4gICAgICAgICAgICAvLyBcIi4uLiB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBpcyBhc3N1bWVkIHRvIGJlXG4gICAgICAgICAgICAvLyB0aGUgcmVmbGVjdGlvbiBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb25cbiAgICAgICAgICAgIC8vIHRoZSBwcmV2aW91cyBjb21tYW5kIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50LlwiXG4gICAgICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdTJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tDY1NzXS8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIEMsIGMsIFMsIG9yIHMsXG4gICAgICAgICAgICAgIC8vIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICAgICAgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgICAgIHkgPSB0ZW1wWTtcblxuICAgICAgICAgICAgLy8gc2V0IGNvbnRyb2wgcG9pbnQgdG8gMm5kIG9uZSBvZiB0aGlzIGNvbW1hbmRcbiAgICAgICAgICAgIC8vIFwiLi4uIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmVcbiAgICAgICAgICAgIC8vIHRoZSByZWZsZWN0aW9uIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvblxuICAgICAgICAgICAgLy8gdGhlIHByZXZpb3VzIGNvbW1hbmQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXCJcbiAgICAgICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0gY3VycmVudFsyXTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdxJzogLy8gcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdO1xuXG4gICAgICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUSc6IC8vIHF1YWRyYXRpY0N1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG5cbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd0JzogLy8gc2hvcnRoYW5kIHF1YWRyYXRpY0N1cnZlVG8sIHJlbGF0aXZlXG5cbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tRcVR0XS8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIFEsIHEsIFQgb3IgdCxcbiAgICAgICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgdGVtcFggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgdGVtcFkgPSBjdXJyZW50WzJdO1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tRcVR0XS8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIFEsIHEsIFQgb3IgdCxcbiAgICAgICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSB0aGlzXG4gICAgICAgICAgICBkcmF3QXJjKGN0eCwgeCArIGwsIHkgKyB0LCBbXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNl0gKyB4ICsgbCxcbiAgICAgICAgICAgICAgY3VycmVudFs3XSArIHkgKyB0XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHggKz0gY3VycmVudFs2XTtcbiAgICAgICAgICAgIHkgKz0gY3VycmVudFs3XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSB0aGlzXG4gICAgICAgICAgICBkcmF3QXJjKGN0eCwgeCArIGwsIHkgKyB0LCBbXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNl0gKyBsLFxuICAgICAgICAgICAgICBjdXJyZW50WzddICsgdFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB4ID0gY3VycmVudFs2XTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzddO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgIHggPSBzdWJwYXRoU3RhcnRYO1xuICAgICAgICAgICAgeSA9IHN1YnBhdGhTdGFydFk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBwYXRoIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl9yZW5kZXJQYXRoQ29tbWFuZHMoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5QYXRoICgnICsgdGhpcy5jb21wbGV4aXR5KCkgK1xuICAgICAgICAnKTogeyBcInRvcFwiOiAnICsgdGhpcy50b3AgKyAnLCBcImxlZnRcIjogJyArIHRoaXMubGVmdCArICcgfT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgbyA9IGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwge1xuICAgICAgICBwYXRoOiB0aGlzLnBhdGgubWFwKGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uc2xpY2UoKTsgfSksXG4gICAgICAgIHRvcDogdGhpcy50b3AsXG4gICAgICAgIGxlZnQ6IHRoaXMubGVmdCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGF0YWxlc3Mgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG8gPSB0aGlzLnRvT2JqZWN0KFsnc291cmNlUGF0aCddLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG4gICAgICBpZiAoby5zb3VyY2VQYXRoKSB7XG4gICAgICAgIGRlbGV0ZSBvLnBhdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIGNodW5rcyA9IFtdLFxuICAgICAgICAgIG1hcmt1cCA9IHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAoKSwgYWRkVHJhbnNmb3JtID0gJyc7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnBhdGgubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY2h1bmtzLnB1c2godGhpcy5wYXRoW2ldLmpvaW4oJyAnKSk7XG4gICAgICB9XG4gICAgICB2YXIgcGF0aCA9IGNodW5rcy5qb2luKCcgJyk7XG4gICAgICBhZGRUcmFuc2Zvcm0gPSAnIHRyYW5zbGF0ZSgnICsgKC10aGlzLnBhdGhPZmZzZXQueCkgKyAnLCAnICsgKC10aGlzLnBhdGhPZmZzZXQueSkgKyAnKSAnO1xuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8cGF0aCAnLCB0aGlzLmdldFN2Z0lkKCksXG4gICAgICAgICdkPVwiJywgcGF0aCxcbiAgICAgICAgJ1wiIHN0eWxlPVwiJywgdGhpcy5nZXRTdmdTdHlsZXMoKSxcbiAgICAgICAgJ1wiIHRyYW5zZm9ybT1cIicsIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKCksIGFkZFRyYW5zZm9ybSxcbiAgICAgICAgdGhpcy5nZXRTdmdUcmFuc2Zvcm1NYXRyaXgoKSwgJ1wiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiAnLFxuICAgICAgICB0aGlzLmFkZFBhaW50T3JkZXIoKSxcbiAgICAgICAgJy8+XFxuJ1xuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHJldml2ZXIgPyByZXZpdmVyKG1hcmt1cC5qb2luKCcnKSkgOiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlIGNvbXBsZXhpdHlcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHkgb2YgdGhpcyBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aC5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BhcnNlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgY29vcmRzID0gW10sXG4gICAgICAgICAgY3VycmVudFBhdGgsXG4gICAgICAgICAgcGFyc2VkLFxuICAgICAgICAgIHJlID0gLyhbLStdPygoXFxkK1xcLlxcZCspfCgoXFxkKyl8KFxcLlxcZCspKSkoPzplWy0rXT9cXGQrKT8pL2lnLFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIGNvb3Jkc1N0cjtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGNvb3Jkc1BhcnNlZCwgbGVuID0gdGhpcy5wYXRoLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnRQYXRoID0gdGhpcy5wYXRoW2ldO1xuXG4gICAgICAgIGNvb3Jkc1N0ciA9IGN1cnJlbnRQYXRoLnNsaWNlKDEpLnRyaW0oKTtcbiAgICAgICAgY29vcmRzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoY29vcmRzU3RyKSkpIHtcbiAgICAgICAgICBjb29yZHMucHVzaChtYXRjaFswXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb29yZHNQYXJzZWQgPSBbY3VycmVudFBhdGguY2hhckF0KDApXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGNvb3Jkcy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgICBwYXJzZWQgPSBwYXJzZUZsb2F0KGNvb3Jkc1tqXSk7XG4gICAgICAgICAgaWYgKCFpc05hTihwYXJzZWQpKSB7XG4gICAgICAgICAgICBjb29yZHNQYXJzZWQucHVzaChwYXJzZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb21tYW5kID0gY29vcmRzUGFyc2VkWzBdLFxuICAgICAgICAgICAgY29tbWFuZExlbmd0aCA9IGNvbW1hbmRMZW5ndGhzW2NvbW1hbmQudG9Mb3dlckNhc2UoKV0sXG4gICAgICAgICAgICByZXBlYXRlZENvbW1hbmQgPSByZXBlYXRlZENvbW1hbmRzW2NvbW1hbmRdIHx8IGNvbW1hbmQ7XG5cbiAgICAgICAgaWYgKGNvb3Jkc1BhcnNlZC5sZW5ndGggLSAxID4gY29tbWFuZExlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGsgPSAxLCBrbGVuID0gY29vcmRzUGFyc2VkLmxlbmd0aDsgayA8IGtsZW47IGsgKz0gY29tbWFuZExlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW2NvbW1hbmRdLmNvbmNhdChjb29yZHNQYXJzZWQuc2xpY2UoaywgayArIGNvbW1hbmRMZW5ndGgpKSk7XG4gICAgICAgICAgICBjb21tYW5kID0gcmVwZWF0ZWRDb21tYW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChjb29yZHNQYXJzZWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BhcnNlRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhWCA9IFtdLFxuICAgICAgICAgIGFZID0gW10sXG4gICAgICAgICAgY3VycmVudCwgLy8gY3VycmVudCBpbnN0cnVjdGlvblxuICAgICAgICAgIHByZXZpb3VzID0gbnVsbCxcbiAgICAgICAgICBzdWJwYXRoU3RhcnRYID0gMCxcbiAgICAgICAgICBzdWJwYXRoU3RhcnRZID0gMCxcbiAgICAgICAgICB4ID0gMCwgLy8gY3VycmVudCB4XG4gICAgICAgICAgeSA9IDAsIC8vIGN1cnJlbnQgeVxuICAgICAgICAgIGNvbnRyb2xYID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHhcbiAgICAgICAgICBjb250cm9sWSA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB5XG4gICAgICAgICAgdGVtcFgsXG4gICAgICAgICAgdGVtcFksXG4gICAgICAgICAgYm91bmRzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5wYXRoLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cbiAgICAgICAgY3VycmVudCA9IHRoaXMucGF0aFtpXTtcblxuICAgICAgICBzd2l0Y2ggKGN1cnJlbnRbMF0pIHsgLy8gZmlyc3QgbGV0dGVyXG5cbiAgICAgICAgICBjYXNlICdsJzogLy8gbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgeSArPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0wnOiAvLyBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2gnOiAvLyBob3Jpem9udGFsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIGJvdW5kcyA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdIJzogLy8gaG9yaXpvbnRhbCBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIGJvdW5kcyA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd2JzogLy8gdmVydGljYWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgeSArPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1YnOiAvLyB2ZXJpY2FsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ20nOiAvLyBtb3ZlVG8sIHJlbGF0aXZlXG4gICAgICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRYID0geDtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFkgPSB5O1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ00nOiAvLyBtb3ZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WCA9IHg7XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRZID0geTtcbiAgICAgICAgICAgIGJvdW5kcyA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjJzogLy8gYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbNV07XG4gICAgICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzZdO1xuICAgICAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbNF07XG4gICAgICAgICAgICBib3VuZHMgPSBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkN1cnZlKHgsIHksXG4gICAgICAgICAgICAgIHggKyBjdXJyZW50WzFdLCAvLyB4MVxuICAgICAgICAgICAgICB5ICsgY3VycmVudFsyXSwgLy8geTFcbiAgICAgICAgICAgICAgY29udHJvbFgsIC8vIHgyXG4gICAgICAgICAgICAgIGNvbnRyb2xZLCAvLyB5MlxuICAgICAgICAgICAgICB0ZW1wWCxcbiAgICAgICAgICAgICAgdGVtcFlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0MnOiAvLyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzNdO1xuICAgICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICBjb250cm9sWCxcbiAgICAgICAgICAgICAgY29udHJvbFksXG4gICAgICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNl1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gY3VycmVudFs1XTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzZdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG5cbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdO1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tDY1NzXS8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIEMsIGMsIFMsIG9yIHMsXG4gICAgICAgICAgICAgIC8vIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjb250cm9sWCxcbiAgICAgICAgICAgICAgY29udHJvbFksXG4gICAgICAgICAgICAgIHggKyBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICB5ICsgY3VycmVudFsyXSxcbiAgICAgICAgICAgICAgdGVtcFgsXG4gICAgICAgICAgICAgIHRlbXBZXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy8gc2V0IGNvbnRyb2wgcG9pbnQgdG8gMm5kIG9uZSBvZiB0aGlzIGNvbW1hbmRcbiAgICAgICAgICAgIC8vIFwiLi4uIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmVcbiAgICAgICAgICAgIC8vIHRoZSByZWZsZWN0aW9uIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvblxuICAgICAgICAgICAgLy8gdGhlIHByZXZpb3VzIGNvbW1hbmQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXCJcbiAgICAgICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdTJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tDY1NzXS8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIEMsIGMsIFMsIG9yIHMsXG4gICAgICAgICAgICAgIC8vIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvdW5kcyA9IGZhYnJpYy51dGlsLmdldEJvdW5kc09mQ3VydmUoeCwgeSxcbiAgICAgICAgICAgICAgY29udHJvbFgsXG4gICAgICAgICAgICAgIGNvbnRyb2xZLFxuICAgICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICB0ZW1wWCxcbiAgICAgICAgICAgICAgdGVtcFlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgICAgICAvLyBzZXQgY29udHJvbCBwb2ludCB0byAybmQgb25lIG9mIHRoaXMgY29tbWFuZFxuICAgICAgICAgICAgLy8gXCIuLi4gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgaXMgYXNzdW1lZCB0byBiZVxuICAgICAgICAgICAgLy8gdGhlIHJlZmxlY3Rpb24gb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9uXG4gICAgICAgICAgICAvLyB0aGUgcHJldmlvdXMgY29tbWFuZCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb2ludC5cIlxuICAgICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdxJzogLy8gcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdO1xuICAgICAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG4gICAgICAgICAgICBib3VuZHMgPSBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkN1cnZlKHgsIHksXG4gICAgICAgICAgICAgIGNvbnRyb2xYLFxuICAgICAgICAgICAgICBjb250cm9sWSxcbiAgICAgICAgICAgICAgY29udHJvbFgsXG4gICAgICAgICAgICAgIGNvbnRyb2xZLFxuICAgICAgICAgICAgICB0ZW1wWCxcbiAgICAgICAgICAgICAgdGVtcFlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjb250cm9sWCxcbiAgICAgICAgICAgICAgY29udHJvbFksXG4gICAgICAgICAgICAgIGNvbnRyb2xYLFxuICAgICAgICAgICAgICBjb250cm9sWSxcbiAgICAgICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICAgICAgY3VycmVudFs0XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzNdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3QnOiAvLyBzaG9ydGhhbmQgcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzJdO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzWzBdLm1hdGNoKC9bUXFUdF0vKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBjb21tYW5kIG9yIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIHdhcyBub3QgYSBRLCBxLCBUIG9yIHQsXG4gICAgICAgICAgICAgIC8vIGFzc3VtZSB0aGUgY29udHJvbCBwb2ludCBpcyBjb2luY2lkZW50IHdpdGggdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICAgICAgY29udHJvbFggPSB4O1xuICAgICAgICAgICAgICBjb250cm9sWSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjb250cm9sWCxcbiAgICAgICAgICAgICAgY29udHJvbFksXG4gICAgICAgICAgICAgIGNvbnRyb2xYLFxuICAgICAgICAgICAgICBjb250cm9sWSxcbiAgICAgICAgICAgICAgdGVtcFgsXG4gICAgICAgICAgICAgIHRlbXBZXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgdGVtcFggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgdGVtcFkgPSBjdXJyZW50WzJdO1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tRcVR0XS8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIFEsIHEsIFQgb3IgdCxcbiAgICAgICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjb250cm9sWCxcbiAgICAgICAgICAgICAgY29udHJvbFksXG4gICAgICAgICAgICAgIGNvbnRyb2xYLFxuICAgICAgICAgICAgICBjb250cm9sWSxcbiAgICAgICAgICAgICAgdGVtcFgsXG4gICAgICAgICAgICAgIHRlbXBZXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIC8vIFRPRE86IG9wdGltaXplIHRoaXNcbiAgICAgICAgICAgIGJvdW5kcyA9IGZhYnJpYy51dGlsLmdldEJvdW5kc09mQXJjKHgsIHksXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNl0gKyB4LFxuICAgICAgICAgICAgICBjdXJyZW50WzddICsgeVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggKz0gY3VycmVudFs2XTtcbiAgICAgICAgICAgIHkgKz0gY3VycmVudFs3XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSB0aGlzXG4gICAgICAgICAgICBib3VuZHMgPSBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkFyYyh4LCB5LFxuICAgICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgICAgICBjdXJyZW50WzVdLFxuICAgICAgICAgICAgICBjdXJyZW50WzZdLFxuICAgICAgICAgICAgICBjdXJyZW50WzddXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IGN1cnJlbnRbNl07XG4gICAgICAgICAgICB5ID0gY3VycmVudFs3XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICB4ID0gc3VicGF0aFN0YXJ0WDtcbiAgICAgICAgICAgIHkgPSBzdWJwYXRoU3RhcnRZO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgICAgICBib3VuZHMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICBhWC5wdXNoKHBvaW50LngpO1xuICAgICAgICAgIGFZLnB1c2gocG9pbnQueSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhWC5wdXNoKHgpO1xuICAgICAgICBhWS5wdXNoKHkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWluWCA9IG1pbihhWCkgfHwgMCxcbiAgICAgICAgICBtaW5ZID0gbWluKGFZKSB8fCAwLFxuICAgICAgICAgIG1heFggPSBtYXgoYVgpIHx8IDAsXG4gICAgICAgICAgbWF4WSA9IG1heChhWSkgfHwgMCxcbiAgICAgICAgICBkZWx0YVggPSBtYXhYIC0gbWluWCxcbiAgICAgICAgICBkZWx0YVkgPSBtYXhZIC0gbWluWSxcblxuICAgICAgICAgIG8gPSB7XG4gICAgICAgICAgICBsZWZ0OiBtaW5YLFxuICAgICAgICAgICAgdG9wOiBtaW5ZLFxuICAgICAgICAgICAgd2lkdGg6IGRlbHRhWCxcbiAgICAgICAgICAgIGhlaWdodDogZGVsdGFZXG4gICAgICAgICAgfTtcblxuICAgICAgcmV0dXJuIG87XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmYWJyaWMuUGF0aCBmcm9tIGFuIG9iamVjdFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlBhdGguZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9iamVjdC5zb3VyY2VQYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHBhdGhVcmwgPSBvYmplY3Quc291cmNlUGF0aDtcbiAgICAgIGZhYnJpYy5sb2FkU1ZHRnJvbVVSTChwYXRoVXJsLCBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHBhdGggPSBlbGVtZW50c1swXTtcbiAgICAgICAgcGF0aC5zZXRPcHRpb25zKG9iamVjdCk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHBhdGgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnUGF0aCcsIG9iamVjdCwgY2FsbGJhY2ssICdwYXRoJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSBgZmFicmljLlBhdGguZnJvbUVsZW1lbnRgKVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aFxuICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuUGF0aC5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KFsnZCddKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmYWJyaWMuUGF0aCBmcm9tIGFuIFNWRyA8cGF0aD4gZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aFxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gT3B0aW9ucyBjYWxsYmFjayBpbnZva2VkIGFmdGVyIHBhcnNpbmcgaXMgZmluaXNoZWRcbiAgICovXG4gIGZhYnJpYy5QYXRoLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLlBhdGguQVRUUklCVVRFX05BTUVTKTtcbiAgICBjYWxsYmFjayhuZXcgZmFicmljLlBhdGgocGFyc2VkQXR0cmlidXRlcy5kLCBleHRlbmQocGFyc2VkQXR0cmlidXRlcywgb3B0aW9ucykpKTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIG1pbiA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbixcbiAgICAgIG1heCA9IGZhYnJpYy51dGlsLmFycmF5Lm1heDtcblxuICBpZiAoZmFicmljLkdyb3VwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEdyb3VwIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuR3JvdXBcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAbWl4ZXMgZmFicmljLkNvbGxlY3Rpb25cbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTMjZ3JvdXBzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuR3JvdXAjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5Hcm91cCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIGZhYnJpYy5Db2xsZWN0aW9uLCAvKiogQGxlbmRzIGZhYnJpYy5Hcm91cC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdncm91cCcsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBzdHJva2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZVdpZHRoOiAwLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIGNsaWNrIGV2ZW50cyBzaG91bGQgYWxzbyBjaGVjayBmb3Igc3VidGFyZ2V0c1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN1YlRhcmdldENoZWNrOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEdyb3VwcyBhcmUgY29udGFpbmVyLCBkbyBub3QgcmVuZGVyIGFueXRoaW5nIG9uIHRoZXlyIG93biwgZW5jZSBubyBjYWNoZSBwcm9wZXJ0aWVzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNhY2hlUHJvcGVydGllczogW10sXG5cbiAgICAvKipcbiAgICAgKiBzZXRPbkdyb3VwIGlzIGEgbWV0aG9kIHVzZWQgZm9yIFRleHRCb3ggdGhhdCBpcyBubyBtb3JlIHVzZWQgc2luY2UgMi4wLjAgVGhlIGJlaGF2aW9yIGlzIHN0aWxsXG4gICAgICogYXZhaWxhYmxlIHNldHRpbmcgdGhpcyBib29sZWFuIHRvIHRydWUuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdXNlU2V0T25Hcm91cDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RzIEdyb3VwIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaXNBbHJlYWR5R3JvdXBlZF0gaWYgdHJ1ZSwgb2JqZWN0cyBoYXZlIGJlZW4gZ3JvdXBlZCBhbHJlYWR5LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9iamVjdHMsIG9wdGlvbnMsIGlzQWxyZWFkeUdyb3VwZWQpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgLy8gaWYgb2JqZWN0cyBlbmNsb3NlZCBpbiBhIGdyb3VwIGhhdmUgYmVlbiBncm91cGVkIGFscmVhZHksXG4gICAgICAvLyB3ZSBjYW5ub3QgY2hhbmdlIHByb3BlcnRpZXMgb2Ygb2JqZWN0cy5cbiAgICAgIC8vIFRodXMgd2UgbmVlZCB0byBzZXQgb3B0aW9ucyB0byBncm91cCB3aXRob3V0IG9iamVjdHMsXG4gICAgICBpc0FscmVhZHlHcm91cGVkICYmIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9vYmplY3RzID0gb2JqZWN0cyB8fCBbXTtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5ncm91cCA9IHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm9yaWdpblgpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5YID0gb3B0aW9ucy5vcmlnaW5YO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMub3JpZ2luWSkge1xuICAgICAgICB0aGlzLm9yaWdpblkgPSBvcHRpb25zLm9yaWdpblk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNBbHJlYWR5R3JvdXBlZCkge1xuICAgICAgICB2YXIgY2VudGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmNlbnRlclBvaW50O1xuICAgICAgICAvLyBpZiBjb21pbmcgZnJvbSBzdmcgaSBkbyBub3Qgd2FudCB0byBjYWxjIGJvdW5kcy5cbiAgICAgICAgLy8gaSBhc3N1bWUgd2lkdGggYW5kIGhlaWdodCBhcmUgcGFzc2VkIGFsb25nIG9wdGlvbnNcbiAgICAgICAgY2VudGVyIHx8IHRoaXMuX2NhbGNCb3VuZHMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0c0Nvb3JkcyhjZW50ZXIpO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5jZW50ZXJQb2ludDtcbiAgICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl91cGRhdGVPYmplY3RzQUNvb3JkcygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBDb29yZHNDaGFuZ2VdIGlmIHRydWUsIGNvb3JkaW5hdGVzIG9mIG9iamVjdHMgZW5jbG9zZWQgaW4gYSBncm91cCBkbyBub3QgY2hhbmdlXG4gICAgICovXG4gICAgX3VwZGF0ZU9iamVjdHNBQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpZ25vcmVab29tID0gdHJ1ZSwgc2tpcEFic29sdXRlID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaS0tOyApe1xuICAgICAgICB0aGlzLl9vYmplY3RzW2ldLnNldENvb3JkcyhpZ25vcmVab29tLCBza2lwQWJzb2x1dGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBDb29yZHNDaGFuZ2VdIGlmIHRydWUsIGNvb3JkaW5hdGVzIG9mIG9iamVjdHMgZW5jbG9zZWQgaW4gYSBncm91cCBkbyBub3QgY2hhbmdlXG4gICAgICovXG4gICAgX3VwZGF0ZU9iamVjdHNDb29yZHM6IGZ1bmN0aW9uKGNlbnRlcikge1xuICAgICAgdmFyIGNlbnRlciA9IGNlbnRlciB8fCB0aGlzLmdldENlbnRlclBvaW50KCk7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGktLTsgKXtcbiAgICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0Q29vcmRzKHRoaXMuX29iamVjdHNbaV0sIGNlbnRlcik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBjZW50ZXIsIGN1cnJlbnQgY2VudGVyIG9mIGdyb3VwLlxuICAgICAqL1xuICAgIF91cGRhdGVPYmplY3RDb29yZHM6IGZ1bmN0aW9uKG9iamVjdCwgY2VudGVyKSB7XG4gICAgICB2YXIgb2JqZWN0TGVmdCA9IG9iamVjdC5sZWZ0LFxuICAgICAgICAgIG9iamVjdFRvcCA9IG9iamVjdC50b3AsXG4gICAgICAgICAgaWdub3JlWm9vbSA9IHRydWUsIHNraXBBYnNvbHV0ZSA9IHRydWU7XG5cbiAgICAgIG9iamVjdC5zZXQoe1xuICAgICAgICBsZWZ0OiBvYmplY3RMZWZ0IC0gY2VudGVyLngsXG4gICAgICAgIHRvcDogb2JqZWN0VG9wIC0gY2VudGVyLnlcbiAgICAgIH0pO1xuICAgICAgb2JqZWN0Lmdyb3VwID0gdGhpcztcbiAgICAgIG9iamVjdC5zZXRDb29yZHMoaWdub3JlWm9vbSwgc2tpcEFic29sdXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW5hdGlvbiBvZiBhIGdyb3VwXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuR3JvdXA6ICgnICsgdGhpcy5jb21wbGV4aXR5KCkgKyAnKT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIG9iamVjdCB0byBhIGdyb3VwOyBUaGVuIHJlY2FsY3VsYXRlcyBncm91cCdzIGRpbWVuc2lvbiwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBhZGRXaXRoVXBkYXRlOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHRoaXMuX3Jlc3RvcmVPYmplY3RzU3RhdGUoKTtcbiAgICAgIGZhYnJpYy51dGlsLnJlc2V0T2JqZWN0VHJhbnNmb3JtKHRoaXMpO1xuICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICB0aGlzLl9vYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgICAgb2JqZWN0Lmdyb3VwID0gdGhpcztcbiAgICAgICAgb2JqZWN0Ll9zZXQoJ2NhbnZhcycsIHRoaXMuY2FudmFzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhbGNCb3VuZHMoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNDb29yZHMoKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIG9iamVjdCBmcm9tIGEgZ3JvdXA7IFRoZW4gcmVjYWxjdWxhdGVzIGdyb3VwJ3MgZGltZW5zaW9uLCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbW92ZVdpdGhVcGRhdGU6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdGhpcy5fcmVzdG9yZU9iamVjdHNTdGF0ZSgpO1xuICAgICAgZmFicmljLnV0aWwucmVzZXRPYmplY3RUcmFuc2Zvcm0odGhpcyk7XG5cbiAgICAgIHRoaXMucmVtb3ZlKG9iamVjdCk7XG4gICAgICB0aGlzLl9jYWxjQm91bmRzKCk7XG4gICAgICB0aGlzLl91cGRhdGVPYmplY3RzQ29vcmRzKCk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25PYmplY3RBZGRlZDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIG9iamVjdC5ncm91cCA9IHRoaXM7XG4gICAgICBvYmplY3QuX3NldCgnY2FudmFzJywgdGhpcy5jYW52YXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbk9iamVjdFJlbW92ZWQ6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICBkZWxldGUgb2JqZWN0Lmdyb3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7XG4gICAgICBpZiAodGhpcy51c2VTZXRPbkdyb3VwKSB7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzW2ldLnNldE9uR3JvdXAoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdjYW52YXMnKSB7XG4gICAgICAgIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uX3NldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19zZXQnLCBrZXksIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG9ianNUb09iamVjdCA9IHRoaXMuZ2V0T2JqZWN0cygpLm1hcChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsRGVmYXVsdHMgPSBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgIG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IG9iai5ncm91cC5pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgICAgdmFyIF9vYmogPSBvYmoudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICAgIG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IG9yaWdpbmFsRGVmYXVsdHM7XG4gICAgICAgIHJldHVybiBfb2JqO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpLCB7XG4gICAgICAgIG9iamVjdHM6IG9ianNUb09iamVjdFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlLCBpbiBkYXRhbGVzcyBtb2RlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvRGF0YWxlc3NPYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBvYmpzVG9PYmplY3QsIHNvdXJjZVBhdGggPSB0aGlzLnNvdXJjZVBhdGg7XG4gICAgICBpZiAoc291cmNlUGF0aCkge1xuICAgICAgICBvYmpzVG9PYmplY3QgPSBzb3VyY2VQYXRoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9ianNUb09iamVjdCA9IHRoaXMuZ2V0T2JqZWN0cygpLm1hcChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICB2YXIgb3JpZ2luYWxEZWZhdWx0cyA9IG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgICAgICBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBvYmouZ3JvdXAuaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgICAgdmFyIF9vYmogPSBvYmoudG9EYXRhbGVzc09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgICAgICBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBvcmlnaW5hbERlZmF1bHRzO1xuICAgICAgICAgIHJldHVybiBfb2JqO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvRGF0YWxlc3NPYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwge1xuICAgICAgICBvYmplY3RzOiBvYmpzVG9PYmplY3RcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGluc3RhbmNlIG9uIGEgZ2l2ZW4gY29udGV4dFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY29udGV4dCB0byByZW5kZXIgaW5zdGFuY2Ugb25cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtRG9uZSA9IHRydWU7XG4gICAgICB0aGlzLmNhbGxTdXBlcigncmVuZGVyJywgY3R4KTtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybURvbmUgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjaWRlIGlmIHRoZSBvYmplY3Qgc2hvdWxkIGNhY2hlIG9yIG5vdC4gQ3JlYXRlIGl0cyBvd24gY2FjaGUgbGV2ZWxcbiAgICAgKiBvYmplY3RDYWNoaW5nIGlzIGEgZ2xvYmFsIGZsYWcsIHdpbnMgb3ZlciBldmVyeXRoaW5nXG4gICAgICogbmVlZHNJdHNPd25DYWNoZSBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBvYmplY3QgZHJhd2luZyBtZXRob2QgcmVxdWlyZXNcbiAgICAgKiBhIGNhY2hlIHN0ZXAuIE5vbmUgb2YgdGhlIGZhYnJpYyBjbGFzc2VzIHJlcXVpcmVzIGl0LlxuICAgICAqIEdlbmVyYWxseSB5b3UgZG8gbm90IGNhY2hlIG9iamVjdHMgaW4gZ3JvdXBzIGJlY2F1c2UgdGhlIGdyb3VwIG91dHNpZGUgaXMgY2FjaGVkLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2hvdWxkQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG93bkNhY2hlID0gdGhpcy5vYmplY3RDYWNoaW5nICYmICghdGhpcy5ncm91cCB8fCB0aGlzLm5lZWRzSXRzT3duQ2FjaGUoKSB8fCAhdGhpcy5ncm91cC5pc09uQUNhY2hlKCkpO1xuICAgICAgdGhpcy5vd25DYWNoaW5nID0gb3duQ2FjaGU7XG4gICAgICBpZiAob3duQ2FjaGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5fb2JqZWN0c1tpXS53aWxsRHJhd1NoYWRvdygpKSB7XG4gICAgICAgICAgICB0aGlzLm93bkNhY2hpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvd25DYWNoZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBvYmplY3Qgb3IgYSBjaGlsZCBvYmplY3Qgd2lsbCBjYXN0IGEgc2hhZG93XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB3aWxsRHJhd1NoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zaGFkb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCd3aWxsRHJhd1NoYWRvdycpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX29iamVjdHNbaV0ud2lsbERyYXdTaGFkb3coKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgZ3JvdXAgb3IgaXRzIHBhcmVudCBncm91cCBhcmUgY2FjaGluZywgcmVjdXJzaXZlbHkgdXBcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzT25BQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3duQ2FjaGluZyB8fCAodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLmlzT25BQ2FjaGUoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgdGhlIGRyYXdpbmcgb3BlcmF0aW9uIGZvciBhbiBvYmplY3Qgb24gYSBzcGVjaWZpZWQgY29udGV4dFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3T2JqZWN0OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX29iamVjdHNbaV0ucmVuZGVyKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGNhY2hlIGlzIGRpcnR5XG4gICAgICovXG4gICAgaXNDYWNoZURpcnR5OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNhbGxTdXBlcignaXNDYWNoZURpcnR5JykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RhdGVmdWxsQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX29iamVjdHNbaV0uaXNDYWNoZURpcnR5KHRydWUpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NhY2hlQ2FudmFzKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGdyb3VwIGhhcyBub3QgYSBjYWNoZSBjYW52YXMgdGhlcmUgaXMgbm90aGluZyB0byBjbGVhblxuICAgICAgICAgICAgdmFyIHggPSB0aGlzLmNhY2hlV2lkdGggLyB0aGlzLnpvb21YLCB5ID0gdGhpcy5jYWNoZUhlaWdodCAvIHRoaXMuem9vbVk7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuY2xlYXJSZWN0KC14IC8gMiwgLXkgLyAyLCB4LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0b3JlcyBvcmlnaW5hbCBzdGF0ZSBvZiBlYWNoIG9mIGdyb3VwIG9iamVjdHMgKG9yaWdpbmFsIHN0YXRlIGlzIHRoYXQgd2hpY2ggd2FzIGJlZm9yZSBncm91cCB3YXMgY3JlYXRlZCkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgX3Jlc3RvcmVPYmplY3RzU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fb2JqZWN0cy5mb3JFYWNoKHRoaXMuX3Jlc3RvcmVPYmplY3RTdGF0ZSwgdGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVhbGlzZXMgdGhlIHRyYW5zZm9ybSBmcm9tIHRoaXMgZ3JvdXAgb250byB0aGUgc3VwcGxpZWQgb2JqZWN0XG4gICAgICogaS5lLiBpdCB0ZWxscyB5b3Ugd2hhdCB3b3VsZCBoYXBwZW4gaWYgdGhlIHN1cHBsaWVkIG9iamVjdCB3YXMgaW5cbiAgICAgKiB0aGUgZ3JvdXAsIGFuZCB0aGVuIHRoZSBncm91cCB3YXMgZGVzdHJveWVkLiBJdCBtdXRhdGVzIHRoZSBzdXBwbGllZFxuICAgICAqIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRyYW5zZm9ybWVkT2JqZWN0XG4gICAgICovXG4gICAgcmVhbGl6ZVRyYW5zZm9ybTogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgbWF0cml4ID0gb2JqZWN0LmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgICBvcHRpb25zID0gZmFicmljLnV0aWwucXJEZWNvbXBvc2UobWF0cml4KSxcbiAgICAgICAgICBjZW50ZXIgPSBuZXcgZmFicmljLlBvaW50KG9wdGlvbnMudHJhbnNsYXRlWCwgb3B0aW9ucy50cmFuc2xhdGVZKTtcbiAgICAgIG9iamVjdC5mbGlwWCA9IGZhbHNlO1xuICAgICAgb2JqZWN0LmZsaXBZID0gZmFsc2U7XG4gICAgICBvYmplY3Quc2V0KCdzY2FsZVgnLCBvcHRpb25zLnNjYWxlWCk7XG4gICAgICBvYmplY3Quc2V0KCdzY2FsZVknLCBvcHRpb25zLnNjYWxlWSk7XG4gICAgICBvYmplY3Quc2tld1ggPSBvcHRpb25zLnNrZXdYO1xuICAgICAgb2JqZWN0LnNrZXdZID0gb3B0aW9ucy5za2V3WTtcbiAgICAgIG9iamVjdC5hbmdsZSA9IG9wdGlvbnMuYW5nbGU7XG4gICAgICBvYmplY3Quc2V0UG9zaXRpb25CeU9yaWdpbihjZW50ZXIsICdjZW50ZXInLCAnY2VudGVyJyk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBvcmlnaW5hbCBzdGF0ZSBvZiBhIHNwZWNpZmllZCBvYmplY3QgaW4gZ3JvdXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICovXG4gICAgX3Jlc3RvcmVPYmplY3RTdGF0ZTogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB0aGlzLnJlYWxpemVUcmFuc2Zvcm0ob2JqZWN0KTtcbiAgICAgIG9iamVjdC5zZXRDb29yZHMoKTtcbiAgICAgIGRlbGV0ZSBvYmplY3QuZ3JvdXA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYSBncm91cCAocmVzdG9yaW5nIHN0YXRlIG9mIGl0cyBvYmplY3RzKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIHdoZW4gZ3JvdXAgaXMgZGVzdHJveWVkIG9iamVjdHMgbmVlZHMgdG8gZ2V0IGEgcmVwYWludCB0byBiZSBldmVudHVhbGx5XG4gICAgICAvLyBkaXNwbGF5ZWQgb24gY2FudmFzLlxuICAgICAgdGhpcy5fb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3Quc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzdG9yZU9iamVjdHNTdGF0ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgZ3JvdXAgYW4gYWN0aXZlIHNlbGVjdGlvbiwgcmVtb3ZlIHRoZSBncm91cCBmcm9tIGNhbnZhc1xuICAgICAqIHRoZSBncm91cCBoYXMgdG8gYmUgb24gY2FudmFzIGZvciB0aGlzIHRvIHdvcmsuXG4gICAgICogQHJldHVybiB7ZmFicmljLkFjdGl2ZVNlbGVjdGlvbn0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB0b0FjdGl2ZVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cywgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICB0aGlzLl9vYmplY3RzID0gW107XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMudG9PYmplY3QoKTtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLm9iamVjdHM7XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gbmV3IGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24oW10pO1xuICAgICAgYWN0aXZlU2VsZWN0aW9uLnNldChvcHRpb25zKTtcbiAgICAgIGFjdGl2ZVNlbGVjdGlvbi50eXBlID0gJ2FjdGl2ZVNlbGVjdGlvbic7XG4gICAgICBjYW52YXMucmVtb3ZlKHRoaXMpO1xuICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3QuZ3JvdXAgPSBhY3RpdmVTZWxlY3Rpb247XG4gICAgICAgIG9iamVjdC5kaXJ0eSA9IHRydWU7XG4gICAgICAgIGNhbnZhcy5hZGQob2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgYWN0aXZlU2VsZWN0aW9uLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cyA9IG9iamVjdHM7XG4gICAgICBjYW52YXMuX2FjdGl2ZU9iamVjdCA9IGFjdGl2ZVNlbGVjdGlvbjtcbiAgICAgIGFjdGl2ZVNlbGVjdGlvbi5zZXRDb29yZHMoKTtcbiAgICAgIHJldHVybiBhY3RpdmVTZWxlY3Rpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGEgZ3JvdXAgKHJlc3RvcmluZyBzdGF0ZSBvZiBpdHMgb2JqZWN0cylcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdW5ncm91cE9uQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXN0b3JlT2JqZWN0c1N0YXRlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY29vcmRpbmF0ZXMgb2YgYWxsIG9iamVjdHMgaW5zaWRlIGdyb3VwXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldE9iamVjdHNDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlnbm9yZVpvb20gPSB0cnVlLCBza2lwQWJzb2x1dGUgPSB0cnVlO1xuICAgICAgdGhpcy5mb3JFYWNoT2JqZWN0KGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3Quc2V0Q29vcmRzKGlnbm9yZVpvb20sIHNraXBBYnNvbHV0ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjQm91bmRzOiBmdW5jdGlvbihvbmx5V2lkdGhIZWlnaHQpIHtcbiAgICAgIHZhciBhWCA9IFtdLFxuICAgICAgICAgIGFZID0gW10sXG4gICAgICAgICAgbywgcHJvcCxcbiAgICAgICAgICBwcm9wcyA9IFsndHInLCAnYnInLCAnYmwnLCAndGwnXSxcbiAgICAgICAgICBpID0gMCwgaUxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoLFxuICAgICAgICAgIGosIGpMZW4gPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgaWdub3JlWm9vbSA9IHRydWU7XG5cbiAgICAgIGZvciAoIDsgaSA8IGlMZW47ICsraSkge1xuICAgICAgICBvID0gdGhpcy5fb2JqZWN0c1tpXTtcbiAgICAgICAgby5zZXRDb29yZHMoaWdub3JlWm9vbSk7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqKyspIHtcbiAgICAgICAgICBwcm9wID0gcHJvcHNbal07XG4gICAgICAgICAgYVgucHVzaChvLm9Db29yZHNbcHJvcF0ueCk7XG4gICAgICAgICAgYVkucHVzaChvLm9Db29yZHNbcHJvcF0ueSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXQodGhpcy5fZ2V0Qm91bmRzKGFYLCBhWSwgb25seVdpZHRoSGVpZ2h0KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEJvdW5kczogZnVuY3Rpb24oYVgsIGFZLCBvbmx5V2lkdGhIZWlnaHQpIHtcbiAgICAgIHZhciBtaW5YWSA9IG5ldyBmYWJyaWMuUG9pbnQobWluKGFYKSwgbWluKGFZKSksXG4gICAgICAgICAgbWF4WFkgPSBuZXcgZmFicmljLlBvaW50KG1heChhWCksIG1heChhWSkpLFxuICAgICAgICAgIG9iaiA9IHtcbiAgICAgICAgICAgIHdpZHRoOiAobWF4WFkueCAtIG1pblhZLngpIHx8IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IChtYXhYWS55IC0gbWluWFkueSkgfHwgMFxuICAgICAgICAgIH07XG5cbiAgICAgIGlmICghb25seVdpZHRoSGVpZ2h0KSB7XG4gICAgICAgIG9iai5sZWZ0ID0gbWluWFkueCB8fCAwO1xuICAgICAgICBvYmoudG9wID0gbWluWFkueSB8fCAwO1xuICAgICAgICBpZiAodGhpcy5vcmlnaW5YID09PSAnY2VudGVyJykge1xuICAgICAgICAgIG9iai5sZWZ0ICs9IG9iai53aWR0aCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3JpZ2luWCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIG9iai5sZWZ0ICs9IG9iai53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcmlnaW5ZID09PSAnY2VudGVyJykge1xuICAgICAgICAgIG9iai50b3AgKz0gb2JqLmhlaWdodCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3JpZ2luWSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICBvYmoudG9wICs9IG9iai5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciBtYXJrdXAgPSB0aGlzLl9jcmVhdGVCYXNlU1ZHTWFya3VwKCk7XG4gICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgJzxnICcsIHRoaXMuZ2V0U3ZnSWQoKSwgJ3RyYW5zZm9ybT1cIicsXG4gICAgICAgIC8qIGF2b2lkaW5nIHN0eWxlcyBpbnRlbnRpb25hbGx5ICovXG4gICAgICAgIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKCksXG4gICAgICAgIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtTWF0cml4KCksXG4gICAgICAgICdcIiBzdHlsZT1cIicsXG4gICAgICAgIHRoaXMuZ2V0U3ZnRmlsdGVyKCksXG4gICAgICAgICdcIj5cXG4nXG4gICAgICApO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBtYXJrdXAucHVzaCgnXFx0JywgdGhpcy5fb2JqZWN0c1tpXS50b1NWRyhyZXZpdmVyKSk7XG4gICAgICB9XG5cbiAgICAgIG1hcmt1cC5wdXNoKCc8L2c+XFxuJyk7XG5cbiAgICAgIHJldHVybiByZXZpdmVyID8gcmV2aXZlcihtYXJrdXAuam9pbignJykpIDogbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuR3JvdXB9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Hcm91cFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYSBncm91cCBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZ3JvdXAgaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLkdyb3VwLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMob2JqZWN0Lm9iamVjdHMsIGZ1bmN0aW9uKGVubGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgIHZhciBvcHRpb25zID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9iamVjdCwgdHJ1ZSk7XG4gICAgICBkZWxldGUgb3B0aW9ucy5vYmplY3RzO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobmV3IGZhYnJpYy5Hcm91cChlbmxpdmVuZWRPYmplY3RzLCBvcHRpb25zLCB0cnVlKSk7XG4gICAgfSk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KTtcblxuICBpZiAoZmFicmljLkFjdGl2ZVNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHcm91cCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkFjdGl2ZVNlbGVjdGlvblxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuR3JvdXBcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTMjZ3JvdXBzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkdyb3VwLCAvKiogQGxlbmRzIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24ucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnYWN0aXZlU2VsZWN0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdHMgQWN0aXZlU2VsZWN0aW9uIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob2JqZWN0cywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB0aGlzLl9vYmplY3RzID0gb2JqZWN0cyB8fCBbXTtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5ncm91cCA9IHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm9yaWdpblgpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5YID0gb3B0aW9ucy5vcmlnaW5YO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMub3JpZ2luWSkge1xuICAgICAgICB0aGlzLm9yaWdpblkgPSBvcHRpb25zLm9yaWdpblk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWxjQm91bmRzKCk7XG4gICAgICB0aGlzLl91cGRhdGVPYmplY3RzQ29vcmRzKCk7XG4gICAgICBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGUgYWN0aXZlU2VsZWN0aW9uIHRvIGEgbm9ybWFsIGdyb3VwLFxuICAgICAqIEhpZ2ggbGV2ZWwgZnVuY3Rpb24gdGhhdCBhdXRvbWF0aWNhbGx5IGFkZHMgaXQgdG8gY2FudmFzIGFzXG4gICAgICogYWN0aXZlIG9iamVjdC4gbm8gZXZlbnRzIGZpcmVkLlxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH1cbiAgICAgKi9cbiAgICB0b0dyb3VwOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cztcbiAgICAgIHRoaXMuX29iamVjdHMgPSBbXTtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy50b09iamVjdCgpO1xuICAgICAgdmFyIG5ld0dyb3VwID0gbmV3IGZhYnJpYy5Hcm91cChbXSk7XG4gICAgICBkZWxldGUgb3B0aW9ucy5vYmplY3RzO1xuICAgICAgbmV3R3JvdXAuc2V0KG9wdGlvbnMpO1xuICAgICAgbmV3R3JvdXAudHlwZSA9ICdncm91cCc7XG4gICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIG9iamVjdC5ncm91cCA9IG5ld0dyb3VwO1xuICAgICAgICBvYmplY3QuY2FudmFzLnJlbW92ZShvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICBuZXdHcm91cC5fb2JqZWN0cyA9IG9iamVjdHM7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBuZXdHcm91cDtcbiAgICAgIH1cbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIGNhbnZhcy5hZGQobmV3R3JvdXApO1xuICAgICAgY2FudmFzLl9hY3RpdmVPYmplY3QgPSBuZXdHcm91cDtcbiAgICAgIG5ld0dyb3VwLnNldENvb3JkcygpO1xuICAgICAgcmV0dXJuIG5ld0dyb3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiByZXR1cm5zIHRydWUsIGRlc2VsZWN0aW9uIGlzIGNhbmNlbGxlZC5cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBbY2FuY2VsXVxuICAgICAqL1xuICAgIG9uRGVzZWxlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgZ3JvdXBcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5BY3RpdmVTZWxlY3Rpb246ICgnICsgdGhpcy5jb21wbGV4aXR5KCkgKyAnKT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7XG4gICAgICBpZiAoa2V5ID09PSAnY2FudmFzJykge1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnVzZVNldE9uR3JvdXApIHtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uc2V0T25Hcm91cChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmFicmljLk9iamVjdC5wcm90b3R5cGUuX3NldC5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNpZGUgaWYgdGhlIG9iamVjdCBzaG91bGQgY2FjaGUgb3Igbm90LiBDcmVhdGUgaXRzIG93biBjYWNoZSBsZXZlbFxuICAgICAqIG9iamVjdENhY2hpbmcgaXMgYSBnbG9iYWwgZmxhZywgd2lucyBvdmVyIGV2ZXJ5dGhpbmdcbiAgICAgKiBuZWVkc0l0c093bkNhY2hlIHNob3VsZCBiZSB1c2VkIHdoZW4gdGhlIG9iamVjdCBkcmF3aW5nIG1ldGhvZCByZXF1aXJlc1xuICAgICAqIGEgY2FjaGUgc3RlcC4gTm9uZSBvZiB0aGUgZmFicmljIGNsYXNzZXMgcmVxdWlyZXMgaXQuXG4gICAgICogR2VuZXJhbGx5IHlvdSBkbyBub3QgY2FjaGUgb2JqZWN0cyBpbiBncm91cHMgYmVjYXVzZSB0aGUgZ3JvdXAgb3V0c2lkZSBpcyBjYWNoZWQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzaG91bGRDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IG9yIGEgY2hpbGQgb2JqZWN0IHdpbGwgY2FzdCBhIHNoYWRvd1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgd2lsbERyYXdTaGFkb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc2hhZG93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcignd2lsbERyYXdTaGFkb3cnKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9vYmplY3RzW2ldLndpbGxEcmF3U2hhZG93KCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIGdyb3VwIG9yIGl0cyBwYXJlbnQgZ3JvdXAgYXJlIGNhY2hpbmcsIHJlY3Vyc2l2ZWx5IHVwXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc09uQUNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjb250cm9scyBhbmQgYm9yZGVycyBmb3IgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlT3ZlcnJpZGVdIHByb3BlcnRpZXMgdG8gb3ZlcnJpZGUgdGhlIG9iamVjdCBzdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY2hpbGRyZW5PdmVycmlkZV0gcHJvcGVydGllcyB0byBvdmVycmlkZSB0aGUgY2hpbGRyZW4gb3ZlcnJpZGVzXG4gICAgICovXG4gICAgX3JlbmRlckNvbnRyb2xzOiBmdW5jdGlvbihjdHgsIHN0eWxlT3ZlcnJpZGUsIGNoaWxkcmVuT3ZlcnJpZGUpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmlzTW92aW5nID8gdGhpcy5ib3JkZXJPcGFjaXR5V2hlbk1vdmluZyA6IDE7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3JlbmRlckNvbnRyb2xzJywgY3R4LCBzdHlsZU92ZXJyaWRlKTtcbiAgICAgIGNoaWxkcmVuT3ZlcnJpZGUgPSBjaGlsZHJlbk92ZXJyaWRlIHx8IHsgfTtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGRyZW5PdmVycmlkZS5oYXNDb250cm9scyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY2hpbGRyZW5PdmVycmlkZS5oYXNDb250cm9scyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjaGlsZHJlbk92ZXJyaWRlLmhhc1JvdGF0aW5nUG9pbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNoaWxkcmVuT3ZlcnJpZGUuaGFzUm90YXRpbmdQb2ludCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW5PdmVycmlkZS5mb3JBY3RpdmVTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5fcmVuZGVyQ29udHJvbHMoY3R4LCBjaGlsZHJlbk92ZXJyaWRlKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb259IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGEgZ3JvdXAgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIEFjdGl2ZVNlbGVjdGlvbiBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMob2JqZWN0Lm9iamVjdHMsIGZ1bmN0aW9uKGVubGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgIGRlbGV0ZSBvYmplY3Qub2JqZWN0cztcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG5ldyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uKGVubGl2ZW5lZE9iamVjdHMsIG9iamVjdCwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZDtcblxuICBpZiAoIWdsb2JhbC5mYWJyaWMpIHtcbiAgICBnbG9iYWwuZmFicmljID0geyB9O1xuICB9XG5cbiAgaWYgKGdsb2JhbC5mYWJyaWMuSW1hZ2UpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkltYWdlIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogSW1hZ2UgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0xI2ltYWdlc31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdpbWFnZScsXG5cbiAgICAvKipcbiAgICAgKiBjcm9zc09yaWdpbiB2YWx1ZSAob25lIG9mIFwiXCIsIFwiYW5vbnltb3VzXCIsIFwidXNlLWNyZWRlbnRpYWxzXCIpXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjcm9zc09yaWdpbjogJycsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBhIHN0cm9rZS5cbiAgICAgKiBGb3IgaW1hZ2UgcXVhbGl0eSBhIHN0cm9rZSBtdWx0aXBsZSBvZiAyIGdpdmVzIGJldHRlciByZXN1bHRzLlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlV2lkdGg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBwcml2YXRlXG4gICAgICogY29udGFpbnMgbGFzdCB2YWx1ZSBvZiBzY2FsZVggdG8gZGV0ZWN0XG4gICAgICogaWYgdGhlIEltYWdlIGdvdCByZXNpemVkIGFmdGVyIHRoZSBsYXN0IFJlbmRlclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIF9sYXN0U2NhbGVYOiAxLFxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZVxuICAgICAqIGNvbnRhaW5zIGxhc3QgdmFsdWUgb2Ygc2NhbGVZIHRvIGRldGVjdFxuICAgICAqIGlmIHRoZSBJbWFnZSBnb3QgcmVzaXplZCBhZnRlciB0aGUgbGFzdCBSZW5kZXJcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBfbGFzdFNjYWxlWTogMSxcblxuICAgIC8qKlxuICAgICAqIHByaXZhdGVcbiAgICAgKiBjb250YWlucyBsYXN0IHZhbHVlIG9mIHNjYWxpbmcgYXBwbGllZCBieSB0aGUgYXBwbHkgZmlsdGVyIGNoYWluXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgX2ZpbHRlclNjYWxpbmdYOiAxLFxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZVxuICAgICAqIGNvbnRhaW5zIGxhc3QgdmFsdWUgb2Ygc2NhbGluZyBhcHBsaWVkIGJ5IHRoZSBhcHBseSBmaWx0ZXIgY2hhaW5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBfZmlsdGVyU2NhbGluZ1k6IDEsXG5cbiAgICAvKipcbiAgICAgKiBtaW5pbXVtIHNjYWxlIGZhY3RvciB1bmRlciB3aGljaCBhbnkgcmVzaXplRmlsdGVyIGlzIHRyaWdnZXJlZCB0byByZXNpemUgdGhlIGltYWdlXG4gICAgICogMCB3aWxsIGRpc2FibGUgdGhlIGF1dG9tYXRpYyByZXNpemUuIDEgd2lsbCB0cmlnZ2VyIGF1dG9tYXRpY2FsbHkgYWx3YXlzLlxuICAgICAqIG51bWJlciBiaWdnZXIgdGhhbiAxIGFyZSBub3QgaW1wbGVtZW50ZWQgeWV0LlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIG1pbmltdW1TY2FsZVRyaWdnZXI6IDAuNSxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmXG4gICAgICogc3RhdGUgb2YgYW4gb2JqZWN0IGlzIGNoYW5nZWQgKHtAbGluayBmYWJyaWMuT2JqZWN0I2hhc1N0YXRlQ2hhbmdlZH0pXG4gICAgICogYXMgd2VsbCBhcyBmb3IgaGlzdG9yeSAodW5kby9yZWRvKSBwdXJwb3Nlc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc3RhdGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zdGF0ZVByb3BlcnRpZXMuY29uY2F0KCdjcm9wWCcsICdjcm9wWScpLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBpcyBjYWNoZWQgb24gYW4gYWRkaXRpb25hbCBjYW52YXMuXG4gICAgICogZGVmYXVsdCB0byBmYWxzZSBmb3IgaW1hZ2VzXG4gICAgICogc2luY2UgMS43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvYmplY3RDYWNoaW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIGtleSB1c2VkIHRvIHJldHJpZXZlIHRoZSB0ZXh0dXJlIHJlcHJlc2VudGluZyB0aGlzIGltYWdlXG4gICAgICogc2luY2UgMi4wLjBcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNhY2hlS2V5OiAnJyxcblxuICAgIC8qKlxuICAgICAqIEltYWdlIGNyb3AgaW4gcGl4ZWxzIGZyb20gb3JpZ2luYWwgaW1hZ2Ugc2l6ZS5cbiAgICAgKiBzaW5jZSAyLjAuMFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3JvcFg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBJbWFnZSBjcm9wIGluIHBpeGVscyBmcm9tIG9yaWdpbmFsIGltYWdlIHNpemUuXG4gICAgICogc2luY2UgMi4wLjBcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNyb3BZOiAwLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnQgfCBTdHJpbmd9IGVsZW1lbnQgSW1hZ2UgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgYWZ0ZXIgZXZlbnR1YWwgZmlsdGVycyBhcHBsaWVkLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgdGhpcy5maWx0ZXJzID0gW107XG4gICAgICB0aGlzLmNhY2hlS2V5ID0gJ3RleHR1cmUnICsgZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX2luaXRFbGVtZW50KGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGltYWdlIGVsZW1lbnQgd2hpY2ggdGhpcyBpbnN0YW5jZSBpZiBiYXNlZCBvblxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEltYWdlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGltYWdlIGVsZW1lbnQgZm9yIHRoaXMgaW5zdGFuY2UgdG8gYSBzcGVjaWZpZWQgb25lLlxuICAgICAqIElmIGZpbHRlcnMgZGVmaW5lZCB0aGV5IGFyZSBhcHBsaWVkIHRvIG5ldyBpbWFnZS5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBjYW52YXMucmVuZGVyQWxsYCBhbmQgYG9iamVjdC5zZXRDb29yZHNgIGFmdGVyIHJlcGxhY2luZywgdG8gcmVuZGVyIG5ldyBpbWFnZSBhbmQgdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZX0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRFbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICB2YXIgYmFja2VuZCA9IGZhYnJpYy5maWx0ZXJCYWNrZW5kO1xuICAgICAgaWYgKGJhY2tlbmQgJiYgYmFja2VuZC5ldmljdENhY2hlc0ZvcktleSkge1xuICAgICAgICBiYWNrZW5kLmV2aWN0Q2FjaGVzRm9yS2V5KHRoaXMuY2FjaGVLZXkpO1xuICAgICAgICBiYWNrZW5kLmV2aWN0Q2FjaGVzRm9yS2V5KHRoaXMuY2FjaGVLZXkgKyAnX2ZpbHRlcmVkJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMuX29yaWdpbmFsRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9pbml0Q29uZmlnKG9wdGlvbnMpO1xuICAgICAgaWYgKHRoaXMucmVzaXplRmlsdGVyKSB7XG4gICAgICAgIHRoaXMuYXBwbHlSZXNpemVGaWx0ZXJzKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5maWx0ZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB0aGlzLmFwcGx5RmlsdGVycygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBjYWNoZUtleSBpZiB3ZSBoYXZlIGEgd2ViR2xCYWNrZW5kXG4gICAgICogZGVsZXRlIHJlZmVyZW5jZSB0byBpbWFnZSBlbGVtZW50c1xuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGJhY2tlbmQgPSBmYWJyaWMuZmlsdGVyQmFja2VuZDtcbiAgICAgIGlmIChiYWNrZW5kICYmIGJhY2tlbmQuZXZpY3RDYWNoZXNGb3JLZXkpIHtcbiAgICAgICAgYmFja2VuZC5ldmljdENhY2hlc0ZvcktleSh0aGlzLmNhY2hlS2V5KTtcbiAgICAgICAgYmFja2VuZC5ldmljdENhY2hlc0ZvcktleSh0aGlzLmNhY2hlS2V5ICsgJ19maWx0ZXJlZCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5fb3JpZ2luYWxFbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2ZpbHRlcmVkRWwgPSB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY3Jvc3NPcmlnaW4gdmFsdWUgKG9uIGFuIGluc3RhbmNlIGFuZCBjb3JyZXNwb25kaW5nIGltYWdlIGVsZW1lbnQpXG4gICAgICogQHJldHVybiB7ZmFicmljLkltYWdlfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuICAgICAgdGhpcy5fZWxlbWVudC5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvcmlnaW5hbCBzaXplIG9mIGFuIGltYWdlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBcIndpZHRoXCIgYW5kIFwiaGVpZ2h0XCIgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdldE9yaWdpbmFsU2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGVsZW1lbnQud2lkdGgsXG4gICAgICAgIGhlaWdodDogZWxlbWVudC5oZWlnaHRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9zdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnN0cm9rZSB8fCB0aGlzLnN0cm9rZVdpZHRoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB3ID0gdGhpcy53aWR0aCAvIDIsIGggPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKC13LCAtaCk7XG4gICAgICBjdHgubGluZVRvKHcsIC1oKTtcbiAgICAgIGN0eC5saW5lVG8odywgaCk7XG4gICAgICBjdHgubGluZVRvKC13LCBoKTtcbiAgICAgIGN0eC5saW5lVG8oLXcsIC1oKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckRhc2hlZFN0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgeCA9IC10aGlzLndpZHRoIC8gMixcbiAgICAgICAgICB5ID0gLXRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgICB3ID0gdGhpcy53aWR0aCxcbiAgICAgICAgICBoID0gdGhpcy5oZWlnaHQ7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9zZXRTdHJva2VTdHlsZXMoY3R4LCB0aGlzKTtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCB4LCB5LCB4ICsgdywgeSwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCB4ICsgdywgeSwgeCArIHcsIHkgKyBoLCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHggKyB3LCB5ICsgaCwgeCwgeSArIGgsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgeCwgeSArIGgsIHgsIHksIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBmaWx0ZXJzID0gW107XG5cbiAgICAgIHRoaXMuZmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpbHRlck9iaikge1xuICAgICAgICBpZiAoZmlsdGVyT2JqKSB7XG4gICAgICAgICAgZmlsdGVycy5wdXNoKGZpbHRlck9iai50b09iamVjdCgpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgb2JqZWN0ID0gZXh0ZW5kKFxuICAgICAgICB0aGlzLmNhbGxTdXBlcihcbiAgICAgICAgICAndG9PYmplY3QnLFxuICAgICAgICAgIFsnY3Jvc3NPcmlnaW4nLCAnY3JvcFgnLCAnY3JvcFknXS5jb25jYXQocHJvcGVydGllc1RvSW5jbHVkZSlcbiAgICAgICAgKSwge1xuICAgICAgICAgIHNyYzogdGhpcy5nZXRTcmMoKSxcbiAgICAgICAgICBmaWx0ZXJzOiBmaWx0ZXJzLFxuICAgICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnJlc2l6ZUZpbHRlcikge1xuICAgICAgICBvYmplY3QucmVzaXplRmlsdGVyID0gdGhpcy5yZXNpemVGaWx0ZXIudG9PYmplY3QoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhbiBpbWFnZSBoYXMgY3JvcCBhcHBsaWVkLCBpbnNwZWN0aW5nIHZhbHVlcyBvZiBjcm9wWCxjcm9wWSx3aWR0aCxoaWdodC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc0Nyb3A6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JvcFggfHwgdGhpcy5jcm9wWSB8fCB0aGlzLndpZHRoIDwgdGhpcy5fZWxlbWVudC53aWR0aCB8fCB0aGlzLmhlaWdodCA8IHRoaXMuX2VsZW1lbnQuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICB2YXIgbWFya3VwID0gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cCgpLCB4ID0gLXRoaXMud2lkdGggLyAyLCB5ID0gLXRoaXMuaGVpZ2h0IC8gMiwgY2xpcFBhdGggPSAnJztcbiAgICAgIGlmICh0aGlzLmhhc0Nyb3AoKSkge1xuICAgICAgICB2YXIgY2xpcFBhdGhJZCA9IGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICAgJzxjbGlwUGF0aCBpZD1cImltYWdlQ3JvcF8nICsgY2xpcFBhdGhJZCArICdcIj5cXG4nLFxuICAgICAgICAgICdcXHQ8cmVjdCB4PVwiJyArIHggKyAnXCIgeT1cIicgKyB5ICsgJ1wiIHdpZHRoPVwiJyArIHRoaXMud2lkdGggKyAnXCIgaGVpZ2h0PVwiJyArIHRoaXMuaGVpZ2h0ICsgJ1wiIC8+XFxuJyxcbiAgICAgICAgICAnPC9jbGlwUGF0aD5cXG4nXG4gICAgICAgICk7XG4gICAgICAgIGNsaXBQYXRoID0gJyBjbGlwLXBhdGg9XCJ1cmwoI2ltYWdlQ3JvcF8nICsgY2xpcFBhdGhJZCArICcpXCIgJztcbiAgICAgIH1cbiAgICAgIG1hcmt1cC5wdXNoKCc8ZyB0cmFuc2Zvcm09XCInLCB0aGlzLmdldFN2Z1RyYW5zZm9ybSgpLCB0aGlzLmdldFN2Z1RyYW5zZm9ybU1hdHJpeCgpLCAnXCI+XFxuJyk7XG4gICAgICB2YXIgaW1hZ2VNYXJrdXAgPSBbJ1xcdDxpbWFnZSAnLCB0aGlzLmdldFN2Z0lkKCksICd4bGluazpocmVmPVwiJywgdGhpcy5nZXRTdmdTcmModHJ1ZSksXG4gICAgICAgICdcIiB4PVwiJywgeCAtIHRoaXMuY3JvcFgsICdcIiB5PVwiJywgeSAtIHRoaXMuY3JvcFksXG4gICAgICAgICdcIiBzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKCksXG4gICAgICAgIC8vIHdlJ3JlIGVzc2VudGlhbGx5IG1vdmluZyBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb24gZnJvbSB0b3AvbGVmdCBjb3JuZXIgdG8gdGhlIGNlbnRlciBvZiB0aGUgc2hhcGVcbiAgICAgICAgLy8gYnkgd3JhcHBpbmcgaXQgaW4gY29udGFpbmVyIDxnPiBlbGVtZW50IHdpdGggYWN0dWFsIHRyYW5zZm9ybWF0aW9uLCB0aGVuIG9mZnNldHRpbmcgb2JqZWN0IHRvIHRoZSB0b3AvbGVmdFxuICAgICAgICAvLyBzbyB0aGF0IG9iamVjdCdzIGNlbnRlciBhbGlnbnMgd2l0aCBjb250YWluZXIncyBsZWZ0L3RvcFxuICAgICAgICAnXCIgd2lkdGg9XCInLCB0aGlzLl9lbGVtZW50LndpZHRoIHx8IHRoaXMuX2VsZW1lbnQubmF0dXJhbFdpZHRoLFxuICAgICAgICAnXCIgaGVpZ2h0PVwiJywgdGhpcy5fZWxlbWVudC5oZWlnaHQgfHwgdGhpcy5fZWxlbWVudC5oZWlnaHQsXG4gICAgICAgICdcIicsIGNsaXBQYXRoLFxuICAgICAgICAnPjwvaW1hZ2U+XFxuJ107XG4gICAgICBpZiAodGhpcy5wYWludEZpcnN0ID09PSAnZmlsbCcpIHtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobWFya3VwLCBpbWFnZU1hcmt1cCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdHJva2UgfHwgdGhpcy5zdHJva2VEYXNoQXJyYXkpIHtcbiAgICAgICAgdmFyIG9yaWdGaWxsID0gdGhpcy5maWxsO1xuICAgICAgICB0aGlzLmZpbGwgPSBudWxsO1xuICAgICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgICAnXFx0PHJlY3QgJyxcbiAgICAgICAgICAneD1cIicsIHgsICdcIiB5PVwiJywgeSxcbiAgICAgICAgICAnXCIgd2lkdGg9XCInLCB0aGlzLndpZHRoLCAnXCIgaGVpZ2h0PVwiJywgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgJ1wiIHN0eWxlPVwiJywgdGhpcy5nZXRTdmdTdHlsZXMoKSxcbiAgICAgICAgICAnXCIvPlxcbidcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5maWxsID0gb3JpZ0ZpbGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wYWludEZpcnN0ICE9PSAnZmlsbCcpIHtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobWFya3VwLCBpbWFnZU1hcmt1cCk7XG4gICAgICB9XG4gICAgICBtYXJrdXAucHVzaCgnPC9nPlxcbicpO1xuXG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIobWFya3VwLmpvaW4oJycpKSA6IG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzb3VyY2Ugb2YgYW4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbHRlcmVkIGluZGljYXRlcyBpZiB0aGUgc3JjIGlzIG5lZWRlZCBmb3Igc3ZnXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTb3VyY2Ugb2YgYW4gaW1hZ2VcbiAgICAgKi9cbiAgICBnZXRTcmM6IGZ1bmN0aW9uKGZpbHRlcmVkKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGZpbHRlcmVkID8gdGhpcy5fZWxlbWVudCA6IHRoaXMuX29yaWdpbmFsRWxlbWVudDtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGlmIChlbGVtZW50LnRvRGF0YVVSTCkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50LnRvRGF0YVVSTCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50LnNyYztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zcmMgfHwgJyc7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgc291cmNlIG9mIGFuIGltYWdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNyYyBTb3VyY2Ugc3RyaW5nIChVUkwpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayBpcyBpbnZva2VkIHdoZW4gaW1hZ2UgaGFzIGJlZW4gbG9hZGVkIChhbmQgYWxsIGZpbHRlcnMgaGF2ZSBiZWVuIGFwcGxpZWQpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZX0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRTcmM6IGZ1bmN0aW9uKHNyYywgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZShzcmMsIGZ1bmN0aW9uKGltZykge1xuICAgICAgICB0aGlzLnNldEVsZW1lbnQoaW1nLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc2V0V2lkdGhIZWlnaHQoKTtcbiAgICAgICAgY2FsbGJhY2sodGhpcyk7XG4gICAgICB9LCB0aGlzLCBvcHRpb25zICYmIG9wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLkltYWdlOiB7IHNyYzogXCInICsgdGhpcy5nZXRTcmMoKSArICdcIiB9Pic7XG4gICAgfSxcblxuICAgIGFwcGx5UmVzaXplRmlsdGVyczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZmlsdGVyID0gdGhpcy5yZXNpemVGaWx0ZXIsXG4gICAgICAgICAgcmV0aW5hU2NhbGluZyA9IHRoaXMuY2FudmFzID8gdGhpcy5jYW52YXMuZ2V0UmV0aW5hU2NhbGluZygpIDogMSxcbiAgICAgICAgICBtaW5pbXVtU2NhbGUgPSB0aGlzLm1pbmltdW1TY2FsZVRyaWdnZXIsXG4gICAgICAgICAgc2NhbGVYID0gdGhpcy5zY2FsZVggKiByZXRpbmFTY2FsaW5nLFxuICAgICAgICAgIHNjYWxlWSA9IHRoaXMuc2NhbGVZICogcmV0aW5hU2NhbGluZyxcbiAgICAgICAgICBlbGVtZW50VG9GaWx0ZXIgPSB0aGlzLl9maWx0ZXJlZEVsIHx8IHRoaXMuX29yaWdpbmFsRWxlbWVudDtcbiAgICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICAgIHRoaXMuc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKCFmaWx0ZXIgfHwgKHNjYWxlWCA+IG1pbmltdW1TY2FsZSAmJiBzY2FsZVkgPiBtaW5pbXVtU2NhbGUpKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50VG9GaWx0ZXI7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdYID0gMTtcbiAgICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1kgPSAxO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWZhYnJpYy5maWx0ZXJCYWNrZW5kKSB7XG4gICAgICAgIGZhYnJpYy5maWx0ZXJCYWNrZW5kID0gZmFicmljLmluaXRGaWx0ZXJCYWNrZW5kKCk7XG4gICAgICB9XG4gICAgICB2YXIgY2FudmFzRWwgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCksXG4gICAgICAgICAgY2FjaGVLZXkgPSB0aGlzLl9maWx0ZXJlZEVsID8gdGhpcy5jYWNoZUtleSA6ICh0aGlzLmNhY2hlS2V5ICsgJ19maWx0ZXJlZCcpLFxuICAgICAgICAgIHNvdXJjZVdpZHRoID0gZWxlbWVudFRvRmlsdGVyLndpZHRoLCBzb3VyY2VIZWlnaHQgPSBlbGVtZW50VG9GaWx0ZXIuaGVpZ2h0O1xuICAgICAgY2FudmFzRWwud2lkdGggPSBzb3VyY2VXaWR0aDtcbiAgICAgIGNhbnZhc0VsLmhlaWdodCA9IHNvdXJjZUhlaWdodDtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBjYW52YXNFbDtcbiAgICAgIGZpbHRlci5zY2FsZVggPSBzY2FsZVg7XG4gICAgICBmaWx0ZXIuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgZmFicmljLmZpbHRlckJhY2tlbmQuYXBwbHlGaWx0ZXJzKFxuICAgICAgICBbZmlsdGVyXSwgZWxlbWVudFRvRmlsdGVyLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0LCB0aGlzLl9lbGVtZW50LCBjYWNoZUtleSk7XG4gICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWCA9IGNhbnZhc0VsLndpZHRoIC8gdGhpcy5fb3JpZ2luYWxFbGVtZW50LndpZHRoO1xuICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1kgPSBjYW52YXNFbC5oZWlnaHQgLyB0aGlzLl9vcmlnaW5hbEVsZW1lbnQuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlcnMgYXNzaWduZWQgdG8gdGhpcyBpbWFnZSAoZnJvbSBcImZpbHRlcnNcIiBhcnJheSkgb3IgZnJvbSBmaWx0ZXIgcGFyYW1cbiAgICAgKiBAbWV0aG9kIGFwcGx5RmlsdGVyc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnMgdG8gYmUgYXBwbGllZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yUmVzaXppbmcgc3BlY2lmeSBpZiB0aGUgZmlsdGVyIG9wZXJhdGlvbiBpcyBhIHJlc2l6ZSBvcGVyYXRpb25cbiAgICAgKiBAcmV0dXJuIHt0aGlzQXJnfSByZXR1cm4gdGhlIGZhYnJpYy5JbWFnZSBvYmplY3RcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYXBwbHlGaWx0ZXJzOiBmdW5jdGlvbihmaWx0ZXJzKSB7XG5cbiAgICAgIGZpbHRlcnMgPSBmaWx0ZXJzIHx8IHRoaXMuZmlsdGVycyB8fCBbXTtcbiAgICAgIGZpbHRlcnMgPSBmaWx0ZXJzLmZpbHRlcihmdW5jdGlvbihmaWx0ZXIpIHsgcmV0dXJuIGZpbHRlcjsgfSk7XG4gICAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgICB0aGlzLnNldCgnZGlydHknLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gdGhpcy5fb3JpZ2luYWxFbGVtZW50O1xuICAgICAgICB0aGlzLl9maWx0ZXJlZEVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1ggPSAxO1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWSA9IDE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW1nRWxlbWVudCA9IHRoaXMuX29yaWdpbmFsRWxlbWVudCxcbiAgICAgICAgICBzb3VyY2VXaWR0aCA9IGltZ0VsZW1lbnQubmF0dXJhbFdpZHRoIHx8IGltZ0VsZW1lbnQud2lkdGgsXG4gICAgICAgICAgc291cmNlSGVpZ2h0ID0gaW1nRWxlbWVudC5uYXR1cmFsSGVpZ2h0IHx8IGltZ0VsZW1lbnQuaGVpZ2h0O1xuXG4gICAgICBpZiAodGhpcy5fZWxlbWVudCA9PT0gdGhpcy5fb3JpZ2luYWxFbGVtZW50KSB7XG4gICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGlzIHRoZSBzYW1lIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGVsZW1lbnRcbiAgICAgICAgdmFyIGNhbnZhc0VsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgICBjYW52YXNFbC53aWR0aCA9IHNvdXJjZVdpZHRoO1xuICAgICAgICBjYW52YXNFbC5oZWlnaHQgPSBzb3VyY2VIZWlnaHQ7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBjYW52YXNFbDtcbiAgICAgICAgdGhpcy5fZmlsdGVyZWRFbCA9IGNhbnZhc0VsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGNsZWFyIHRoZSBleGlzdGluZyBlbGVtZW50IHRvIGdldCBuZXcgZmlsdGVyIGRhdGFcbiAgICAgICAgdGhpcy5fZWxlbWVudC5nZXRDb250ZXh0KCcyZCcpLmNsZWFyUmVjdCgwLCAwLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGlmICghZmFicmljLmZpbHRlckJhY2tlbmQpIHtcbiAgICAgICAgZmFicmljLmZpbHRlckJhY2tlbmQgPSBmYWJyaWMuaW5pdEZpbHRlckJhY2tlbmQoKTtcbiAgICAgIH1cbiAgICAgIGZhYnJpYy5maWx0ZXJCYWNrZW5kLmFwcGx5RmlsdGVycyhcbiAgICAgICAgZmlsdGVycywgdGhpcy5fb3JpZ2luYWxFbGVtZW50LCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0LCB0aGlzLl9lbGVtZW50LCB0aGlzLmNhY2hlS2V5KTtcbiAgICAgIGlmICh0aGlzLl9vcmlnaW5hbEVsZW1lbnQud2lkdGggIT09IHRoaXMuX2VsZW1lbnQud2lkdGggfHxcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxFbGVtZW50LmhlaWdodCAhPT0gdGhpcy5fZWxlbWVudC5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1ggPSB0aGlzLl9lbGVtZW50LndpZHRoIC8gdGhpcy5fb3JpZ2luYWxFbGVtZW50LndpZHRoO1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWSA9IHRoaXMuX2VsZW1lbnQuaGVpZ2h0IC8gdGhpcy5fb3JpZ2luYWxFbGVtZW50LmhlaWdodDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICh0aGlzLmlzTW92aW5nID09PSBmYWxzZSAmJiB0aGlzLnJlc2l6ZUZpbHRlciAmJiB0aGlzLl9uZWVkc1Jlc2l6ZSgpKSB7XG4gICAgICAgIHRoaXMuX2xhc3RTY2FsZVggPSB0aGlzLnNjYWxlWDtcbiAgICAgICAgdGhpcy5fbGFzdFNjYWxlWSA9IHRoaXMuc2NhbGVZO1xuICAgICAgICB0aGlzLmFwcGx5UmVzaXplRmlsdGVycygpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3Ryb2tlKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gICAgX3JlbmRlckZpbGw6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHcgPSB0aGlzLndpZHRoLCBoID0gdGhpcy5oZWlnaHQsIHNXID0gdyAqIHRoaXMuX2ZpbHRlclNjYWxpbmdYLCBzSCA9IGggKiB0aGlzLl9maWx0ZXJTY2FsaW5nWSxcbiAgICAgICAgICB4ID0gLXcgLyAyLCB5ID0gLWggLyAyLCBlbGVtZW50VG9EcmF3ID0gdGhpcy5fZWxlbWVudDtcbiAgICAgIGVsZW1lbnRUb0RyYXcgJiYgY3R4LmRyYXdJbWFnZShlbGVtZW50VG9EcmF3LFxuICAgICAgICB0aGlzLmNyb3BYICogdGhpcy5fZmlsdGVyU2NhbGluZ1gsXG4gICAgICAgIHRoaXMuY3JvcFkgKiB0aGlzLl9maWx0ZXJTY2FsaW5nWSxcbiAgICAgICAgc1csXG4gICAgICAgIHNILFxuICAgICAgICB4LCB5LCB3LCBoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGUsIG5lZWRlZCB0byBjaGVjayBpZiBpbWFnZSBuZWVkcyByZXNpemVcbiAgICAgKi9cbiAgICBfbmVlZHNSZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICh0aGlzLnNjYWxlWCAhPT0gdGhpcy5fbGFzdFNjYWxlWCB8fCB0aGlzLnNjYWxlWSAhPT0gdGhpcy5fbGFzdFNjYWxlWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0V2lkdGhIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcblxuICAgICAgdGhpcy5zZXQoJ3dpZHRoJywgZWxlbWVudC53aWR0aCk7XG4gICAgICB0aGlzLnNldCgnaGVpZ2h0JywgZWxlbWVudC5oZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgSW1hZ2UgY2xhc3MncyBpbml0aWFsaXphdGlvbiBtZXRob2QuIFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHlcbiAgICAgKiBjYWxsZWQgYnkgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fFN0cmluZ30gZWxlbWVudCBUaGUgZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIF9pbml0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5zZXRFbGVtZW50KGZhYnJpYy51dGlsLmdldEJ5SWQoZWxlbWVudCksIG9wdGlvbnMpO1xuICAgICAgZmFicmljLnV0aWwuYWRkQ2xhc3ModGhpcy5nZXRFbGVtZW50KCksIGZhYnJpYy5JbWFnZS5DU1NfQ0FOVkFTKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX2luaXRDb25maWc6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc2V0V2lkdGhIZWlnaHQob3B0aW9ucyk7XG4gICAgICBpZiAodGhpcy5fZWxlbWVudCAmJiB0aGlzLmNyb3NzT3JpZ2luKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnMgdG8gYmUgaW5pdGlhbGl6ZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbGwgZmFicmljLkltYWdlLmZpbHRlcnMgaW5zdGFuY2VzIGFyZSBjcmVhdGVkXG4gICAgICovXG4gICAgX2luaXRGaWx0ZXJzOiBmdW5jdGlvbihmaWx0ZXJzLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGZpbHRlcnMgJiYgZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMoZmlsdGVycywgZnVuY3Rpb24oZW5saXZlbmVkT2JqZWN0cykge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZE9iamVjdHMpO1xuICAgICAgICB9LCAnZmFicmljLkltYWdlLmZpbHRlcnMnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IHdpdGggd2lkdGgvaGVpZ2h0IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBfc2V0V2lkdGhIZWlnaHQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMud2lkdGggPSBvcHRpb25zICYmICgnd2lkdGgnIGluIG9wdGlvbnMpXG4gICAgICAgID8gb3B0aW9ucy53aWR0aFxuICAgICAgICA6ICh0aGlzLmdldEVsZW1lbnQoKVxuICAgICAgICAgID8gdGhpcy5nZXRFbGVtZW50KCkud2lkdGggfHwgMFxuICAgICAgICAgIDogMCk7XG5cbiAgICAgIHRoaXMuaGVpZ2h0ID0gb3B0aW9ucyAmJiAoJ2hlaWdodCcgaW4gb3B0aW9ucylcbiAgICAgICAgPyBvcHRpb25zLmhlaWdodFxuICAgICAgICA6ICh0aGlzLmdldEVsZW1lbnQoKVxuICAgICAgICAgID8gdGhpcy5nZXRFbGVtZW50KCkuaGVpZ2h0IHx8IDBcbiAgICAgICAgICA6IDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgb2Zmc2V0IGZvciBjZW50ZXIgYW5kIHNjYWxlIGZhY3RvciBmb3IgdGhlIGltYWdlIGluIG9yZGVyIHRvIHJlc3BlY3RcbiAgICAgKiB0aGUgcHJlc2VydmVBc3BlY3RSYXRpbyBhdHRyaWJ1dGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBwYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBBUiA9IGZhYnJpYy51dGlsLnBhcnNlUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZSh0aGlzLnByZXNlcnZlQXNwZWN0UmF0aW8gfHwgJycpLFxuICAgICAgICAgIHJXaWR0aCA9IHRoaXMuX2VsZW1lbnQud2lkdGgsIHJIZWlnaHQgPSB0aGlzLl9lbGVtZW50LmhlaWdodCxcbiAgICAgICAgICBzY2FsZVggPSAxLCBzY2FsZVkgPSAxLCBvZmZzZXRMZWZ0ID0gMCwgb2Zmc2V0VG9wID0gMCwgY3JvcFggPSAwLCBjcm9wWSA9IDAsXG4gICAgICAgICAgb2Zmc2V0LCBwV2lkdGggPSB0aGlzLndpZHRoLCBwSGVpZ2h0ID0gdGhpcy5oZWlnaHQsIHBhcnNlZEF0dHJpYnV0ZXMgPSB7IHdpZHRoOiBwV2lkdGgsIGhlaWdodDogcEhlaWdodCB9O1xuICAgICAgaWYgKHBBUiAmJiAocEFSLmFsaWduWCAhPT0gJ25vbmUnIHx8IHBBUi5hbGlnblkgIT09ICdub25lJykpIHtcbiAgICAgICAgaWYgKHBBUi5tZWV0T3JTbGljZSA9PT0gJ21lZXQnKSB7XG4gICAgICAgICAgc2NhbGVYID0gc2NhbGVZID0gZmFicmljLnV0aWwuZmluZFNjYWxlVG9GaXQodGhpcy5fZWxlbWVudCwgcGFyc2VkQXR0cmlidXRlcyk7XG4gICAgICAgICAgb2Zmc2V0ID0gKHBXaWR0aCAtIHJXaWR0aCAqIHNjYWxlWCkgLyAyO1xuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWluJykge1xuICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IC1vZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWF4Jykge1xuICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2Zmc2V0ID0gKHBIZWlnaHQgLSBySGVpZ2h0ICogc2NhbGVZKSAvIDI7XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblkgPT09ICdNaW4nKSB7XG4gICAgICAgICAgICBvZmZzZXRUb3AgPSAtb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocEFSLmFsaWduWSA9PT0gJ01heCcpIHtcbiAgICAgICAgICAgIG9mZnNldFRvcCA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBBUi5tZWV0T3JTbGljZSA9PT0gJ3NsaWNlJykge1xuICAgICAgICAgIHNjYWxlWCA9IHNjYWxlWSA9IGZhYnJpYy51dGlsLmZpbmRTY2FsZVRvQ292ZXIodGhpcy5fZWxlbWVudCwgcGFyc2VkQXR0cmlidXRlcyk7XG4gICAgICAgICAgb2Zmc2V0ID0gcldpZHRoIC0gcFdpZHRoIC8gc2NhbGVYO1xuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWlkJykge1xuICAgICAgICAgICAgY3JvcFggPSBvZmZzZXQgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocEFSLmFsaWduWCA9PT0gJ01heCcpIHtcbiAgICAgICAgICAgIGNyb3BYID0gb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBvZmZzZXQgPSBySGVpZ2h0IC0gcEhlaWdodCAvIHNjYWxlWTtcbiAgICAgICAgICBpZiAocEFSLmFsaWduWSA9PT0gJ01pZCcpIHtcbiAgICAgICAgICAgIGNyb3BZID0gb2Zmc2V0IC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblkgPT09ICdNYXgnKSB7XG4gICAgICAgICAgICBjcm9wWSA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcldpZHRoID0gcFdpZHRoIC8gc2NhbGVYO1xuICAgICAgICAgIHJIZWlnaHQgPSBwSGVpZ2h0IC8gc2NhbGVZO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2NhbGVYID0gcFdpZHRoIC8gcldpZHRoO1xuICAgICAgICBzY2FsZVkgPSBwSGVpZ2h0IC8gckhlaWdodDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiByV2lkdGgsXG4gICAgICAgIGhlaWdodDogckhlaWdodCxcbiAgICAgICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgICAgIHNjYWxlWTogc2NhbGVZLFxuICAgICAgICBvZmZzZXRMZWZ0OiBvZmZzZXRMZWZ0LFxuICAgICAgICBvZmZzZXRUb3A6IG9mZnNldFRvcCxcbiAgICAgICAgY3JvcFg6IGNyb3BYLFxuICAgICAgICBjcm9wWTogY3JvcFlcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogRGVmYXVsdCBDU1MgY2xhc3MgbmFtZSBmb3IgY2FudmFzXG4gICAqIEBzdGF0aWNcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuQ1NTX0NBTlZBUyA9ICdjYW52YXMtaW1nJztcblxuICAvKipcbiAgICogQWxpYXMgZm9yIGdldFNyY1xuICAgKiBAc3RhdGljXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UucHJvdG90eXBlLmdldFN2Z1NyYyA9IGZhYnJpYy5JbWFnZS5wcm90b3R5cGUuZ2V0U3JjO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZSBmcm9tIGl0cyBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBpbWFnZSBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKF9vYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9iamVjdCA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShfb2JqZWN0KTtcbiAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2Uob2JqZWN0LnNyYywgZnVuY3Rpb24oaW1nLCBlcnJvcikge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZmFicmljLkltYWdlLnByb3RvdHlwZS5faW5pdEZpbHRlcnMuY2FsbChvYmplY3QsIG9iamVjdC5maWx0ZXJzLCBmdW5jdGlvbihmaWx0ZXJzKSB7XG4gICAgICAgIG9iamVjdC5maWx0ZXJzID0gZmlsdGVycyB8fCBbXTtcbiAgICAgICAgZmFicmljLkltYWdlLnByb3RvdHlwZS5faW5pdEZpbHRlcnMuY2FsbChvYmplY3QsIFtvYmplY3QucmVzaXplRmlsdGVyXSwgZnVuY3Rpb24ocmVzaXplRmlsdGVycykge1xuICAgICAgICAgIG9iamVjdC5yZXNpemVGaWx0ZXIgPSByZXNpemVGaWx0ZXJzWzBdO1xuICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBmYWJyaWMuSW1hZ2UoaW1nLCBvYmplY3QpO1xuICAgICAgICAgIGNhbGxiYWNrKGltYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LCBudWxsLCBvYmplY3QuY3Jvc3NPcmlnaW4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZSBmcm9tIGFuIFVSTCBzdHJpbmdcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCB0byBjcmVhdGUgYW4gaW1hZ2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGltYWdlIGlzIGNyZWF0ZWQgKG5ld2x5IGNyZWF0ZWQgaW1hZ2UgaXMgcGFzc2VkIGFzIGEgZmlyc3QgYXJndW1lbnQpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbaW1nT3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5mcm9tVVJMID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaywgaW1nT3B0aW9ucykge1xuICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZSh1cmwsIGZ1bmN0aW9uKGltZykge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobmV3IGZhYnJpYy5JbWFnZShpbWcsIGltZ09wdGlvbnMpKTtcbiAgICB9LCBudWxsLCBpbWdPcHRpb25zICYmIGltZ09wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICB9O1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLkltYWdlLmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3RydWN0Lmh0bWwjSW1hZ2VFbGVtZW50fVxuICAgKi9cbiAgZmFicmljLkltYWdlLkFUVFJJQlVURV9OQU1FUyA9XG4gICAgZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdCgneCB5IHdpZHRoIGhlaWdodCBwcmVzZXJ2ZUFzcGVjdFJhdGlvIHhsaW5rOmhyZWYgY3Jvc3NPcmlnaW4nLnNwbGl0KCcgJykpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuSW1hZ2V9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBmYWJyaWMuSW1hZ2Ugb2JqZWN0IGlzIGNyZWF0ZWRcbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2VcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5JbWFnZS5BVFRSSUJVVEVfTkFNRVMpO1xuICAgIGZhYnJpYy5JbWFnZS5mcm9tVVJMKHBhcnNlZEF0dHJpYnV0ZXNbJ3hsaW5rOmhyZWYnXSwgY2FsbGJhY2ssXG4gICAgICBleHRlbmQoKG9wdGlvbnMgPyBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob3B0aW9ucykgOiB7IH0pLCBwYXJzZWRBdHRyaWJ1dGVzKSk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7TnVtYmVyfSBhbmdsZSB2YWx1ZVxuICAgKi9cbiAgX2dldEFuZ2xlVmFsdWVGb3JTdHJhaWdodGVuOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYW5nbGUgPSB0aGlzLmFuZ2xlICUgMzYwO1xuICAgIGlmIChhbmdsZSA+IDApIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKChhbmdsZSAtIDEpIC8gOTApICogOTA7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnJvdW5kKGFuZ2xlIC8gOTApICogOTA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0cmFpZ2h0ZW5zIGFuIG9iamVjdCAocm90YXRpbmcgaXQgZnJvbSBjdXJyZW50IGFuZ2xlIHRvIG9uZSBvZiAwLCA5MCwgMTgwLCAyNzAsIGV0Yy4gZGVwZW5kaW5nIG9uIHdoaWNoIGlzIGNsb3NlcilcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBzdHJhaWdodGVuOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJvdGF0ZSh0aGlzLl9nZXRBbmdsZVZhbHVlRm9yU3RyYWlnaHRlbigpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyB7QGxpbmsgZmFicmljLk9iamVjdC5wcm90b3R5cGUuc3RyYWlnaHRlbn0gYnV0IHdpdGggYW5pbWF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFja3MgT2JqZWN0IHdpdGggY2FsbGJhY2sgZnVuY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25Db21wbGV0ZV0gSW52b2tlZCBvbiBjb21wbGV0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25DaGFuZ2VdIEludm9rZWQgb24gZXZlcnkgc3RlcCBvZiBhbmltYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmeFN0cmFpZ2h0ZW46IGZ1bmN0aW9uKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcyB8fCB7IH07XG5cbiAgICB2YXIgZW1wdHkgPSBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgb25Db21wbGV0ZSA9IGNhbGxiYWNrcy5vbkNvbXBsZXRlIHx8IGVtcHR5LFxuICAgICAgICBvbkNoYW5nZSA9IGNhbGxiYWNrcy5vbkNoYW5nZSB8fCBlbXB0eSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgZmFicmljLnV0aWwuYW5pbWF0ZSh7XG4gICAgICBzdGFydFZhbHVlOiB0aGlzLmdldCgnYW5nbGUnKSxcbiAgICAgIGVuZFZhbHVlOiB0aGlzLl9nZXRBbmdsZVZhbHVlRm9yU3RyYWlnaHRlbigpLFxuICAgICAgZHVyYXRpb246IHRoaXMuRlhfRFVSQVRJT04sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgX3RoaXMucm90YXRlKHZhbHVlKTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMuc2V0Q29vcmRzKCk7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBTdHJhaWdodGVucyBvYmplY3QsIHRoZW4gcmVyZW5kZXJzIGNhbnZhc1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc3RyYWlnaHRlblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHN0cmFpZ2h0ZW5PYmplY3Q6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICBvYmplY3Quc3RyYWlnaHRlbigpO1xuICAgIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIHtAbGluayBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZS5zdHJhaWdodGVuT2JqZWN0fSwgYnV0IGFuaW1hdGVkXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzdHJhaWdodGVuXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnhTdHJhaWdodGVuT2JqZWN0OiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgb2JqZWN0LmZ4U3RyYWlnaHRlbih7XG4gICAgICBvbkNoYW5nZTogdGhpcy5yZXF1ZXN0UmVuZGVyQWxsQm91bmRcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogVGVzdHMgaWYgd2ViZ2wgc3VwcG9ydHMgY2VydGFpbiBwcmVjaXNpb25cbiAgICogQHBhcmFtIHtXZWJHTH0gQ2FudmFzIFdlYkdMIGNvbnRleHQgdG8gdGVzdCBvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gUHJlY2lzaW9uIHRvIHRlc3QgY2FuIGJlIGFueSBvZiBmb2xsb3dpbmc6ICdsb3dwJywgJ21lZGl1bXAnLCAnaGlnaHAnXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSB1c2VyJ3MgYnJvd3NlciBXZWJHTCBzdXBwb3J0cyBnaXZlbiBwcmVjaXNpb24uXG4gICAqL1xuICBmdW5jdGlvbiB0ZXN0UHJlY2lzaW9uKGdsLCBwcmVjaXNpb24pe1xuICAgIHZhciBmcmFnbWVudFNvdXJjZSA9ICdwcmVjaXNpb24gJyArIHByZWNpc2lvbiArICcgZmxvYXQ7XFxudm9pZCBtYWluKCl7fSc7XG4gICAgdmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ21lbnRTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZSB3aGV0aGVyIHRoaXMgZmlsdGVyaW5nIGJhY2tlbmQgaXMgc3VwcG9ydGVkIGJ5IHRoZSB1c2VyJ3MgYnJvd3Nlci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbGVTaXplIGNoZWNrIGlmIHRoZSB0aWxlU2l6ZSBpcyBzdXBwb3J0ZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIncyBicm93c2VyIHN1cHBvcnRzIFdlYkdMLlxuICAgKi9cbiAgZmFicmljLmlzV2ViZ2xTdXBwb3J0ZWQgPSBmdW5jdGlvbih0aWxlU2l6ZSkge1xuICAgIGlmIChmYWJyaWMuaXNMaWtlbHlOb2RlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRpbGVTaXplID0gdGlsZVNpemUgfHwgZmFicmljLldlYmdsRmlsdGVyQmFja2VuZC5wcm90b3R5cGUudGlsZVNpemU7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHZhciBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnKTtcbiAgICB2YXIgaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBpZiAoZ2wpIHtcbiAgICAgIGZhYnJpYy5tYXhUZXh0dXJlU2l6ZSA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKTtcbiAgICAgIGlzU3VwcG9ydGVkID0gZmFicmljLm1heFRleHR1cmVTaXplID49IHRpbGVTaXplO1xuICAgICAgdmFyIHByZWNpc2lvbnMgPSBbJ2hpZ2hwJywgJ21lZGl1bXAnLCAnbG93cCddO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspe1xuICAgICAgICBpZiAodGVzdFByZWNpc2lvbihnbCwgcHJlY2lzaW9uc1tpXSkpe1xuICAgICAgICAgIGZhYnJpYy53ZWJHbFByZWNpc2lvbiA9IHByZWNpc2lvbnNbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaXNTdXBwb3J0ZWQgPSBpc1N1cHBvcnRlZDtcbiAgICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG4gIH07XG5cbiAgZmFicmljLldlYmdsRmlsdGVyQmFja2VuZCA9IFdlYmdsRmlsdGVyQmFja2VuZDtcblxuICAvKipcbiAgICogV2ViR0wgZmlsdGVyIGJhY2tlbmQuXG4gICAqL1xuICBmdW5jdGlvbiBXZWJnbEZpbHRlckJhY2tlbmQob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudGlsZVNpemUpIHtcbiAgICAgIHRoaXMudGlsZVNpemUgPSBvcHRpb25zLnRpbGVTaXplO1xuICAgIH1cbiAgICB0aGlzLnNldHVwR0xDb250ZXh0KHRoaXMudGlsZVNpemUsIHRoaXMudGlsZVNpemUpO1xuICAgIHRoaXMuY2FwdHVyZUdQVUluZm8oKTtcbiAgfTtcblxuICBXZWJnbEZpbHRlckJhY2tlbmQucHJvdG90eXBlID0gLyoqIEBsZW5kcyBmYWJyaWMuV2ViZ2xGaWx0ZXJCYWNrZW5kLnByb3RvdHlwZSAqLyB7XG5cbiAgICB0aWxlU2l6ZTogMjA0OCxcblxuICAgIC8qKlxuICAgICAqIEV4cGVyaW1lbnRhbC4gVGhpcyBvYmplY3QgaXMgYSBzb3J0IG9mIHJlcG9zaXRvcnkgb2YgaGVscCBsYXllcnMgdXNlZCB0byBhdm9pZFxuICAgICAqIG9mIHJlY3JlYXRpbmcgdGhlbSBkdXJpbmcgZnJlcXVlbnQgZmlsdGVyaW5nLiBJZiB5b3UgYXJlIHByZXZpZXdpbmcgYSBmaWx0ZXIgd2l0aFxuICAgICAqIGEgc2xpZGVyIHlvdSBwcm9ibGFibHkgZG8gbm90IHdhbnQgdG8gY3JlYXRlIGhlbHAgbGF5ZXJzIGV2ZXJ5IGZpbHRlciBzdGVwLlxuICAgICAqIGluIHRoaXMgb2JqZWN0IHRoZXJlIHdpbGwgYmUgYXBwZW5kZWQgc29tZSBjYW52YXNlcywgY3JlYXRlZCBvbmNlLCByZXNpemVkIHNvbWV0aW1lc1xuICAgICAqIGNsZWFyZWQgbmV2ZXIuIENsZWFyaW5nIGlzIGxlZnQgdG8gdGhlIGRldmVsb3Blci5cbiAgICAgKiovXG4gICAgcmVzb3VyY2VzOiB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0dXAgYSBXZWJHTCBjb250ZXh0IHN1aXRhYmxlIGZvciBmaWx0ZXJpbmcsIGFuZCBiaW5kIGFueSBuZWVkZWQgZXZlbnQgaGFuZGxlcnMuXG4gICAgICovXG4gICAgc2V0dXBHTENvbnRleHQ6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5jcmVhdGVXZWJHTENhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgdGhpcy5hUG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAxLCAxLCAwLCAxLCAxXSk7XG4gICAgICB0aGlzLmNob29zZUZhc3Rlc3RDb3B5R0xUbzJETWV0aG9kKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQaWNrIGEgbWV0aG9kIHRvIGNvcHkgZGF0YSBmcm9tIEdMIGNvbnRleHQgdG8gMmQgY2FudmFzLiAgSW4gc29tZSBicm93c2VycyB1c2luZ1xuICAgICAqIHB1dEltYWdlRGF0YSBpcyBmYXN0ZXIgdGhhbiBkcmF3SW1hZ2UgZm9yIHRoYXQgc3BlY2lmaWMgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGNob29zZUZhc3Rlc3RDb3B5R0xUbzJETWV0aG9kOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgY2FuTWVhc3VyZVBlcmYgPSB0eXBlb2Ygd2luZG93LnBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJztcbiAgICAgIHZhciBjYW5Vc2VJbWFnZURhdGE7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgSW1hZ2VEYXRhKDEsIDEpO1xuICAgICAgICBjYW5Vc2VJbWFnZURhdGEgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FuVXNlSW1hZ2VEYXRhID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIHZhciBjYW5Vc2VBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIHZhciBjYW5Vc2VVaW50OENsYW1wZWQgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgICBpZiAoIShjYW5NZWFzdXJlUGVyZiAmJiBjYW5Vc2VJbWFnZURhdGEgJiYgY2FuVXNlQXJyYXlCdWZmZXIgJiYgY2FuVXNlVWludDhDbGFtcGVkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0YXJnZXRDYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIHZhciBpbWFnZUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgdmFyIHRlc3RDb250ZXh0ID0ge1xuICAgICAgICBpbWFnZUJ1ZmZlcjogaW1hZ2VCdWZmZXIsXG4gICAgICAgIGRlc3RpbmF0aW9uV2lkdGg6IHdpZHRoLFxuICAgICAgICBkZXN0aW5hdGlvbkhlaWdodDogaGVpZ2h0LFxuICAgICAgICB0YXJnZXRDYW52YXM6IHRhcmdldENhbnZhc1xuICAgICAgfTtcbiAgICAgIHZhciBzdGFydFRpbWUsIGRyYXdJbWFnZVRpbWUsIHB1dEltYWdlRGF0YVRpbWU7XG4gICAgICB0YXJnZXRDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRhcmdldENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgIHN0YXJ0VGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvcHlHTFRvMkREcmF3SW1hZ2UuY2FsbCh0ZXN0Q29udGV4dCwgdGhpcy5nbCwgdGVzdENvbnRleHQpO1xuICAgICAgZHJhd0ltYWdlVGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgc3RhcnRUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29weUdMVG8yRFB1dEltYWdlRGF0YS5jYWxsKHRlc3RDb250ZXh0LCB0aGlzLmdsLCB0ZXN0Q29udGV4dCk7XG4gICAgICBwdXRJbWFnZURhdGFUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICBpZiAoZHJhd0ltYWdlVGltZSA+IHB1dEltYWdlRGF0YVRpbWUpIHtcbiAgICAgICAgdGhpcy5pbWFnZUJ1ZmZlciA9IGltYWdlQnVmZmVyO1xuICAgICAgICB0aGlzLmNvcHlHTFRvMkQgPSBjb3B5R0xUbzJEUHV0SW1hZ2VEYXRhO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuY29weUdMVG8yRCA9IGNvcHlHTFRvMkREcmF3SW1hZ2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNhbnZhcyBlbGVtZW50IGFuZCBhc3NvY2lhdGVkIFdlYkdMIGNvbnRleHQgYW5kIGF0dGFjaGVzIHRoZW0gYXNcbiAgICAgKiBjbGFzcyBwcm9wZXJ0aWVzIHRvIHRoZSBHTEZpbHRlckJhY2tlbmQgY2xhc3MuXG4gICAgICovXG4gICAgY3JlYXRlV2ViR0xDYW52YXM6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBjYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB2YXIgZ2xPcHRpb25zID0ge1xuICAgICAgICAgICAgYWxwaGE6IHRydWUsXG4gICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlLFxuICAgICAgICAgICAgZGVwdGg6IGZhbHNlLFxuICAgICAgICAgICAgc3RlbmNpbDogZmFsc2UsXG4gICAgICAgICAgICBhbnRpYWxpYXM6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGdsT3B0aW9ucyk7XG4gICAgICBpZiAoIWdsKSB7XG4gICAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGdsT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAoIWdsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XG4gICAgICAvLyB0aGlzIGNhbnZhcyBjYW4gZmlyZSB3ZWJnbGNvbnRleHRsb3N0IGFuZCB3ZWJnbGNvbnRleHRyZXN0b3JlZFxuICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICB0aGlzLmdsID0gZ2w7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGFwcGx5IHRoZSByZXF1ZXN0ZWQgZmlsdGVycyB0byB0aGUgc291cmNlIHByb3ZpZGVkLCBkcmF3aW5nIHRoZSBmaWx0ZXJlZCBvdXRwdXRcbiAgICAgKiB0byB0aGUgcHJvdmlkZWQgdGFyZ2V0IGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnMgVGhlIGZpbHRlcnMgdG8gYXBwbHkuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBzb3VyY2UgVGhlIHNvdXJjZSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSBzb3VyY2UgaW5wdXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBzb3VyY2UgaW5wdXQuXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gdGFyZ2V0Q2FudmFzIFRoZSBkZXN0aW5hdGlvbiBmb3IgZmlsdGVyZWQgb3V0cHV0IHRvIGJlIGRyYXduLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfHVuZGVmaW5lZH0gY2FjaGVLZXkgQSBrZXkgdXNlZCB0byBjYWNoZSByZXNvdXJjZXMgcmVsYXRlZCB0byB0aGUgc291cmNlLiBJZlxuICAgICAqIG9taXR0ZWQsIGNhY2hpbmcgd2lsbCBiZSBza2lwcGVkLlxuICAgICAqL1xuICAgIGFwcGx5RmlsdGVyczogZnVuY3Rpb24oZmlsdGVycywgc291cmNlLCB3aWR0aCwgaGVpZ2h0LCB0YXJnZXRDYW52YXMsIGNhY2hlS2V5KSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgdmFyIGNhY2hlZFRleHR1cmU7XG4gICAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgICAgY2FjaGVkVGV4dHVyZSA9IHRoaXMuZ2V0Q2FjaGVkVGV4dHVyZShjYWNoZUtleSwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBwaXBlbGluZVN0YXRlID0ge1xuICAgICAgICBvcmlnaW5hbFdpZHRoOiBzb3VyY2Uud2lkdGggfHwgc291cmNlLm9yaWdpbmFsV2lkdGgsXG4gICAgICAgIG9yaWdpbmFsSGVpZ2h0OiBzb3VyY2UuaGVpZ2h0IHx8IHNvdXJjZS5vcmlnaW5hbEhlaWdodCxcbiAgICAgICAgc291cmNlV2lkdGg6IHdpZHRoLFxuICAgICAgICBzb3VyY2VIZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgZGVzdGluYXRpb25XaWR0aDogd2lkdGgsXG4gICAgICAgIGRlc3RpbmF0aW9uSGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGNvbnRleHQ6IGdsLFxuICAgICAgICBzb3VyY2VUZXh0dXJlOiB0aGlzLmNyZWF0ZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQsICFjYWNoZWRUZXh0dXJlICYmIHNvdXJjZSksXG4gICAgICAgIHRhcmdldFRleHR1cmU6IHRoaXMuY3JlYXRlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCksXG4gICAgICAgIG9yaWdpbmFsVGV4dHVyZTogY2FjaGVkVGV4dHVyZSB8fFxuICAgICAgICAgIHRoaXMuY3JlYXRlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCwgIWNhY2hlZFRleHR1cmUgJiYgc291cmNlKSxcbiAgICAgICAgcGFzc2VzOiBmaWx0ZXJzLmxlbmd0aCxcbiAgICAgICAgd2ViZ2w6IHRydWUsXG4gICAgICAgIGFQb3NpdGlvbjogdGhpcy5hUG9zaXRpb24sXG4gICAgICAgIHByb2dyYW1DYWNoZTogdGhpcy5wcm9ncmFtQ2FjaGUsXG4gICAgICAgIHBhc3M6IDAsXG4gICAgICAgIGZpbHRlckJhY2tlbmQ6IHRoaXMsXG4gICAgICAgIHRhcmdldENhbnZhczogdGFyZ2V0Q2FudmFzXG4gICAgICB9O1xuICAgICAgdmFyIHRlbXBGYm8gPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0ZW1wRmJvKTtcbiAgICAgIGZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWx0ZXIpIHsgZmlsdGVyICYmIGZpbHRlci5hcHBseVRvKHBpcGVsaW5lU3RhdGUpOyB9KTtcbiAgICAgIHJlc2l6ZUNhbnZhc0lmTmVlZGVkKHBpcGVsaW5lU3RhdGUpO1xuICAgICAgdGhpcy5jb3B5R0xUbzJEKGdsLCBwaXBlbGluZVN0YXRlKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgICAgZ2wuZGVsZXRlVGV4dHVyZShwaXBlbGluZVN0YXRlLnNvdXJjZVRleHR1cmUpO1xuICAgICAgZ2wuZGVsZXRlVGV4dHVyZShwaXBlbGluZVN0YXRlLnRhcmdldFRleHR1cmUpO1xuICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIodGVtcEZibyk7XG4gICAgICB0YXJnZXRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICByZXR1cm4gcGlwZWxpbmVTdGF0ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNhbWUgYXMgdGhlIGFwcGx5RmlsdGVyIG1ldGhvZCBidXQgd2l0aCBhZGRpdGlvbmFsIGxvZ2dpbmcgb2YgV2ViR0xcbiAgICAgKiBlcnJvcnMuXG4gICAgICovXG4gICAgYXBwbHlGaWx0ZXJzRGVidWc6IGZ1bmN0aW9uKGZpbHRlcnMsIHNvdXJjZSwgd2lkdGgsIGhlaWdodCwgdGFyZ2V0Q2FudmFzLCBjYWNoZUtleSkge1xuICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGlzIHVzZWZ1bCB3aGVuIGRlYnVnZ2luZyBhIHNwZWNpZmljIGlzc3VlIGJ1dCBhZGRzIH4xMHggc2xvd2Rvd24uXG4gICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgdmFyIHJldCA9IHRoaXMuYXBwbHlGaWx0ZXJzKGZpbHRlcnMsIHNvdXJjZSwgd2lkdGgsIGhlaWdodCwgdGFyZ2V0Q2FudmFzLCBjYWNoZUtleSk7XG4gICAgICB2YXIgZ2xFcnJvciA9IGdsLmdldEVycm9yKCk7XG4gICAgICBpZiAoZ2xFcnJvciAhPT0gZ2wuTk9fRVJST1IpIHtcbiAgICAgICAgdmFyIGVycm9yU3RyaW5nID0gdGhpcy5nbEVycm9yVG9TdHJpbmcoZ2wsIGdsRXJyb3IpO1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1dlYkdMIEVycm9yICcgKyBlcnJvclN0cmluZyk7XG4gICAgICAgIGVycm9yLmdsRXJyb3JDb2RlID0gZ2xFcnJvcjtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICBnbEVycm9yVG9TdHJpbmc6IGZ1bmN0aW9uKGNvbnRleHQsIGVycm9yQ29kZSkge1xuICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAnQ29udGV4dCB1bmRlZmluZWQgZm9yIGVycm9yIGNvZGU6ICcgKyBlcnJvckNvZGU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZXJyb3JDb2RlICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gJ0Vycm9yIGNvZGUgaXMgbm90IGEgbnVtYmVyJztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZXJyb3JDb2RlKSB7XG4gICAgICAgIGNhc2UgY29udGV4dC5OT19FUlJPUjpcbiAgICAgICAgICByZXR1cm4gJ05PX0VSUk9SJztcbiAgICAgICAgY2FzZSBjb250ZXh0LklOVkFMSURfRU5VTTpcbiAgICAgICAgICByZXR1cm4gJ0lOVkFMSURfRU5VTSc7XG4gICAgICAgIGNhc2UgY29udGV4dC5JTlZBTElEX1ZBTFVFOlxuICAgICAgICAgIHJldHVybiAnSU5WQUxJRF9WQUxVRSc7XG4gICAgICAgIGNhc2UgY29udGV4dC5JTlZBTElEX09QRVJBVElPTjpcbiAgICAgICAgICByZXR1cm4gJ0lOVkFMSURfT1BFUkFUSU9OJztcbiAgICAgICAgY2FzZSBjb250ZXh0LklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OOlxuICAgICAgICAgIHJldHVybiAnSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT04nO1xuICAgICAgICBjYXNlIGNvbnRleHQuT1VUX09GX01FTU9SWTpcbiAgICAgICAgICByZXR1cm4gJ09VVF9PRl9NRU1PUlknO1xuICAgICAgICBjYXNlIGNvbnRleHQuQ09OVEVYVF9MT1NUX1dFQkdMOlxuICAgICAgICAgIHJldHVybiAnQ09OVEVYVF9MT1NUX1dFQkdMJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gJ1VOS05PV05fRVJST1InO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggZXZlbnQgbGlzdGVuZXJzLCByZW1vdmUgcmVmZXJlbmNlcywgYW5kIGNsZWFuIHVwIGNhY2hlcy5cbiAgICAgKi9cbiAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGVhcldlYkdMQ2FjaGVzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdpcGUgb3V0IFdlYkdMLXJlbGF0ZWQgY2FjaGVzLlxuICAgICAqL1xuICAgIGNsZWFyV2ViR0xDYWNoZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wcm9ncmFtQ2FjaGUgPSB7fTtcbiAgICAgIHRoaXMudGV4dHVyZUNhY2hlID0ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFdlYkdMIHRleHR1cmUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQWNjZXB0cyBzcGVjaWZpYyBkaW1lbnNpb25zIHRvIGluaXRpYWxpemUgdGhlIHRleHR1ZXIgdG8gb3IgYSBzb3VyY2UgaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNvbnRleHQgdG8gdXNlIGZvciBjcmVhdGluZyB0aGUgdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIHRvIGluaXRpYWxpemUgdGhlIHRleHR1cmUgYXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IHRvIGluaXRpYWxpemUgdGhlIHRleHR1cmUuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSB0ZXh0dXJlSW1hZ2VTb3VyY2UgQSBzb3VyY2UgZm9yIHRoZSB0ZXh0dXJlIGRhdGEuXG4gICAgICogQHJldHVybnMge1dlYkdMVGV4dHVyZX1cbiAgICAgKi9cbiAgICBjcmVhdGVUZXh0dXJlOiBmdW5jdGlvbihnbCwgd2lkdGgsIGhlaWdodCwgdGV4dHVyZUltYWdlU291cmNlKSB7XG4gICAgICB2YXIgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGlmICh0ZXh0dXJlSW1hZ2VTb3VyY2UpIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0ZXh0dXJlSW1hZ2VTb3VyY2UpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgd2lkdGgsIGhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FuIGJlIG9wdGlvbmFsbHkgdXNlZCB0byBnZXQgYSB0ZXh0dXJlIGZyb20gdGhlIGNhY2hlIGFycmF5XG4gICAgICpcbiAgICAgKiBJZiBhbiBleGlzdGluZyB0ZXh0dXJlIGlzIG5vdCBmb3VuZCwgYSBuZXcgdGV4dHVyZSBpcyBjcmVhdGVkIGFuZCBjYWNoZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdW5pcXVlSWQgQSBjYWNoZSBrZXkgdG8gdXNlIHRvIGZpbmQgYW4gZXhpc3RpbmcgdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHRleHR1cmVJbWFnZVNvdXJjZSBBIHNvdXJjZSB0byB1c2UgdG8gY3JlYXRlIHRoZVxuICAgICAqIHRleHR1cmUgY2FjaGUgZW50cnkgaWYgb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAgICovXG4gICAgZ2V0Q2FjaGVkVGV4dHVyZTogZnVuY3Rpb24odW5pcXVlSWQsIHRleHR1cmVJbWFnZVNvdXJjZSkge1xuICAgICAgaWYgKHRoaXMudGV4dHVyZUNhY2hlW3VuaXF1ZUlkXSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlQ2FjaGVbdW5pcXVlSWRdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGVUZXh0dXJlKFxuICAgICAgICAgIHRoaXMuZ2wsIHRleHR1cmVJbWFnZVNvdXJjZS53aWR0aCwgdGV4dHVyZUltYWdlU291cmNlLmhlaWdodCwgdGV4dHVyZUltYWdlU291cmNlKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlQ2FjaGVbdW5pcXVlSWRdID0gdGV4dHVyZTtcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFyIG91dCBjYWNoZWQgcmVzb3VyY2VzIHJlbGF0ZWQgdG8gYSBzb3VyY2UgaW1hZ2UgdGhhdCBoYXMgYmVlblxuICAgICAqIGZpbHRlcmVkIHByZXZpb3VzbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2FjaGVLZXkgVGhlIGNhY2hlIGtleSBwcm92aWRlZCB3aGVuIHRoZSBzb3VyY2UgaW1hZ2Ugd2FzIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGV2aWN0Q2FjaGVzRm9yS2V5OiBmdW5jdGlvbihjYWNoZUtleSkge1xuICAgICAgaWYgKHRoaXMudGV4dHVyZUNhY2hlW2NhY2hlS2V5XSkge1xuICAgICAgICB0aGlzLmdsLmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldKTtcbiAgICAgICAgZGVsZXRlIHRoaXMudGV4dHVyZUNhY2hlW2NhY2hlS2V5XTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29weUdMVG8yRDogY29weUdMVG8yRERyYXdJbWFnZSxcblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gZXh0cmFjdCBHUFUgaW5mb3JtYXRpb24gc3RyaW5ncyBmcm9tIGEgV2ViR0wgY29udGV4dC5cbiAgICAgKlxuICAgICAqIFVzZWZ1bCBpbmZvcm1hdGlvbiB3aGVuIGRlYnVnZ2luZyBvciBibGFja2xpc3Rpbmcgc3BlY2lmaWMgR1BVcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEEgR1BVIGluZm8gb2JqZWN0IHdpdGggcmVuZGVyZXIgYW5kIHZlbmRvciBzdHJpbmdzLlxuICAgICAqL1xuICAgIGNhcHR1cmVHUFVJbmZvOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmdwdUluZm8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3B1SW5mbztcbiAgICAgIH1cbiAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICB2YXIgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kZWJ1Z19yZW5kZXJlcl9pbmZvJyk7XG4gICAgICB2YXIgZ3B1SW5mbyA9IHsgcmVuZGVyZXI6ICcnLCB2ZW5kb3I6ICcnIH07XG4gICAgICBpZiAoZXh0KSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IGdsLmdldFBhcmFtZXRlcihleHQuVU5NQVNLRURfUkVOREVSRVJfV0VCR0wpO1xuICAgICAgICB2YXIgdmVuZG9yID0gZ2wuZ2V0UGFyYW1ldGVyKGV4dC5VTk1BU0tFRF9WRU5ET1JfV0VCR0wpO1xuICAgICAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgICAgICBncHVJbmZvLnJlbmRlcmVyID0gcmVuZGVyZXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVuZG9yKSB7XG4gICAgICAgICAgZ3B1SW5mby52ZW5kb3IgPSB2ZW5kb3IudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5ncHVJbmZvID0gZ3B1SW5mbztcbiAgICAgIHJldHVybiBncHVJbmZvO1xuICAgIH0sXG4gIH07XG59KSgpO1xuXG5mdW5jdGlvbiByZXNpemVDYW52YXNJZk5lZWRlZChwaXBlbGluZVN0YXRlKSB7XG4gIHZhciB0YXJnZXRDYW52YXMgPSBwaXBlbGluZVN0YXRlLnRhcmdldENhbnZhcyxcbiAgICAgIHdpZHRoID0gdGFyZ2V0Q2FudmFzLndpZHRoLCBoZWlnaHQgPSB0YXJnZXRDYW52YXMuaGVpZ2h0LFxuICAgICAgZFdpZHRoID0gcGlwZWxpbmVTdGF0ZS5kZXN0aW5hdGlvbldpZHRoLFxuICAgICAgZEhlaWdodCA9IHBpcGVsaW5lU3RhdGUuZGVzdGluYXRpb25IZWlnaHQ7XG5cbiAgaWYgKHdpZHRoICE9PSBkV2lkdGggfHwgaGVpZ2h0ICE9PSBkSGVpZ2h0KSB7XG4gICAgdGFyZ2V0Q2FudmFzLndpZHRoID0gZFdpZHRoO1xuICAgIHRhcmdldENhbnZhcy5oZWlnaHQgPSBkSGVpZ2h0O1xuICB9XG59XG5cbi8qKlxuICogQ29weSBhbiBpbnB1dCBXZWJHTCBjYW52YXMgb24gdG8gYW4gb3V0cHV0IDJEIGNhbnZhcy5cbiAqXG4gKiBUaGUgV2ViR0wgY2FudmFzIGlzIGFzc3VtZWQgdG8gYmUgdXBzaWRlIGRvd24sIHdpdGggdGhlIHRvcC1sZWZ0IHBpeGVsIG9mIHRoZVxuICogZGVzaXJlZCBvdXRwdXQgaW1hZ2UgYXBwZWFyaW5nIGluIHRoZSBib3R0b20tbGVmdCBjb3JuZXIgb2YgdGhlIFdlYkdMIGNhbnZhcy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gc291cmNlQ29udGV4dCBUaGUgV2ViR0wgY29udGV4dCB0byBjb3B5IGZyb20uXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSB0YXJnZXRDYW52YXMgVGhlIDJEIHRhcmdldCBjYW52YXMgdG8gY29weSBvbiB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwaXBlbGluZVN0YXRlIFRoZSAyRCB0YXJnZXQgY2FudmFzIHRvIGNvcHkgb24gdG8uXG4gKi9cbmZ1bmN0aW9uIGNvcHlHTFRvMkREcmF3SW1hZ2UoZ2wsIHBpcGVsaW5lU3RhdGUpIHtcbiAgdmFyIGdsQ2FudmFzID0gZ2wuY2FudmFzLCB0YXJnZXRDYW52YXMgPSBwaXBlbGluZVN0YXRlLnRhcmdldENhbnZhcyxcbiAgICAgIGN0eCA9IHRhcmdldENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjdHgudHJhbnNsYXRlKDAsIHRhcmdldENhbnZhcy5oZWlnaHQpOyAvLyBtb3ZlIGl0IGRvd24gYWdhaW5cbiAgY3R4LnNjYWxlKDEsIC0xKTsgLy8gdmVydGljYWwgZmxpcFxuICAvLyB3aGVyZSBpcyBteSBpbWFnZSBvbiB0aGUgYmlnIGdsY2FudmFzP1xuICB2YXIgc291cmNlWSA9IGdsQ2FudmFzLmhlaWdodCAtIHRhcmdldENhbnZhcy5oZWlnaHQ7XG4gIGN0eC5kcmF3SW1hZ2UoZ2xDYW52YXMsIDAsIHNvdXJjZVksIHRhcmdldENhbnZhcy53aWR0aCwgdGFyZ2V0Q2FudmFzLmhlaWdodCwgMCwgMCxcbiAgICB0YXJnZXRDYW52YXMud2lkdGgsIHRhcmdldENhbnZhcy5oZWlnaHQpO1xufVxuXG4vKipcbiAqIENvcHkgYW4gaW5wdXQgV2ViR0wgY2FudmFzIG9uIHRvIGFuIG91dHB1dCAyRCBjYW52YXMgdXNpbmcgMmQgY2FudmFzJyBwdXRJbWFnZURhdGFcbiAqIEFQSS4gTWVhc3VyYWJseSBmYXN0ZXIgdGhhbiB1c2luZyBjdHguZHJhd0ltYWdlIGluIEZpcmVmb3ggKHZlcnNpb24gNTQgb24gT1NYIFNpZXJyYSkuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IHNvdXJjZUNvbnRleHQgVGhlIFdlYkdMIGNvbnRleHQgdG8gY29weSBmcm9tLlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gdGFyZ2V0Q2FudmFzIFRoZSAyRCB0YXJnZXQgY2FudmFzIHRvIGNvcHkgb24gdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gcGlwZWxpbmVTdGF0ZSBUaGUgMkQgdGFyZ2V0IGNhbnZhcyB0byBjb3B5IG9uIHRvLlxuICovXG5mdW5jdGlvbiBjb3B5R0xUbzJEUHV0SW1hZ2VEYXRhKGdsLCBwaXBlbGluZVN0YXRlKSB7XG4gIHZhciB0YXJnZXRDYW52YXMgPSBwaXBlbGluZVN0YXRlLnRhcmdldENhbnZhcywgY3R4ID0gdGFyZ2V0Q2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgICBkV2lkdGggPSBwaXBlbGluZVN0YXRlLmRlc3RpbmF0aW9uV2lkdGgsXG4gICAgICBkSGVpZ2h0ID0gcGlwZWxpbmVTdGF0ZS5kZXN0aW5hdGlvbkhlaWdodCxcbiAgICAgIG51bUJ5dGVzID0gZFdpZHRoICogZEhlaWdodCAqIDQ7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciB1OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuaW1hZ2VCdWZmZXIsIDAsIG51bUJ5dGVzKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciB1OENsYW1wZWQgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkodGhpcy5pbWFnZUJ1ZmZlciwgMCwgbnVtQnl0ZXMpO1xuXG4gIGdsLnJlYWRQaXhlbHMoMCwgMCwgZFdpZHRoLCBkSGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB1OCk7XG4gIHZhciBpbWdEYXRhID0gbmV3IEltYWdlRGF0YSh1OENsYW1wZWQsIGRXaWR0aCwgZEhlaWdodCk7XG4gIGN0eC5wdXRJbWFnZURhdGEoaW1nRGF0YSwgMCwgMCk7XG59XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cbiAgZmFicmljLkNhbnZhczJkRmlsdGVyQmFja2VuZCA9IENhbnZhczJkRmlsdGVyQmFja2VuZDtcblxuICAvKipcbiAgICogQ2FudmFzIDJEIGZpbHRlciBiYWNrZW5kLlxuICAgKi9cbiAgZnVuY3Rpb24gQ2FudmFzMmRGaWx0ZXJCYWNrZW5kKCkge307XG5cbiAgQ2FudmFzMmRGaWx0ZXJCYWNrZW5kLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLkNhbnZhczJkRmlsdGVyQmFja2VuZC5wcm90b3R5cGUgKi8ge1xuICAgIGV2aWN0Q2FjaGVzRm9yS2V5OiBub29wLFxuICAgIGRpc3Bvc2U6IG5vb3AsXG4gICAgY2xlYXJXZWJHTENhY2hlczogbm9vcCxcblxuICAgIC8qKlxuICAgICAqIEV4cGVyaW1lbnRhbC4gVGhpcyBvYmplY3QgaXMgYSBzb3J0IG9mIHJlcG9zaXRvcnkgb2YgaGVscCBsYXllcnMgdXNlZCB0byBhdm9pZFxuICAgICAqIG9mIHJlY3JlYXRpbmcgdGhlbSBkdXJpbmcgZnJlcXVlbnQgZmlsdGVyaW5nLiBJZiB5b3UgYXJlIHByZXZpZXdpbmcgYSBmaWx0ZXIgd2l0aFxuICAgICAqIGEgc2xpZGVyIHlvdSBwcm9iYWJseSBkbyBub3Qgd2FudCB0byBjcmVhdGUgaGVscCBsYXllcnMgZXZlcnkgZmlsdGVyIHN0ZXAuXG4gICAgICogaW4gdGhpcyBvYmplY3QgdGhlcmUgd2lsbCBiZSBhcHBlbmRlZCBzb21lIGNhbnZhc2VzLCBjcmVhdGVkIG9uY2UsIHJlc2l6ZWQgc29tZXRpbWVzXG4gICAgICogY2xlYXJlZCBuZXZlci4gQ2xlYXJpbmcgaXMgbGVmdCB0byB0aGUgZGV2ZWxvcGVyLlxuICAgICAqKi9cbiAgICByZXNvdXJjZXM6IHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBhIHNldCBvZiBmaWx0ZXJzIGFnYWluc3QgYSBzb3VyY2UgaW1hZ2UgYW5kIGRyYXcgdGhlIGZpbHRlcmVkIG91dHB1dFxuICAgICAqIHRvIHRoZSBwcm92aWRlZCBkZXN0aW5hdGlvbiBjYW52YXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VuaGFuY2VkRmlsdGVyfSBmaWx0ZXJzIFRoZSBmaWx0ZXIgdG8gYXBwbHkuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBzb3VyY2VFbGVtZW50IFRoZSBzb3VyY2UgdG8gYmUgZmlsdGVyZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNvdXJjZVdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgc291cmNlIGlucHV0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzb3VyY2VIZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgc291cmNlIGlucHV0LlxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IHRhcmdldENhbnZhcyBUaGUgZGVzdGluYXRpb24gZm9yIGZpbHRlcmVkIG91dHB1dCB0byBiZSBkcmF3bi5cbiAgICAgKi9cbiAgICBhcHBseUZpbHRlcnM6IGZ1bmN0aW9uKGZpbHRlcnMsIHNvdXJjZUVsZW1lbnQsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQsIHRhcmdldENhbnZhcykge1xuICAgICAgdmFyIGN0eCA9IHRhcmdldENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmRyYXdJbWFnZShzb3VyY2VFbGVtZW50LCAwLCAwLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KTtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpO1xuICAgICAgdmFyIG9yaWdpbmFsSW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KTtcbiAgICAgIHZhciBwaXBlbGluZVN0YXRlID0ge1xuICAgICAgICBzb3VyY2VXaWR0aDogc291cmNlV2lkdGgsXG4gICAgICAgIHNvdXJjZUhlaWdodDogc291cmNlSGVpZ2h0LFxuICAgICAgICBpbWFnZURhdGE6IGltYWdlRGF0YSxcbiAgICAgICAgb3JpZ2luYWxFbDogc291cmNlRWxlbWVudCxcbiAgICAgICAgb3JpZ2luYWxJbWFnZURhdGE6IG9yaWdpbmFsSW1hZ2VEYXRhLFxuICAgICAgICBjYW52YXNFbDogdGFyZ2V0Q2FudmFzLFxuICAgICAgICBjdHg6IGN0eCxcbiAgICAgICAgZmlsdGVyQmFja2VuZDogdGhpcyxcbiAgICAgIH07XG4gICAgICBmaWx0ZXJzLmZvckVhY2goZnVuY3Rpb24oZmlsdGVyKSB7IGZpbHRlci5hcHBseVRvKHBpcGVsaW5lU3RhdGUpOyB9KTtcbiAgICAgIGlmIChwaXBlbGluZVN0YXRlLmltYWdlRGF0YS53aWR0aCAhPT0gc291cmNlV2lkdGggfHwgcGlwZWxpbmVTdGF0ZS5pbWFnZURhdGEuaGVpZ2h0ICE9PSBzb3VyY2VIZWlnaHQpIHtcbiAgICAgICAgdGFyZ2V0Q2FudmFzLndpZHRoID0gcGlwZWxpbmVTdGF0ZS5pbWFnZURhdGEud2lkdGg7XG4gICAgICAgIHRhcmdldENhbnZhcy5oZWlnaHQgPSBwaXBlbGluZVN0YXRlLmltYWdlRGF0YS5oZWlnaHQ7XG4gICAgICB9XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKHBpcGVsaW5lU3RhdGUuaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgIHJldHVybiBwaXBlbGluZVN0YXRlO1xuICAgIH0sXG5cbiAgfTtcbn0pKCk7XG5cblxuLyoqXG4gKiBAbmFtZXNwYWNlIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gKiBAbWVtYmVyT2YgZmFicmljLkltYWdlXG4gKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMiNpbWFnZV9maWx0ZXJzfVxuICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICovXG5mYWJyaWMuSW1hZ2UuZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzIHx8IHsgfTtcblxuLyoqXG4gKiBSb290IGZpbHRlciBjbGFzcyBmcm9tIHdoaWNoIGFsbCBmaWx0ZXIgY2xhc3NlcyBpbmhlcml0IGZyb21cbiAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAqL1xuZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlciA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBGaWx0ZXIgdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgdHlwZTogJ0Jhc2VGaWx0ZXInLFxuXG4gIC8qKlxuICAgKiBBcnJheSBvZiBhdHRyaWJ1dGVzIHRvIHNlbmQgd2l0aCBidWZmZXJzLiBkbyBub3QgbW9kaWZ5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHZlcnRleFNvdXJjZTogJ2F0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbjtcXG4nICtcbiAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgJ3ZUZXhDb29yZCA9IGFQb3NpdGlvbjtcXG4nICtcbiAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQoYVBvc2l0aW9uICogMi4wIC0gMS4wLCAwLjAsIDEuMCk7XFxuJyArXG4gICAgJ30nLFxuXG4gIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgJ2dsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAnfScsXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBmaWx0ZXIncyBwcm9wZXJ0aWVzIGZyb20gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBzZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIgcHJvZ3JhbS5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB0byB1c2UgZm9yIHNoYWRlciBjb21waWxhdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGZyYWdtZW50U291cmNlIGZyYWdtZW50U2hhZGVyIHNvdXJjZSBmb3IgY29tcGlsYXRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHZlcnRleFNvdXJjZSB2ZXJ0ZXhTaGFkZXIgc291cmNlIGZvciBjb21waWxhdGlvblxuICAgKi9cbiAgY3JlYXRlUHJvZ3JhbTogZnVuY3Rpb24oZ2wsIGZyYWdtZW50U291cmNlLCB2ZXJ0ZXhTb3VyY2UpIHtcbiAgICBmcmFnbWVudFNvdXJjZSA9IGZyYWdtZW50U291cmNlIHx8IHRoaXMuZnJhZ21lbnRTb3VyY2U7XG4gICAgdmVydGV4U291cmNlID0gdmVydGV4U291cmNlIHx8IHRoaXMudmVydGV4U291cmNlO1xuICAgIGlmIChmYWJyaWMud2ViR2xQcmVjaXNpb24gIT09ICdoaWdocCcpe1xuICAgICAgZnJhZ21lbnRTb3VyY2UgPSBmcmFnbWVudFNvdXJjZS5yZXBsYWNlKFxuICAgICAgICAvcHJlY2lzaW9uIGhpZ2hwIGZsb2F0L2csXG4gICAgICAgICdwcmVjaXNpb24gJyArIGZhYnJpYy53ZWJHbFByZWNpc2lvbiArICcgZmxvYXQnXG4gICAgICApO1xuICAgIH1cbiAgICB2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpO1xuICAgIGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHZlcnRleFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItdGVtcGxhdGVcbiAgICAgICAgJ1ZlcnRleCBzaGFkZXIgY29tcGlsZSBlcnJvciBmb3IgJyArIHRoaXMudHlwZSArICc6ICcgK1xuICAgICAgICBnbC5nZXRTaGFkZXJJbmZvTG9nKHZlcnRleFNoYWRlcilcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ21lbnRTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXRlbXBsYXRlXG4gICAgICAgICdGcmFnbWVudCBzaGFkZXIgY29tcGlsZSBlcnJvciBmb3IgJyArIHRoaXMudHlwZSArICc6ICcgK1xuICAgICAgICBnbC5nZXRTaGFkZXJJbmZvTG9nKGZyYWdtZW50U2hhZGVyKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci10ZW1wbGF0ZVxuICAgICAgICAnU2hhZGVyIGxpbmsgZXJyb3IgZm9yIFwiJHt0aGlzLnR5cGV9XCIgJyArXG4gICAgICAgIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBhdHRyaWJ1dGVMb2NhdGlvbnMgPSB0aGlzLmdldEF0dHJpYnV0ZUxvY2F0aW9ucyhnbCwgcHJvZ3JhbSk7XG4gICAgdmFyIHVuaWZvcm1Mb2NhdGlvbnMgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbnMoZ2wsIHByb2dyYW0pIHx8IHsgfTtcbiAgICB1bmlmb3JtTG9jYXRpb25zLnVTdGVwVyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVN0ZXBXJyk7XG4gICAgdW5pZm9ybUxvY2F0aW9ucy51U3RlcEggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTdGVwSCcpO1xuICAgIHJldHVybiB7XG4gICAgICBwcm9ncmFtOiBwcm9ncmFtLFxuICAgICAgYXR0cmlidXRlTG9jYXRpb25zOiBhdHRyaWJ1dGVMb2NhdGlvbnMsXG4gICAgICB1bmlmb3JtTG9jYXRpb25zOiB1bmlmb3JtTG9jYXRpb25zXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbWFwIG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBXZWJHTEF0dHJpYnV0ZUxvY2F0aW9uIG9iamVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhlIHNoYWRlciBwcm9ncmFtIGZyb20gd2hpY2ggdG8gdGFrZSBhdHRyaWJ1dGUgbG9jYXRpb25zLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBIG1hcCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYXR0cmlidXRlIGxvY2F0aW9ucy5cbiAgICovXG4gIGdldEF0dHJpYnV0ZUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgYVBvc2l0aW9uOiBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVBvc2l0aW9uJyksXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbWFwIG9mIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0cy5cbiAgICpcbiAgICogSW50ZW5kZWQgdG8gYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGUgc2hhZGVyIHByb2dyYW0uXG4gICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoZSBzaGFkZXIgcHJvZ3JhbSBmcm9tIHdoaWNoIHRvIHRha2UgdW5pZm9ybSBsb2NhdGlvbnMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEEgbWFwIG9mIHVuaWZvcm0gbmFtZXMgdG8gdW5pZm9ybSBsb2NhdGlvbnMuXG4gICAqL1xuICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbiAoLyogZ2wsIHByb2dyYW0gKi8pIHtcbiAgICAvLyBpbiBjYXNlIGkgZG8gbm90IG5lZWQgYW55IHNwZWNpYWwgdW5pZm9ybSBpIG5lZWQgdG8gcmV0dXJuIGFuIGVtcHR5IG9iamVjdFxuICAgIHJldHVybiB7IH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlbmQgYXR0cmlidXRlIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0gb24gdGhlIEdQVS5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhlIHNoYWRlciBwcm9ncmFtLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlTG9jYXRpb25zIEEgbWFwIG9mIHNoYWRlciBhdHRyaWJ1dGUgbmFtZXMgdG8gdGhlaXIgbG9jYXRpb25zLlxuICAgKi9cbiAgc2VuZEF0dHJpYnV0ZURhdGE6IGZ1bmN0aW9uKGdsLCBhdHRyaWJ1dGVMb2NhdGlvbnMsIGFQb3NpdGlvbkRhdGEpIHtcbiAgICB2YXIgYXR0cmlidXRlTG9jYXRpb24gPSBhdHRyaWJ1dGVMb2NhdGlvbnMuYVBvc2l0aW9uO1xuICAgIHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyaWJ1dGVMb2NhdGlvbik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyaWJ1dGVMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYVBvc2l0aW9uRGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xuICB9LFxuXG4gIF9zZXR1cEZyYW1lQnVmZmVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGdsID0gb3B0aW9ucy5jb250ZXh0LCB3aWR0aCwgaGVpZ2h0O1xuICAgIGlmIChvcHRpb25zLnBhc3NlcyA+IDEpIHtcbiAgICAgIHdpZHRoID0gb3B0aW9ucy5kZXN0aW5hdGlvbldpZHRoO1xuICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5kZXN0aW5hdGlvbkhlaWdodDtcbiAgICAgIGlmIChvcHRpb25zLnNvdXJjZVdpZHRoICE9PSB3aWR0aCB8fCBvcHRpb25zLnNvdXJjZUhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUob3B0aW9ucy50YXJnZXRUZXh0dXJlKTtcbiAgICAgICAgb3B0aW9ucy50YXJnZXRUZXh0dXJlID0gb3B0aW9ucy5maWx0ZXJCYWNrZW5kLmNyZWF0ZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELFxuICAgICAgICBvcHRpb25zLnRhcmdldFRleHR1cmUsIDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGRyYXcgbGFzdCBmaWx0ZXIgb24gY2FudmFzIGFuZCBub3QgdG8gZnJhbWVidWZmZXIuXG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgZ2wuZmluaXNoKCk7XG4gICAgfVxuICB9LFxuXG4gIF9zd2FwVGV4dHVyZXM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnBhc3Nlcy0tO1xuICAgIG9wdGlvbnMucGFzcysrO1xuICAgIHZhciB0ZW1wID0gb3B0aW9ucy50YXJnZXRUZXh0dXJlO1xuICAgIG9wdGlvbnMudGFyZ2V0VGV4dHVyZSA9IG9wdGlvbnMuc291cmNlVGV4dHVyZTtcbiAgICBvcHRpb25zLnNvdXJjZVRleHR1cmUgPSB0ZW1wO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnRlbnRpb25hbGx5IGxlZnQgYmxhbmssIHRvIGJlIG92ZXJyaWRkZW4gaW4gY3VzdG9tIGZpbHRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICoqL1xuICBpc05ldXRyYWxTdGF0ZTogZnVuY3Rpb24oLyogb3B0aW9ucyAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQXBwbHkgdGhpcyBmaWx0ZXIgdG8gdGhlIGlucHV0IGltYWdlIGRhdGEgcHJvdmlkZWQuXG4gICAqXG4gICAqIERldGVybWluZXMgd2hldGhlciB0byB1c2UgV2ViR0wgb3IgQ2FudmFzMkQgYmFzZWQgb24gdGhlIG9wdGlvbnMud2ViZ2wgZmxhZy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucGFzc2VzIFRoZSBudW1iZXIgb2YgZmlsdGVycyByZW1haW5pbmcgdG8gYmUgZXhlY3V0ZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLndlYmdsIFdoZXRoZXIgdG8gdXNlIHdlYmdsIHRvIHJlbmRlciB0aGUgZmlsdGVyLlxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy5zb3VyY2VUZXh0dXJlIFRoZSB0ZXh0dXJlIHNldHVwIGFzIHRoZSBzb3VyY2UgdG8gYmUgZmlsdGVyZWQuXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnRhcmdldFRleHR1cmUgVGhlIHRleHR1cmUgd2hlcmUgZmlsdGVyZWQgb3V0cHV0IHNob3VsZCBiZSBkcmF3bi5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgKi9cbiAgYXBwbHlUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLndlYmdsKSB7XG4gICAgICBpZiAob3B0aW9ucy5wYXNzZXMgPiAxICYmIHRoaXMuaXNOZXV0cmFsU3RhdGUob3B0aW9ucykpIHtcbiAgICAgICAgLy8gYXZvaWQgZG9pbmcgc29tZXRoaW5nIHRoYXQgd2UgZG8gbm90IG5lZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0dXBGcmFtZUJ1ZmZlcihvcHRpb25zKTtcbiAgICAgIHRoaXMuYXBwbHlUb1dlYkdMKG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc3dhcFRleHR1cmVzKG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIGlmICghdGhpcy5pc05ldXRyYWxTdGF0ZSgpKSB7XG4gICAgICB0aGlzLmFwcGx5VG8yZChvcHRpb25zKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY2FjaGVkIHNoYWRlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgKi9cbiAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KHRoaXMudHlwZSkpIHtcbiAgICAgIG9wdGlvbnMucHJvZ3JhbUNhY2hlW3RoaXMudHlwZV0gPSB0aGlzLmNyZWF0ZVByb2dyYW0ob3B0aW9ucy5jb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMucHJvZ3JhbUNhY2hlW3RoaXMudHlwZV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGx5IHRoaXMgZmlsdGVyIHVzaW5nIHdlYmdsLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wYXNzZXMgVGhlIG51bWJlciBvZiBmaWx0ZXJzIHJlbWFpbmluZyB0byBiZSBleGVjdXRlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMud2ViZ2wgV2hldGhlciB0byB1c2Ugd2ViZ2wgdG8gcmVuZGVyIHRoZSBmaWx0ZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLm9yaWdpbmFsVGV4dHVyZSBUaGUgdGV4dHVyZSBvZiB0aGUgb3JpZ2luYWwgaW5wdXQgaW1hZ2UuXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnNvdXJjZVRleHR1cmUgVGhlIHRleHR1cmUgc2V0dXAgYXMgdGhlIHNvdXJjZSB0byBiZSBmaWx0ZXJlZC5cbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMudGFyZ2V0VGV4dHVyZSBUaGUgdGV4dHVyZSB3aGVyZSBmaWx0ZXJlZCBvdXRwdXQgc2hvdWxkIGJlIGRyYXduLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAqL1xuICBhcHBseVRvV2ViR0w6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZ2wgPSBvcHRpb25zLmNvbnRleHQ7XG4gICAgdmFyIHNoYWRlciA9IHRoaXMucmV0cmlldmVTaGFkZXIob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMucGFzcyA9PT0gMCAmJiBvcHRpb25zLm9yaWdpbmFsVGV4dHVyZSkge1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgb3B0aW9ucy5vcmlnaW5hbFRleHR1cmUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG9wdGlvbnMuc291cmNlVGV4dHVyZSk7XG4gICAgfVxuICAgIGdsLnVzZVByb2dyYW0oc2hhZGVyLnByb2dyYW0pO1xuICAgIHRoaXMuc2VuZEF0dHJpYnV0ZURhdGEoZ2wsIHNoYWRlci5hdHRyaWJ1dGVMb2NhdGlvbnMsIG9wdGlvbnMuYVBvc2l0aW9uKTtcblxuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudW5pZm9ybUxvY2F0aW9ucy51U3RlcFcsIDEgLyBvcHRpb25zLnNvdXJjZVdpZHRoKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVuaWZvcm1Mb2NhdGlvbnMudVN0ZXBILCAxIC8gb3B0aW9ucy5zb3VyY2VIZWlnaHQpO1xuXG4gICAgdGhpcy5zZW5kVW5pZm9ybURhdGEoZ2wsIHNoYWRlci51bmlmb3JtTG9jYXRpb25zKTtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCBvcHRpb25zLmRlc3RpbmF0aW9uV2lkdGgsIG9wdGlvbnMuZGVzdGluYXRpb25IZWlnaHQpO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICB9LFxuXG4gIGJpbmRBZGRpdGlvbmFsVGV4dHVyZTogZnVuY3Rpb24oZ2wsIHRleHR1cmUsIHRleHR1cmVVbml0KSB7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0ZXh0dXJlVW5pdCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgLy8gcmVzZXQgYWN0aXZlIHRleHR1cmUgdG8gMCBhcyB1c3VhbFxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICB9LFxuXG4gIHVuYmluZEFkZGl0aW9uYWxUZXh0dXJlOiBmdW5jdGlvbihnbCwgdGV4dHVyZVVuaXQpIHtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRleHR1cmVVbml0KTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgfSxcblxuICBnZXRNYWluUGFyYW1ldGVyOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpc1t0aGlzLm1haW5QYXJhbWV0ZXJdO1xuICB9LFxuXG4gIHNldE1haW5QYXJhbWV0ZXI6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpc1t0aGlzLm1haW5QYXJhbWV0ZXJdID0gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlbmQgdW5pZm9ybSBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtIG9uIHRoZSBHUFUuXG4gICAqXG4gICAqIEludGVuZGVkIHRvIGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3Nlcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhlIHNoYWRlciBwcm9ncmFtLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzaGFkZXIgdW5pZm9ybSBuYW1lcyB0byB0aGVpciBsb2NhdGlvbnMuXG4gICAqL1xuICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKC8qIGdsLCB1bmlmb3JtTG9jYXRpb25zICovKSB7XG4gICAgLy8gSW50ZW50aW9uYWxseSBsZWZ0IGJsYW5rLiAgT3ZlcnJpZGUgbWUgaW4gc3ViY2xhc3Nlcy5cbiAgfSxcblxuICAvKipcbiAgICogSWYgbmVlZGVkIGJ5IGEgMmQgZmlsdGVyLCB0aGlzIGZ1bmN0aW9ucyBjYW4gY3JlYXRlIGFuIGhlbHBlciBjYW52YXMgdG8gYmUgdXNlZFxuICAgKiByZW1lbWJlciB0aGF0IG9wdGlvbnMudGFyZ2V0Q2FudmFzIGlzIGF2YWlsYWJsZSBmb3IgdXNlIHRpbGwgZW5kIG9mIGNoYWluLlxuICAgKi9cbiAgY3JlYXRlSGVscExheWVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmhlbHBMYXllcikge1xuICAgICAgdmFyIGhlbHBMYXllciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgaGVscExheWVyLndpZHRoID0gb3B0aW9ucy5zb3VyY2VXaWR0aDtcbiAgICAgIGhlbHBMYXllci5oZWlnaHQgPSBvcHRpb25zLnNvdXJjZUhlaWdodDtcbiAgICAgIG9wdGlvbnMuaGVscExheWVyID0gaGVscExheWVyO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICovXG4gIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2JqZWN0ID0geyB0eXBlOiB0aGlzLnR5cGUgfSwgbWFpblAgPSB0aGlzLm1haW5QYXJhbWV0ZXI7XG4gICAgaWYgKG1haW5QKSB7XG4gICAgICBvYmplY3RbbWFpblBdID0gdGhpc1ttYWluUF07XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gSlNPTlxuICAgKi9cbiAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAvLyBkZWxlZ2F0ZSwgbm90IGFsaWFzXG4gICAgcmV0dXJuIHRoaXMudG9PYmplY3QoKTtcbiAgfVxufSk7XG5cbmZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVyc1tvYmplY3QudHlwZV0ob2JqZWN0KTtcbiAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZmlsdGVyKTtcbiAgcmV0dXJuIGZpbHRlcjtcbn07XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQ29sb3IgTWF0cml4IGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXhcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXgjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAc2VlIHtATGluayBodHRwOi8vd3d3LndlYndhc3AuY28udWsvdHV0b3JpYWxzLzIxOS9Db2xvcl9NYXRyaXhfRmlsdGVyLnBocH1cbiAgICogQHNlZSB7QExpbmsgaHR0cDovL3Bob2Jvc2xhYi5vcmcvbG9nLzIwMTMvMTEvZmFzdC1pbWFnZS1maWx0ZXJzLXdpdGgtd2ViZ2x9XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPktvZGFjaHJvbWUgZmlsdGVyPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4KHtcbiAgICogIG1hdHJpeDogW1xuICAgICAgIDEuMTI4NTU4MjM5NjU5MzUyNSwgLTAuMzk2NzM4MjI4MzYwMTM0OCwgLTAuMDM5OTI1NTkxNzI5MjE3OTMsIDAsIDYzLjcyOTU4NzYyMTk2NTAyLFxuICAgICAgIC0wLjE2NDA0MzM5OTYyMjQ0NjE2LCAxLjA4MzUyNTE1NjYyOTEzMDQsIC0wLjA1NDk4ODA1MTE1NjMzMTMyLCAwLCAyNC43MzI0MDc4OTY3MDYyMDMsXG4gICAgICAgLTAuMTY3ODYwMTA3MDYxNTU3NjMsIC0wLjU2MDM0MTYyNzc2OTUyNDgsIDEuNjAxNDg1MDc2MTk2NDk0MywgMCwgMzUuNjI5ODI4MDc0NjA5NDYsXG4gICAgICAgMCwgMCwgMCwgMSwgMFxuICAgICAgXVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkNvbG9yTWF0cml4ID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnQ29sb3JNYXRyaXgnLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd1bmlmb3JtIG1hdDQgdUNvbG9yTWF0cml4O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjNCB1Q29uc3RhbnRzO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdjb2xvciAqPSB1Q29sb3JNYXRyaXg7XFxuJyArXG4gICAgICAgICdjb2xvciArPSB1Q29uc3RhbnRzO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvcm1hdHJpeCBmb3IgcGl4ZWxzLlxuICAgICAqIGFycmF5IG9mIDIwIGZsb2F0cy4gTnVtYmVycyBpbiBwb3NpdGlvbnMgNCwgOSwgMTQsIDE5IGxvb3NlIG1lYW5pbmdcbiAgICAgKiBvdXRzaWRlIHRoZSAtMSwgMSByYW5nZS5cbiAgICAgKiAwLjAwMzkyMTU2ODYgaXMgdGhlIHBhcnQgb2YgMSB0aGF0IGdldCB0cmFuc2xhdGVkIHRvIDEgaW4gMmRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtYXRyaXggYXJyYXkgb2YgMjAgbnVtYmVycy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1hdHJpeDogW1xuICAgICAgMSwgMCwgMCwgMCwgMCxcbiAgICAgIDAsIDEsIDAsIDAsIDAsXG4gICAgICAwLCAwLCAxLCAwLCAwLFxuICAgICAgMCwgMCwgMCwgMSwgMFxuICAgIF0sXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnbWF0cml4JyxcblxuICAgIC8qKlxuICAgICAqIExvY2sgdGhlIGNvbG9ybWF0cml4IG9uIHRoZSBjb2xvciBwYXJ0LCBza2lwcGluZyBhbHBoYSwgbWFubHkgZm9yIG5vbiB3ZWJnbCBzY2VuYXJpb1xuICAgICAqIHRvIHNhdmUgc29tZSBjYWxjdWxhdGlvblxuICAgICAqL1xuICAgIGNvbG9yc09ubHk6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgLy8gY3JlYXRlIGEgbmV3IGFycmF5IGluc3RlYWQgbXV0YXRpbmcgdGhlIHByb3RvdHlwZSB3aXRoIHB1c2hcbiAgICAgIHRoaXMubWF0cml4ID0gdGhpcy5tYXRyaXguc2xpY2UoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludGVudGlvbmFsbHkgbGVmdCBibGFuaywgdG8gYmUgb3ZlcnJpZGRlbiBpbiBjdXN0b20gZmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICoqL1xuICAgIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbigvKiBvcHRpb25zICovKSB7XG4gICAgICB2YXIgX2NsYXNzID0gZmlsdGVycy5Db2xvck1hdHJpeDtcbiAgICAgIGZvciAodmFyIGkgPSAyMDsgaS0tOykge1xuICAgICAgICBpZiAodGhpcy5tYXRyaXhbaV0gIT09IF9jbGFzcy5wcm90b3R5cGUubWF0cml4W2ldKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIENvbG9yTWF0cml4IG9wZXJhdGlvbiB0byBhIFVpbnQ4QXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgaUxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIG0gPSB0aGlzLm1hdHJpeCxcbiAgICAgICAgICByLCBnLCBiLCBhLCBpLCBjb2xvcnNPbmx5ID0gdGhpcy5jb2xvcnNPbmx5O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaUxlbjsgaSArPSA0KSB7XG4gICAgICAgIHIgPSBkYXRhW2ldO1xuICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcbiAgICAgICAgaWYgKGNvbG9yc09ubHkpIHtcbiAgICAgICAgICBkYXRhW2ldID0gciAqIG1bMF0gKyBnICogbVsxXSArIGIgKiBtWzJdICsgbVs0XSAqIDI1NTtcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9IHIgKiBtWzVdICsgZyAqIG1bNl0gKyBiICogbVs3XSArIG1bOV0gKiAyNTU7XG4gICAgICAgICAgZGF0YVtpICsgMl0gPSByICogbVsxMF0gKyBnICogbVsxMV0gKyBiICogbVsxMl0gKyBtWzE0XSAqIDI1NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhID0gZGF0YVtpICsgM107XG4gICAgICAgICAgZGF0YVtpXSA9IHIgKiBtWzBdICsgZyAqIG1bMV0gKyBiICogbVsyXSArIGEgKiBtWzNdICsgbVs0XSAqIDI1NTtcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9IHIgKiBtWzVdICsgZyAqIG1bNl0gKyBiICogbVs3XSArIGEgKiBtWzhdICsgbVs5XSAqIDI1NTtcbiAgICAgICAgICBkYXRhW2kgKyAyXSA9IHIgKiBtWzEwXSArIGcgKiBtWzExXSArIGIgKiBtWzEyXSArIGEgKiBtWzEzXSArIG1bMTRdICogMjU1O1xuICAgICAgICAgIGRhdGFbaSArIDNdID0gciAqIG1bMTVdICsgZyAqIG1bMTZdICsgYiAqIG1bMTddICsgYSAqIG1bMThdICsgbVsxOV0gKiAyNTU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVDb2xvck1hdHJpeDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Q29sb3JNYXRyaXgnKSxcbiAgICAgICAgdUNvbnN0YW50czogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Q29uc3RhbnRzJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0cml4LFxuICAgICAgICAgIG1hdHJpeCA9IFtcbiAgICAgICAgICAgIG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sXG4gICAgICAgICAgICBtWzVdLCBtWzZdLCBtWzddLCBtWzhdLFxuICAgICAgICAgICAgbVsxMF0sIG1bMTFdLCBtWzEyXSwgbVsxM10sXG4gICAgICAgICAgICBtWzE1XSwgbVsxNl0sIG1bMTddLCBtWzE4XVxuICAgICAgICAgIF0sXG4gICAgICAgICAgY29uc3RhbnRzID0gW21bNF0sIG1bOV0sIG1bMTRdLCBtWzE5XV07XG4gICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHVuaWZvcm1Mb2NhdGlvbnMudUNvbG9yTWF0cml4LCBmYWxzZSwgbWF0cml4KTtcbiAgICAgIGdsLnVuaWZvcm00ZnYodW5pZm9ybUxvY2F0aW9ucy51Q29uc3RhbnRzLCBjb25zdGFudHMpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gZnVuY3Rpb24gdG8gaW52b2tlIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeH0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXhcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4LmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQnJpZ2h0bmVzcyBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJyaWdodG5lc3NcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcyNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcyh7XG4gICAqICAgYnJpZ2h0bmVzczogMC4wNVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkJyaWdodG5lc3MgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0JyaWdodG5lc3MnLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgYnJpZ2h0bmVzcyBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1QnJpZ2h0bmVzcztcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdjb2xvci5yZ2IgKz0gdUJyaWdodG5lc3M7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIEJyaWdodG5lc3MgdmFsdWUsIGZyb20gLTEgdG8gMS5cbiAgICAgKiB0cmFuc2xhdGVkIHRvIC0yNTUgdG8gMjU1IGZvciAyZFxuICAgICAqIDAuMDAzOTIxNTY4NiBpcyB0aGUgcGFydCBvZiAxIHRoYXQgZ2V0IHRyYW5zbGF0ZWQgdG8gMSBpbiAyZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBicmlnaHRuZXNzXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBicmlnaHRuZXNzOiAwLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgdGhlIHByb3BlcnR5IHRoYXQgaXMgdGhlIGZpbHRlciBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWFpblBhcmFtZXRlcjogJ2JyaWdodG5lc3MnLFxuXG4gICAgLyoqXG4gICAgKiBBcHBseSB0aGUgQnJpZ2h0bmVzcyBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAqXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuYnJpZ2h0bmVzcyA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpLCBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBicmlnaHRuZXNzID0gTWF0aC5yb3VuZCh0aGlzLmJyaWdodG5lc3MgKiAyNTUpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaV0gPSBkYXRhW2ldICsgYnJpZ2h0bmVzcztcbiAgICAgICAgZGF0YVtpICsgMV0gPSBkYXRhW2kgKyAxXSArIGJyaWdodG5lc3M7XG4gICAgICAgIGRhdGFbaSArIDJdID0gZGF0YVtpICsgMl0gKyBicmlnaHRuZXNzO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUJyaWdodG5lc3M6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUJyaWdodG5lc3MnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVCcmlnaHRuZXNzLCB0aGlzLmJyaWdodG5lc3MpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzc30gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzc1xuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcy5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEFkYXB0ZWQgZnJvbSA8YSBocmVmPVwiaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvY2FudmFzL2ltYWdlZmlsdGVycy9cIj5odG1sNXJvY2tzIGFydGljbGU8L2E+XG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGVcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+U2hhcnBlbiBmaWx0ZXI8L2NhcHRpb24+XG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlKHtcbiAgICogICBtYXRyaXg6IFsgMCwgLTEsICAwLFxuICAgKiAgICAgICAgICAgIC0xLCAgNSwgLTEsXG4gICAqICAgICAgICAgICAgIDAsIC0xLCAgMCBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5CbHVyIGZpbHRlcjwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUoe1xuICAgKiAgIG1hdHJpeDogWyAxLzksIDEvOSwgMS85LFxuICAgKiAgICAgICAgICAgICAxLzksIDEvOSwgMS85LFxuICAgKiAgICAgICAgICAgICAxLzksIDEvOSwgMS85IF1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtYm9zcyBmaWx0ZXI8L2NhcHRpb24+XG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlKHtcbiAgICogICBtYXRyaXg6IFsgMSwgICAxLCAgMSxcbiAgICogICAgICAgICAgICAgMSwgMC43LCAtMSxcbiAgICogICAgICAgICAgICAtMSwgIC0xLCAtMSBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWJvc3MgZmlsdGVyIHdpdGggb3BhcXVlbmVzczwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUoe1xuICAgKiAgIG9wYXF1ZTogdHJ1ZSxcbiAgICogICBtYXRyaXg6IFsgMSwgICAxLCAgMSxcbiAgICogICAgICAgICAgICAgMSwgMC43LCAtMSxcbiAgICogICAgICAgICAgICAtMSwgIC0xLCAtMSBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cbiAgZmlsdGVycy5Db252b2x1dGUgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnQ29udm9sdXRlJyxcblxuICAgIC8qXG4gICAgICogT3BhcXVlIHZhbHVlICh0cnVlL2ZhbHNlKVxuICAgICAqL1xuICAgIG9wYXF1ZTogZmFsc2UsXG5cbiAgICAvKlxuICAgICAqIG1hdHJpeCBmb3IgdGhlIGZpbHRlciwgbWF4IDl4OVxuICAgICAqL1xuICAgIG1hdHJpeDogWzAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDBdLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgYnJpZ2h0bmVzcyBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6IHtcbiAgICAgIENvbnZvbHV0ZV8zXzE6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs5XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAwKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgMy4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCAzLjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMSksIHVTdGVwSCAqIChoIC0gMSkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpICogdU1hdHJpeFtpbnQoaCAqIDMuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV8zXzA6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs5XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAxKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgMy4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCAzLjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMS4wKSwgdVN0ZXBIICogKGggLSAxLjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDMuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gYWxwaGE7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV81XzE6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFsyNV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDUuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgNS4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDIuMCksIHVTdGVwSCAqIChoIC0gMi4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykgKiB1TWF0cml4W2ludChoICogNS4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzVfMDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzI1XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAxKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgNS4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA1LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMi4wKSwgdVN0ZXBIICogKGggLSAyLjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDUuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gYWxwaGE7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV83XzE6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs0OV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDcuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgNy4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDMuMCksIHVTdGVwSCAqIChoIC0gMy4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykgKiB1TWF0cml4W2ludChoICogNy4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzdfMDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzQ5XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAxKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgNy4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA3LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMy4wKSwgdVN0ZXBIICogKGggLSAzLjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDcuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gYWxwaGE7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV85XzE6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs4MV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDkuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgOS4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDQuMCksIHVTdGVwSCAqIChoIC0gNC4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykgKiB1TWF0cml4W2ludChoICogOS4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzlfMDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzgxXTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAxKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgOS4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA5LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gNC4wKSwgdVN0ZXBIICogKGggLSA0LjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDkuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gYWxwaGE7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm9wYXF1ZT1mYWxzZV0gT3BhcXVlIHZhbHVlICh0cnVlL2ZhbHNlKVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm1hdHJpeF0gRmlsdGVyIG1hdHJpeFxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAqIFJldHJpZXZlcyB0aGUgY2FjaGVkIHNoYWRlci5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICovXG4gICAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBzaXplID0gTWF0aC5zcXJ0KHRoaXMubWF0cml4Lmxlbmd0aCk7XG4gICAgICB2YXIgY2FjaGVLZXkgPSB0aGlzLnR5cGUgKyAnXycgKyBzaXplICsgJ18nICsgKHRoaXMub3BhcXVlID8gMSA6IDApO1xuICAgICAgdmFyIHNoYWRlclNvdXJjZSA9IHRoaXMuZnJhZ21lbnRTb3VyY2VbY2FjaGVLZXldO1xuICAgICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldID0gdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMuY29udGV4dCwgc2hhZGVyU291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBCcmlnaHRuZXNzIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICB3ZWlnaHRzID0gdGhpcy5tYXRyaXgsXG4gICAgICAgICAgc2lkZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KHdlaWdodHMubGVuZ3RoKSksXG4gICAgICAgICAgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUgLyAyKSxcbiAgICAgICAgICBzdyA9IGltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgICBzaCA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgb3V0cHV0ID0gb3B0aW9ucy5jdHguY3JlYXRlSW1hZ2VEYXRhKHN3LCBzaCksXG4gICAgICAgICAgZHN0ID0gb3V0cHV0LmRhdGEsXG4gICAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgZGVzdGluYXRpb24gaW1hZ2UgcGl4ZWxzXG4gICAgICAgICAgYWxwaGFGYWMgPSB0aGlzLm9wYXF1ZSA/IDEgOiAwLFxuICAgICAgICAgIHIsIGcsIGIsIGEsIGRzdE9mZixcbiAgICAgICAgICBzY3gsIHNjeSwgc3JjT2ZmLCB3dCxcbiAgICAgICAgICB4LCB5LCBjeCwgY3k7XG5cbiAgICAgIGZvciAoeSA9IDA7IHkgPCBzaDsgeSsrKSB7XG4gICAgICAgIGZvciAoeCA9IDA7IHggPCBzdzsgeCsrKSB7XG4gICAgICAgICAgZHN0T2ZmID0gKHkgKiBzdyArIHgpICogNDtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHdlaWdoZWQgc3VtIG9mIHRoZSBzb3VyY2UgaW1hZ2UgcGl4ZWxzIHRoYXRcbiAgICAgICAgICAvLyBmYWxsIHVuZGVyIHRoZSBjb252b2x1dGlvbiBtYXRyaXhcbiAgICAgICAgICByID0gMDsgZyA9IDA7IGIgPSAwOyBhID0gMDtcblxuICAgICAgICAgIGZvciAoY3kgPSAwOyBjeSA8IHNpZGU7IGN5KyspIHtcbiAgICAgICAgICAgIGZvciAoY3ggPSAwOyBjeCA8IHNpZGU7IGN4KyspIHtcbiAgICAgICAgICAgICAgc2N5ID0geSArIGN5IC0gaGFsZlNpZGU7XG4gICAgICAgICAgICAgIHNjeCA9IHggKyBjeCAtIGhhbGZTaWRlO1xuXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICAgICAgaWYgKHNjeSA8IDAgfHwgc2N5ID4gc2ggfHwgc2N4IDwgMCB8fCBzY3ggPiBzdykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3JjT2ZmID0gKHNjeSAqIHN3ICsgc2N4KSAqIDQ7XG4gICAgICAgICAgICAgIHd0ID0gd2VpZ2h0c1tjeSAqIHNpZGUgKyBjeF07XG5cbiAgICAgICAgICAgICAgciArPSBkYXRhW3NyY09mZl0gKiB3dDtcbiAgICAgICAgICAgICAgZyArPSBkYXRhW3NyY09mZiArIDFdICogd3Q7XG4gICAgICAgICAgICAgIGIgKz0gZGF0YVtzcmNPZmYgKyAyXSAqIHd0O1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICAgIGlmICghYWxwaGFGYWMpIHtcbiAgICAgICAgICAgICAgICBhICs9IGRhdGFbc3JjT2ZmICsgM10gKiB3dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkc3RbZHN0T2ZmXSA9IHI7XG4gICAgICAgICAgZHN0W2RzdE9mZiArIDFdID0gZztcbiAgICAgICAgICBkc3RbZHN0T2ZmICsgMl0gPSBiO1xuICAgICAgICAgIGlmICghYWxwaGFGYWMpIHtcbiAgICAgICAgICAgIGRzdFtkc3RPZmYgKyAzXSA9IGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHN0W2RzdE9mZiArIDNdID0gZGF0YVtkc3RPZmYgKyAzXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuaW1hZ2VEYXRhID0gb3V0cHV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdU1hdHJpeDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1TWF0cml4JyksXG4gICAgICAgIHVPcGFxdWU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndU9wYXF1ZScpLFxuICAgICAgICB1SGFsZlNpemU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUhhbGZTaXplJyksXG4gICAgICAgIHVTaXplOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTaXplJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWZ2KHVuaWZvcm1Mb2NhdGlvbnMudU1hdHJpeCwgdGhpcy5tYXRyaXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnKSwge1xuICAgICAgICBvcGFxdWU6IHRoaXMub3BhcXVlLFxuICAgICAgICBtYXRyaXg6IHRoaXMubWF0cml4XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogR3JheXNjYWxlIGltYWdlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGUoKTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkdyYXlzY2FsZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdHcmF5c2NhbGUnLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6IHtcbiAgICAgIGF2ZXJhZ2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IGF2ZXJhZ2UgPSAoY29sb3IuciArIGNvbG9yLmIgKyBjb2xvci5nKSAvIDMuMDtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNChhdmVyYWdlLCBhdmVyYWdlLCBhdmVyYWdlLCBjb2xvci5hKTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgbGlnaHRuZXNzOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGludCB1TW9kZTtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAgICdmbG9hdCBhdmVyYWdlID0gKG1heChtYXgoY29sLnIsIGNvbC5nKSxjb2wuYikgKyBtaW4obWluKGNvbC5yLCBjb2wuZyksY29sLmIpKSAvIDIuMDtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNChhdmVyYWdlLCBhdmVyYWdlLCBhdmVyYWdlLCBjb2wuYSk7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIGx1bWlub3NpdHk6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gaW50IHVNb2RlO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2wgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IGF2ZXJhZ2UgPSAwLjIxICogY29sLnIgKyAwLjcyICogY29sLmcgKyAwLjA3ICogY29sLmI7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHZlYzQoYXZlcmFnZSwgYXZlcmFnZSwgYXZlcmFnZSwgY29sLmEpO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogR3JheXNjYWxlIG1vZGUsIGJldHdlZW4gJ2F2ZXJhZ2UnLCAnbGlnaHRuZXNzJywgJ2x1bWlub3NpdHknXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1vZGU6ICdhdmVyYWdlJyxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdtb2RlJyxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBHcmF5c2NhbGUgb3BlcmF0aW9uIHRvIGEgVWludDhBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaSxcbiAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aCwgdmFsdWUsXG4gICAgICAgICAgbW9kZSA9IHRoaXMubW9kZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBpZiAobW9kZSA9PT0gJ2F2ZXJhZ2UnKSB7XG4gICAgICAgICAgdmFsdWUgPSAoZGF0YVtpXSArIGRhdGFbaSArIDFdICsgZGF0YVtpICsgMl0pIC8gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb2RlID09PSAnbGlnaHRuZXNzJykge1xuICAgICAgICAgIHZhbHVlID0gKE1hdGgubWluKGRhdGFbaV0sIGRhdGFbaSArIDFdLCBkYXRhW2kgKyAyXSkgK1xuICAgICAgICAgICAgTWF0aC5tYXgoZGF0YVtpXSwgZGF0YVtpICsgMV0sIGRhdGFbaSArIDJdKSkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGUgPT09ICdsdW1pbm9zaXR5Jykge1xuICAgICAgICAgIHZhbHVlID0gMC4yMSAqIGRhdGFbaV0gKyAwLjcyICogZGF0YVtpICsgMV0gKyAwLjA3ICogZGF0YVtpICsgMl07XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtpXSA9IHZhbHVlO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IHZhbHVlO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNhY2hlZCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNhY2hlS2V5ID0gdGhpcy50eXBlICsgJ18nICsgdGhpcy5tb2RlO1xuICAgICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgdmFyIHNoYWRlclNvdXJjZSA9IHRoaXMuZnJhZ21lbnRTb3VyY2VbdGhpcy5tb2RlXTtcbiAgICAgICAgb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldID0gdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMuY29udGV4dCwgc2hhZGVyU291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1TW9kZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1TW9kZScpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgLy8gZGVmYXVsdCBhdmVyYWdlIG1vZGUuXG4gICAgICB2YXIgbW9kZSA9IDE7XG4gICAgICBnbC51bmlmb3JtMWkodW5pZm9ybUxvY2F0aW9ucy51TW9kZSwgbW9kZSk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGV9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBJbnZlcnQgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydCgpO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgKi9cbiAgZmlsdGVycy5JbnZlcnQgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnSW52ZXJ0JyxcblxuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gaW50IHVJbnZlcnQ7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnaWYgKHVJbnZlcnQgPT0gMSkge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCAtIGNvbG9yLnIsMS4wIC1jb2xvci5nLDEuMCAtY29sb3IuYixjb2xvci5hKTtcXG4nICtcbiAgICAgICAgJ30gZWxzZSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnfVxcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIGludmVydC4gaWYgZmFsc2UsIGRvZXMgbm90aGluZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW52ZXJ0XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbnZlcnQ6IHRydWUsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnaW52ZXJ0JyxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBJbnZlcnQgb3BlcmF0aW9uIHRvIGEgVWludDhBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLmludmVydCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpLFxuICAgICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaV0gPSAyNTUgLSBkYXRhW2ldO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IDI1NSAtIGRhdGFbaSArIDFdO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IDI1NSAtIGRhdGFbaSArIDJdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUludmVydDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1SW52ZXJ0JyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWkodW5pZm9ybUxvY2F0aW9ucy51SW52ZXJ0LCB0aGlzLmludmVydCk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnR9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydFxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0LmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBOb2lzZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZSh7XG4gICAqICAgbm9pc2U6IDcwMFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICovXG4gIGZpbHRlcnMuTm9pc2UgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2UucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdOb2lzZScsXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBub2lzZSBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1Tm9pc2U7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1U2VlZDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ2Zsb2F0IHJhbmQodmVjMiBjbywgZmxvYXQgc2VlZCwgZmxvYXQgdlNjYWxlKSB7XFxuJyArXG4gICAgICAgICdyZXR1cm4gZnJhY3Qoc2luKGRvdChjby54eSAqIHZTY2FsZSAsdmVjMigxMi45ODk4ICwgNzguMjMzKSkpICogNDM3NTguNTQ1MyAqIChzZWVkICsgMC4wMSkgLyAyLjApO1xcbicgK1xuICAgICAgJ31cXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnY29sb3IucmdiICs9ICgwLjUgLSByYW5kKHZUZXhDb29yZCwgdVNlZWQsIDAuMSAvIHVTdGVwSCkpICogdU5vaXNlO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSB0aGUgcHJvcGVydHkgdGhhdCBpcyB0aGUgZmlsdGVyIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtYWluUGFyYW1ldGVyOiAnbm9pc2UnLFxuXG4gICAgLyoqXG4gICAgICogTm9pc2UgdmFsdWUsIGZyb21cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbm9pc2VcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG5vaXNlOiAwLFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEJyaWdodG5lc3Mgb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5ub2lzZSA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpLCBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBub2lzZSA9IHRoaXMubm9pc2UsIHJhbmQ7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDQpIHtcblxuICAgICAgICByYW5kID0gKDAuNSAtIE1hdGgucmFuZG9tKCkpICogbm9pc2U7XG5cbiAgICAgICAgZGF0YVtpXSArPSByYW5kO1xuICAgICAgICBkYXRhW2kgKyAxXSArPSByYW5kO1xuICAgICAgICBkYXRhW2kgKyAyXSArPSByYW5kO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdU5vaXNlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VOb2lzZScpLFxuICAgICAgICB1U2VlZDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U2VlZCcpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudU5vaXNlLCB0aGlzLm5vaXNlIC8gMjU1KTtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVTZWVkLCBNYXRoLnJhbmRvbSgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgbm9pc2U6IHRoaXMubm9pc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2VcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBQaXhlbGF0ZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZSh7XG4gICAqICAgYmxvY2tzaXplOiA4XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuUGl4ZWxhdGUgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdQaXhlbGF0ZScsXG5cbiAgICBibG9ja3NpemU6IDQsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnYmxvY2tzaXplJyxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIFBpeGVsYXRlIHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVCbG9ja3NpemU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICdmbG9hdCBibG9ja1cgPSB1QmxvY2tzaXplICogdVN0ZXBXO1xcbicgK1xuICAgICAgICAnZmxvYXQgYmxvY2tIID0gdUJsb2Nrc2l6ZSAqIHVTdGVwVztcXG4nICtcbiAgICAgICAgJ2ludCBwb3NYID0gaW50KHZUZXhDb29yZC54IC8gYmxvY2tXKTtcXG4nICtcbiAgICAgICAgJ2ludCBwb3NZID0gaW50KHZUZXhDb29yZC55IC8gYmxvY2tIKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IGZwb3NYID0gZmxvYXQocG9zWCk7XFxuJyArXG4gICAgICAgICdmbG9hdCBmcG9zWSA9IGZsb2F0KHBvc1kpO1xcbicgK1xuICAgICAgICAndmVjMiBzcXVhcmVDb29yZHMgPSB2ZWMyKGZwb3NYICogYmxvY2tXLCBmcG9zWSAqIGJsb2NrSCk7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCBzcXVhcmVDb29yZHMpO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgUGl4ZWxhdGUgb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5ibG9ja3NpemUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBpTGVuID0gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgICAgICBqTGVuID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgIGluZGV4LCBpLCBqLCByLCBnLCBiLCBhLFxuICAgICAgICAgIF9pLCBfaiwgX2lMZW4sIF9qTGVuO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaUxlbjsgaSArPSB0aGlzLmJsb2Nrc2l6ZSkge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSB0aGlzLmJsb2Nrc2l6ZSkge1xuXG4gICAgICAgICAgaW5kZXggPSAoaSAqIDQpICogakxlbiArIChqICogNCk7XG5cbiAgICAgICAgICByID0gZGF0YVtpbmRleF07XG4gICAgICAgICAgZyA9IGRhdGFbaW5kZXggKyAxXTtcbiAgICAgICAgICBiID0gZGF0YVtpbmRleCArIDJdO1xuICAgICAgICAgIGEgPSBkYXRhW2luZGV4ICsgM107XG5cbiAgICAgICAgICBfaUxlbiA9IE1hdGgubWluKGkgKyB0aGlzLmJsb2Nrc2l6ZSwgaUxlbik7XG4gICAgICAgICAgX2pMZW4gPSBNYXRoLm1pbihqICsgdGhpcy5ibG9ja3NpemUsIGpMZW4pO1xuICAgICAgICAgIGZvciAoX2kgPSBpOyBfaSA8IF9pTGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBmb3IgKF9qID0gajsgX2ogPCBfakxlbjsgX2orKykge1xuICAgICAgICAgICAgICBpbmRleCA9IChfaSAqIDQpICogakxlbiArIChfaiAqIDQpO1xuICAgICAgICAgICAgICBkYXRhW2luZGV4XSA9IHI7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXggKyAxXSA9IGc7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXggKyAyXSA9IGI7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXggKyAzXSA9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlIHdoZW4gdGhlIGZpbHRlciBpcyBub3QgZ29ubmEgYXBwbHkgY2hhbmdlcyB0byB0aGUgaW1hZ2VcbiAgICAgKiovXG4gICAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmxvY2tzaXplID09PSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUJsb2Nrc2l6ZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1QmxvY2tzaXplJyksXG4gICAgICAgIHVTdGVwVzogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U3RlcFcnKSxcbiAgICAgICAgdVN0ZXBIOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTdGVwSCcpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudUJsb2Nrc2l6ZSwgdGhpcy5ibG9ja3NpemUpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGV9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB3aGl0ZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZUNvbG9yXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZUNvbG9yI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvcih7XG4gICAqICAgdGhyZXNob2xkOiAwLjIsXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cbiAgZmlsdGVycy5SZW1vdmVDb2xvciA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvci5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1JlbW92ZUNvbG9yJyxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIHRvIHJlbW92ZSwgaW4gYW55IGZvcm1hdCB1bmRlcnN0b29kIGJ5IGZhYnJpYy5Db2xvci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29sb3I6ICcjRkZGRkZGJyxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIGJyaWdodG5lc3MgcHJvZ3JhbVxuICAgICAqL1xuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjNCB1TG93O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjNCB1SGlnaDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2lmKGFsbChncmVhdGVyVGhhbihnbF9GcmFnQ29sb3IucmdiLHVMb3cucmdiKSkgJiYgYWxsKGdyZWF0ZXJUaGFuKHVIaWdoLnJnYixnbF9GcmFnQ29sb3IucmdiKSkpIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmEgPSAwLjA7XFxuJyArXG4gICAgICAgICd9XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBkaXN0YW5jZSB0byBhY3R1YWwgY29sb3IsIGFzIHZhbHVlIHVwIG9yIGRvd24gZnJvbSBlYWNoIHIsZyxiXG4gICAgICogYmV0d2VlbiAwIGFuZCAxXG4gICAgICoqL1xuICAgIGRpc3RhbmNlOiAwLjAyLFxuXG4gICAgLyoqXG4gICAgICogRm9yIGNvbG9yIHRvIHJlbW92ZSBpbnNpZGUgZGlzdGFuY2UsIHVzZSBhbHBoYSBjaGFubmVsIGZvciBhIHNtb290aGVyIGRlbGV0aW9uXG4gICAgICogTk9UIElNUExFTUVOVEVEIFlFVFxuICAgICAqKi9cbiAgICB1c2VBbHBoYTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVXaGl0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbG9yPSNSUkdHQkJdIFRocmVzaG9sZCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kaXN0YW5jZT0xMF0gRGlzdGFuY2UgdmFsdWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZmlsdGVyIHRvIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaSxcbiAgICAgICAgICBkaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2UgKiAyNTUsXG4gICAgICAgICAgciwgZywgYixcbiAgICAgICAgICBzb3VyY2UgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGxvd0MgPSBbXG4gICAgICAgICAgICBzb3VyY2VbMF0gLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIHNvdXJjZVsxXSAtIGRpc3RhbmNlLFxuICAgICAgICAgICAgc291cmNlWzJdIC0gZGlzdGFuY2UsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBoaWdoQyA9IFtcbiAgICAgICAgICAgIHNvdXJjZVswXSArIGRpc3RhbmNlLFxuICAgICAgICAgICAgc291cmNlWzFdICsgZGlzdGFuY2UsXG4gICAgICAgICAgICBzb3VyY2VbMl0gKyBkaXN0YW5jZSxcbiAgICAgICAgICBdO1xuXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHIgPSBkYXRhW2ldO1xuICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcblxuICAgICAgICBpZiAociA+IGxvd0NbMF0gJiZcbiAgICAgICAgICAgIGcgPiBsb3dDWzFdICYmXG4gICAgICAgICAgICBiID4gbG93Q1syXSAmJlxuICAgICAgICAgICAgciA8IGhpZ2hDWzBdICYmXG4gICAgICAgICAgICBnIDwgaGlnaENbMV0gJiZcbiAgICAgICAgICAgIGIgPCBoaWdoQ1syXSkge1xuICAgICAgICAgIGRhdGFbaSArIDNdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUxvdzogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1TG93JyksXG4gICAgICAgIHVIaWdoOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VIaWdoJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICB2YXIgc291cmNlID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKS5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBkaXN0YW5jZSA9IHBhcnNlRmxvYXQodGhpcy5kaXN0YW5jZSksXG4gICAgICAgICAgbG93QyA9IFtcbiAgICAgICAgICAgIDAgKyBzb3VyY2VbMF0gLyAyNTUgLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIDAgKyBzb3VyY2VbMV0gLyAyNTUgLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIDAgKyBzb3VyY2VbMl0gLyAyNTUgLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICBdLFxuICAgICAgICAgIGhpZ2hDID0gW1xuICAgICAgICAgICAgc291cmNlWzBdIC8gMjU1ICsgZGlzdGFuY2UsXG4gICAgICAgICAgICBzb3VyY2VbMV0gLyAyNTUgKyBkaXN0YW5jZSxcbiAgICAgICAgICAgIHNvdXJjZVsyXSAvIDI1NSArIGRpc3RhbmNlLFxuICAgICAgICAgICAgMVxuICAgICAgICAgIF07XG4gICAgICBnbC51bmlmb3JtNGZ2KHVuaWZvcm1Mb2NhdGlvbnMudUxvdywgbG93Qyk7XG4gICAgICBnbC51bmlmb3JtNGZ2KHVuaWZvcm1Mb2NhdGlvbnMudUhpZ2gsIGhpZ2hDKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgIGRpc3RhbmNlOiB0aGlzLmRpc3RhbmNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlQ29sb3J9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZVdoaXRlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvci5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICB2YXIgbWF0cmljZXMgPSB7XG4gICAgQnJvd25pZTogW1xuICAgICAgMC41OTk3MCwwLjM0NTUzLC0wLjI3MDgyLDAsMC4xODYsXG4gICAgICAtMC4wMzc3MCwwLjg2MDk1LDAuMTUwNTksMCwtMC4xNDQ5LFxuICAgICAgMC4yNDExMywtMC4wNzQ0MSwwLjQ0OTcyLDAsLTAuMDI5NjUsXG4gICAgICAwLDAsMCwxLDBcbiAgICBdLFxuICAgIFZpbnRhZ2U6IFtcbiAgICAgIDAuNjI3OTMsMC4zMjAyMSwtMC4wMzk2NSwwLDAuMDM3ODQsXG4gICAgICAwLjAyNTc4LDAuNjQ0MTEsMC4wMzI1OSwwLDAuMDI5MjYsXG4gICAgICAwLjA0NjYwLC0wLjA4NTEyLDAuNTI0MTYsMCwwLjAyMDIzLFxuICAgICAgMCwwLDAsMSwwXG4gICAgXSxcbiAgICBLb2RhY2hyb21lOiBbXG4gICAgICAxLjEyODU1LC0wLjM5NjczLC0wLjAzOTkyLDAsMC4yNDk5MSxcbiAgICAgIC0wLjE2NDA0LDEuMDgzNTIsLTAuMDU0OTgsMCwwLjA5Njk4LFxuICAgICAgLTAuMTY3ODYsLTAuNTYwMzQsMS42MDE0OCwwLDAuMTM5NzIsXG4gICAgICAwLDAsMCwxLDBcbiAgICBdLFxuICAgIFRlY2huaWNvbG9yOiBbXG4gICAgICAxLjkxMjUyLC0wLjg1NDUzLC0wLjA5MTU1LDAsMC4wNDYyNCxcbiAgICAgIC0wLjMwODc4LDEuNzY1ODksLTAuMTA2MDEsMCwtMC4yNzU4OSxcbiAgICAgIC0wLjIzMTEwLC0wLjc1MDE4LDEuODQ3NTksMCwwLjEyMTM3LFxuICAgICAgMCwwLDAsMSwwXG4gICAgXSxcbiAgICBQb2xhcm9pZDogW1xuICAgICAgMS40MzgsLTAuMDYyLC0wLjA2MiwwLDAsXG4gICAgICAtMC4xMjIsMS4zNzgsLTAuMTIyLDAsMCxcbiAgICAgIC0wLjAxNiwtMC4wMTYsMS40ODMsMCwwLFxuICAgICAgMCwwLDAsMSwwXG4gICAgXSxcbiAgICBTZXBpYTogW1xuICAgICAgMC4zOTMsIDAuNzY5LCAwLjE4OSwgMCwgMCxcbiAgICAgIDAuMzQ5LCAwLjY4NiwgMC4xNjgsIDAsIDAsXG4gICAgICAwLjI3MiwgMC41MzQsIDAuMTMxLCAwLCAwLFxuICAgICAgMCwgMCwgMCwgMSwgMFxuICAgIF0sXG4gICAgQmxhY2tXaGl0ZTogW1xuICAgICAgMS41LCAxLjUsIDEuNSwgMCwgLTEsXG4gICAgICAxLjUsIDEuNSwgMS41LCAwLCAtMSxcbiAgICAgIDEuNSwgMS41LCAxLjUsIDAsIC0xLFxuICAgICAgMCwgMCwgMCwgMSwgMCxcbiAgICBdXG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIG1hdHJpY2VzKSB7XG4gICAgZmlsdGVyc1trZXldID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5Db2xvck1hdHJpeCwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TZXBpYS5wcm90b3R5cGUgKi8ge1xuXG4gICAgICAvKipcbiAgICAgICAqIEZpbHRlciB0eXBlXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAgICogQGRlZmF1bHRcbiAgICAgICAqL1xuICAgICAgdHlwZToga2V5LFxuXG4gICAgICAvKipcbiAgICAgICAqIENvbG9ybWF0cml4IGZvciB0aGUgZWZmZWN0XG4gICAgICAgKiBhcnJheSBvZiAyMCBmbG9hdHMuIE51bWJlcnMgaW4gcG9zaXRpb25zIDQsIDksIDE0LCAxOSBsb29zZSBtZWFuaW5nXG4gICAgICAgKiBvdXRzaWRlIHRoZSAtMSwgMSByYW5nZS5cbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeCBhcnJheSBvZiAyMCBudW1iZXJzLlxuICAgICAgICogQGRlZmF1bHRcbiAgICAgICAqL1xuICAgICAgbWF0cml4OiBtYXRyaWNlc1trZXldLFxuXG4gICAgICAvKipcbiAgICAgICAqIExvY2sgdGhlIG1hdHJpeCBleHBvcnQgZm9yIHRoaXMga2luZCBvZiBzdGF0aWMsIHBhcmFtZXRlciBsZXNzIGZpbHRlcnMuXG4gICAgICAgKi9cbiAgICAgIG1haW5QYXJhbWV0ZXI6IGZhbHNlLFxuICAgICAgLyoqXG4gICAgICAgKiBMb2NrIHRoZSBjb2xvcm1hdHJpeCBvbiB0aGUgY29sb3IgcGFydCwgc2tpcHBpbmcgYWxwaGFcbiAgICAgICAqL1xuICAgICAgY29sb3JzT25seTogdHJ1ZSxcblxuICAgIH0pO1xuICAgIGZhYnJpYy5JbWFnZS5maWx0ZXJzW2tleV0uZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcbiAgfVxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQ29sb3IgQmxlbmQgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVyLkJsZW5kQ29sb3JcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yKHtcbiAgICogIGNvbG9yOiAnIzAwMCcsXG4gICAqICBtb2RlOiAnbXVsdGlwbHknXG4gICAqIH0pO1xuICAgKlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2Uoe1xuICAgKiAgaW1hZ2U6IGZhYnJpY0ltYWdlT2JqZWN0LFxuICAgKiAgbW9kZTogJ211bHRpcGx5JyxcbiAgICogIGFscGhhOiAwLjVcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqL1xuXG4gIGZpbHRlcnMuQmxlbmRDb2xvciA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZC5wcm90b3R5cGUgKi8ge1xuICAgIHR5cGU6ICdCbGVuZENvbG9yJyxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIHRvIG1ha2UgdGhlIGJsZW5kIG9wZXJhdGlvbiB3aXRoLiBkZWZhdWx0IHRvIGEgcmVkZGlzaCBjb2xvciBzaW5jZSBibGFjayBvciB3aGl0ZVxuICAgICAqIGdpdmVzIGFsd2F5cyBzdHJvbmcgcmVzdWx0LlxuICAgICAqKi9cbiAgICBjb2xvcjogJyNGOTVDNjMnLFxuXG4gICAgLyoqXG4gICAgICogQmxlbmQgbW9kZSBmb3IgdGhlIGZpbHRlcjogb25lIG9mIG11bHRpcGx5LCBhZGQsIGRpZmYsIHNjcmVlbiwgc3VidHJhY3QsXG4gICAgICogZGFya2VuLCBsaWdodGVuLCBvdmVybGF5LCBleGNsdXNpb24sIHRpbnQuXG4gICAgICoqL1xuICAgIG1vZGU6ICdtdWx0aXBseScsXG5cbiAgICAvKipcbiAgICAgKiBhbHBoYSB2YWx1ZS4gcmVwcmVzZW50IHRoZSBzdHJlbmd0aCBvZiB0aGUgYmxlbmQgY29sb3Igb3BlcmF0aW9uLlxuICAgICAqKi9cbiAgICBhbHBoYTogMSxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIE11bHRpcGx5IHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZToge1xuICAgICAgbXVsdGlwbHk6ICdnbF9GcmFnQ29sb3IucmdiICo9IHVDb2xvci5yZ2I7XFxuJyxcbiAgICAgIHNjcmVlbjogJ2dsX0ZyYWdDb2xvci5yZ2IgPSAxLjAgLSAoMS4wIC0gZ2xfRnJhZ0NvbG9yLnJnYikgKiAoMS4wIC0gdUNvbG9yLnJnYik7XFxuJyxcbiAgICAgIGFkZDogJ2dsX0ZyYWdDb2xvci5yZ2IgKz0gdUNvbG9yLnJnYjtcXG4nLFxuICAgICAgZGlmZjogJ2dsX0ZyYWdDb2xvci5yZ2IgPSBhYnMoZ2xfRnJhZ0NvbG9yLnJnYiAtIHVDb2xvci5yZ2IpO1xcbicsXG4gICAgICBzdWJ0cmFjdDogJ2dsX0ZyYWdDb2xvci5yZ2IgLT0gdUNvbG9yLnJnYjtcXG4nLFxuICAgICAgbGlnaHRlbjogJ2dsX0ZyYWdDb2xvci5yZ2IgPSBtYXgoZ2xfRnJhZ0NvbG9yLnJnYiwgdUNvbG9yLnJnYik7XFxuJyxcbiAgICAgIGRhcmtlbjogJ2dsX0ZyYWdDb2xvci5yZ2IgPSBtaW4oZ2xfRnJhZ0NvbG9yLnJnYiwgdUNvbG9yLnJnYik7XFxuJyxcbiAgICAgIGV4Y2x1c2lvbjogJ2dsX0ZyYWdDb2xvci5yZ2IgKz0gdUNvbG9yLnJnYiAtIDIuMCAqICh1Q29sb3IucmdiICogZ2xfRnJhZ0NvbG9yLnJnYik7XFxuJyxcbiAgICAgIG92ZXJsYXk6ICdpZiAodUNvbG9yLnIgPCAwLjUpIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLnIgKj0gMi4wICogdUNvbG9yLnI7XFxuJyArXG4gICAgICAgICd9IGVsc2Uge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuciA9IDEuMCAtIDIuMCAqICgxLjAgLSBnbF9GcmFnQ29sb3IucikgKiAoMS4wIC0gdUNvbG9yLnIpO1xcbicgK1xuICAgICAgICAnfVxcbicgK1xuICAgICAgICAnaWYgKHVDb2xvci5nIDwgMC41KSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5nICo9IDIuMCAqIHVDb2xvci5nO1xcbicgK1xuICAgICAgICAnfSBlbHNlIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmcgPSAxLjAgLSAyLjAgKiAoMS4wIC0gZ2xfRnJhZ0NvbG9yLmcpICogKDEuMCAtIHVDb2xvci5nKTtcXG4nICtcbiAgICAgICAgJ31cXG4nICtcbiAgICAgICAgJ2lmICh1Q29sb3IuYiA8IDAuNSkge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuYiAqPSAyLjAgKiB1Q29sb3IuYjtcXG4nICtcbiAgICAgICAgJ30gZWxzZSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5iID0gMS4wIC0gMi4wICogKDEuMCAtIGdsX0ZyYWdDb2xvci5iKSAqICgxLjAgLSB1Q29sb3IuYik7XFxuJyArXG4gICAgICAgICd9XFxuJyxcbiAgICAgIHRpbnQ6ICdnbF9GcmFnQ29sb3IucmdiICo9ICgxLjAgLSB1Q29sb3IuYSk7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IucmdiICs9IHVDb2xvci5yZ2I7XFxuJyxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYnVpbGQgdGhlIGZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIGZpbHRlcnMsIGpvaW5pbmcgdGhlIGNvbW1vbiBwYXJ0IHdpdGhcbiAgICAgKiB0aGUgc3BlY2lmaWMgb25lLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RlIHRoZSBtb2RlIG9mIHRoZSBmaWx0ZXIsIGEga2V5IG9mIHRoaXMuZnJhZ21lbnRTb3VyY2VcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBzb3VyY2UgdG8gYmUgY29tcGlsZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJ1aWxkU291cmNlOiBmdW5jdGlvbihtb2RlKSB7XG4gICAgICByZXR1cm4gJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSB2ZWM0IHVDb2xvcjtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAgICdpZiAoY29sb3IuYSA+IDAuMCkge1xcbicgK1xuICAgICAgICAgICAgdGhpcy5mcmFnbWVudFNvdXJjZVttb2RlXSArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgJ30nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNhY2hlZCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNhY2hlS2V5ID0gdGhpcy50eXBlICsgJ18nICsgdGhpcy5tb2RlLCBzaGFkZXJTb3VyY2U7XG4gICAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgICAgICBzaGFkZXJTb3VyY2UgPSB0aGlzLmJ1aWxkU291cmNlKHRoaXMubW9kZSk7XG4gICAgICAgIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XSA9IHRoaXMuY3JlYXRlUHJvZ3JhbShvcHRpb25zLmNvbnRleHQsIHNoYWRlclNvdXJjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgQmxlbmQgb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpTGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgdHIsIHRnLCB0YixcbiAgICAgICAgICByLCBnLCBiLFxuICAgICAgICAgIHNvdXJjZSwgYWxwaGExID0gMSAtIHRoaXMuYWxwaGE7XG5cbiAgICAgIHNvdXJjZSA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcikuZ2V0U291cmNlKCk7XG4gICAgICB0ciA9IHNvdXJjZVswXSAqIHRoaXMuYWxwaGE7XG4gICAgICB0ZyA9IHNvdXJjZVsxXSAqIHRoaXMuYWxwaGE7XG4gICAgICB0YiA9IHNvdXJjZVsyXSAqIHRoaXMuYWxwaGE7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaUxlbjsgaSArPSA0KSB7XG5cbiAgICAgICAgciA9IGRhdGFbaV07XG4gICAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgYiA9IGRhdGFbaSArIDJdO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICAgICAgY2FzZSAnbXVsdGlwbHknOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHIgKiB0ciAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZyAqIHRnIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiICogdGIgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzY3JlZW4nOlxuICAgICAgICAgICAgZGF0YVtpXSA9IDI1NSAtICgyNTUgLSByKSAqICgyNTUgLSB0cikgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IDI1NSAtICgyNTUgLSBnKSAqICgyNTUgLSB0ZykgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IDI1NSAtICgyNTUgLSBiKSAqICgyNTUgLSB0YikgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHIgKyB0cjtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZyArIHRnO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiICsgdGI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkaWZmJzpcbiAgICAgICAgICBjYXNlICdkaWZmZXJlbmNlJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSBNYXRoLmFicyhyIC0gdHIpO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBNYXRoLmFicyhnIC0gdGcpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBNYXRoLmFicyhiIC0gdGIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc3VidHJhY3QnOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHIgLSB0cjtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZyAtIHRnO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiIC0gdGI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkYXJrZW4nOlxuICAgICAgICAgICAgZGF0YVtpXSA9IE1hdGgubWluKHIsIHRyKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gTWF0aC5taW4oZywgdGcpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBNYXRoLm1pbihiLCB0Yik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdsaWdodGVuJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSBNYXRoLm1heChyLCB0cik7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IE1hdGgubWF4KGcsIHRnKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gTWF0aC5tYXgoYiwgdGIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnb3ZlcmxheSc6XG4gICAgICAgICAgICBkYXRhW2ldID0gdHIgPCAxMjggPyAoMiAqIHIgKiB0ciAvIDI1NSkgOiAoMjU1IC0gMiAqICgyNTUgLSByKSAqICgyNTUgLSB0cikgLyAyNTUpO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSB0ZyA8IDEyOCA/ICgyICogZyAqIHRnIC8gMjU1KSA6ICgyNTUgLSAyICogKDI1NSAtIGcpICogKDI1NSAtIHRnKSAvIDI1NSk7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IHRiIDwgMTI4ID8gKDIgKiBiICogdGIgLyAyNTUpIDogKDI1NSAtIDIgKiAoMjU1IC0gYikgKiAoMjU1IC0gdGIpIC8gMjU1KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2V4Y2x1c2lvbic6XG4gICAgICAgICAgICBkYXRhW2ldID0gdHIgKyByIC0gKCgyICogdHIgKiByKSAvIDI1NSk7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IHRnICsgZyAtICgoMiAqIHRnICogZykgLyAyNTUpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSB0YiArIGIgLSAoKDIgKiB0YiAqIGIpIC8gMjU1KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RpbnQnOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHRyICsgciAqIGFscGhhMTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gdGcgKyBnICogYWxwaGExO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSB0YiArIGIgKiBhbHBoYTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVDb2xvcjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Q29sb3InKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpLmdldFNvdXJjZSgpO1xuICAgICAgc291cmNlWzBdID0gdGhpcy5hbHBoYSAqIHNvdXJjZVswXSAvIDI1NTtcbiAgICAgIHNvdXJjZVsxXSA9IHRoaXMuYWxwaGEgKiBzb3VyY2VbMV0gLyAyNTU7XG4gICAgICBzb3VyY2VbMl0gPSB0aGlzLmFscGhhICogc291cmNlWzJdIC8gMjU1O1xuICAgICAgc291cmNlWzNdID0gdGhpcy5hbHBoYTtcbiAgICAgIGdsLnVuaWZvcm00ZnYodW5pZm9ybUxvY2F0aW9ucy51Q29sb3IsIHNvdXJjZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgIGFscGhhOiB0aGlzLmFscGhhXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEltYWdlIEJsZW5kIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlci5CbGVuZEltYWdlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRDb2xvcih7XG4gICAqICBjb2xvcjogJyMwMDAnLFxuICAgKiAgbW9kZTogJ211bHRpcGx5J1xuICAgKiB9KTtcbiAgICpcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlKHtcbiAgICogIGltYWdlOiBmYWJyaWNJbWFnZU9iamVjdCxcbiAgICogIG1vZGU6ICdtdWx0aXBseScsXG4gICAqICBhbHBoYTogMC41XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cblxuICBmaWx0ZXJzLkJsZW5kSW1hZ2UgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZS5wcm90b3R5cGUgKi8ge1xuICAgIHR5cGU6ICdCbGVuZEltYWdlJyxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIHRvIG1ha2UgdGhlIGJsZW5kIG9wZXJhdGlvbiB3aXRoLiBkZWZhdWx0IHRvIGEgcmVkZGlzaCBjb2xvciBzaW5jZSBibGFjayBvciB3aGl0ZVxuICAgICAqIGdpdmVzIGFsd2F5cyBzdHJvbmcgcmVzdWx0LlxuICAgICAqKi9cbiAgICBpbWFnZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEJsZW5kIG1vZGUgZm9yIHRoZSBmaWx0ZXI6IG9uZSBvZiBtdWx0aXBseSwgYWRkLCBkaWZmLCBzY3JlZW4sIHN1YnRyYWN0LFxuICAgICAqIGRhcmtlbiwgbGlnaHRlbiwgb3ZlcmxheSwgZXhjbHVzaW9uLCB0aW50LlxuICAgICAqKi9cbiAgICBtb2RlOiAnbXVsdGlwbHknLFxuXG4gICAgLyoqXG4gICAgICogYWxwaGEgdmFsdWUuIHJlcHJlc2VudCB0aGUgc3RyZW5ndGggb2YgdGhlIGJsZW5kIGNvbG9yIG9wZXJhdGlvbi5cbiAgICAgKiovXG4gICAgYWxwaGE6IDEsXG5cbiAgICB2ZXJ0ZXhTb3VyY2U6ICdhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkMjtcXG4nICtcbiAgICAgICd1bmlmb3JtIG1hdDMgdVRyYW5zZm9ybU1hdHJpeDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2VGV4Q29vcmQgPSBhUG9zaXRpb247XFxuJyArXG4gICAgICAgICd2VGV4Q29vcmQyID0gKHVUcmFuc2Zvcm1NYXRyaXggKiB2ZWMzKGFQb3NpdGlvbiwgMS4wKSkueHk7XFxuJyArXG4gICAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQoYVBvc2l0aW9uICogMi4wIC0gMS4wLCAwLjAsIDEuMCk7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBNdWx0aXBseSBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6IHtcbiAgICAgIG11bHRpcGx5OiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1SW1hZ2U7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHZlYzQgdUNvbG9yO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQyO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yMiA9IHRleHR1cmUyRCh1SW1hZ2UsIHZUZXhDb29yZDIpO1xcbicgK1xuICAgICAgICAgICdjb2xvci5yZ2JhICo9IGNvbG9yMi5yZ2JhO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgbWFzazogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdUltYWdlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSB2ZWM0IHVDb2xvcjtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkMjtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvcjIgPSB0ZXh0dXJlMkQodUltYWdlLCB2VGV4Q29vcmQyKTtcXG4nICtcbiAgICAgICAgICAnY29sb3IuYSA9IGNvbG9yMi5hO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNhY2hlZCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNhY2hlS2V5ID0gdGhpcy50eXBlICsgJ18nICsgdGhpcy5tb2RlO1xuICAgICAgdmFyIHNoYWRlclNvdXJjZSA9IHRoaXMuZnJhZ21lbnRTb3VyY2VbdGhpcy5tb2RlXTtcbiAgICAgIGlmICghb3B0aW9ucy5wcm9ncmFtQ2FjaGUuaGFzT3duUHJvcGVydHkoY2FjaGVLZXkpKSB7XG4gICAgICAgIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XSA9IHRoaXMuY3JlYXRlUHJvZ3JhbShvcHRpb25zLmNvbnRleHQsIHNoYWRlclNvdXJjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldO1xuICAgIH0sXG5cbiAgICBhcHBseVRvV2ViR0w6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIC8vIGxvYWQgdGV4dHVyZSB0byBibGVuZC5cbiAgICAgIHZhciBnbCA9IG9wdGlvbnMuY29udGV4dCxcbiAgICAgICAgICB0ZXh0dXJlID0gdGhpcy5jcmVhdGVUZXh0dXJlKG9wdGlvbnMuZmlsdGVyQmFja2VuZCwgdGhpcy5pbWFnZSk7XG4gICAgICB0aGlzLmJpbmRBZGRpdGlvbmFsVGV4dHVyZShnbCwgdGV4dHVyZSwgZ2wuVEVYVFVSRTEpO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2FwcGx5VG9XZWJHTCcsIG9wdGlvbnMpO1xuICAgICAgdGhpcy51bmJpbmRBZGRpdGlvbmFsVGV4dHVyZShnbCwgZ2wuVEVYVFVSRTEpO1xuICAgIH0sXG5cbiAgICBjcmVhdGVUZXh0dXJlOiBmdW5jdGlvbihiYWNrZW5kLCBpbWFnZSkge1xuICAgICAgcmV0dXJuIGJhY2tlbmQuZ2V0Q2FjaGVkVGV4dHVyZShpbWFnZS5jYWNoZUtleSwgaW1hZ2UuX2VsZW1lbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgYSB0cmFuc2Zvcm1NYXRyaXggdG8gYWRhcHQgdGhlIGltYWdlIHRvIGJsZW5kIG92ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICAqL1xuICAgIGNhbGN1bGF0ZU1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlLFxuICAgICAgICAgIHdpZHRoID0gaW1hZ2UuX2VsZW1lbnQud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gaW1hZ2UuX2VsZW1lbnQuaGVpZ2h0O1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgMSAvIGltYWdlLnNjYWxlWCwgMCwgMCxcbiAgICAgICAgMCwgMSAvIGltYWdlLnNjYWxlWSwgMCxcbiAgICAgICAgLWltYWdlLmxlZnQgLyB3aWR0aCwgLWltYWdlLnRvcCAvIGhlaWdodCwgMVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEJsZW5kIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIHJlc291cmNlcyA9IG9wdGlvbnMuZmlsdGVyQmFja2VuZC5yZXNvdXJjZXMsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpTGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgd2lkdGggPSBvcHRpb25zLmltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBvcHRpb25zLmltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgdHIsIHRnLCB0YiwgdGEsXG4gICAgICAgICAgciwgZywgYiwgYSxcbiAgICAgICAgICBjYW52YXMxLCBjb250ZXh0LCBpbWFnZSA9IHRoaXMuaW1hZ2UsIGJsZW5kRGF0YTtcblxuICAgICAgaWYgKCFyZXNvdXJjZXMuYmxlbmRJbWFnZSkge1xuICAgICAgICByZXNvdXJjZXMuYmxlbmRJbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgfVxuICAgICAgY2FudmFzMSA9IHJlc291cmNlcy5ibGVuZEltYWdlO1xuICAgICAgaWYgKGNhbnZhczEud2lkdGggIT09IHdpZHRoIHx8IGNhbnZhczEuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgY2FudmFzMS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMxLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQgPSBjYW52YXMxLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjb250ZXh0LnNldFRyYW5zZm9ybShpbWFnZS5zY2FsZVgsIDAsIDAsIGltYWdlLnNjYWxlWSwgaW1hZ2UubGVmdCwgaW1hZ2UudG9wKTtcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLl9lbGVtZW50LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGJsZW5kRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlMZW47IGkgKz0gNCkge1xuXG4gICAgICAgIHIgPSBkYXRhW2ldO1xuICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcbiAgICAgICAgYSA9IGRhdGFbaSArIDNdO1xuXG4gICAgICAgIHRyID0gYmxlbmREYXRhW2ldO1xuICAgICAgICB0ZyA9IGJsZW5kRGF0YVtpICsgMV07XG4gICAgICAgIHRiID0gYmxlbmREYXRhW2kgKyAyXTtcbiAgICAgICAgdGEgPSBibGVuZERhdGFbaSArIDNdO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICAgICAgY2FzZSAnbXVsdGlwbHknOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHIgKiB0ciAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZyAqIHRnIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiICogdGIgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAzXSA9IGEgKiB0YSAvIDI1NTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21hc2snOlxuICAgICAgICAgICAgZGF0YVtpICsgM10gPSB0YTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1VHJhbnNmb3JtTWF0cml4OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VUcmFuc2Zvcm1NYXRyaXgnKSxcbiAgICAgICAgdUltYWdlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VJbWFnZScpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuY2FsY3VsYXRlTWF0cml4KCk7XG4gICAgICBnbC51bmlmb3JtMWkodW5pZm9ybUxvY2F0aW9ucy51SW1hZ2UsIDEpOyAvLyB0ZXh0dXJlIHVuaXQgMS5cbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodW5pZm9ybUxvY2F0aW9ucy51VHJhbnNmb3JtTWF0cml4LCBmYWxzZSwgbWF0cml4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgaW1hZ2U6IHRoaXMuaW1hZ2UgJiYgdGhpcy5pbWFnZS50b09iamVjdCgpLFxuICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgIGFscGhhOiB0aGlzLmFscGhhXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGZhYnJpYy5JbWFnZS5mcm9tT2JqZWN0KG9iamVjdC5pbWFnZSwgZnVuY3Rpb24oaW1hZ2UpIHtcbiAgICAgIHZhciBvcHRpb25zID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9iamVjdCk7XG4gICAgICBvcHRpb25zLmltYWdlID0gaW1hZ2U7XG4gICAgICBjYWxsYmFjayhuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZShvcHRpb25zKSk7XG4gICAgfSk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksIHBvdyA9IE1hdGgucG93LCBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICBzcXJ0ID0gTWF0aC5zcXJ0LCBhYnMgPSBNYXRoLmFicywgcm91bmQgPSBNYXRoLnJvdW5kLCBzaW4gPSBNYXRoLnNpbixcbiAgICAgIGNlaWwgPSBNYXRoLmNlaWwsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBSZXNpemUgaW1hZ2UgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemVcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZSgpO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgKi9cbiAgZmlsdGVycy5SZXNpemUgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnUmVzaXplJyxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlc2l6ZVR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJlc2l6ZVR5cGU6ICdoZXJtaXRlJyxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIGZhY3RvciBmb3IgcmVzaXppbmcsIHggYXhpc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVhcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNjYWxlWDogMCxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIGZhY3RvciBmb3IgcmVzaXppbmcsIHkgYXhpc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNjYWxlWTogMCxcblxuICAgIC8qKlxuICAgICAqIExhbmN6b3NMb2JlcyBwYXJhbWV0ZXIgZm9yIGxhbmN6b3MgZmlsdGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxhbmN6b3NMb2Jlc1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbGFuY3pvc0xvYmVzOiAzLFxuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdURlbHRhOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VEZWx0YScpLFxuICAgICAgICB1VGFwczogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1VGFwcycpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTJmdih1bmlmb3JtTG9jYXRpb25zLnVEZWx0YSwgdGhpcy5ob3Jpem9udGFsID8gWzEgLyB0aGlzLndpZHRoLCAwXSA6IFswLCAxIC8gdGhpcy5oZWlnaHRdKTtcbiAgICAgIGdsLnVuaWZvcm0xZnYodW5pZm9ybUxvY2F0aW9ucy51VGFwcywgdGhpcy50YXBzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjYWNoZWQgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgICovXG4gICAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBmaWx0ZXJXaW5kb3cgPSB0aGlzLmdldEZpbHRlcldpbmRvdygpLCBjYWNoZUtleSA9IHRoaXMudHlwZSArICdfJyArIGZpbHRlcldpbmRvdztcbiAgICAgIGlmICghb3B0aW9ucy5wcm9ncmFtQ2FjaGUuaGFzT3duUHJvcGVydHkoY2FjaGVLZXkpKSB7XG4gICAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHRoaXMuZ2VuZXJhdGVTaGFkZXIoZmlsdGVyV2luZG93KTtcbiAgICAgICAgb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldID0gdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMuY29udGV4dCwgZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XTtcbiAgICB9LFxuXG4gICAgZ2V0RmlsdGVyV2luZG93OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzY2FsZSA9IHRoaXMudGVtcFNjYWxlO1xuICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmxhbmN6b3NMb2JlcyAvIHNjYWxlKTtcbiAgICB9LFxuXG4gICAgZ2V0VGFwczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbG9iZUZ1bmN0aW9uID0gdGhpcy5sYW5jem9zQ3JlYXRlKHRoaXMubGFuY3pvc0xvYmVzKSwgc2NhbGUgPSB0aGlzLnRlbXBTY2FsZSxcbiAgICAgICAgICBmaWx0ZXJXaW5kb3cgPSB0aGlzLmdldEZpbHRlcldpbmRvdygpLCB0YXBzID0gbmV3IEFycmF5KGZpbHRlcldpbmRvdyk7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBmaWx0ZXJXaW5kb3c7IGkrKykge1xuICAgICAgICB0YXBzW2kgLSAxXSA9IGxvYmVGdW5jdGlvbihpICogc2NhbGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHZlcnRleCBhbmQgc2hhZGVyIHNvdXJjZXMgZnJvbSB0aGUgbmVjZXNzYXJ5IHN0ZXBzIG51bWJlcnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZmlsdGVyV2luZG93XG4gICAgICovXG4gICAgZ2VuZXJhdGVTaGFkZXI6IGZ1bmN0aW9uKGZpbHRlcldpbmRvdykge1xuICAgICAgdmFyIG9mZnNldHMgPSBuZXcgQXJyYXkoZmlsdGVyV2luZG93KSxcbiAgICAgICAgICBmcmFnbWVudFNoYWRlciA9IHRoaXMuZnJhZ21lbnRTb3VyY2VUT1AsIGZpbHRlcldpbmRvdztcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gZmlsdGVyV2luZG93OyBpKyspIHtcbiAgICAgICAgb2Zmc2V0c1tpIC0gMV0gPSBpICsgJy4wICogdURlbHRhJztcbiAgICAgIH1cblxuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJ3VuaWZvcm0gZmxvYXQgdVRhcHNbJyArIGZpbHRlcldpbmRvdyArICddO1xcbic7XG4gICAgICBmcmFnbWVudFNoYWRlciArPSAndm9pZCBtYWluKCkge1xcbic7XG4gICAgICBmcmFnbWVudFNoYWRlciArPSAnICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbic7XG4gICAgICBmcmFnbWVudFNoYWRlciArPSAnICBmbG9hdCBzdW0gPSAxLjA7XFxuJztcblxuICAgICAgb2Zmc2V0cy5mb3JFYWNoKGZ1bmN0aW9uKG9mZnNldCwgaSkge1xuICAgICAgICBmcmFnbWVudFNoYWRlciArPSAnICBjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArICcgKyBvZmZzZXQgKyAnKSAqIHVUYXBzWycgKyBpICsgJ107XFxuJztcbiAgICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJyAgY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgLSAnICsgb2Zmc2V0ICsgJykgKiB1VGFwc1snICsgaSArICddO1xcbic7XG4gICAgICAgIGZyYWdtZW50U2hhZGVyICs9ICcgIHN1bSArPSAyLjAgKiB1VGFwc1snICsgaSArICddO1xcbic7XG4gICAgICB9KTtcbiAgICAgIGZyYWdtZW50U2hhZGVyICs9ICcgIGdsX0ZyYWdDb2xvciA9IGNvbG9yIC8gc3VtO1xcbic7XG4gICAgICBmcmFnbWVudFNoYWRlciArPSAnfSc7XG4gICAgICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG4gICAgfSxcblxuICAgIGZyYWdtZW50U291cmNlVE9QOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjMiB1RGVsdGE7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nLFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIHJlc2l6ZSBmaWx0ZXIgdG8gdGhlIGltYWdlXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIHVzZSBXZWJHTCBvciBDYW52YXMyRCBiYXNlZCBvbiB0aGUgb3B0aW9ucy53ZWJnbCBmbGFnLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wYXNzZXMgVGhlIG51bWJlciBvZiBmaWx0ZXJzIHJlbWFpbmluZyB0byBiZSBleGVjdXRlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy53ZWJnbCBXaGV0aGVyIHRvIHVzZSB3ZWJnbCB0byByZW5kZXIgdGhlIGZpbHRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy5zb3VyY2VUZXh0dXJlIFRoZSB0ZXh0dXJlIHNldHVwIGFzIHRoZSBzb3VyY2UgdG8gYmUgZmlsdGVyZWQuXG4gICAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMudGFyZ2V0VGV4dHVyZSBUaGUgdGV4dHVyZSB3aGVyZSBmaWx0ZXJlZCBvdXRwdXQgc2hvdWxkIGJlIGRyYXduLlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICAqL1xuICAgIGFwcGx5VG86IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLndlYmdsKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnBhc3NlcyA+IDEgJiYgdGhpcy5pc05ldXRyYWxTdGF0ZShvcHRpb25zKSkge1xuICAgICAgICAgIC8vIGF2b2lkIGRvaW5nIHNvbWV0aGluZyB0aGF0IHdlIGRvIG5vdCBuZWVkXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMucGFzc2VzKys7XG4gICAgICAgIHRoaXMud2lkdGggPSBvcHRpb25zLnNvdXJjZVdpZHRoO1xuICAgICAgICB0aGlzLmhvcml6b250YWwgPSB0cnVlO1xuICAgICAgICB0aGlzLmRXID0gTWF0aC5yb3VuZCh0aGlzLndpZHRoICogdGhpcy5zY2FsZVgpO1xuICAgICAgICB0aGlzLmRIID0gb3B0aW9ucy5zb3VyY2VIZWlnaHQ7XG4gICAgICAgIHRoaXMudGVtcFNjYWxlID0gdGhpcy5kVyAvIHRoaXMud2lkdGg7XG4gICAgICAgIHRoaXMudGFwcyA9IHRoaXMuZ2V0VGFwcygpO1xuICAgICAgICBvcHRpb25zLmRlc3RpbmF0aW9uV2lkdGggPSB0aGlzLmRXO1xuICAgICAgICB0aGlzLl9zZXR1cEZyYW1lQnVmZmVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmFwcGx5VG9XZWJHTChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc3dhcFRleHR1cmVzKG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zLnNvdXJjZVdpZHRoID0gb3B0aW9ucy5kZXN0aW5hdGlvbldpZHRoO1xuXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5zb3VyY2VIZWlnaHQ7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRIID0gTWF0aC5yb3VuZCh0aGlzLmhlaWdodCAqIHRoaXMuc2NhbGVZKTtcbiAgICAgICAgdGhpcy50ZW1wU2NhbGUgPSB0aGlzLmRIIC8gdGhpcy5oZWlnaHQ7XG4gICAgICAgIHRoaXMudGFwcyA9IHRoaXMuZ2V0VGFwcygpO1xuICAgICAgICBvcHRpb25zLmRlc3RpbmF0aW9uSGVpZ2h0ID0gdGhpcy5kSDtcbiAgICAgICAgdGhpcy5fc2V0dXBGcmFtZUJ1ZmZlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5hcHBseVRvV2ViR0wob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3N3YXBUZXh0dXJlcyhvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5zb3VyY2VIZWlnaHQgPSBvcHRpb25zLmRlc3RpbmF0aW9uSGVpZ2h0O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIXRoaXMuaXNOZXV0cmFsU3RhdGUob3B0aW9ucykpIHtcbiAgICAgICAgdGhpcy5hcHBseVRvMmQob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgc2NhbGVYID0gb3B0aW9ucy5zY2FsZVggfHwgdGhpcy5zY2FsZVgsXG4gICAgICAgICAgc2NhbGVZID0gb3B0aW9ucy5zY2FsZVkgfHwgdGhpcy5zY2FsZVk7XG4gICAgICByZXR1cm4gc2NhbGVYID09PSAxICYmIHNjYWxlWSA9PT0gMTtcbiAgICB9LFxuXG4gICAgbGFuY3pvc0NyZWF0ZTogZnVuY3Rpb24obG9iZXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgIGlmICh4ID49IGxvYmVzIHx8IHggPD0gLWxvYmVzKSB7XG4gICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA8IDEuMTkyMDkyOTBFLTA3ICYmIHggPiAtMS4xOTIwOTI5MEUtMDcpIHtcbiAgICAgICAgICByZXR1cm4gMS4wO1xuICAgICAgICB9XG4gICAgICAgIHggKj0gTWF0aC5QSTtcbiAgICAgICAgdmFyIHh4ID0geCAvIGxvYmVzO1xuICAgICAgICByZXR1cm4gKHNpbih4KSAvIHgpICogc2luKHh4KSAvIHh4O1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXIgdG8gY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVYXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWVxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIHNjYWxlWCA9IHRoaXMuc2NhbGVYLFxuICAgICAgICAgIHNjYWxlWSA9IHRoaXMuc2NhbGVZO1xuXG4gICAgICB0aGlzLnJjcFNjYWxlWCA9IDEgLyBzY2FsZVg7XG4gICAgICB0aGlzLnJjcFNjYWxlWSA9IDEgLyBzY2FsZVk7XG5cbiAgICAgIHZhciBvVyA9IGltYWdlRGF0YS53aWR0aCwgb0ggPSBpbWFnZURhdGEuaGVpZ2h0LFxuICAgICAgICAgIGRXID0gcm91bmQob1cgKiBzY2FsZVgpLCBkSCA9IHJvdW5kKG9IICogc2NhbGVZKSxcbiAgICAgICAgICBuZXdEYXRhO1xuXG4gICAgICBpZiAodGhpcy5yZXNpemVUeXBlID09PSAnc2xpY2VIYWNrJykge1xuICAgICAgICBuZXdEYXRhID0gdGhpcy5zbGljZUJ5VHdvKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMucmVzaXplVHlwZSA9PT0gJ2hlcm1pdGUnKSB7XG4gICAgICAgIG5ld0RhdGEgPSB0aGlzLmhlcm1pdGVGYXN0UmVzaXplKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMucmVzaXplVHlwZSA9PT0gJ2JpbGluZWFyJykge1xuICAgICAgICBuZXdEYXRhID0gdGhpcy5iaWxpbmVhckZpbHRlcmluZyhvcHRpb25zLCBvVywgb0gsIGRXLCBkSCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnJlc2l6ZVR5cGUgPT09ICdsYW5jem9zJykge1xuICAgICAgICBuZXdEYXRhID0gdGhpcy5sYW5jem9zUmVzaXplKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuaW1hZ2VEYXRhID0gbmV3RGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHNsaWNlQnlUd29cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9XIE9yaWdpbmFsIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9IIE9yaWdpbmFsIEhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkVyBEZXN0aW5hdGlvbiBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkSCBEZXN0aW5hdGlvbiBIZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2VEYXRhfVxuICAgICAqL1xuICAgIHNsaWNlQnlUd286IGZ1bmN0aW9uKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgbXVsdCA9IDAuNSwgZG9uZVcgPSBmYWxzZSwgZG9uZUggPSBmYWxzZSwgc3RlcFcgPSBvVyAqIG11bHQsXG4gICAgICAgICAgc3RlcEggPSBvSCAqIG11bHQsIHJlc291cmNlcyA9IGZhYnJpYy5maWx0ZXJCYWNrZW5kLnJlc291cmNlcyxcbiAgICAgICAgICB0bXBDYW52YXMsIGN0eCwgc1ggPSAwLCBzWSA9IDAsIGRYID0gb1csIGRZID0gMDtcbiAgICAgIGlmICghcmVzb3VyY2VzLnNsaWNlQnlUd28pIHtcbiAgICAgICAgcmVzb3VyY2VzLnNsaWNlQnlUd28gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIH1cbiAgICAgIHRtcENhbnZhcyA9IHJlc291cmNlcy5zbGljZUJ5VHdvO1xuICAgICAgaWYgKHRtcENhbnZhcy53aWR0aCA8IG9XICogMS41IHx8IHRtcENhbnZhcy5oZWlnaHQgPCBvSCkge1xuICAgICAgICB0bXBDYW52YXMud2lkdGggPSBvVyAqIDEuNTtcbiAgICAgICAgdG1wQ2FudmFzLmhlaWdodCA9IG9IO1xuICAgICAgfVxuICAgICAgY3R4ID0gdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIG9XICogMS41LCBvSCk7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG5cbiAgICAgIGRXID0gZmxvb3IoZFcpO1xuICAgICAgZEggPSBmbG9vcihkSCk7XG5cbiAgICAgIHdoaWxlICghZG9uZVcgfHwgIWRvbmVIKSB7XG4gICAgICAgIG9XID0gc3RlcFc7XG4gICAgICAgIG9IID0gc3RlcEg7XG4gICAgICAgIGlmIChkVyA8IGZsb29yKHN0ZXBXICogbXVsdCkpIHtcbiAgICAgICAgICBzdGVwVyA9IGZsb29yKHN0ZXBXICogbXVsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3RlcFcgPSBkVztcbiAgICAgICAgICBkb25lVyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRIIDwgZmxvb3Ioc3RlcEggKiBtdWx0KSkge1xuICAgICAgICAgIHN0ZXBIID0gZmxvb3Ioc3RlcEggKiBtdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzdGVwSCA9IGRIO1xuICAgICAgICAgIGRvbmVIID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZHJhd0ltYWdlKHRtcENhbnZhcywgc1gsIHNZLCBvVywgb0gsIGRYLCBkWSwgc3RlcFcsIHN0ZXBIKTtcbiAgICAgICAgc1ggPSBkWDtcbiAgICAgICAgc1kgPSBkWTtcbiAgICAgICAgZFkgKz0gc3RlcEg7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3R4LmdldEltYWdlRGF0YShzWCwgc1ksIGRXLCBkSCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciBsYW5jem9zUmVzaXplXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvVyBPcmlnaW5hbCBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvSCBPcmlnaW5hbCBIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZFcgRGVzdGluYXRpb24gV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZEggRGVzdGluYXRpb24gSGVpZ2h0XG4gICAgICogQHJldHVybnMge0ltYWdlRGF0YX1cbiAgICAgKi9cbiAgICBsYW5jem9zUmVzaXplOiBmdW5jdGlvbihvcHRpb25zLCBvVywgb0gsIGRXLCBkSCkge1xuXG4gICAgICBmdW5jdGlvbiBwcm9jZXNzKHUpIHtcbiAgICAgICAgdmFyIHYsIGksIHdlaWdodCwgaWR4LCBhLCByZWQsIGdyZWVuLFxuICAgICAgICAgICAgYmx1ZSwgYWxwaGEsIGZYLCBmWTtcbiAgICAgICAgY2VudGVyLnggPSAodSArIDAuNSkgKiByYXRpb1g7XG4gICAgICAgIGljZW50ZXIueCA9IGZsb29yKGNlbnRlci54KTtcbiAgICAgICAgZm9yICh2ID0gMDsgdiA8IGRIOyB2KyspIHtcbiAgICAgICAgICBjZW50ZXIueSA9ICh2ICsgMC41KSAqIHJhdGlvWTtcbiAgICAgICAgICBpY2VudGVyLnkgPSBmbG9vcihjZW50ZXIueSk7XG4gICAgICAgICAgYSA9IDA7IHJlZCA9IDA7IGdyZWVuID0gMDsgYmx1ZSA9IDA7IGFscGhhID0gMDtcbiAgICAgICAgICBmb3IgKGkgPSBpY2VudGVyLnggLSByYW5nZTJYOyBpIDw9IGljZW50ZXIueCArIHJhbmdlMlg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGkgPj0gb1cpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmWCA9IGZsb29yKDEwMDAgKiBhYnMoaSAtIGNlbnRlci54KSk7XG4gICAgICAgICAgICBpZiAoIWNhY2hlTGFuY1tmWF0pIHtcbiAgICAgICAgICAgICAgY2FjaGVMYW5jW2ZYXSA9IHsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpY2VudGVyLnkgLSByYW5nZTJZOyBqIDw9IGljZW50ZXIueSArIHJhbmdlMlk7IGorKykge1xuICAgICAgICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBvSCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZZID0gZmxvb3IoMTAwMCAqIGFicyhqIC0gY2VudGVyLnkpKTtcbiAgICAgICAgICAgICAgaWYgKCFjYWNoZUxhbmNbZlhdW2ZZXSkge1xuICAgICAgICAgICAgICAgIGNhY2hlTGFuY1tmWF1bZlldID0gbGFuY3pvcyhzcXJ0KHBvdyhmWCAqIHJjcFJhdGlvWCwgMikgKyBwb3coZlkgKiByY3BSYXRpb1ksIDIpKSAvIDEwMDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdlaWdodCA9IGNhY2hlTGFuY1tmWF1bZlldO1xuICAgICAgICAgICAgICBpZiAod2VpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgIGlkeCA9IChqICogb1cgKyBpKSAqIDQ7XG4gICAgICAgICAgICAgICAgYSArPSB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgcmVkICs9IHdlaWdodCAqIHNyY0RhdGFbaWR4XTtcbiAgICAgICAgICAgICAgICBncmVlbiArPSB3ZWlnaHQgKiBzcmNEYXRhW2lkeCArIDFdO1xuICAgICAgICAgICAgICAgIGJsdWUgKz0gd2VpZ2h0ICogc3JjRGF0YVtpZHggKyAyXTtcbiAgICAgICAgICAgICAgICBhbHBoYSArPSB3ZWlnaHQgKiBzcmNEYXRhW2lkeCArIDNdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlkeCA9ICh2ICogZFcgKyB1KSAqIDQ7XG4gICAgICAgICAgZGVzdERhdGFbaWR4XSA9IHJlZCAvIGE7XG4gICAgICAgICAgZGVzdERhdGFbaWR4ICsgMV0gPSBncmVlbiAvIGE7XG4gICAgICAgICAgZGVzdERhdGFbaWR4ICsgMl0gPSBibHVlIC8gYTtcbiAgICAgICAgICBkZXN0RGF0YVtpZHggKyAzXSA9IGFscGhhIC8gYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgrK3UgPCBkVykge1xuICAgICAgICAgIHJldHVybiBwcm9jZXNzKHUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZXN0SW1nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzcmNEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBkZXN0SW1nID0gb3B0aW9ucy5jdHguY3JlYXRlSW1hZ2VEYXRhKGRXLCBkSCksXG4gICAgICAgICAgZGVzdERhdGEgPSBkZXN0SW1nLmRhdGEsXG4gICAgICAgICAgbGFuY3pvcyA9IHRoaXMubGFuY3pvc0NyZWF0ZSh0aGlzLmxhbmN6b3NMb2JlcyksXG4gICAgICAgICAgcmF0aW9YID0gdGhpcy5yY3BTY2FsZVgsIHJhdGlvWSA9IHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHJjcFJhdGlvWCA9IDIgLyB0aGlzLnJjcFNjYWxlWCwgcmNwUmF0aW9ZID0gMiAvIHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHJhbmdlMlggPSBjZWlsKHJhdGlvWCAqIHRoaXMubGFuY3pvc0xvYmVzIC8gMiksXG4gICAgICAgICAgcmFuZ2UyWSA9IGNlaWwocmF0aW9ZICogdGhpcy5sYW5jem9zTG9iZXMgLyAyKSxcbiAgICAgICAgICBjYWNoZUxhbmMgPSB7IH0sIGNlbnRlciA9IHsgfSwgaWNlbnRlciA9IHsgfTtcblxuICAgICAgcmV0dXJuIHByb2Nlc3MoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGJpbGluZWFyRmlsdGVyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvVyBPcmlnaW5hbCBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvSCBPcmlnaW5hbCBIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZFcgRGVzdGluYXRpb24gV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZEggRGVzdGluYXRpb24gSGVpZ2h0XG4gICAgICogQHJldHVybnMge0ltYWdlRGF0YX1cbiAgICAgKi9cbiAgICBiaWxpbmVhckZpbHRlcmluZzogZnVuY3Rpb24ob3B0aW9ucywgb1csIG9ILCBkVywgZEgpIHtcbiAgICAgIHZhciBhLCBiLCBjLCBkLCB4LCB5LCBpLCBqLCB4RGlmZiwgeURpZmYsIGNobmwsXG4gICAgICAgICAgY29sb3IsIG9mZnNldCA9IDAsIG9yaWdQaXgsIHJhdGlvWCA9IHRoaXMucmNwU2NhbGVYLFxuICAgICAgICAgIHJhdGlvWSA9IHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHc0ID0gNCAqIChvVyAtIDEpLCBpbWcgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBwaXhlbHMgPSBpbWcuZGF0YSwgZGVzdEltYWdlID0gb3B0aW9ucy5jdHguY3JlYXRlSW1hZ2VEYXRhKGRXLCBkSCksXG4gICAgICAgICAgZGVzdFBpeGVscyA9IGRlc3RJbWFnZS5kYXRhO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGRIOyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGRXOyBqKyspIHtcbiAgICAgICAgICB4ID0gZmxvb3IocmF0aW9YICogaik7XG4gICAgICAgICAgeSA9IGZsb29yKHJhdGlvWSAqIGkpO1xuICAgICAgICAgIHhEaWZmID0gcmF0aW9YICogaiAtIHg7XG4gICAgICAgICAgeURpZmYgPSByYXRpb1kgKiBpIC0geTtcbiAgICAgICAgICBvcmlnUGl4ID0gNCAqICh5ICogb1cgKyB4KTtcblxuICAgICAgICAgIGZvciAoY2hubCA9IDA7IGNobmwgPCA0OyBjaG5sKyspIHtcbiAgICAgICAgICAgIGEgPSBwaXhlbHNbb3JpZ1BpeCArIGNobmxdO1xuICAgICAgICAgICAgYiA9IHBpeGVsc1tvcmlnUGl4ICsgNCArIGNobmxdO1xuICAgICAgICAgICAgYyA9IHBpeGVsc1tvcmlnUGl4ICsgdzQgKyBjaG5sXTtcbiAgICAgICAgICAgIGQgPSBwaXhlbHNbb3JpZ1BpeCArIHc0ICsgNCArIGNobmxdO1xuICAgICAgICAgICAgY29sb3IgPSBhICogKDEgLSB4RGlmZikgKiAoMSAtIHlEaWZmKSArIGIgKiB4RGlmZiAqICgxIC0geURpZmYpICtcbiAgICAgICAgICAgICAgICAgICAgYyAqIHlEaWZmICogKDEgLSB4RGlmZikgKyBkICogeERpZmYgKiB5RGlmZjtcbiAgICAgICAgICAgIGRlc3RQaXhlbHNbb2Zmc2V0KytdID0gY29sb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzdEltYWdlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBoZXJtaXRlRmFzdFJlc2l6ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb1cgT3JpZ2luYWwgV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb0ggT3JpZ2luYWwgSGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRXIERlc3RpbmF0aW9uIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRIIERlc3RpbmF0aW9uIEhlaWdodFxuICAgICAqIEByZXR1cm5zIHtJbWFnZURhdGF9XG4gICAgICovXG4gICAgaGVybWl0ZUZhc3RSZXNpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKSB7XG4gICAgICB2YXIgcmF0aW9XID0gdGhpcy5yY3BTY2FsZVgsIHJhdGlvSCA9IHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHJhdGlvV0hhbGYgPSBjZWlsKHJhdGlvVyAvIDIpLFxuICAgICAgICAgIHJhdGlvSEhhbGYgPSBjZWlsKHJhdGlvSCAvIDIpLFxuICAgICAgICAgIGltZyA9IG9wdGlvbnMuaW1hZ2VEYXRhLCBkYXRhID0gaW1nLmRhdGEsXG4gICAgICAgICAgaW1nMiA9IG9wdGlvbnMuY3R4LmNyZWF0ZUltYWdlRGF0YShkVywgZEgpLCBkYXRhMiA9IGltZzIuZGF0YTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZEg7IGorKykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRXOyBpKyspIHtcbiAgICAgICAgICB2YXIgeDIgPSAoaSArIGogKiBkVykgKiA0LCB3ZWlnaHQgPSAwLCB3ZWlnaHRzID0gMCwgd2VpZ2h0c0FscGhhID0gMCxcbiAgICAgICAgICAgICAgZ3hSID0gMCwgZ3hHID0gMCwgZ3hCID0gMCwgZ3hBID0gMCwgY2VudGVyWSA9IChqICsgMC41KSAqIHJhdGlvSDtcbiAgICAgICAgICBmb3IgKHZhciB5eSA9IGZsb29yKGogKiByYXRpb0gpOyB5eSA8IChqICsgMSkgKiByYXRpb0g7IHl5KyspIHtcbiAgICAgICAgICAgIHZhciBkeSA9IGFicyhjZW50ZXJZIC0gKHl5ICsgMC41KSkgLyByYXRpb0hIYWxmLFxuICAgICAgICAgICAgICAgIGNlbnRlclggPSAoaSArIDAuNSkgKiByYXRpb1csIHcwID0gZHkgKiBkeTtcbiAgICAgICAgICAgIGZvciAodmFyIHh4ID0gZmxvb3IoaSAqIHJhdGlvVyk7IHh4IDwgKGkgKyAxKSAqIHJhdGlvVzsgeHgrKykge1xuICAgICAgICAgICAgICB2YXIgZHggPSBhYnMoY2VudGVyWCAtICh4eCArIDAuNSkpIC8gcmF0aW9XSGFsZixcbiAgICAgICAgICAgICAgICAgIHcgPSBzcXJ0KHcwICsgZHggKiBkeCk7XG4gICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCAqL1xuICAgICAgICAgICAgICBpZiAodyA+IDEgJiYgdyA8IC0xKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy9oZXJtaXRlIGZpbHRlclxuICAgICAgICAgICAgICB3ZWlnaHQgPSAyICogdyAqIHcgKiB3IC0gMyAqIHcgKiB3ICsgMTtcbiAgICAgICAgICAgICAgaWYgKHdlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICBkeCA9IDQgKiAoeHggKyB5eSAqIG9XKTtcbiAgICAgICAgICAgICAgICAvL2FscGhhXG4gICAgICAgICAgICAgICAgZ3hBICs9IHdlaWdodCAqIGRhdGFbZHggKyAzXTtcbiAgICAgICAgICAgICAgICB3ZWlnaHRzQWxwaGEgKz0gd2VpZ2h0O1xuICAgICAgICAgICAgICAgIC8vY29sb3JzXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbZHggKyAzXSA8IDI1NSkge1xuICAgICAgICAgICAgICAgICAgd2VpZ2h0ID0gd2VpZ2h0ICogZGF0YVtkeCArIDNdIC8gMjUwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBneFIgKz0gd2VpZ2h0ICogZGF0YVtkeF07XG4gICAgICAgICAgICAgICAgZ3hHICs9IHdlaWdodCAqIGRhdGFbZHggKyAxXTtcbiAgICAgICAgICAgICAgICBneEIgKz0gd2VpZ2h0ICogZGF0YVtkeCArIDJdO1xuICAgICAgICAgICAgICAgIHdlaWdodHMgKz0gd2VpZ2h0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWRlcHRoICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGEyW3gyXSA9IGd4UiAvIHdlaWdodHM7XG4gICAgICAgICAgZGF0YTJbeDIgKyAxXSA9IGd4RyAvIHdlaWdodHM7XG4gICAgICAgICAgZGF0YTJbeDIgKyAyXSA9IGd4QiAvIHdlaWdodHM7XG4gICAgICAgICAgZGF0YTJbeDIgKyAzXSA9IGd4QSAvIHdlaWdodHNBbHBoYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGltZzI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIHNjYWxlWDogdGhpcy5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogdGhpcy5zY2FsZVksXG4gICAgICAgIHJlc2l6ZVR5cGU6IHRoaXMucmVzaXplVHlwZSxcbiAgICAgICAgbGFuY3pvc0xvYmVzOiB0aGlzLmxhbmN6b3NMb2Jlc1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQ29udHJhc3QgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3Qoe1xuICAgKiAgIGNvbnRyYXN0OiA0MFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkNvbnRyYXN0ID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnQ29udHJhc3QnLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1Q29udHJhc3Q7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnZmxvYXQgY29udHJhc3RGID0gMS4wMTUgKiAodUNvbnRyYXN0ICsgMS4wKSAvICgxLjAgKiAoMS4wMTUgLSB1Q29udHJhc3QpKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLnJnYiA9IGNvbnRyYXN0RiAqIChjb2xvci5yZ2IgLSAwLjUpICsgMC41O1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICBjb250cmFzdDogMCxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdjb250cmFzdCcsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbnRyYXN0PTBdIFZhbHVlIHRvIGNvbnRyYXN0IHRoZSBpbWFnZSB1cCAoLTEuLi4xKVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICAqIEFwcGx5IHRoZSBDb250cmFzdCBvcGVyYXRpb24gdG8gYSBVaW50OEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAgKlxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4QXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuY29udHJhc3QgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLCBpLCBsZW4sXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBjb250cmFzdCA9IE1hdGguZmxvb3IodGhpcy5jb250cmFzdCAqIDI1NSksXG4gICAgICAgICAgY29udHJhc3RGID0gMjU5ICogKGNvbnRyYXN0ICsgMjU1KSAvICgyNTUgKiAoMjU5IC0gY29udHJhc3QpKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaV0gPSBjb250cmFzdEYgKiAoZGF0YVtpXSAtIDEyOCkgKyAxMjg7XG4gICAgICAgIGRhdGFbaSArIDFdID0gY29udHJhc3RGICogKGRhdGFbaSArIDFdIC0gMTI4KSArIDEyODtcbiAgICAgICAgZGF0YVtpICsgMl0gPSBjb250cmFzdEYgKiAoZGF0YVtpICsgMl0gLSAxMjgpICsgMTI4O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUNvbnRyYXN0OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VDb250cmFzdCcpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudUNvbnRyYXN0LCB0aGlzLmNvbnRyYXN0KTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0fSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdFxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3QuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIFNhdHVyYXRlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0aW9uI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0aW9uKHtcbiAgICogICBzYXR1cmF0aW9uOiAxMDBcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5TYXR1cmF0aW9uID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb24ucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdTYXR1cmF0aW9uJyxcblxuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdVNhdHVyYXRpb247XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnZmxvYXQgcmdNYXggPSBtYXgoY29sb3IuciwgY29sb3IuZyk7XFxuJyArXG4gICAgICAgICdmbG9hdCByZ2JNYXggPSBtYXgocmdNYXgsIGNvbG9yLmIpO1xcbicgK1xuICAgICAgICAnY29sb3IuciArPSByZ2JNYXggIT0gY29sb3IuciA/IChyZ2JNYXggLSBjb2xvci5yKSAqIHVTYXR1cmF0aW9uIDogMC4wMDtcXG4nICtcbiAgICAgICAgJ2NvbG9yLmcgKz0gcmdiTWF4ICE9IGNvbG9yLmcgPyAocmdiTWF4IC0gY29sb3IuZykgKiB1U2F0dXJhdGlvbiA6IDAuMDA7XFxuJyArXG4gICAgICAgICdjb2xvci5iICs9IHJnYk1heCAhPSBjb2xvci5iID8gKHJnYk1heCAtIGNvbG9yLmIpICogdVNhdHVyYXRpb24gOiAwLjAwO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICBzYXR1cmF0aW9uOiAwLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ3NhdHVyYXRpb24nLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zYXR1cmF0ZT0wXSBWYWx1ZSB0byBzYXR1cmF0ZSB0aGUgaW1hZ2UgKC0xLi4uMSlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBTYXR1cmF0aW9uIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuc2F0dXJhdGlvbiA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBhZGp1c3QgPSAtdGhpcy5zYXR1cmF0aW9uLCBpLCBtYXg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChkYXRhW2ldLCBkYXRhW2kgKyAxXSwgZGF0YVtpICsgMl0pO1xuICAgICAgICBkYXRhW2ldICs9IG1heCAhPT0gZGF0YVtpXSA/IChtYXggLSBkYXRhW2ldKSAqIGFkanVzdCA6IDA7XG4gICAgICAgIGRhdGFbaSArIDFdICs9IG1heCAhPT0gZGF0YVtpICsgMV0gPyAobWF4IC0gZGF0YVtpICsgMV0pICogYWRqdXN0IDogMDtcbiAgICAgICAgZGF0YVtpICsgMl0gKz0gbWF4ICE9PSBkYXRhW2kgKyAyXSA/IChtYXggLSBkYXRhW2kgKyAyXSkgKiBhZGp1c3QgOiAwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdVNhdHVyYXRpb246IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVNhdHVyYXRpb24nKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVTYXR1cmF0aW9uLCAtdGhpcy5zYXR1cmF0aW9uKTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb259IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0aW9uLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBCbHVyIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuQmx1clxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbHVyI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbHVyKHtcbiAgICogICBibHVyOiAwLjVcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqL1xuICBmaWx0ZXJzLkJsdXIgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmx1ci5wcm90b3R5cGUgKi8ge1xuXG4gICAgdHlwZTogJ0JsdXInLFxuXG4gICAgLypcbidnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCk7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC03ICogdURlbHRhKSowLjAwNDQyOTkxMjEwNTUxMTMyNjU7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC02ICogdURlbHRhKSowLjAwODk1NzgxMjExNzk0OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtNSAqIHVEZWx0YSkqMC4wMjE1OTYzODY2MDUzOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtNCAqIHVEZWx0YSkqMC4wNDQzNjgzMzM4NzE4OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtMyAqIHVEZWx0YSkqMC4wNzc2NzQ0MjE5OTMzOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtMiAqIHVEZWx0YSkqMC4xMTU4NzY2MjExMDU7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC0xICogdURlbHRhKSowLjE0NzMwODA1NjEyMTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICAgICAgICAgICAgICApKjAuMTU5NTc2OTEyMTYxOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAxICogdURlbHRhKSowLjE0NzMwODA1NjEyMTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgMiAqIHVEZWx0YSkqMC4xMTU4NzY2MjExMDU7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDMgKiB1RGVsdGEpKjAuMDc3Njc0NDIxOTkzMzsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgNCAqIHVEZWx0YSkqMC4wNDQzNjgzMzM4NzE4OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyA1ICogdURlbHRhKSowLjAyMTU5NjM4NjYwNTM7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDYgKiB1RGVsdGEpKjAuMDA4OTU3ODEyMTE3OTQ7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDcgKiB1RGVsdGEpKjAuMDA0NDI5OTEyMTA1NTExMzI2NTsnLFxuKi9cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIHZlYzIgdURlbHRhO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAnY29uc3QgZmxvYXQgblNhbXBsZXMgPSAxNS4wO1xcbicgK1xuICAgICAgJ3ZlYzMgdjNvZmZzZXQgPSB2ZWMzKDEyLjk4OTgsIDc4LjIzMywgMTUxLjcxODIpO1xcbicgK1xuICAgICAgJ2Zsb2F0IHJhbmRvbSh2ZWMzIHNjYWxlKSB7XFxuJyArXG4gICAgICAgIC8qIHVzZSB0aGUgZnJhZ21lbnQgcG9zaXRpb24gZm9yIGEgZGlmZmVyZW50IHNlZWQgcGVyLXBpeGVsICovXG4gICAgICAgICdyZXR1cm4gZnJhY3Qoc2luKGRvdChnbF9GcmFnQ29vcmQueHl6LCBzY2FsZSkpICogNDM3NTguNTQ1Myk7XFxuJyArXG4gICAgICAnfVxcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxuJyArXG4gICAgICAgICdmbG9hdCB0b3RhbCA9IDAuMDtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IG9mZnNldCA9IHJhbmRvbSh2M29mZnNldCk7XFxuJyArXG4gICAgICAgICdmb3IgKGZsb2F0IHQgPSAtblNhbXBsZXM7IHQgPD0gblNhbXBsZXM7IHQrKykge1xcbicgK1xuICAgICAgICAgICdmbG9hdCBwZXJjZW50ID0gKHQgKyBvZmZzZXQgLSAwLjUpIC8gblNhbXBsZXM7XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IHdlaWdodCA9IDEuMCAtIGFicyhwZXJjZW50KTtcXG4nICtcbiAgICAgICAgICAnY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyB1RGVsdGEgKiBwZXJjZW50KSAqIHdlaWdodDtcXG4nICtcbiAgICAgICAgICAndG90YWwgKz0gd2VpZ2h0O1xcbicgK1xuICAgICAgICAnfVxcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3IgLyB0b3RhbDtcXG4nICtcbiAgICAgICd9JyxcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuICAgIC8qKlxuICAgICAqIGJsdXIgdmFsdWUsIGluIHBlcmNlbnRhZ2Ugb2YgaW1hZ2UgZGltZW5zaW9ucy5cbiAgICAgKiBzcGVjaWZpYyB0byBrZWVwIHRoZSBpbWFnZSBibHVyIGNvbnN0YW50IGF0IGRpZmZlcmVudCByZXNvbHV0aW9uc1xuICAgICAqIHJhbmdlIGJld3RlZW4gMCBhbmQgMS5cbiAgICAgKi9cbiAgICBibHVyOiAwLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ2JsdXInLFxuXG4gICAgYXBwbHlUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMud2ViZ2wpIHtcbiAgICAgICAgLy8gdGhpcyBhc3BlY3RSYXRpbyBpcyB1c2VkIHRvIGdpdmUgdGhlIHNhbWUgYmx1ciB0byB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbFxuICAgICAgICB0aGlzLmFzcGVjdFJhdGlvID0gb3B0aW9ucy5zb3VyY2VXaWR0aCAvIG9wdGlvbnMuc291cmNlSGVpZ2h0O1xuICAgICAgICBvcHRpb25zLnBhc3NlcysrO1xuICAgICAgICB0aGlzLl9zZXR1cEZyYW1lQnVmZmVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmhvcml6b250YWwgPSB0cnVlO1xuICAgICAgICB0aGlzLmFwcGx5VG9XZWJHTChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc3dhcFRleHR1cmVzKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zZXR1cEZyYW1lQnVmZmVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmhvcml6b250YWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hcHBseVRvV2ViR0wob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3N3YXBUZXh0dXJlcyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmFwcGx5VG8yZChvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAvLyBwYWludCBjYW52YXNFbCB3aXRoIGN1cnJlbnQgaW1hZ2UgZGF0YS5cbiAgICAgIC8vb3B0aW9ucy5jdHgucHV0SW1hZ2VEYXRhKG9wdGlvbnMuaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgIG9wdGlvbnMuaW1hZ2VEYXRhID0gdGhpcy5zaW1wbGVCbHVyKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBzaW1wbGVCbHVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgcmVzb3VyY2VzID0gb3B0aW9ucy5maWx0ZXJCYWNrZW5kLnJlc291cmNlcywgY2FudmFzMSwgY2FudmFzMixcbiAgICAgICAgICB3aWR0aCA9IG9wdGlvbnMuaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IG9wdGlvbnMuaW1hZ2VEYXRhLmhlaWdodDtcblxuICAgICAgaWYgKCFyZXNvdXJjZXMuYmx1ckxheWVyMSkge1xuICAgICAgICByZXNvdXJjZXMuYmx1ckxheWVyMSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgICAgcmVzb3VyY2VzLmJsdXJMYXllcjIgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICB9XG4gICAgICBjYW52YXMxID0gcmVzb3VyY2VzLmJsdXJMYXllcjE7XG4gICAgICBjYW52YXMyID0gcmVzb3VyY2VzLmJsdXJMYXllcjI7XG4gICAgICBpZiAoY2FudmFzMS53aWR0aCAhPT0gd2lkdGggfHwgY2FudmFzMS5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICBjYW52YXMyLndpZHRoID0gY2FudmFzMS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMyLmhlaWdodCA9IGNhbnZhczEuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfVxuICAgICAgdmFyIGN0eDEgPSBjYW52YXMxLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgY3R4MiA9IGNhbnZhczIuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBuU2FtcGxlcyA9IDE1LFxuICAgICAgICAgIHJhbmRvbSwgcGVyY2VudCwgaiwgaSxcbiAgICAgICAgICBibHVyID0gdGhpcy5ibHVyICogMC4wNiAqIDAuNTtcblxuICAgICAgLy8gbG9hZCBmaXJzdCBjYW52YXNcbiAgICAgIGN0eDEucHV0SW1hZ2VEYXRhKG9wdGlvbnMuaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgIGN0eDIuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICBmb3IgKGkgPSAtblNhbXBsZXM7IGkgPD0gblNhbXBsZXM7IGkrKykge1xuICAgICAgICByYW5kb20gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgLyA0O1xuICAgICAgICBwZXJjZW50ID0gaSAvIG5TYW1wbGVzO1xuICAgICAgICBqID0gYmx1ciAqIHBlcmNlbnQgKiB3aWR0aCArIHJhbmRvbTtcbiAgICAgICAgY3R4Mi5nbG9iYWxBbHBoYSA9IDEgLSBNYXRoLmFicyhwZXJjZW50KTtcbiAgICAgICAgY3R4Mi5kcmF3SW1hZ2UoY2FudmFzMSwgaiwgcmFuZG9tKTtcbiAgICAgICAgY3R4MS5kcmF3SW1hZ2UoY2FudmFzMiwgMCwgMCk7XG4gICAgICAgIGN0eDIuZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICBjdHgyLmNsZWFyUmVjdCgwLCAwLCBjYW52YXMyLndpZHRoLCBjYW52YXMyLmhlaWdodCk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAtblNhbXBsZXM7IGkgPD0gblNhbXBsZXM7IGkrKykge1xuICAgICAgICByYW5kb20gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgLyA0O1xuICAgICAgICBwZXJjZW50ID0gaSAvIG5TYW1wbGVzO1xuICAgICAgICBqID0gYmx1ciAqIHBlcmNlbnQgKiBoZWlnaHQgKyByYW5kb207XG4gICAgICAgIGN0eDIuZ2xvYmFsQWxwaGEgPSAxIC0gTWF0aC5hYnMocGVyY2VudCk7XG4gICAgICAgIGN0eDIuZHJhd0ltYWdlKGNhbnZhczEsIHJhbmRvbSwgaik7XG4gICAgICAgIGN0eDEuZHJhd0ltYWdlKGNhbnZhczIsIDAsIDApO1xuICAgICAgICBjdHgyLmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgY3R4Mi5jbGVhclJlY3QoMCwgMCwgY2FudmFzMi53aWR0aCwgY2FudmFzMi5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5jdHguZHJhd0ltYWdlKGNhbnZhczEsIDAsIDApO1xuICAgICAgdmFyIG5ld0ltYWdlRGF0YSA9IG9wdGlvbnMuY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMxLndpZHRoLCBjYW52YXMxLmhlaWdodCk7XG4gICAgICBjdHgxLmdsb2JhbEFscGhhID0gMTtcbiAgICAgIGN0eDEuY2xlYXJSZWN0KDAsIDAsIGNhbnZhczEud2lkdGgsIGNhbnZhczEuaGVpZ2h0KTtcbiAgICAgIHJldHVybiBuZXdJbWFnZURhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZWx0YTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1RGVsdGEnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIHZhciBkZWx0YSA9IHRoaXMuY2hvb3NlUmlnaHREZWx0YSgpO1xuICAgICAgZ2wudW5pZm9ybTJmdih1bmlmb3JtTG9jYXRpb25zLmRlbHRhLCBkZWx0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNob29zZSByaWdodCB2YWx1ZSBvZiBpbWFnZSBwZXJjZW50YWdlIHRvIGJsdXIgd2l0aFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gYSBudW1lcmljIGFycmF5IHdpdGggZGVsdGEgdmFsdWVzXG4gICAgICovXG4gICAgY2hvb3NlUmlnaHREZWx0YTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYmx1clNjYWxlID0gMSwgZGVsdGEgPSBbMCwgMF0sIGJsdXI7XG4gICAgICBpZiAodGhpcy5ob3Jpem9udGFsKSB7XG4gICAgICAgIGlmICh0aGlzLmFzcGVjdFJhdGlvID4gMSkge1xuICAgICAgICAgIC8vIGltYWdlIGlzIHdpZGUsIGkgd2FudCB0byBzaHJpbmsgcmFkaXVzIGhvcml6b250YWxcbiAgICAgICAgICBibHVyU2NhbGUgPSAxIC8gdGhpcy5hc3BlY3RSYXRpbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmFzcGVjdFJhdGlvIDwgMSkge1xuICAgICAgICAgIC8vIGltYWdlIGlzIHRhbGwsIGkgd2FudCB0byBzaHJpbmsgcmFkaXVzIHZlcnRpY2FsXG4gICAgICAgICAgYmx1clNjYWxlID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmx1ciA9IGJsdXJTY2FsZSAqIHRoaXMuYmx1ciAqIDAuMTI7XG4gICAgICBpZiAodGhpcy5ob3Jpem9udGFsKSB7XG4gICAgICAgIGRlbHRhWzBdID0gYmx1cjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkZWx0YVsxXSA9IGJsdXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVsdGE7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGEgSlNPTiBkZWZpbml0aW9uIG9mIGEgQmx1ckZpbHRlciBpbnRvIGEgY29uY3JldGUgaW5zdGFuY2UuXG4gICAqL1xuICBmaWx0ZXJzLkJsdXIuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEdhbW1hIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWFcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWEjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdhbW1hKHtcbiAgICogICBicmlnaHRuZXNzOiAyMDBcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5HYW1tYSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0dhbW1hJyxcblxuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjMyB1R2FtbWE7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAndmVjMyBjb3JyZWN0aW9uID0gKDEuMCAvIHVHYW1tYSk7XFxuJyArXG4gICAgICAgICdjb2xvci5yID0gcG93KGNvbG9yLnIsIGNvcnJlY3Rpb24ucik7XFxuJyArXG4gICAgICAgICdjb2xvci5nID0gcG93KGNvbG9yLmcsIGNvcnJlY3Rpb24uZyk7XFxuJyArXG4gICAgICAgICdjb2xvci5iID0gcG93KGNvbG9yLmIsIGNvcnJlY3Rpb24uYik7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvci5yZ2IgKj0gY29sb3IuYTtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIEdhbW1hIGFycmF5IHZhbHVlLCBmcm9tIDAuMDEgdG8gMi4yLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGdhbW1hXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBnYW1tYTogWzEsIDEsIDFdLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgdGhlIHByb3BlcnR5IHRoYXQgaXMgdGhlIGZpbHRlciBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWFpblBhcmFtZXRlcjogJ2dhbW1hJyxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBHYW1tYSBvcGVyYXRpb24gdG8gYSBVaW50OEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4QXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBnYW1tYSA9IHRoaXMuZ2FtbWEsIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIHJJbnYgPSAxIC8gZ2FtbWFbMF0sIGdJbnYgPSAxIC8gZ2FtbWFbMV0sXG4gICAgICAgICAgYkludiA9IDEgLyBnYW1tYVsyXSwgaTtcblxuICAgICAgaWYgKCF0aGlzLnJWYWxzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLnJWYWxzID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHRoaXMuZ1ZhbHMgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5iVmFscyA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIC0gcHJlLWNvbXB1dGUgYSBsb29rLXVwIHRhYmxlIGZvciBlYWNoIGNvbG9yIGNoYW5uZWxcbiAgICAgIC8vIGluc3RlYWQgb2YgcGVyZm9ybWluZyB0aGVzZSBwb3cgY2FsbHMgZm9yIGVhY2ggcGl4ZWwgaW4gdGhlIGltYWdlLlxuICAgICAgZm9yIChpID0gMCwgbGVuID0gMjU2OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5yVmFsc1tpXSA9IE1hdGgucG93KGkgLyAyNTUsIHJJbnYpICogMjU1O1xuICAgICAgICB0aGlzLmdWYWxzW2ldID0gTWF0aC5wb3coaSAvIDI1NSwgZ0ludikgKiAyNTU7XG4gICAgICAgIHRoaXMuYlZhbHNbaV0gPSBNYXRoLnBvdyhpIC8gMjU1LCBiSW52KSAqIDI1NTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZGF0YVtpXSA9IHRoaXMuclZhbHNbZGF0YVtpXV07XG4gICAgICAgIGRhdGFbaSArIDFdID0gdGhpcy5nVmFsc1tkYXRhW2kgKyAxXV07XG4gICAgICAgIGRhdGFbaSArIDJdID0gdGhpcy5iVmFsc1tkYXRhW2kgKyAyXV07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1R2FtbWE6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUdhbW1hJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtM2Z2KHVuaWZvcm1Mb2NhdGlvbnMudUdhbW1hLCB0aGlzLmdhbW1hKTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkdhbW1hfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWEuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEEgY29udGFpbmVyIGNsYXNzIHRoYXQga25vd3MgaG93IHRvIGFwcGx5IGEgc2VxdWVuY2Ugb2YgZmlsdGVycyB0byBhbiBpbnB1dCBpbWFnZS5cbiAgICovXG4gIGZpbHRlcnMuQ29tcG9zZWQgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQ29tcG9zZWQucHJvdG90eXBlICovIHtcblxuICAgIHR5cGU6ICdDb21wb3NlZCcsXG5cbiAgICAvKipcbiAgICAgKiBBIG5vbiBzcGFyc2UgYXJyYXkgb2YgZmlsdGVycyB0byBhcHBseVxuICAgICAqL1xuICAgIHN1YkZpbHRlcnM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIC8vIGNyZWF0ZSBhIG5ldyBhcnJheSBpbnN0ZWFkIG11dGF0aW5nIHRoZSBwcm90b3R5cGUgd2l0aCBwdXNoXG4gICAgICB0aGlzLnN1YkZpbHRlcnMgPSB0aGlzLnN1YkZpbHRlcnMuc2xpY2UoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoaXMgY29udGFpbmVyJ3MgZmlsdGVycyB0byB0aGUgaW5wdXQgaW1hZ2UgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnBhc3NlcyBUaGUgbnVtYmVyIG9mIGZpbHRlcnMgcmVtYWluaW5nIHRvIGJlIGFwcGxpZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucy5wYXNzZXMgKz0gdGhpcy5zdWJGaWx0ZXJzLmxlbmd0aCAtIDE7XG4gICAgICB0aGlzLnN1YkZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgICAgZmlsdGVyLmFwcGx5VG8ob3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoaXMgZmlsdGVyIGludG8gSlNPTi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZpbHRlci5cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnKSwge1xuICAgICAgICBzdWJGaWx0ZXJzOiB0aGlzLnN1YkZpbHRlcnMubWFwKGZ1bmN0aW9uKGZpbHRlcikgeyByZXR1cm4gZmlsdGVyLnRvT2JqZWN0KCk7IH0pLFxuICAgICAgfSk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGEgSlNPTiBkZWZpbml0aW9uIG9mIGEgQ29tcG9zZWRGaWx0ZXIgaW50byBhIGNvbmNyZXRlIGluc3RhbmNlLlxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQ29tcG9zZWQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmlsdGVycyA9IG9iamVjdC5zdWJGaWx0ZXJzIHx8IFtdLFxuICAgICAgICBzdWJGaWx0ZXJzID0gZmlsdGVycy5tYXAoZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVyc1tmaWx0ZXIudHlwZV0oZmlsdGVyKTtcbiAgICAgICAgfSksXG4gICAgICAgIGluc3RhbmNlID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbXBvc2VkKHsgc3ViRmlsdGVyczogc3ViRmlsdGVycyB9KTtcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhpbnN0YW5jZSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEh1ZVJvdGF0aW9uIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb24jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9uKHtcbiAgICogICByb3RhdGlvbjogLTAuNVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkh1ZVJvdGF0aW9uID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5Db2xvck1hdHJpeCwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvbi5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0h1ZVJvdGF0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIEh1ZVJvdGF0aW9uIHZhbHVlLCBmcm9tIC0xIHRvIDEuXG4gICAgICogdGhlIHVuaXQgaXMgcmFkaWFuc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBteVBhcmFtZXRlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcm90YXRpb246IDAsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSB0aGUgcHJvcGVydHkgdGhhdCBpcyB0aGUgZmlsdGVyIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtYWluUGFyYW1ldGVyOiAncm90YXRpb24nLFxuXG4gICAgY2FsY3VsYXRlTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByYWQgPSB0aGlzLnJvdGF0aW9uICogTWF0aC5QSSwgY29zID0gZmFicmljLnV0aWwuY29zKHJhZCksIHNpbiA9IGZhYnJpYy51dGlsLnNpbihyYWQpLFxuICAgICAgICAgIGFUaGlyZCA9IDEgLyAzLCBhVGhpcmRTcXRTaW4gPSBNYXRoLnNxcnQoYVRoaXJkKSAqIHNpbiwgT25lTWludXNDb3MgPSAxIC0gY29zO1xuICAgICAgdGhpcy5tYXRyaXggPSBbXG4gICAgICAgIDEsIDAsIDAsIDAsIDAsXG4gICAgICAgIDAsIDEsIDAsIDAsIDAsXG4gICAgICAgIDAsIDAsIDEsIDAsIDAsXG4gICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICAgIF07XG4gICAgICB0aGlzLm1hdHJpeFswXSA9IGNvcyArIE9uZU1pbnVzQ29zIC8gMztcbiAgICAgIHRoaXMubWF0cml4WzFdID0gYVRoaXJkICogT25lTWludXNDb3MgLSBhVGhpcmRTcXRTaW47XG4gICAgICB0aGlzLm1hdHJpeFsyXSA9IGFUaGlyZCAqIE9uZU1pbnVzQ29zICsgYVRoaXJkU3F0U2luO1xuICAgICAgdGhpcy5tYXRyaXhbNV0gPSBhVGhpcmQgKiBPbmVNaW51c0NvcyArIGFUaGlyZFNxdFNpbjtcbiAgICAgIHRoaXMubWF0cml4WzZdID0gY29zICsgYVRoaXJkICogT25lTWludXNDb3M7XG4gICAgICB0aGlzLm1hdHJpeFs3XSA9IGFUaGlyZCAqIE9uZU1pbnVzQ29zIC0gYVRoaXJkU3F0U2luO1xuICAgICAgdGhpcy5tYXRyaXhbMTBdID0gYVRoaXJkICogT25lTWludXNDb3MgLSBhVGhpcmRTcXRTaW47XG4gICAgICB0aGlzLm1hdHJpeFsxMV0gPSBhVGhpcmQgKiBPbmVNaW51c0NvcyArIGFUaGlyZFNxdFNpbjtcbiAgICAgIHRoaXMubWF0cml4WzEyXSA9IGNvcyArIGFUaGlyZCAqIE9uZU1pbnVzQ29zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGlzIGZpbHRlciB0byB0aGUgaW5wdXQgaW1hZ2UgZGF0YSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0byB1c2UgV2ViR0wgb3IgQ2FudmFzMkQgYmFzZWQgb24gdGhlIG9wdGlvbnMud2ViZ2wgZmxhZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucGFzc2VzIFRoZSBudW1iZXIgb2YgZmlsdGVycyByZW1haW5pbmcgdG8gYmUgZXhlY3V0ZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMud2ViZ2wgV2hldGhlciB0byB1c2Ugd2ViZ2wgdG8gcmVuZGVyIHRoZSBmaWx0ZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMuc291cmNlVGV4dHVyZSBUaGUgdGV4dHVyZSBzZXR1cCBhcyB0aGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnRhcmdldFRleHR1cmUgVGhlIHRleHR1cmUgd2hlcmUgZmlsdGVyZWQgb3V0cHV0IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGN1bGF0ZU1hdHJpeCgpO1xuICAgICAgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5wcm90b3R5cGUuYXBwbHlUby5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvbn0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb25cbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9uLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lO1xuXG4gIGlmIChmYWJyaWMuVGV4dCkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuVGV4dCBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogVGV4dCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlRleHRcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMiN0ZXh0fVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuVGV4dCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlRleHQgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5UZXh0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIHdoaWNoIHdoZW4gc2V0IGNhdXNlIG9iamVjdCB0byBjaGFuZ2UgZGltZW5zaW9uc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHM6IFtcbiAgICAgICdmb250U2l6ZScsXG4gICAgICAnZm9udFdlaWdodCcsXG4gICAgICAnZm9udEZhbWlseScsXG4gICAgICAnZm9udFN0eWxlJyxcbiAgICAgICdsaW5lSGVpZ2h0JyxcbiAgICAgICd0ZXh0JyxcbiAgICAgICdjaGFyU3BhY2luZycsXG4gICAgICAndGV4dEFsaWduJyxcbiAgICAgICdzdHlsZXMnLFxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZU5ld2xpbmU6IC9cXHI/XFxuLyxcblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBmaWx0ZXIgZm9yIHdoaXRlc3BhY2VzIHRoYXQgaXMgbm90IGEgbmV3IGxpbmUuXG4gICAgICogTW9zdGx5IHVzZWQgd2hlbiB0ZXh0IGlzICdqdXN0aWZ5JyBhbGlnbmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlU3BhY2VzQW5kVGFiczogL1sgXFx0XFxyXS9nLFxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbHRlciBmb3Igd2hpdGVzcGFjZSB0aGF0IGlzIG5vdCBhIG5ldyBsaW5lLlxuICAgICAqIE1vc3RseSB1c2VkIHdoZW4gdGV4dCBpcyAnanVzdGlmeScgYWxpZ25lZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZVNwYWNlQW5kVGFiOiAvWyBcXHRcXHJdLyxcblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBmaWx0ZXIgY29uc2VjdXRpdmUgZ3JvdXBzIG9mIG5vbiBzcGFjZXMuXG4gICAgICogTW9zdGx5IHVzZWQgd2hlbiB0ZXh0IGlzICdqdXN0aWZ5JyBhbGlnbmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlV29yZHM6IC9cXFMrL2csXG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogICAgICAgICAgICAgICAgICd0ZXh0JyxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgc2l6ZSAoaW4gcGl4ZWxzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZm9udFNpemU6ICAgICAgICAgICAgIDQwLFxuXG4gICAgLyoqXG4gICAgICogRm9udCB3ZWlnaHQgKGUuZy4gYm9sZCwgbm9ybWFsLCA0MDAsIDYwMCwgODAwKVxuICAgICAqIEB0eXBlIHsoTnVtYmVyfFN0cmluZyl9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmb250V2VpZ2h0OiAgICAgICAgICAgJ25vcm1hbCcsXG5cbiAgICAvKipcbiAgICAgKiBGb250IGZhbWlseVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZm9udEZhbWlseTogICAgICAgICAgICdUaW1lcyBOZXcgUm9tYW4nLFxuXG4gICAgLyoqXG4gICAgICogVGV4dCBkZWNvcmF0aW9uIHVuZGVybGluZS5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHVuZGVybGluZTogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IGRlY29yYXRpb24gb3ZlcmxpbmUuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvdmVybGluZTogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IGRlY29yYXRpb24gbGluZXRocm91Z2guXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsaW5ldGhyb3VnaDogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IGFsaWdubWVudC4gUG9zc2libGUgdmFsdWVzOiBcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJyaWdodFwiLCBcImp1c3RpZnlcIixcbiAgICAgKiBcImp1c3RpZnktbGVmdFwiLCBcImp1c3RpZnktY2VudGVyXCIgb3IgXCJqdXN0aWZ5LXJpZ2h0XCIuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0ZXh0QWxpZ246ICAgICAgICAgICAgJ2xlZnQnLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBzdHlsZSAuIFBvc3NpYmxlIHZhbHVlczogXCJcIiwgXCJub3JtYWxcIiwgXCJpdGFsaWNcIiBvciBcIm9ibGlxdWVcIi5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZvbnRTdHlsZTogICAgICAgICAgICAnbm9ybWFsJyxcblxuICAgIC8qKlxuICAgICAqIExpbmUgaGVpZ2h0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsaW5lSGVpZ2h0OiAgICAgICAgICAgMS4xNixcblxuICAgIC8qKlxuICAgICAqIFN1cGVyc2NyaXB0IHNjaGVtYSBvYmplY3QgKG1pbmltdW0gb3ZlcmxhcClcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3VwZXJzY3JpcHQ6IHtcbiAgICAgIHNpemU6ICAgICAgMC42MCwgLy8gZm9udFNpemUgZmFjdG9yXG4gICAgICBiYXNlbGluZTogLTAuMzUgIC8vIGJhc2VsaW5lLXNoaWZ0IGZhY3RvciAodXB3YXJkcylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaXB0IHNjaGVtYSBvYmplY3QgKG1pbmltdW0gb3ZlcmxhcClcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Vic2NyaXB0OiB7XG4gICAgICBzaXplOiAgICAgIDAuNjAsIC8vIGZvbnRTaXplIGZhY3RvclxuICAgICAgYmFzZWxpbmU6ICAwLjExICAvLyBiYXNlbGluZS1zaGlmdCBmYWN0b3IgKGRvd253YXJkcylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBvZiB0ZXh0IGxpbmVzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0ZXh0QmFja2dyb3VuZENvbG9yOiAgJycsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZlxuICAgICAqIHN0YXRlIG9mIGFuIG9iamVjdCBpcyBjaGFuZ2VkICh7QGxpbmsgZmFicmljLk9iamVjdCNoYXNTdGF0ZUNoYW5nZWR9KVxuICAgICAqIGFzIHdlbGwgYXMgZm9yIGhpc3RvcnkgKHVuZG8vcmVkbykgcHVycG9zZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0YXRlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuc3RhdGVQcm9wZXJ0aWVzLmNvbmNhdCgnZm9udEZhbWlseScsXG4gICAgICAnZm9udFdlaWdodCcsXG4gICAgICAnZm9udFNpemUnLFxuICAgICAgJ3RleHQnLFxuICAgICAgJ3VuZGVybGluZScsXG4gICAgICAnb3ZlcmxpbmUnLFxuICAgICAgJ2xpbmV0aHJvdWdoJyxcbiAgICAgICd0ZXh0QWxpZ24nLFxuICAgICAgJ2ZvbnRTdHlsZScsXG4gICAgICAnbGluZUhlaWdodCcsXG4gICAgICAndGV4dEJhY2tncm91bmRDb2xvcicsXG4gICAgICAnY2hhclNwYWNpbmcnLFxuICAgICAgJ3N0eWxlcycpLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWYgY2FjaGUgbmVlZHMgcmVmcmVzaFxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCdmb250RmFtaWx5JyxcbiAgICAgICdmb250V2VpZ2h0JyxcbiAgICAgICdmb250U2l6ZScsXG4gICAgICAndGV4dCcsXG4gICAgICAndW5kZXJsaW5lJyxcbiAgICAgICdvdmVybGluZScsXG4gICAgICAnbGluZXRocm91Z2gnLFxuICAgICAgJ3RleHRBbGlnbicsXG4gICAgICAnZm9udFN0eWxlJyxcbiAgICAgICdsaW5lSGVpZ2h0JyxcbiAgICAgICd0ZXh0QmFja2dyb3VuZENvbG9yJyxcbiAgICAgICdjaGFyU3BhY2luZycsXG4gICAgICAnc3R5bGVzJyksXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRlZmluZWQsIGFuIG9iamVjdCBpcyByZW5kZXJlZCB2aWEgc3Ryb2tlIGFuZCB0aGlzIHByb3BlcnR5IHNwZWNpZmllcyBpdHMgY29sb3IuXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSB3YXMgbmFtZWQgXCJzdHJva2VTdHlsZVwiIHVudGlsIHYxLjEuNlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlOiAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgb2JqZWN0IHJlcHJlc2VudGluZyBzaGFkb3cgb2YgdGhpcyBzaGFwZS5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHdhcyBuYW1lZCBcInRleHRTaGFkb3dcIiAoU3RyaW5nKSB1bnRpbCB2MS4yLjExXG4gICAgICogQHR5cGUgZmFicmljLlNoYWRvd1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2hhZG93OiAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9mb250U2l6ZUZyYWN0aW9uOiAwLjIyMixcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb2Zmc2V0czoge1xuICAgICAgdW5kZXJsaW5lOiAwLjEwLFxuICAgICAgbGluZXRocm91Z2g6IC0wLjMxNSxcbiAgICAgIG92ZXJsaW5lOiAtMC44OFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IExpbmUgcHJvcG9ydGlvbiB0byBmb250IFNpemUgKGluIHBpeGVscylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIF9mb250U2l6ZU11bHQ6ICAgICAgICAgICAgIDEuMTMsXG5cbiAgICAvKipcbiAgICAgKiBhZGRpdGlvbmFsIHNwYWNlIGJldHdlZW4gY2hhcmFjdGVyc1xuICAgICAqIGV4cHJlc3NlZCBpbiB0aG91c2FuZHMgb2YgZW0gdW5pdFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2hhclNwYWNpbmc6ICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBPYmplY3QgY29udGFpbmluZyBjaGFyYWN0ZXIgc3R5bGVzIC0gdG9wLWxldmVsIHByb3BlcnRpZXMgLT4gbGluZSBudW1iZXJzLFxuICAgICAqIDJuZC1sZXZlbCBwcm9wZXJ0aWVzIC0gY2hhcmF0ZXIgbnVtYmVyc1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3R5bGVzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIGEgY29udGV4dCB0byBtZWFzdXJlIHRleHQgY2hhciBvciBjb3VwbGUgb2YgY2hhcnNcbiAgICAgKiB0aGUgY2FjaGVDb250ZXh0IG9mIHRoZSBjYW52YXMgd2lsbCBiZSB1c2VkIG9yIGEgZnJlc2hseSBjcmVhdGVkIG9uZSBpZiB0aGUgb2JqZWN0IGlzIG5vdCBvbiBjYW52YXNcbiAgICAgKiBvbmNlIGNyZWF0ZWQgaXQgd2lsbCBiZSByZWZlcmVuY2VkIG9uIGZhYnJpYy5fbWVhc3VyaW5nQ29udGV4dCB0byBhdm9pZGUgY3JlYXRpbmcgYSBjYW52YXMgZm9yIGV2ZXJ5XG4gICAgICogdGV4dCBvYmplY3QgY3JlYXRlZC5cbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgX21lYXN1cmluZ0NvbnRleHQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBCYXNlbGluZSBzaGlmdCwgc3RseWVzIG9ubHksIGtlZXAgYXQgMCBmb3IgdGhlIG1haW4gdGV4dCBvYmplY3RcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZGVsdGFZOiAwLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgcHJvcGVydGllcyB0aGF0IGRlZmluZSBhIHN0eWxlIHVuaXQgKG9mICdzdHlsZXMnKS5cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBfc3R5bGVQcm9wZXJ0aWVzOiBbXG4gICAgICAnc3Ryb2tlJyxcbiAgICAgICdzdHJva2VXaWR0aCcsXG4gICAgICAnZmlsbCcsXG4gICAgICAnZm9udEZhbWlseScsXG4gICAgICAnZm9udFNpemUnLFxuICAgICAgJ2ZvbnRXZWlnaHQnLFxuICAgICAgJ2ZvbnRTdHlsZScsXG4gICAgICAndW5kZXJsaW5lJyxcbiAgICAgICdvdmVybGluZScsXG4gICAgICAnbGluZXRocm91Z2gnLFxuICAgICAgJ2RlbHRhWScsXG4gICAgICAndGV4dEJhY2tncm91bmRDb2xvcicsXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIGNvbnRhaW5zIGNoYXJhY3RlcnMgYm91bmRpbmcgYm94ZXNcbiAgICAgKi9cbiAgICBfX2NoYXJCb3VuZHM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogdXNlIHRoaXMgc2l6ZSB3aGVuIG1lYXN1cmluZyB0ZXh0LiBUbyBhdm9pZCBJRTExIHJvdW5kaW5nIGVycm9yc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENBQ0hFX0ZPTlRfU0laRTogNDAwLFxuXG4gICAgLyoqXG4gICAgICogY29udGFpbnMgdGhlIG1pbiB0ZXh0IHdpZHRoIHRvIGF2b2lkIGdldHRpbmcgMFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBNSU5fVEVYVF9XSURUSDogMixcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGV4dCBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbih0ZXh0LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLnN0eWxlcyA9IG9wdGlvbnMgPyAob3B0aW9ucy5zdHlsZXMgfHwgeyB9KSA6IHsgfTtcbiAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICB0aGlzLl9fc2tpcERpbWVuc2lvbiA9IHRydWU7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fX3NraXBEaW1lbnNpb24gPSBmYWxzZTtcbiAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLnNldHVwU3RhdGUoeyBwcm9wZXJ0eVNldDogJ19kaW1lbnNpb25BZmZlY3RpbmdQcm9wcycgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGNvbnRleCBmb3IgbWVhc3VyZW1lbnQgb2YgdGV4dCBzdHJpbmcuXG4gICAgICogaWYgY3JlYXRlZCBpdCBnZXRzIHN0b3JlZCBmb3IgcmV1c2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUZXh0IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGdldE1lYXN1cmluZ0NvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaWYgd2UgZGlkIG5vdCByZXR1cm4gd2UgaGF2ZSB0byBtZWFzdXJlIHNvbWV0aGluZy5cbiAgICAgIGlmICghZmFicmljLl9tZWFzdXJpbmdDb250ZXh0KSB7XG4gICAgICAgIGZhYnJpYy5fbWVhc3VyaW5nQ29udGV4dCA9IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmNvbnRleHRDYWNoZSB8fFxuICAgICAgICAgIGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhYnJpYy5fbWVhc3VyaW5nQ29udGV4dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBEaXZpZGVzIHRleHQgaW50byBsaW5lcyBvZiB0ZXh0IGFuZCBsaW5lcyBvZiBncmFwaGVtZXMuXG4gICAgICovXG4gICAgX3NwbGl0VGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmV3TGluZXMgPSB0aGlzLl9zcGxpdFRleHRJbnRvTGluZXModGhpcy50ZXh0KTtcbiAgICAgIHRoaXMudGV4dExpbmVzID0gbmV3TGluZXMubGluZXM7XG4gICAgICB0aGlzLl90ZXh0TGluZXMgPSBuZXdMaW5lcy5ncmFwaGVtZUxpbmVzO1xuICAgICAgdGhpcy5fdW53cmFwcGVkVGV4dExpbmVzID0gbmV3TGluZXMuX3Vud3JhcHBlZExpbmVzO1xuICAgICAgdGhpcy5fdGV4dCA9IG5ld0xpbmVzLmdyYXBoZW1lVGV4dDtcbiAgICAgIHJldHVybiBuZXdMaW5lcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBvciB1cGRhdGUgdGV4dCBkaW1lbnNpb25zLlxuICAgICAqIFVwZGF0ZXMgdGhpcy53aWR0aCBhbmQgdGhpcy5oZWlnaHQgd2l0aCB0aGUgcHJvcGVyIHZhbHVlcy5cbiAgICAgKiBEb2VzIG5vdCByZXR1cm4gZGltZW5zaW9ucy5cbiAgICAgKi9cbiAgICBpbml0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fX3NraXBEaW1lbnNpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3BsaXRUZXh0KCk7XG4gICAgICB0aGlzLl9jbGVhckNhY2hlKCk7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5jYWxjVGV4dFdpZHRoKCkgfHwgdGhpcy5jdXJzb3JXaWR0aCB8fCB0aGlzLk1JTl9URVhUX1dJRFRIO1xuICAgICAgaWYgKHRoaXMudGV4dEFsaWduLmluZGV4T2YoJ2p1c3RpZnknKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gb25jZSB0ZXh0IGlzIG1lYXN1cmVkIHdlIG5lZWQgdG8gbWFrZSBzcGFjZSBmYXR0ZXIgdG8gbWFrZSBqdXN0aWZpZWQgdGV4dC5cbiAgICAgICAgdGhpcy5lbmxhcmdlU3BhY2VzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY2FsY1RleHRIZWlnaHQoKTtcbiAgICAgIHRoaXMuc2F2ZVN0YXRlKHsgcHJvcGVydHlTZXQ6ICdfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMnIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmxhcmdlIHNwYWNlIGJveGVzIGFuZCBzaGlmdCB0aGUgb3RoZXJzXG4gICAgICovXG4gICAgZW5sYXJnZVNwYWNlczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGlmZlNwYWNlLCBjdXJyZW50TGluZVdpZHRoLCBudW1iZXJPZlNwYWNlcywgYWNjdW11bGF0ZWRTcGFjZSwgbGluZSwgY2hhckJvdW5kLCBzcGFjZXM7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHRBbGlnbiAhPT0gJ2p1c3RpZnknICYmIChpID09PSBsZW4gLSAxIHx8IHRoaXMuaXNFbmRPZldyYXBwaW5nKGkpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGFjY3VtdWxhdGVkU3BhY2UgPSAwO1xuICAgICAgICBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2ldO1xuICAgICAgICBjdXJyZW50TGluZVdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgoaSk7XG4gICAgICAgIGlmIChjdXJyZW50TGluZVdpZHRoIDwgdGhpcy53aWR0aCAmJiAoc3BhY2VzID0gdGhpcy50ZXh0TGluZXNbaV0ubWF0Y2godGhpcy5fcmVTcGFjZXNBbmRUYWJzKSkpIHtcbiAgICAgICAgICBudW1iZXJPZlNwYWNlcyA9IHNwYWNlcy5sZW5ndGg7XG4gICAgICAgICAgZGlmZlNwYWNlID0gKHRoaXMud2lkdGggLSBjdXJyZW50TGluZVdpZHRoKSAvIG51bWJlck9mU3BhY2VzO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPD0gamxlbjsgaisrKSB7XG4gICAgICAgICAgICBjaGFyQm91bmQgPSB0aGlzLl9fY2hhckJvdW5kc1tpXVtqXTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZVNwYWNlQW5kVGFiLnRlc3QobGluZVtqXSkpIHtcbiAgICAgICAgICAgICAgY2hhckJvdW5kLndpZHRoICs9IGRpZmZTcGFjZTtcbiAgICAgICAgICAgICAgY2hhckJvdW5kLmtlcm5lZFdpZHRoICs9IGRpZmZTcGFjZTtcbiAgICAgICAgICAgICAgY2hhckJvdW5kLmxlZnQgKz0gYWNjdW11bGF0ZWRTcGFjZTtcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZWRTcGFjZSArPSBkaWZmU3BhY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY2hhckJvdW5kLmxlZnQgKz0gYWNjdW11bGF0ZWRTcGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIHRoZSB0ZXh0IGxpbmUgaXMgZW5kZWQgd2l0aCBhbiBoYXJkIGJyZWFrXG4gICAgICogdGV4dCBhbmQgaXRleHQgZG8gbm90IGhhdmUgd3JhcHBpbmcsIHJldHVybiBmYWxzZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbmRPZldyYXBwaW5nOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHJldHVybiBsaW5lSW5kZXggPT09IHRoaXMuX3RleHRMaW5lcy5sZW5ndGggLSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRleHQgb2JqZWN0XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5UZXh0ICgnICsgdGhpcy5jb21wbGV4aXR5KCkgK1xuICAgICAgICAnKTogeyBcInRleHRcIjogXCInICsgdGhpcy50ZXh0ICsgJ1wiLCBcImZvbnRGYW1pbHlcIjogXCInICsgdGhpcy5mb250RmFtaWx5ICsgJ1wiIH0+JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkaW1lbnNpb24gYW5kIHRoZSB6b29tIGxldmVsIG5lZWRlZCB0byBjcmVhdGUgYSBjYWNoZSBjYW52YXNcbiAgICAgKiBiaWcgZW5vdWdoIHRvIGhvc3QgdGhlIG9iamVjdCB0byBiZSBjYWNoZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltLnggd2lkdGggb2Ygb2JqZWN0IHRvIGJlIGNhY2hlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW0ueSBoZWlnaHQgb2Ygb2JqZWN0IHRvIGJlIGNhY2hlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0ud2lkdGggd2lkdGggb2YgY2FudmFzXG4gICAgICogQHJldHVybiB7T2JqZWN0fS5oZWlnaHQgaGVpZ2h0IG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uem9vbVggem9vbVggem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21ZIHpvb21ZIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICovXG4gICAgX2dldENhY2hlQ2FudmFzRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGltcyA9IHRoaXMuY2FsbFN1cGVyKCdfZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zJyk7XG4gICAgICB2YXIgZm9udFNpemUgPSB0aGlzLmZvbnRTaXplO1xuICAgICAgZGltcy53aWR0aCArPSBmb250U2l6ZSAqIGRpbXMuem9vbVg7XG4gICAgICBkaW1zLmhlaWdodCArPSBmb250U2l6ZSAqIGRpbXMuem9vbVk7XG4gICAgICByZXR1cm4gZGltcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl9zZXRUZXh0U3R5bGVzKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0TGluZXNCYWNrZ3JvdW5kKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0RGVjb3JhdGlvbihjdHgsICd1bmRlcmxpbmUnKTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHQoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHREZWNvcmF0aW9uKGN0eCwgJ292ZXJsaW5lJyk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0RGVjb3JhdGlvbihjdHgsICdsaW5ldGhyb3VnaCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAodGhpcy5wYWludEZpcnN0ID09PSAnc3Ryb2tlJykge1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0U3Ryb2tlKGN0eCk7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHRGaWxsKGN0eCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dEZpbGwoY3R4KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dFN0cm9rZShjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZvbnQgcGFyYW1ldGVyIG9mIHRoZSBjb250ZXh0IHdpdGggdGhlIG9iamVjdCBwcm9wZXJ0aWVzIG9yIHdpdGggY2hhclN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjaGFyU3R5bGVdIG9iamVjdCB3aXRoIGZvbnQgc3R5bGUgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY2hhclN0eWxlLmZvbnRGYW1pbHldIEZvbnQgRmFtaWx5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjaGFyU3R5bGUuZm9udFNpemVdIEZvbnQgc2l6ZSBpbiBwaXhlbHMuICggd2l0aG91dCBweCBzdWZmaXggKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY2hhclN0eWxlLmZvbnRXZWlnaHRdIEZvbnQgd2VpZ2h0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjaGFyU3R5bGUuZm9udFN0eWxlXSBGb250IHN0eWxlIChpdGFsaWN8bm9ybWFsKVxuICAgICAqL1xuICAgIF9zZXRUZXh0U3R5bGVzOiBmdW5jdGlvbihjdHgsIGNoYXJTdHlsZSwgZm9yTWVhc3VyaW5nKSB7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWMnO1xuICAgICAgY3R4LmZvbnQgPSB0aGlzLl9nZXRGb250RGVjbGFyYXRpb24oY2hhclN0eWxlLCBmb3JNZWFzdXJpbmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgYW5kIHJldHVybiB0aGUgdGV4dCBXaWR0aCBtZWFzdXJpbmcgZWFjaCBsaW5lLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTWF4aW11bSB3aWR0aCBvZiBmYWJyaWMuVGV4dCBvYmplY3RcbiAgICAgKi9cbiAgICBjYWxjVGV4dFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXhXaWR0aCA9IHRoaXMuZ2V0TGluZVdpZHRoKDApO1xuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyZW50TGluZVdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgoaSk7XG4gICAgICAgIGlmIChjdXJyZW50TGluZVdpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICBtYXhXaWR0aCA9IGN1cnJlbnRMaW5lV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXhXaWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE1ldGhvZCBuYW1lIChcImZpbGxUZXh0XCIgb3IgXCJzdHJva2VUZXh0XCIpXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lIFRleHQgdG8gcmVuZGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBwb3NpdGlvbiBvZiB0ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgcG9zaXRpb24gb2YgdGV4dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggSW5kZXggb2YgYSBsaW5lIGluIGEgdGV4dFxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0TGluZTogZnVuY3Rpb24obWV0aG9kLCBjdHgsIGxpbmUsIGxlZnQsIHRvcCwgbGluZUluZGV4KSB7XG4gICAgICB0aGlzLl9yZW5kZXJDaGFycyhtZXRob2QsIGN0eCwgbGluZSwgbGVmdCwgdG9wLCBsaW5lSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSB0ZXh0IGJhY2tncm91bmQgZm9yIGxpbmVzLCB0YWtpbmcgY2FyZSBvZiBzdHlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0TGluZXNCYWNrZ3JvdW5kOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy50ZXh0QmFja2dyb3VuZENvbG9yICYmICF0aGlzLnN0eWxlSGFzKCd0ZXh0QmFja2dyb3VuZENvbG9yJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGxpbmVUb3BPZmZzZXQgPSAwLCBoZWlnaHRPZkxpbmUsXG4gICAgICAgICAgbGluZUxlZnRPZmZzZXQsIG9yaWdpbmFsRmlsbCA9IGN0eC5maWxsU3R5bGUsXG4gICAgICAgICAgbGluZSwgbGFzdENvbG9yLFxuICAgICAgICAgIGxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCksXG4gICAgICAgICAgdG9wT2Zmc2V0ID0gdGhpcy5fZ2V0VG9wT2Zmc2V0KCksXG4gICAgICAgICAgYm94U3RhcnQgPSAwLCBib3hXaWR0aCA9IDAsIGNoYXJCb3gsIGN1cnJlbnRDb2xvcjtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBoZWlnaHRPZkxpbmUgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKTtcbiAgICAgICAgaWYgKCF0aGlzLnRleHRCYWNrZ3JvdW5kQ29sb3IgJiYgIXRoaXMuc3R5bGVIYXMoJ3RleHRCYWNrZ3JvdW5kQ29sb3InLCBpKSkge1xuICAgICAgICAgIGxpbmVUb3BPZmZzZXQgKz0gaGVpZ2h0T2ZMaW5lO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbaV07XG4gICAgICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQoaSk7XG4gICAgICAgIGJveFdpZHRoID0gMDtcbiAgICAgICAgYm94U3RhcnQgPSAwO1xuICAgICAgICBsYXN0Q29sb3IgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIDAsICd0ZXh0QmFja2dyb3VuZENvbG9yJyk7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgICBjaGFyQm94ID0gdGhpcy5fX2NoYXJCb3VuZHNbaV1bal07XG4gICAgICAgICAgY3VycmVudENvbG9yID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCBqLCAndGV4dEJhY2tncm91bmRDb2xvcicpO1xuICAgICAgICAgIGlmIChjdXJyZW50Q29sb3IgIT09IGxhc3RDb2xvcikge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhc3RDb2xvcjtcbiAgICAgICAgICAgIGxhc3RDb2xvciAmJiBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICAgIGxlZnRPZmZzZXQgKyBsaW5lTGVmdE9mZnNldCArIGJveFN0YXJ0LFxuICAgICAgICAgICAgICB0b3BPZmZzZXQgKyBsaW5lVG9wT2Zmc2V0LFxuICAgICAgICAgICAgICBib3hXaWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYm94U3RhcnQgPSBjaGFyQm94LmxlZnQ7XG4gICAgICAgICAgICBib3hXaWR0aCA9IGNoYXJCb3gud2lkdGg7XG4gICAgICAgICAgICBsYXN0Q29sb3IgPSBjdXJyZW50Q29sb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRDb2xvcikge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjdXJyZW50Q29sb3I7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgbGVmdE9mZnNldCArIGxpbmVMZWZ0T2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgICAgICB0b3BPZmZzZXQgKyBsaW5lVG9wT2Zmc2V0LFxuICAgICAgICAgICAgYm94V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVUb3BPZmZzZXQgKz0gaGVpZ2h0T2ZMaW5lO1xuICAgICAgfVxuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9yaWdpbmFsRmlsbDtcbiAgICAgIC8vIGlmIHRoZXJlIGlzIHRleHQgYmFja2dyb3VuZCBjb2xvciBub1xuICAgICAgLy8gb3RoZXIgc2hhZG93cyBzaG91bGQgYmUgY2FzdGVkXG4gICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVjbCBzdHlsZSBkZWNsYXJhdGlvbiBmb3IgY2FjaGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVjbC5mb250RmFtaWx5IGZvbnRGYW1pbHlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVjbC5mb250U3R5bGUgZm9udFN0eWxlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlY2wuZm9udFdlaWdodCBmb250V2VpZ2h0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSByZWZlcmVuY2UgdG8gY2FjaGVcbiAgICAgKi9cbiAgICBnZXRGb250Q2FjaGU6IGZ1bmN0aW9uKGRlY2wpIHtcbiAgICAgIHZhciBmb250RmFtaWx5ID0gZGVjbC5mb250RmFtaWx5LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoIWZhYnJpYy5jaGFyV2lkdGhzQ2FjaGVbZm9udEZhbWlseV0pIHtcbiAgICAgICAgZmFicmljLmNoYXJXaWR0aHNDYWNoZVtmb250RmFtaWx5XSA9IHsgfTtcbiAgICAgIH1cbiAgICAgIHZhciBjYWNoZSA9IGZhYnJpYy5jaGFyV2lkdGhzQ2FjaGVbZm9udEZhbWlseV0sXG4gICAgICAgICAgY2FjaGVQcm9wID0gZGVjbC5mb250U3R5bGUudG9Mb3dlckNhc2UoKSArICdfJyArIChkZWNsLmZvbnRXZWlnaHQgKyAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghY2FjaGVbY2FjaGVQcm9wXSkge1xuICAgICAgICBjYWNoZVtjYWNoZVByb3BdID0geyB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlW2NhY2hlUHJvcF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGFwcGx5IGFsbCB0aGUgY2hhcmFjdGVyIHN0eWxlIHRvIGNhbnZhcyBmb3IgcmVuZGVyaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gX2NoYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGVjbF1cbiAgICAgKi9cbiAgICBfYXBwbHlDaGFyU3R5bGVzOiBmdW5jdGlvbihtZXRob2QsIGN0eCwgbGluZUluZGV4LCBjaGFySW5kZXgsIHN0eWxlRGVjbGFyYXRpb24pIHtcblxuICAgICAgdGhpcy5fc2V0RmlsbFN0eWxlcyhjdHgsIHN0eWxlRGVjbGFyYXRpb24pO1xuICAgICAgdGhpcy5fc2V0U3Ryb2tlU3R5bGVzKGN0eCwgc3R5bGVEZWNsYXJhdGlvbik7XG5cbiAgICAgIGN0eC5mb250ID0gdGhpcy5fZ2V0Rm9udERlY2xhcmF0aW9uKHN0eWxlRGVjbGFyYXRpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBtZWFzdXJlIGFuZCByZXR1cm4gdGhlIHdpZHRoIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci5cbiAgICAgKiBwb3NzaWJseSBvdmVycmlkZGVuIHRvIGFjY29tbW9kYXRlIGRpZmZlcmVudCBtZWFzdXJlIGxvZ2ljIG9yXG4gICAgICogdG8gaG9vayBzb21lIGV4dGVybmFsIGxpYiBmb3IgY2hhcmFjdGVyIG1lYXN1cmVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2hhciB0byBiZSBtZWFzdXJlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFyU3R5bGUgc3R5bGUgb2YgY2hhciB0byBiZSBtZWFzdXJlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJldmlvdXNDaGFyXSBwcmV2aW91cyBjaGFyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcmV2Q2hhclN0eWxlXSBzdHlsZSBvZiBwcmV2aW91cyBjaGFyXG4gICAgICovXG4gICAgX21lYXN1cmVDaGFyOiBmdW5jdGlvbihfY2hhciwgY2hhclN0eWxlLCBwcmV2aW91c0NoYXIsIHByZXZDaGFyU3R5bGUpIHtcbiAgICAgIC8vIGZpcnN0IGkgdHJ5IHRvIHJldHVybiBmcm9tIGNhY2hlXG4gICAgICB2YXIgZm9udENhY2hlID0gdGhpcy5nZXRGb250Q2FjaGUoY2hhclN0eWxlKSwgZm9udERlY2xhcmF0aW9uID0gdGhpcy5fZ2V0Rm9udERlY2xhcmF0aW9uKGNoYXJTdHlsZSksXG4gICAgICAgICAgcHJldmlvdXNGb250RGVjbGFyYXRpb24gPSB0aGlzLl9nZXRGb250RGVjbGFyYXRpb24ocHJldkNoYXJTdHlsZSksIGNvdXBsZSA9IHByZXZpb3VzQ2hhciArIF9jaGFyLFxuICAgICAgICAgIHN0eWxlc0FyZUVxdWFsID0gZm9udERlY2xhcmF0aW9uID09PSBwcmV2aW91c0ZvbnREZWNsYXJhdGlvbiwgd2lkdGgsIGNvdXBsZVdpZHRoLCBwcmV2aW91c1dpZHRoLFxuICAgICAgICAgIGZvbnRNdWx0aXBsaWVyID0gY2hhclN0eWxlLmZvbnRTaXplIC8gdGhpcy5DQUNIRV9GT05UX1NJWkUsIGtlcm5lZFdpZHRoO1xuXG4gICAgICBpZiAocHJldmlvdXNDaGFyICYmIGZvbnRDYWNoZVtwcmV2aW91c0NoYXJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJldmlvdXNXaWR0aCA9IGZvbnRDYWNoZVtwcmV2aW91c0NoYXJdO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnRDYWNoZVtfY2hhcl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXJuZWRXaWR0aCA9IHdpZHRoID0gZm9udENhY2hlW19jaGFyXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZXNBcmVFcXVhbCAmJiBmb250Q2FjaGVbY291cGxlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvdXBsZVdpZHRoID0gZm9udENhY2hlW2NvdXBsZV07XG4gICAgICAgIGtlcm5lZFdpZHRoID0gY291cGxlV2lkdGggLSBwcmV2aW91c1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQgfHwgcHJldmlvdXNXaWR0aCA9PT0gdW5kZWZpbmVkIHx8IGNvdXBsZVdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuZ2V0TWVhc3VyaW5nQ29udGV4dCgpO1xuICAgICAgICAvLyBzZW5kIGEgVFJVRSB0byBzcGVjaWZ5IG1lYXN1cmluZyBmb250IHNpemUgQ0FDSEVfRk9OVF9TSVpFXG4gICAgICAgIHRoaXMuX3NldFRleHRTdHlsZXMoY3R4LCBjaGFyU3R5bGUsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2VybmVkV2lkdGggPSB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dChfY2hhcikud2lkdGg7XG4gICAgICAgIGZvbnRDYWNoZVtfY2hhcl0gPSB3aWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2aW91c1dpZHRoID09PSB1bmRlZmluZWQgJiYgc3R5bGVzQXJlRXF1YWwgJiYgcHJldmlvdXNDaGFyKSB7XG4gICAgICAgIHByZXZpb3VzV2lkdGggPSBjdHgubWVhc3VyZVRleHQocHJldmlvdXNDaGFyKS53aWR0aDtcbiAgICAgICAgZm9udENhY2hlW3ByZXZpb3VzQ2hhcl0gPSBwcmV2aW91c1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlc0FyZUVxdWFsICYmIGNvdXBsZVdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gd2UgY2FuIG1lYXN1cmUgdGhlIGtlcm5pbmcgY291cGxlIGFuZCBzdWJ0cmFjdCB0aGUgd2lkdGggb2YgdGhlIHByZXZpb3VzIGNoYXJhY3RlclxuICAgICAgICBjb3VwbGVXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChjb3VwbGUpLndpZHRoO1xuICAgICAgICBmb250Q2FjaGVbY291cGxlXSA9IGNvdXBsZVdpZHRoO1xuICAgICAgICBrZXJuZWRXaWR0aCA9IGNvdXBsZVdpZHRoIC0gcHJldmlvdXNXaWR0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aCAqIGZvbnRNdWx0aXBsaWVyLCBrZXJuZWRXaWR0aDoga2VybmVkV2lkdGggKiBmb250TXVsdGlwbGllciB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBoZWlnaHQgb2YgY2hhcmFjdGVyIGF0IGdpdmVuIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmUgdGhlIGxpbmUgbnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXIgdGhlIGNoYXJhY3RlciBudW1iZXJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGZvbnRTaXplIG9mIHRoZSBjaGFyYWN0ZXJcbiAgICAgKi9cbiAgICBnZXRIZWlnaHRPZkNoYXI6IGZ1bmN0aW9uKGxpbmUsIGNoYXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxpbmUsIGNoYXIsICdmb250U2l6ZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBtZWFzdXJlIGEgdGV4dCBsaW5lIG1lYXN1cmluZyBhbGwgY2hhcmFjdGVycy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IGxpbmUgbnVtYmVyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBMaW5lIHdpZHRoXG4gICAgICovXG4gICAgbWVhc3VyZUxpbmU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIGxpbmVJbmZvID0gdGhpcy5fbWVhc3VyZUxpbmUobGluZUluZGV4KTtcbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwKSB7XG4gICAgICAgIGxpbmVJbmZvLndpZHRoIC09IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVJbmZvLndpZHRoIDwgMCkge1xuICAgICAgICBsaW5lSW5mby53aWR0aCA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZUluZm87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG1lYXN1cmUgZXZlcnkgZ3JhcGhlbWUgb2YgYSBsaW5lLCBwb3B1bGF0aW5nIF9fY2hhckJvdW5kc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC53aWR0aCB0b3RhbCB3aWR0aCBvZiBjaGFyYWN0ZXJzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qud2lkdGhPZlNwYWNlcyBsZW5ndGggb2YgY2hhcnMgdGhhdCBtYXRjaCB0aGlzLl9yZVNwYWNlc0FuZFRhYnNcbiAgICAgKi9cbiAgICBfbWVhc3VyZUxpbmU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIHdpZHRoID0gMCwgaSwgZ3JhcGhlbWUsIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XSwgcHJldkdyYXBoZW1lLFxuICAgICAgICAgIGdyYXBoZW1lSW5mbywgbnVtT2ZTcGFjZXMgPSAwLCBsaW5lQm91bmRzID0gbmV3IEFycmF5KGxpbmUubGVuZ3RoKTtcblxuICAgICAgdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XSA9IGxpbmVCb3VuZHM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBncmFwaGVtZSA9IGxpbmVbaV07XG4gICAgICAgIGdyYXBoZW1lSW5mbyA9IHRoaXMuX2dldEdyYXBoZW1lQm94KGdyYXBoZW1lLCBsaW5lSW5kZXgsIGksIHByZXZHcmFwaGVtZSk7XG4gICAgICAgIGxpbmVCb3VuZHNbaV0gPSBncmFwaGVtZUluZm87XG4gICAgICAgIHdpZHRoICs9IGdyYXBoZW1lSW5mby5rZXJuZWRXaWR0aDtcbiAgICAgICAgcHJldkdyYXBoZW1lID0gZ3JhcGhlbWU7XG4gICAgICB9XG4gICAgICAvLyB0aGlzIGxhdGVzdCBib3VuZCBib3ggcmVwcmVzZW50IHRoZSBsYXN0IGNoYXJhY3RlciBvZiB0aGUgbGluZVxuICAgICAgLy8gdG8gc2ltcGxpZnkgY3Vyc29yIGhhbmRsaW5nIGluIGludGVyYWN0aXZlIG1vZGUuXG4gICAgICBsaW5lQm91bmRzW2ldID0ge1xuICAgICAgICBsZWZ0OiBncmFwaGVtZUluZm8gPyBncmFwaGVtZUluZm8ubGVmdCArIGdyYXBoZW1lSW5mby53aWR0aCA6IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBrZXJuZWRXaWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmZvbnRTaXplXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHsgd2lkdGg6IHdpZHRoLCBudW1PZlNwYWNlczogbnVtT2ZTcGFjZXMgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWVhc3VyZSBhbmQgcmV0dXJuIHRoZSBpbmZvIG9mIGEgc2luZ2xlIGdyYXBoZW1lLlxuICAgICAqIG5lZWRzIHRoZSB0aGUgaW5mbyBvZiBwcmV2aW91cyBncmFwaGVtZXMgYWxyZWFkeSBmaWxsZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBncmFwaGVtZSB0byBiZSBtZWFzdXJlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggaW5kZXggb2YgdGhlIGxpbmUgd2hlcmUgdGhlIGNoYXIgaXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4IHBvc2l0aW9uIGluIHRoZSBsaW5lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwcmV2R3JhcGhlbWVdIGNoYXJhY3RlciBwcmVjZWRpbmcgdGhlIG9uZSB0byBiZSBtZWFzdXJlZFxuICAgICAqL1xuICAgIF9nZXRHcmFwaGVtZUJveDogZnVuY3Rpb24oZ3JhcGhlbWUsIGxpbmVJbmRleCwgY2hhckluZGV4LCBwcmV2R3JhcGhlbWUsIHNraXBMZWZ0KSB7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgICAgcHJldlN0eWxlID0gcHJldkdyYXBoZW1lID8gdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBjaGFySW5kZXggLSAxKSA6IHsgfSxcbiAgICAgICAgICBpbmZvID0gdGhpcy5fbWVhc3VyZUNoYXIoZ3JhcGhlbWUsIHN0eWxlLCBwcmV2R3JhcGhlbWUsIHByZXZTdHlsZSksXG4gICAgICAgICAga2VybmVkV2lkdGggPSBpbmZvLmtlcm5lZFdpZHRoLFxuICAgICAgICAgIHdpZHRoID0gaW5mby53aWR0aCwgY2hhclNwYWNpbmc7XG5cbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwKSB7XG4gICAgICAgIGNoYXJTcGFjaW5nID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG4gICAgICAgIHdpZHRoICs9IGNoYXJTcGFjaW5nO1xuICAgICAgICBrZXJuZWRXaWR0aCArPSBjaGFyU3BhY2luZztcbiAgICAgIH1cblxuICAgICAgdmFyIGJveCA9IHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBoZWlnaHQ6IHN0eWxlLmZvbnRTaXplLFxuICAgICAgICBrZXJuZWRXaWR0aDoga2VybmVkV2lkdGgsXG4gICAgICAgIGRlbHRhWTogc3R5bGUuZGVsdGFZLFxuICAgICAgfTtcbiAgICAgIGlmIChjaGFySW5kZXggPiAwICYmICFza2lwTGVmdCkge1xuICAgICAgICB2YXIgcHJldmlvdXNCb3ggPSB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdW2NoYXJJbmRleCAtIDFdO1xuICAgICAgICBib3gubGVmdCA9IHByZXZpb3VzQm94LmxlZnQgKyBwcmV2aW91c0JveC53aWR0aCArIGluZm8ua2VybmVkV2lkdGggLSBpbmZvLndpZHRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJveDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGhlaWdodCBvZiBsaW5lIGF0ICdsaW5lSW5kZXgnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBpbmRleCBvZiBsaW5lIHRvIGNhbGN1bGF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRIZWlnaHRPZkxpbmU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgaWYgKHRoaXMuX19saW5lSGVpZ2h0c1tsaW5lSW5kZXhdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbGluZUhlaWdodHNbbGluZUluZGV4XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XSxcbiAgICAgICAgICAvLyBjaGFyIDAgaXMgbWVhc3VyZWQgYmVmb3JlIHRoZSBsaW5lIGN5Y2xlIGJlY2F1c2UgaXQgbm5lZHMgdG8gY2hhclxuICAgICAgICAgIC8vIGVtcHR5bGluZXNcbiAgICAgICAgICBtYXhIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mQ2hhcihsaW5lSW5kZXgsIDApO1xuICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IGxpbmUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbWF4SGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5nZXRIZWlnaHRPZkNoYXIobGluZUluZGV4LCBpKSwgbWF4SGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX19saW5lSGVpZ2h0c1tsaW5lSW5kZXhdID0gbWF4SGVpZ2h0ICogdGhpcy5saW5lSGVpZ2h0ICogdGhpcy5fZm9udFNpemVNdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGV4dCBib3ggaGVpZ2h0XG4gICAgICovXG4gICAgY2FsY1RleHRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpbmVIZWlnaHQsIGhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxpbmVIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKTtcbiAgICAgICAgaGVpZ2h0ICs9IChpID09PSBsZW4gLSAxID8gbGluZUhlaWdodCAvIHRoaXMubGluZUhlaWdodCA6IGxpbmVIZWlnaHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IExlZnQgb2Zmc2V0XG4gICAgICovXG4gICAgX2dldExlZnRPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIC10aGlzLndpZHRoIC8gMjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRvcCBvZmZzZXRcbiAgICAgKi9cbiAgICBfZ2V0VG9wT2Zmc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAtdGhpcy5oZWlnaHQgLyAyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE1ldGhvZCBuYW1lIChcImZpbGxUZXh0XCIgb3IgXCJzdHJva2VUZXh0XCIpXG4gICAgICovXG4gICAgX3JlbmRlclRleHRDb21tb246IGZ1bmN0aW9uKGN0eCwgbWV0aG9kKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdmFyIGxpbmVIZWlnaHRzID0gMCwgbGVmdCA9IHRoaXMuX2dldExlZnRPZmZzZXQoKSwgdG9wID0gdGhpcy5fZ2V0VG9wT2Zmc2V0KCksXG4gICAgICAgICAgb2Zmc2V0cyA9IHRoaXMuX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtKGN0eCwgbWV0aG9kID09PSAnZmlsbFRleHQnID8gdGhpcy5maWxsIDogdGhpcy5zdHJva2UpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaGVpZ2h0T2ZMaW5lID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSksXG4gICAgICAgICAgICBtYXhIZWlnaHQgPSBoZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHQsXG4gICAgICAgICAgICBsZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQoaSk7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHRMaW5lKFxuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICBjdHgsXG4gICAgICAgICAgdGhpcy5fdGV4dExpbmVzW2ldLFxuICAgICAgICAgIGxlZnQgKyBsZWZ0T2Zmc2V0IC0gb2Zmc2V0cy5vZmZzZXRYLFxuICAgICAgICAgIHRvcCArIGxpbmVIZWlnaHRzICsgbWF4SGVpZ2h0IC0gb2Zmc2V0cy5vZmZzZXRZLFxuICAgICAgICAgIGlcbiAgICAgICAgKTtcbiAgICAgICAgbGluZUhlaWdodHMgKz0gaGVpZ2h0T2ZMaW5lO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclRleHRGaWxsOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5maWxsICYmICF0aGlzLnN0eWxlSGFzKCdmaWxsJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZW5kZXJUZXh0Q29tbW9uKGN0eCwgJ2ZpbGxUZXh0Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0U3Ryb2tlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICgoIXRoaXMuc3Ryb2tlIHx8IHRoaXMuc3Ryb2tlV2lkdGggPT09IDApICYmIHRoaXMuaXNFbXB0eVN0eWxlcygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hhZG93ICYmICF0aGlzLnNoYWRvdy5hZmZlY3RTdHJva2UpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU2hhZG93KGN0eCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHRDb21tb24oY3R4LCAnc3Ryb2tlVGV4dCcpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lIENvbnRlbnQgb2YgdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b3BcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJPZmZzZXRcbiAgICAgKi9cbiAgICBfcmVuZGVyQ2hhcnM6IGZ1bmN0aW9uKG1ldGhvZCwgY3R4LCBsaW5lLCBsZWZ0LCB0b3AsIGxpbmVJbmRleCkge1xuICAgICAgLy8gc2V0IHByb3BlciBsaW5lIG9mZnNldFxuICAgICAgdmFyIGxpbmVIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mTGluZShsaW5lSW5kZXgpLFxuICAgICAgICAgIGlzSnVzdGlmeSA9IHRoaXMudGV4dEFsaWduLmluZGV4T2YoJ2p1c3RpZnknKSAhPT0gLTEsXG4gICAgICAgICAgYWN0dWFsU3R5bGUsXG4gICAgICAgICAgbmV4dFN0eWxlLFxuICAgICAgICAgIGNoYXJzVG9SZW5kZXIgPSAnJyxcbiAgICAgICAgICBjaGFyQm94LFxuICAgICAgICAgIGJveFdpZHRoID0gMCxcbiAgICAgICAgICB0aW1lVG9SZW5kZXIsXG4gICAgICAgICAgc2hvcnRDdXQgPSAhaXNKdXN0aWZ5ICYmIHRoaXMuY2hhclNwYWNpbmcgPT09IDAgJiYgdGhpcy5pc0VtcHR5U3R5bGVzKGxpbmVJbmRleCk7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0b3AgLT0gbGluZUhlaWdodCAqIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24gLyB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICBpZiAoc2hvcnRDdXQpIHtcbiAgICAgICAgLy8gcmVuZGVyIGFsbCB0aGUgbGluZSBpbiBvbmUgcGFzcyB3aXRob3V0IGNoZWNraW5nXG4gICAgICAgIHRoaXMuX3JlbmRlckNoYXIobWV0aG9kLCBjdHgsIGxpbmVJbmRleCwgMCwgdGhpcy50ZXh0TGluZXNbbGluZUluZGV4XSwgbGVmdCwgdG9wLCBsaW5lSGVpZ2h0KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmUubGVuZ3RoIC0gMTsgaSA8PSBsZW47IGkrKykge1xuICAgICAgICB0aW1lVG9SZW5kZXIgPSBpID09PSBsZW4gfHwgdGhpcy5jaGFyU3BhY2luZztcbiAgICAgICAgY2hhcnNUb1JlbmRlciArPSBsaW5lW2ldO1xuICAgICAgICBjaGFyQm94ID0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtpXTtcbiAgICAgICAgaWYgKGJveFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgbGVmdCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoIC0gY2hhckJveC53aWR0aDtcbiAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94LndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJveFdpZHRoICs9IGNoYXJCb3gua2VybmVkV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSnVzdGlmeSAmJiAhdGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3JlU3BhY2VBbmRUYWIudGVzdChsaW5lW2ldKSkge1xuICAgICAgICAgICAgdGltZVRvUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aW1lVG9SZW5kZXIpIHtcbiAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGNoYXJTcGFjaW5nLCB3ZSByZW5kZXIgY2hhciBieSBjaGFyXG4gICAgICAgICAgYWN0dWFsU3R5bGUgPSBhY3R1YWxTdHlsZSB8fCB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGkpO1xuICAgICAgICAgIG5leHRTdHlsZSA9IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgaSArIDEpO1xuICAgICAgICAgIHRpbWVUb1JlbmRlciA9IHRoaXMuX2hhc1N0eWxlQ2hhbmdlZChhY3R1YWxTdHlsZSwgbmV4dFN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyQ2hhcihtZXRob2QsIGN0eCwgbGluZUluZGV4LCBpLCBjaGFyc1RvUmVuZGVyLCBsZWZ0LCB0b3AsIGxpbmVIZWlnaHQpO1xuICAgICAgICAgIGNoYXJzVG9SZW5kZXIgPSAnJztcbiAgICAgICAgICBhY3R1YWxTdHlsZSA9IG5leHRTdHlsZTtcbiAgICAgICAgICBsZWZ0ICs9IGJveFdpZHRoO1xuICAgICAgICAgIGJveFdpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IF9jaGFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSGVpZ2h0IEhlaWdodCBvZiB0aGUgbGluZVxuICAgICAqL1xuICAgIF9yZW5kZXJDaGFyOiBmdW5jdGlvbihtZXRob2QsIGN0eCwgbGluZUluZGV4LCBjaGFySW5kZXgsIF9jaGFyLCBsZWZ0LCB0b3ApIHtcbiAgICAgIHZhciBkZWNsID0gdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgICAgZnVsbERlY2wgPSB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgICAgc2hvdWxkRmlsbCA9IG1ldGhvZCA9PT0gJ2ZpbGxUZXh0JyAmJiBmdWxsRGVjbC5maWxsLFxuICAgICAgICAgIHNob3VsZFN0cm9rZSA9IG1ldGhvZCA9PT0gJ3N0cm9rZVRleHQnICYmIGZ1bGxEZWNsLnN0cm9rZSAmJiBmdWxsRGVjbC5zdHJva2VXaWR0aDtcblxuICAgICAgaWYgKCFzaG91bGRTdHJva2UgJiYgIXNob3VsZEZpbGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVjbCAmJiBjdHguc2F2ZSgpO1xuXG4gICAgICB0aGlzLl9hcHBseUNoYXJTdHlsZXMobWV0aG9kLCBjdHgsIGxpbmVJbmRleCwgY2hhckluZGV4LCBmdWxsRGVjbCk7XG5cbiAgICAgIGlmIChkZWNsICYmIGRlY2wudGV4dEJhY2tncm91bmRDb2xvcikge1xuICAgICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWNsICYmIGRlY2wuZGVsdGFZKSB7XG4gICAgICAgIHRvcCArPSBkZWNsLmRlbHRhWTtcbiAgICAgIH1cblxuICAgICAgc2hvdWxkRmlsbCAmJiBjdHguZmlsbFRleHQoX2NoYXIsIGxlZnQsIHRvcCk7XG4gICAgICBzaG91bGRTdHJva2UgJiYgY3R4LnN0cm9rZVRleHQoX2NoYXIsIGxlZnQsIHRvcCk7XG4gICAgICBkZWNsICYmIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFR1cm5zIHRoZSBjaGFyYWN0ZXIgaW50byBhICdzdXBlcmlvciBmaWd1cmUnIChpLmUuICdzdXBlcnNjcmlwdCcpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IHNlbGVjdGlvbiBzdGFydFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgc2VsZWN0aW9uIGVuZFxuICAgICAqIEByZXR1cm5zIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRTdXBlcnNjcmlwdDogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldFNjcmlwdChzdGFydCwgZW5kLCB0aGlzLnN1cGVyc2NyaXB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHVybnMgdGhlIGNoYXJhY3RlciBpbnRvIGFuICdpbmZlcmlvciBmaWd1cmUnIChpLmUuICdzdWJzY3JpcHQnKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBzZWxlY3Rpb24gc3RhcnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIHNlbGVjdGlvbiBlbmRcbiAgICAgKiBAcmV0dXJucyB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0U3Vic2NyaXB0OiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0U2NyaXB0KHN0YXJ0LCBlbmQsIHRoaXMuc3Vic2NyaXB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyAnc2NoZW1hJyBhdCBnaXZlbiBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IHNlbGVjdGlvbiBzdGFydFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgc2VsZWN0aW9uIGVuZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2hlbWFcbiAgICAgKiBAcmV0dXJucyB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgX3NldFNjcmlwdDogZnVuY3Rpb24oc3RhcnQsIGVuZCwgc2NoZW1hKSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHN0YXJ0LCB0cnVlKSxcbiAgICAgICAgICBmb250U2l6ZSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCwgJ2ZvbnRTaXplJyksXG4gICAgICAgICAgZHkgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgsICdkZWx0YVknKSxcbiAgICAgICAgICBzdHlsZSA9IHsgZm9udFNpemU6IGZvbnRTaXplICogc2NoZW1hLnNpemUsIGRlbHRhWTogZHkgKyBmb250U2l6ZSAqIHNjaGVtYS5iYXNlbGluZSB9O1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdHlsZXMoc3R5bGUsIHN0YXJ0LCBlbmQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByZXZTdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzU3R5bGVcbiAgICAgKi9cbiAgICBfaGFzU3R5bGVDaGFuZ2VkOiBmdW5jdGlvbihwcmV2U3R5bGUsIHRoaXNTdHlsZSkge1xuICAgICAgcmV0dXJuIHByZXZTdHlsZS5maWxsICE9PSB0aGlzU3R5bGUuZmlsbCB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuc3Ryb2tlICE9PSB0aGlzU3R5bGUuc3Ryb2tlIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5zdHJva2VXaWR0aCAhPT0gdGhpc1N0eWxlLnN0cm9rZVdpZHRoIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5mb250U2l6ZSAhPT0gdGhpc1N0eWxlLmZvbnRTaXplIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5mb250RmFtaWx5ICE9PSB0aGlzU3R5bGUuZm9udEZhbWlseSB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuZm9udFdlaWdodCAhPT0gdGhpc1N0eWxlLmZvbnRXZWlnaHQgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLmZvbnRTdHlsZSAhPT0gdGhpc1N0eWxlLmZvbnRTdHlsZSB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuZGVsdGFZICE9PSB0aGlzU3R5bGUuZGVsdGFZO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmV2U3R5bGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGhpc1N0eWxlXG4gICAgICovXG4gICAgX2hhc1N0eWxlQ2hhbmdlZEZvclN2ZzogZnVuY3Rpb24ocHJldlN0eWxlLCB0aGlzU3R5bGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oYXNTdHlsZUNoYW5nZWQocHJldlN0eWxlLCB0aGlzU3R5bGUpIHx8XG4gICAgICAgIHByZXZTdHlsZS5vdmVybGluZSAhPT0gdGhpc1N0eWxlLm92ZXJsaW5lIHx8XG4gICAgICAgIHByZXZTdHlsZS51bmRlcmxpbmUgIT09IHRoaXNTdHlsZS51bmRlcmxpbmUgfHxcbiAgICAgICAgcHJldlN0eWxlLmxpbmV0aHJvdWdoICE9PSB0aGlzU3R5bGUubGluZXRocm91Z2g7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBpbmRleCB0ZXh0IGxpbmVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IExpbmUgbGVmdCBvZmZzZXRcbiAgICAgKi9cbiAgICBfZ2V0TGluZUxlZnRPZmZzZXQ6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIGxpbmVXaWR0aCA9IHRoaXMuZ2V0TGluZVdpZHRoKGxpbmVJbmRleCk7XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHJldHVybiAodGhpcy53aWR0aCAtIGxpbmVXaWR0aCkgLyAyO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoIC0gbGluZVdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudGV4dEFsaWduID09PSAnanVzdGlmeS1jZW50ZXInICYmIHRoaXMuaXNFbmRPZldyYXBwaW5nKGxpbmVJbmRleCkpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLndpZHRoIC0gbGluZVdpZHRoKSAvIDI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24gPT09ICdqdXN0aWZ5LXJpZ2h0JyAmJiB0aGlzLmlzRW5kT2ZXcmFwcGluZyhsaW5lSW5kZXgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoIC0gbGluZVdpZHRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NsZWFyQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fX2xpbmVXaWR0aHMgPSBbXTtcbiAgICAgIHRoaXMuX19saW5lSGVpZ2h0cyA9IFtdO1xuICAgICAgdGhpcy5fX2NoYXJCb3VuZHMgPSBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2hvdWxkQ2xlYXIgPSB0aGlzLl9mb3JjZUNsZWFyQ2FjaGU7XG4gICAgICBzaG91bGRDbGVhciB8fCAoc2hvdWxkQ2xlYXIgPSB0aGlzLmhhc1N0YXRlQ2hhbmdlZCgnX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzJykpO1xuICAgICAgaWYgKHNob3VsZENsZWFyKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLl9mb3JjZUNsZWFyQ2FjaGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaG91bGRDbGVhcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWVhc3VyZSBhIHNpbmdsZSBsaW5lIGdpdmVuIGl0cyBpbmRleC4gVXNlZCB0byBjYWxjdWxhdGUgdGhlIGluaXRpYWxcbiAgICAgKiB0ZXh0IGJvdW5kaW5nIGJveC4gVGhlIHZhbHVlcyBhcmUgY2FsY3VsYXRlZCBhbmQgc3RvcmVkIGluIF9fbGluZVdpZHRocyBjYWNoZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggbGluZSBudW1iZXJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IExpbmUgd2lkdGhcbiAgICAgKi9cbiAgICBnZXRMaW5lV2lkdGg6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgaWYgKHRoaXMuX19saW5lV2lkdGhzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19saW5lV2lkdGhzW2xpbmVJbmRleF07XG4gICAgICB9XG5cbiAgICAgIHZhciB3aWR0aCwgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLCBsaW5lSW5mbztcblxuICAgICAgaWYgKGxpbmUgPT09ICcnKSB7XG4gICAgICAgIHdpZHRoID0gMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsaW5lSW5mbyA9IHRoaXMubWVhc3VyZUxpbmUobGluZUluZGV4KTtcbiAgICAgICAgd2lkdGggPSBsaW5lSW5mby53aWR0aDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19saW5lV2lkdGhzW2xpbmVJbmRleF0gPSB3aWR0aDtcbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuXG4gICAgX2dldFdpZHRoT2ZDaGFyU3BhY2luZzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jaGFyU3BhY2luZyAhPT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb250U2l6ZSAqIHRoaXMuY2hhclNwYWNpbmcgLyAxMDAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgcHJvcGVydHkgYXQgZ2l2ZW4gY2hhcmFjdGVyIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCB0aGUgbGluZSBudW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4IHRoZSBjaGFyYXRlciBudW1iZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgdGhlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJucyB0aGUgdmFsdWUgb2YgJ3Byb3BlcnR5J1xuICAgICAqL1xuICAgIGdldFZhbHVlT2ZQcm9wZXJ0eUF0OiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBjaGFyU3R5bGUgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KTtcbiAgICAgIGlmIChjaGFyU3R5bGUgJiYgdHlwZW9mIGNoYXJTdHlsZVtwcm9wZXJ0eV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBjaGFyU3R5bGVbcHJvcGVydHldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNbcHJvcGVydHldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dERlY29yYXRpb246IGZ1bmN0aW9uKGN0eCwgdHlwZSkge1xuICAgICAgaWYgKCF0aGlzW3R5cGVdICYmICF0aGlzLnN0eWxlSGFzKHR5cGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBoZWlnaHRPZkxpbmUsIHNpemUsIF9zaXplLFxuICAgICAgICAgIGxpbmVMZWZ0T2Zmc2V0LCBkeSwgX2R5LFxuICAgICAgICAgIGxpbmUsIGxhc3REZWNvcmF0aW9uLFxuICAgICAgICAgIGxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCksXG4gICAgICAgICAgdG9wT2Zmc2V0ID0gdGhpcy5fZ2V0VG9wT2Zmc2V0KCksIHRvcCxcbiAgICAgICAgICBib3hTdGFydCwgYm94V2lkdGgsIGNoYXJCb3gsIGN1cnJlbnREZWNvcmF0aW9uLFxuICAgICAgICAgIG1heEhlaWdodCwgY3VycmVudEZpbGwsIGxhc3RGaWxsLFxuICAgICAgICAgIGNoYXJTcGFjaW5nID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaGVpZ2h0T2ZMaW5lID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSk7XG4gICAgICAgIGlmICghdGhpc1t0eXBlXSAmJiAhdGhpcy5zdHlsZUhhcyh0eXBlLCBpKSkge1xuICAgICAgICAgIHRvcE9mZnNldCArPSBoZWlnaHRPZkxpbmU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tpXTtcbiAgICAgICAgbWF4SGVpZ2h0ID0gaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGkpO1xuICAgICAgICBib3hTdGFydCA9IDA7XG4gICAgICAgIGJveFdpZHRoID0gMDtcbiAgICAgICAgbGFzdERlY29yYXRpb24gPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIDAsIHR5cGUpO1xuICAgICAgICBsYXN0RmlsbCA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgMCwgJ2ZpbGwnKTtcbiAgICAgICAgdG9wID0gdG9wT2Zmc2V0ICsgbWF4SGVpZ2h0ICogKDEgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKTtcbiAgICAgICAgc2l6ZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZDaGFyKGksIDApO1xuICAgICAgICBkeSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgMCwgJ2RlbHRhWScpO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGxpbmUubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgICAgY2hhckJveCA9IHRoaXMuX19jaGFyQm91bmRzW2ldW2pdO1xuICAgICAgICAgIGN1cnJlbnREZWNvcmF0aW9uID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCBqLCB0eXBlKTtcbiAgICAgICAgICBjdXJyZW50RmlsbCA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgaiwgJ2ZpbGwnKTtcbiAgICAgICAgICBfc2l6ZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZDaGFyKGksIGopO1xuICAgICAgICAgIF9keSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgaiwgJ2RlbHRhWScpO1xuICAgICAgICAgIGlmICgoY3VycmVudERlY29yYXRpb24gIT09IGxhc3REZWNvcmF0aW9uIHx8IGN1cnJlbnRGaWxsICE9PSBsYXN0RmlsbCB8fCBfc2l6ZSAhPT0gc2l6ZSB8fCBfZHkgIT09IGR5KSAmJlxuICAgICAgICAgICAgICBib3hXaWR0aCA+IDApIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYXN0RmlsbDtcbiAgICAgICAgICAgIGxhc3REZWNvcmF0aW9uICYmIGxhc3RGaWxsICYmIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgbGVmdE9mZnNldCArIGxpbmVMZWZ0T2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgICAgICAgIHRvcCArIHRoaXMub2Zmc2V0c1t0eXBlXSAqIHNpemUgKyBkeSxcbiAgICAgICAgICAgICAgYm94V2lkdGgsXG4gICAgICAgICAgICAgIHRoaXMuZm9udFNpemUgLyAxNVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJveFN0YXJ0ID0gY2hhckJveC5sZWZ0O1xuICAgICAgICAgICAgYm94V2lkdGggPSBjaGFyQm94LndpZHRoO1xuICAgICAgICAgICAgbGFzdERlY29yYXRpb24gPSBjdXJyZW50RGVjb3JhdGlvbjtcbiAgICAgICAgICAgIGxhc3RGaWxsID0gY3VycmVudEZpbGw7XG4gICAgICAgICAgICBzaXplID0gX3NpemU7XG4gICAgICAgICAgICBkeSA9IF9keTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gY3VycmVudEZpbGw7XG4gICAgICAgIGN1cnJlbnREZWNvcmF0aW9uICYmIGN1cnJlbnRGaWxsICYmIGN0eC5maWxsUmVjdChcbiAgICAgICAgICBsZWZ0T2Zmc2V0ICsgbGluZUxlZnRPZmZzZXQgKyBib3hTdGFydCxcbiAgICAgICAgICB0b3AgKyB0aGlzLm9mZnNldHNbdHlwZV0gKiBzaXplICsgZHksXG4gICAgICAgICAgYm94V2lkdGggLSBjaGFyU3BhY2luZyxcbiAgICAgICAgICB0aGlzLmZvbnRTaXplIC8gMTVcbiAgICAgICAgKTtcbiAgICAgICAgdG9wT2Zmc2V0ICs9IGhlaWdodE9mTGluZTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHRoZXJlIGlzIHRleHQgYmFja2dyb3VuZCBjb2xvciBub1xuICAgICAgLy8gb3RoZXIgc2hhZG93cyBzaG91bGQgYmUgY2FzdGVkXG4gICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGZvbnQgZGVjbGFyYXRpb24gc3RyaW5nIGZvciBjYW52YXMgY29udGV4dFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVPYmplY3RdIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IGZvbnQgZGVjbGFyYXRpb24gZm9ybWF0dGVkIGZvciBjYW52YXMgY29udGV4dC5cbiAgICAgKi9cbiAgICBfZ2V0Rm9udERlY2xhcmF0aW9uOiBmdW5jdGlvbihzdHlsZU9iamVjdCwgZm9yTWVhc3VyaW5nKSB7XG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZU9iamVjdCB8fCB0aGlzLCBmYW1pbHkgPSB0aGlzLmZvbnRGYW1pbHksXG4gICAgICAgICAgZm9udElzR2VuZXJpYyA9IGZhYnJpYy5UZXh0LmdlbmVyaWNGb250cy5pbmRleE9mKGZhbWlseS50b0xvd2VyQ2FzZSgpKSA+IC0xO1xuICAgICAgdmFyIGZvbnRGYW1pbHkgPSBmYW1pbHkgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgZmFtaWx5LmluZGV4T2YoJ1xcJycpID4gLTEgfHxcbiAgICAgIGZhbWlseS5pbmRleE9mKCdcIicpID4gLTEgfHwgZm9udElzR2VuZXJpY1xuICAgICAgICA/IHN0eWxlLmZvbnRGYW1pbHkgOiAnXCInICsgc3R5bGUuZm9udEZhbWlseSArICdcIic7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAvLyBub2RlLWNhbnZhcyBuZWVkcyBcIndlaWdodCBzdHlsZVwiLCB3aGlsZSBicm93c2VycyBuZWVkIFwic3R5bGUgd2VpZ2h0XCJcbiAgICAgICAgKGZhYnJpYy5pc0xpa2VseU5vZGUgPyBzdHlsZS5mb250V2VpZ2h0IDogc3R5bGUuZm9udFN0eWxlKSxcbiAgICAgICAgKGZhYnJpYy5pc0xpa2VseU5vZGUgPyBzdHlsZS5mb250U3R5bGUgOiBzdHlsZS5mb250V2VpZ2h0KSxcbiAgICAgICAgZm9yTWVhc3VyaW5nID8gdGhpcy5DQUNIRV9GT05UX1NJWkUgKyAncHgnIDogc3R5bGUuZm9udFNpemUgKyAncHgnLFxuICAgICAgICBmb250RmFtaWx5XG4gICAgICBdLmpvaW4oJyAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0ZXh0IGluc3RhbmNlIG9uIGEgc3BlY2lmaWVkIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIC8vIGRvIG5vdCByZW5kZXIgaWYgb2JqZWN0IGlzIG5vdCB2aXNpYmxlXG4gICAgICBpZiAoIXRoaXMudmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuc2tpcE9mZnNjcmVlbiAmJiAhdGhpcy5ncm91cCAmJiAhdGhpcy5pc09uU2NyZWVuKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGUoKSkge1xuICAgICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGxTdXBlcigncmVuZGVyJywgY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGV4dCBhcyBhbiBhcnJheSBvZiBsaW5lcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0ZXh0IHRvIHNwbGl0XG4gICAgICogQHJldHVybnMge0FycmF5fSBMaW5lcyBpbiB0aGUgdGV4dFxuICAgICAqL1xuICAgIF9zcGxpdFRleHRJbnRvTGluZXM6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQodGhpcy5fcmVOZXdsaW5lKSxcbiAgICAgICAgICBuZXdMaW5lcyA9IG5ldyBBcnJheShsaW5lcy5sZW5ndGgpLFxuICAgICAgICAgIG5ld0xpbmUgPSBbJ1xcbiddLFxuICAgICAgICAgIG5ld1RleHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3TGluZXNbaV0gPSBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdChsaW5lc1tpXSk7XG4gICAgICAgIG5ld1RleHQgPSBuZXdUZXh0LmNvbmNhdChuZXdMaW5lc1tpXSwgbmV3TGluZSk7XG4gICAgICB9XG4gICAgICBuZXdUZXh0LnBvcCgpO1xuICAgICAgcmV0dXJuIHsgX3Vud3JhcHBlZExpbmVzOiBuZXdMaW5lcywgbGluZXM6IGxpbmVzLCBncmFwaGVtZVRleHQ6IG5ld1RleHQsIGdyYXBoZW1lTGluZXM6IG5ld0xpbmVzIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBhZGRpdGlvbmFsUHJvcGVydGllcyA9IFtcbiAgICAgICAgJ3RleHQnLFxuICAgICAgICAnZm9udFNpemUnLFxuICAgICAgICAnZm9udFdlaWdodCcsXG4gICAgICAgICdmb250RmFtaWx5JyxcbiAgICAgICAgJ2ZvbnRTdHlsZScsXG4gICAgICAgICdsaW5lSGVpZ2h0JyxcbiAgICAgICAgJ3VuZGVybGluZScsXG4gICAgICAgICdvdmVybGluZScsXG4gICAgICAgICdsaW5ldGhyb3VnaCcsXG4gICAgICAgICd0ZXh0QWxpZ24nLFxuICAgICAgICAndGV4dEJhY2tncm91bmRDb2xvcicsXG4gICAgICAgICdjaGFyU3BhY2luZycsXG4gICAgICBdLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIHZhciBvYmogPSB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBhZGRpdGlvbmFsUHJvcGVydGllcyk7XG4gICAgICBvYmouc3R5bGVzID0gY2xvbmUodGhpcy5zdHlsZXMsIHRydWUpO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBwcm9wZXJ0eSB0byBhIGdpdmVuIHZhbHVlLiBXaGVuIGNoYW5naW5nIHBvc2l0aW9uL2RpbWVuc2lvbiAtcmVsYXRlZCBwcm9wZXJ0aWVzIChsZWZ0LCB0b3AsIHNjYWxlLCBhbmdsZSwgZXRjLikgYHNldGAgZG9lcyBub3QgdXBkYXRlIHBvc2l0aW9uIG9mIG9iamVjdCdzIGJvcmRlcnMvY29udHJvbHMuIElmIHlvdSBuZWVkIHRvIHVwZGF0ZSB0aG9zZSwgY2FsbCBgc2V0Q29vcmRzKClgLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ga2V5IFByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IChpZiBvYmplY3QsIGl0ZXJhdGUgb3ZlciB0aGUgb2JqZWN0IHByb3BlcnRpZXMpXG4gICAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHZhbHVlIFByb3BlcnR5IHZhbHVlIChpZiBmdW5jdGlvbiwgdGhlIHZhbHVlIGlzIHBhc3NlZCBpbnRvIGl0IGFuZCBpdHMgcmV0dXJuIHZhbHVlIGlzIHVzZWQgYXMgYSBuZXcgb25lKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignc2V0Jywga2V5LCB2YWx1ZSk7XG4gICAgICB2YXIgbmVlZHNEaW1zID0gZmFsc2U7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIgX2tleSBpbiBrZXkpIHtcbiAgICAgICAgICBuZWVkc0RpbXMgPSBuZWVkc0RpbXMgfHwgdGhpcy5fZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMuaW5kZXhPZihfa2V5KSAhPT0gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZWVkc0RpbXMgPSB0aGlzLl9kaW1lbnNpb25BZmZlY3RpbmdQcm9wcy5pbmRleE9mKGtleSkgIT09IC0xO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRzRGltcykge1xuICAgICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb21wbGV4aXR5IG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5XG4gICAgICovXG4gICAgY29tcGxleGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLlRleHQuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dFxuICAgKiBAc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvdGV4dC5odG1sI1RleHRFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuVGV4dC5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KFxuICAgICd4IHkgZHggZHkgZm9udC1mYW1pbHkgZm9udC1zdHlsZSBmb250LXdlaWdodCBmb250LXNpemUgbGV0dGVyLXNwYWNpbmcgdGV4dC1kZWNvcmF0aW9uIHRleHQtYW5jaG9yJy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogRGVmYXVsdCBTVkcgZm9udCBzaXplXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0XG4gICAqL1xuICBmYWJyaWMuVGV4dC5ERUZBVUxUX1NWR19GT05UX1NJWkUgPSAxNjtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuVGV4dCBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50ICg8Yj5ub3QgeWV0IGltcGxlbWVudGVkPC9iPilcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHRcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5UZXh0LmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLlRleHQuQVRUUklCVVRFX05BTUVTKSxcbiAgICAgICAgcGFyc2VkQW5jaG9yID0gcGFyc2VkQXR0cmlidXRlcy50ZXh0QW5jaG9yIHx8ICdsZWZ0JztcbiAgICBvcHRpb25zID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCgob3B0aW9ucyA/IGNsb25lKG9wdGlvbnMpIDogeyB9KSwgcGFyc2VkQXR0cmlidXRlcyk7XG5cbiAgICBvcHRpb25zLnRvcCA9IG9wdGlvbnMudG9wIHx8IDA7XG4gICAgb3B0aW9ucy5sZWZ0ID0gb3B0aW9ucy5sZWZ0IHx8IDA7XG4gICAgaWYgKHBhcnNlZEF0dHJpYnV0ZXMudGV4dERlY29yYXRpb24pIHtcbiAgICAgIHZhciB0ZXh0RGVjb3JhdGlvbiA9IHBhcnNlZEF0dHJpYnV0ZXMudGV4dERlY29yYXRpb247XG4gICAgICBpZiAodGV4dERlY29yYXRpb24uaW5kZXhPZigndW5kZXJsaW5lJykgIT09IC0xKSB7XG4gICAgICAgIG9wdGlvbnMudW5kZXJsaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdvdmVybGluZScpICE9PSAtMSkge1xuICAgICAgICBvcHRpb25zLm92ZXJsaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdsaW5lLXRocm91Z2gnKSAhPT0gLTEpIHtcbiAgICAgICAgb3B0aW9ucy5saW5ldGhyb3VnaCA9IHRydWU7XG4gICAgICB9XG4gICAgICBkZWxldGUgb3B0aW9ucy50ZXh0RGVjb3JhdGlvbjtcbiAgICB9XG4gICAgaWYgKCdkeCcgaW4gcGFyc2VkQXR0cmlidXRlcykge1xuICAgICAgb3B0aW9ucy5sZWZ0ICs9IHBhcnNlZEF0dHJpYnV0ZXMuZHg7XG4gICAgfVxuICAgIGlmICgnZHknIGluIHBhcnNlZEF0dHJpYnV0ZXMpIHtcbiAgICAgIG9wdGlvbnMudG9wICs9IHBhcnNlZEF0dHJpYnV0ZXMuZHk7XG4gICAgfVxuICAgIGlmICghKCdmb250U2l6ZScgaW4gb3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnMuZm9udFNpemUgPSBmYWJyaWMuVGV4dC5ERUZBVUxUX1NWR19GT05UX1NJWkU7XG4gICAgfVxuXG4gICAgdmFyIHRleHRDb250ZW50ID0gJyc7XG5cbiAgICAvLyBUaGUgWE1MIGlzIG5vdCBwcm9wZXJseSBwYXJzZWQgaW4gSUU5IHNvIGEgd29ya2Fyb3VuZCB0byBnZXRcbiAgICAvLyB0ZXh0Q29udGVudCBpcyB0aHJvdWdoIGZpcnN0Q2hpbGQuZGF0YS4gQW5vdGhlciB3b3JrYXJvdW5kIHdvdWxkIGJlXG4gICAgLy8gdG8gY29udmVydCBYTUwgbG9hZGVkIGZyb20gYSBmaWxlIHRvIGJlIGNvbnZlcnRlZCB1c2luZyBET01QYXJzZXIgKHNhbWUgd2F5IGxvYWRTVkdGcm9tU3RyaW5nKCkgZG9lcylcbiAgICBpZiAoISgndGV4dENvbnRlbnQnIGluIGVsZW1lbnQpKSB7XG4gICAgICBpZiAoJ2ZpcnN0Q2hpbGQnIGluIGVsZW1lbnQgJiYgZWxlbWVudC5maXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGlmICgnZGF0YScgaW4gZWxlbWVudC5maXJzdENoaWxkICYmIGVsZW1lbnQuZmlyc3RDaGlsZC5kYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgdGV4dENvbnRlbnQgPSBlbGVtZW50LmZpcnN0Q2hpbGQuZGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRleHRDb250ZW50ID0gZWxlbWVudC50ZXh0Q29udGVudDtcbiAgICB9XG5cbiAgICB0ZXh0Q29udGVudCA9IHRleHRDb250ZW50LnJlcGxhY2UoL15cXHMrfFxccyskfFxcbisvZywgJycpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICB2YXIgb3JpZ2luYWxTdHJva2VXaWR0aCA9IG9wdGlvbnMuc3Ryb2tlV2lkdGg7XG4gICAgb3B0aW9ucy5zdHJva2VXaWR0aCA9IDA7XG5cbiAgICB2YXIgdGV4dCA9IG5ldyBmYWJyaWMuVGV4dCh0ZXh0Q29udGVudCwgb3B0aW9ucyksXG4gICAgICAgIHRleHRIZWlnaHRTY2FsZUZhY3RvciA9IHRleHQuZ2V0U2NhbGVkSGVpZ2h0KCkgLyB0ZXh0LmhlaWdodCxcbiAgICAgICAgbGluZUhlaWdodERpZmYgPSAodGV4dC5oZWlnaHQgKyB0ZXh0LnN0cm9rZVdpZHRoKSAqIHRleHQubGluZUhlaWdodCAtIHRleHQuaGVpZ2h0LFxuICAgICAgICBzY2FsZWREaWZmID0gbGluZUhlaWdodERpZmYgKiB0ZXh0SGVpZ2h0U2NhbGVGYWN0b3IsXG4gICAgICAgIHRleHRIZWlnaHQgPSB0ZXh0LmdldFNjYWxlZEhlaWdodCgpICsgc2NhbGVkRGlmZixcbiAgICAgICAgb2ZmWCA9IDA7XG4gICAgLypcbiAgICAgIEFkanVzdCBwb3NpdGlvbmluZzpcbiAgICAgICAgeC95IGF0dHJpYnV0ZXMgaW4gU1ZHIGNvcnJlc3BvbmQgdG8gdGhlIGJvdHRvbS1sZWZ0IGNvcm5lciBvZiB0ZXh0IGJvdW5kaW5nIGJveFxuICAgICAgICBmYWJyaWMgb3V0cHV0IGJ5IGRlZmF1bHQgYXQgdG9wLCBsZWZ0LlxuICAgICovXG4gICAgaWYgKHBhcnNlZEFuY2hvciA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIG9mZlggPSB0ZXh0LmdldFNjYWxlZFdpZHRoKCkgLyAyO1xuICAgIH1cbiAgICBpZiAocGFyc2VkQW5jaG9yID09PSAncmlnaHQnKSB7XG4gICAgICBvZmZYID0gdGV4dC5nZXRTY2FsZWRXaWR0aCgpO1xuICAgIH1cbiAgICB0ZXh0LnNldCh7XG4gICAgICBsZWZ0OiB0ZXh0LmxlZnQgLSBvZmZYLFxuICAgICAgdG9wOiB0ZXh0LnRvcCAtICh0ZXh0SGVpZ2h0IC0gdGV4dC5mb250U2l6ZSAqICgwLjA3ICsgdGV4dC5fZm9udFNpemVGcmFjdGlvbikpIC8gdGV4dC5saW5lSGVpZ2h0LFxuICAgICAgc3Ryb2tlV2lkdGg6IHR5cGVvZiBvcmlnaW5hbFN0cm9rZVdpZHRoICE9PSAndW5kZWZpbmVkJyA/IG9yaWdpbmFsU3Ryb2tlV2lkdGggOiAxLFxuICAgIH0pO1xuICAgIGNhbGxiYWNrKHRleHQpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5UZXh0IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlRleHQgaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlRleHQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnVGV4dCcsIG9iamVjdCwgY2FsbGJhY2ssICd0ZXh0Jyk7XG4gIH07XG5cbiAgZmFicmljLlRleHQuZ2VuZXJpY0ZvbnRzID0gWydzYW5zLXNlcmlmJywgJ3NlcmlmJywgJ2N1cnNpdmUnLCAnZmFudGFzeScsICdtb25vc3BhY2UnXTtcblxuICBmYWJyaWMudXRpbC5jcmVhdGVBY2Nlc3NvcnMgJiYgZmFicmljLnV0aWwuY3JlYXRlQWNjZXNzb3JzKGZhYnJpYy5UZXh0KTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuVGV4dC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlRleHQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBubyBzdHlsaW5nIG9yIG5vIHN0eWxpbmcgaW4gYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCAsIGxpbmVJbmRleCBpcyBvbiB3cmFwcGVkIGxpbmVzLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbXB0eVN0eWxlczogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBsaW5lSW5kZXggIT09ICd1bmRlZmluZWQnICYmICF0aGlzLnN0eWxlc1tsaW5lSW5kZXhdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IHR5cGVvZiBsaW5lSW5kZXggPT09ICd1bmRlZmluZWQnID8gdGhpcy5zdHlsZXMgOiB7IGxpbmU6IHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gfTtcbiAgICAgIGZvciAodmFyIHAxIGluIG9iaikge1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBvYmpbcDFdKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgZm9yICh2YXIgcDMgaW4gb2JqW3AxXVtwMl0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBhIHN0eWxlIHByb3BlcnR5IG9yIGhhcyBpdCBpbmEgc3BlY2lmaWVkIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdHlsZUhhczogZnVuY3Rpb24ocHJvcGVydHksIGxpbmVJbmRleCkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlcyB8fCAhcHJvcGVydHkgfHwgcHJvcGVydHkgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbGluZUluZGV4ICE9PSAndW5kZWZpbmVkJyAmJiAhdGhpcy5zdHlsZXNbbGluZUluZGV4XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gdHlwZW9mIGxpbmVJbmRleCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLnN0eWxlcyA6IHsgbGluZTogdGhpcy5zdHlsZXNbbGluZUluZGV4XSB9O1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBmb3IgKHZhciBwMSBpbiBvYmopIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGZvciAodmFyIHAyIGluIG9ialtwMV0pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9ialtwMV1bcDJdW3Byb3BlcnR5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjaGFyYWN0ZXJzIGluIGEgdGV4dCBoYXZlIGEgdmFsdWUgZm9yIGEgcHJvcGVydHlcbiAgICAgKiB3aG9zZSB2YWx1ZSBtYXRjaGVzIHRoZSB0ZXh0Ym94J3MgdmFsdWUgZm9yIHRoYXQgcHJvcGVydHkuICBJZiBzbyxcbiAgICAgKiB0aGUgY2hhcmFjdGVyLWxldmVsIHByb3BlcnR5IGlzIGRlbGV0ZWQuICBJZiB0aGUgY2hhcmFjdGVyXG4gICAgICogaGFzIG5vIG90aGVyIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYWxzbyBkZWxldGVkLiAgRmluYWxseSxcbiAgICAgKiBpZiB0aGUgbGluZSBjb250YWluaW5nIHRoYXQgY2hhcmFjdGVyIGhhcyBubyBvdGhlciBjaGFyYWN0ZXJzXG4gICAgICogdGhlbiBpdCBhbHNvIGlzIGRlbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5IHRvIGNvbXBhcmUgYmV0d2VlbiBjaGFyYWN0ZXJzIGFuZCB0ZXh0LlxuICAgICAqL1xuICAgIGNsZWFuU3R5bGU6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzIHx8ICFwcm9wZXJ0eSB8fCBwcm9wZXJ0eSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IHRoaXMuc3R5bGVzLCBzdHlsZXNDb3VudCA9IDAsIGxldHRlckNvdW50LCBzdHlsZVByb3BlcnR5VmFsdWUsXG4gICAgICAgICAgYWxsU3R5bGVPYmplY3RQcm9wZXJ0aWVzTWF0Y2ggPSB0cnVlLCBncmFwaGVtZUNvdW50ID0gMCwgc3R5bGVPYmplY3Q7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGZvciAodmFyIHAxIGluIG9iaikge1xuICAgICAgICBsZXR0ZXJDb3VudCA9IDA7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBmb3IgKHZhciBwMiBpbiBvYmpbcDFdKSB7XG4gICAgICAgICAgdmFyIHN0eWxlT2JqZWN0ID0gb2JqW3AxXVtwMl0sXG4gICAgICAgICAgICAgIHN0eWxlUHJvcGVydHlIYXNCZWVuU2V0ID0gc3R5bGVPYmplY3QuaGFzT3duUHJvcGVydHkocHJvcGVydHkpO1xuXG4gICAgICAgICAgc3R5bGVzQ291bnQrKztcblxuICAgICAgICAgIGlmIChzdHlsZVByb3BlcnR5SGFzQmVlblNldCkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICAgICAgc3R5bGVQcm9wZXJ0eVZhbHVlID0gc3R5bGVPYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3R5bGVPYmplY3RbcHJvcGVydHldICE9PSBzdHlsZVByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICAgICAgYWxsU3R5bGVPYmplY3RQcm9wZXJ0aWVzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0eWxlT2JqZWN0W3Byb3BlcnR5XSA9PT0gdGhpc1twcm9wZXJ0eV0pIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlT2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhbGxTdHlsZU9iamVjdFByb3BlcnRpZXNNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzdHlsZU9iamVjdCkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBsZXR0ZXJDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpbcDFdW3AyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGV0dGVyQ291bnQgPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgb2JqW3AxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaWYgZXZlcnkgZ3JhcGhlbWUgaGFzIHRoZSBzYW1lIHN0eWxlIHNldCB0aGVuXG4gICAgICAvLyBkZWxldGUgdGhvc2Ugc3R5bGVzIGFuZCBzZXQgaXQgb24gdGhlIHBhcmVudFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ3JhcGhlbWVDb3VudCArPSB0aGlzLl90ZXh0TGluZXNbaV0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGFsbFN0eWxlT2JqZWN0UHJvcGVydGllc01hdGNoICYmIHN0eWxlc0NvdW50ID09PSBncmFwaGVtZUNvdW50KSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gc3R5bGVQcm9wZXJ0eVZhbHVlO1xuICAgICAgICB0aGlzLnJlbW92ZVN0eWxlKHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgc3R5bGUgcHJvcGVydHkgb3IgcHJvcGVydGllcyBmcm9tIGFsbCBpbmRpdmlkdWFsIGNoYXJhY3RlciBzdHlsZXNcbiAgICAgKiBpbiBhIHRleHQgb2JqZWN0LiAgRGVsZXRlcyB0aGUgY2hhcmFjdGVyIHN0eWxlIG9iamVjdCBpZiBpdCBjb250YWlucyBubyBvdGhlciBzdHlsZVxuICAgICAqIHByb3BzLiAgRGVsZXRlcyBhIGxpbmUgc3R5bGUgb2JqZWN0IGlmIGl0IGNvbnRhaW5zIG5vIG90aGVyIGNoYXJhY3RlciBzdHlsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcHMgVGhlIHByb3BlcnR5IHRvIHJlbW92ZSBmcm9tIGNoYXJhY3RlciBzdHlsZXMuXG4gICAgICovXG4gICAgcmVtb3ZlU3R5bGU6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzIHx8ICFwcm9wZXJ0eSB8fCBwcm9wZXJ0eSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IHRoaXMuc3R5bGVzLCBsaW5lLCBsaW5lTnVtLCBjaGFyTnVtO1xuICAgICAgZm9yIChsaW5lTnVtIGluIG9iaikge1xuICAgICAgICBsaW5lID0gb2JqW2xpbmVOdW1dO1xuICAgICAgICBmb3IgKGNoYXJOdW0gaW4gbGluZSkge1xuICAgICAgICAgIGRlbGV0ZSBsaW5lW2NoYXJOdW1dW3Byb3BlcnR5XTtcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobGluZVtjaGFyTnVtXSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgbGluZVtjaGFyTnVtXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGxpbmUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBvYmpbbGluZU51bV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZXh0ZW5kU3R5bGVzOiBmdW5jdGlvbihpbmRleCwgc3R5bGVzKSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKGluZGV4KTtcblxuICAgICAgaWYgKCF0aGlzLl9nZXRMaW5lU3R5bGUobG9jLmxpbmVJbmRleCkpIHtcbiAgICAgICAgdGhpcy5fc2V0TGluZVN0eWxlKGxvYy5saW5lSW5kZXgsIHt9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgpKSB7XG4gICAgICAgIHRoaXMuX3NldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCwge30pO1xuICAgICAgfVxuXG4gICAgICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCksIHN0eWxlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgMmQgcmVwcmVzZW50YXRpb24gKGxpbmVJbmRleCBhbmQgY2hhckluZGV4KSBvZiBjdXJzb3IgKG9yIHNlbGVjdGlvbiBzdGFydClcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NlbGVjdGlvblN0YXJ0XSBPcHRpb25hbCBpbmRleC4gV2hlbiBub3QgZ2l2ZW4sIGN1cnJlbnQgc2VsZWN0aW9uU3RhcnQgaXMgdXNlZC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwV3JhcHBpbmddIGNvbnNpZGVyIHRoZSBsb2NhdGlvbiBmb3IgdW53cmFwcGVkIGxpbmVzLiB1c2VmdWxsIHRvIG1hbmFnZSBzdHlsZXMuXG4gICAgICovXG4gICAgZ2V0MkRDdXJzb3JMb2NhdGlvbjogZnVuY3Rpb24oc2VsZWN0aW9uU3RhcnQsIHNraXBXcmFwcGluZykge1xuICAgICAgaWYgKHR5cGVvZiBzZWxlY3Rpb25TdGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgfVxuICAgICAgdmFyIGxpbmVzID0gc2tpcFdyYXBwaW5nID8gdGhpcy5fdW53cmFwcGVkVGV4dExpbmVzIDogdGhpcy5fdGV4dExpbmVzO1xuICAgICAgdmFyIGxlbiA9IGxpbmVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0IDw9IGxpbmVzW2ldLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lSW5kZXg6IGksXG4gICAgICAgICAgICBjaGFySW5kZXg6IHNlbGVjdGlvblN0YXJ0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Rpb25TdGFydCAtPSBsaW5lc1tpXS5sZW5ndGggKyAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZUluZGV4OiBpIC0gMSxcbiAgICAgICAgY2hhckluZGV4OiBsaW5lc1tpIC0gMV0ubGVuZ3RoIDwgc2VsZWN0aW9uU3RhcnQgPyBsaW5lc1tpIC0gMV0ubGVuZ3RoIDogc2VsZWN0aW9uU3RhcnRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgc3R5bGUgb2YgYSBjdXJyZW50IHNlbGVjdGlvbi9jdXJzb3IgKGF0IHRoZSBzdGFydCBwb3NpdGlvbilcbiAgICAgKiBpZiBzdGFydEluZGV4IG9yIGVuZEluZGV4IGFyZSBub3QgcHJvdmlkZWQsIHNsZWN0aW9uU3RhcnQgb3Igc2VsZWN0aW9uRW5kIHdpbGwgYmUgdXNlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0SW5kZXhdIFN0YXJ0IGluZGV4IHRvIGdldCBzdHlsZXMgYXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZEluZGV4XSBFbmQgaW5kZXggdG8gZ2V0IHN0eWxlcyBhdCwgaWYgbm90IHNwZWNpZmllZCBzZWxlY3Rpb25FbmQgb3Igc3RhcnRJbmRleCArIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wbGV0ZV0gZ2V0IGZ1bGwgc3R5bGUgb3Igbm90XG4gICAgICogQHJldHVybiB7QXJyYXl9IHN0eWxlcyBhbiBhcnJheSB3aXRoIG9uZSwgemVybyBvciBtb3JlIFN0eWxlIG9iamVjdHNcbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb25TdHlsZXM6IGZ1bmN0aW9uKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBjb21wbGV0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBzdGFydEluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzdGFydEluZGV4ID0gdGhpcy5zZWxlY3Rpb25TdGFydCB8fCAwO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbmRJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZW5kSW5kZXggPSB0aGlzLnNlbGVjdGlvbkVuZCB8fCBzdGFydEluZGV4O1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XG4gICAgICAgIHN0eWxlcy5wdXNoKHRoaXMuZ2V0U3R5bGVBdFBvc2l0aW9uKGksIGNvbXBsZXRlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHN0eWxlIG9mIGEgY3VycmVudCBzZWxlY3Rpb24vY3Vyc29yIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uICB0byBnZXQgc3R5bGVzIGF0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29tcGxldGVdIGZ1bGwgc3R5bGUgaWYgdHJ1ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gc3R5bGUgU3R5bGUgb2JqZWN0IGF0IGEgc3BlY2lmaWVkIGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRTdHlsZUF0UG9zaXRpb246IGZ1bmN0aW9uKHBvc2l0aW9uLCBjb21wbGV0ZSkge1xuICAgICAgdmFyIGxvYyA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihwb3NpdGlvbiksXG4gICAgICAgICAgc3R5bGUgPSBjb21wbGV0ZSA/IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgpIDpcbiAgICAgICAgICAgIHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCk7XG4gICAgICByZXR1cm4gc3R5bGUgfHwge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgc3R5bGUgb2YgYSBjdXJyZW50IHNlbGVjdGlvbiwgaWYgbm8gc2VsZWN0aW9uIGV4aXN0LCBkbyBub3Qgc2V0IGFueXRoaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVzXSBTdHlsZXMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydEluZGV4XSBTdGFydCBpbmRleCB0byBnZXQgc3R5bGVzIGF0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmRJbmRleF0gRW5kIGluZGV4IHRvIGdldCBzdHlsZXMgYXQsIGlmIG5vdCBzcGVjaWZpZWQgc2VsZWN0aW9uRW5kIG9yIHN0YXJ0SW5kZXggKyAxXG4gICAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFNlbGVjdGlvblN0eWxlczogZnVuY3Rpb24oc3R5bGVzLCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgICAgaWYgKHR5cGVvZiBzdGFydEluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzdGFydEluZGV4ID0gdGhpcy5zZWxlY3Rpb25TdGFydCB8fCAwO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbmRJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZW5kSW5kZXggPSB0aGlzLnNlbGVjdGlvbkVuZCB8fCBzdGFydEluZGV4O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2V4dGVuZFN0eWxlcyhpLCBzdHlsZXMpO1xuICAgICAgfVxuICAgICAgLyogbm90IGluY2x1ZGVkIGluIF9leHRlbmRTdHlsZXMgdG8gYXZvaWQgY2xlYXJpbmcgY2FjaGUgbW9yZSB0aGFuIG9uY2UgKi9cbiAgICAgIHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSByZWZlcmVuY2UsIG5vdCBhIGNsb25lLCBvZiB0aGUgc3R5bGUgb2JqZWN0IGZvciBhIGdpdmVuIGNoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzdHlsZSBvYmplY3RcbiAgICAgKi9cbiAgICBfZ2V0U3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIHZhciBsaW5lU3R5bGUgPSB0aGlzLnN0eWxlcyAmJiB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdO1xuICAgICAgaWYgKCFsaW5lU3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZVN0eWxlW2NoYXJJbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhIG5ldyBvYmplY3QgdGhhdCBjb250YWlucyBhbGwgdGhlIHN0eWxlIHByb3BlcnR5IGZvciBhIGNoYXJhY3RlclxuICAgICAqIHRoZSBvYmplY3QgcmV0dXJuZWQgaXMgbmV3bHkgY3JlYXRlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggb2YgdGhlIGxpbmUgd2hlcmUgdGhlIGNoYXJhY3RlciBpc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXggcG9zaXRpb24gb2YgdGhlIGNoYXJhY3RlciBvbiB0aGUgbGluZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gc3R5bGUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgdmFyIHN0eWxlID0gdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkgfHwgeyB9LFxuICAgICAgICAgIHN0eWxlT2JqZWN0ID0geyB9LCBwcm9wO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zdHlsZVByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJvcCA9IHRoaXMuX3N0eWxlUHJvcGVydGllc1tpXTtcbiAgICAgICAgc3R5bGVPYmplY3RbcHJvcF0gPSB0eXBlb2Ygc3R5bGVbcHJvcF0gPT09ICd1bmRlZmluZWQnID8gdGhpc1twcm9wXSA6IHN0eWxlW3Byb3BdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4LCBzdHlsZSkge1xuICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXhdID0gc3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHlsZXNbbGluZUluZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldExpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4LCBzdHlsZSkge1xuICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XSA9IHN0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGVsZXRlTGluZVN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBwYXJzZURlY29yYXRpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdC50ZXh0RGVjb3JhdGlvbikge1xuICAgICAgb2JqZWN0LnRleHREZWNvcmF0aW9uLmluZGV4T2YoJ3VuZGVybGluZScpID4gLTEgJiYgKG9iamVjdC51bmRlcmxpbmUgPSB0cnVlKTtcbiAgICAgIG9iamVjdC50ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdsaW5lLXRocm91Z2gnKSA+IC0xICYmIChvYmplY3QubGluZXRocm91Z2ggPSB0cnVlKTtcbiAgICAgIG9iamVjdC50ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdvdmVybGluZScpID4gLTEgJiYgKG9iamVjdC5vdmVybGluZSA9IHRydWUpO1xuICAgICAgZGVsZXRlIG9iamVjdC50ZXh0RGVjb3JhdGlvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSVRleHQgY2xhc3MgKGludHJvZHVjZWQgaW4gPGI+djEuNDwvYj4pIEV2ZW50cyBhcmUgYWxzbyBmaXJlZCB3aXRoIFwidGV4dDpcIlxuICAgKiBwcmVmaXggd2hlbiBvYnNlcnZpbmcgY2FudmFzLlxuICAgKiBAY2xhc3MgZmFicmljLklUZXh0XG4gICAqIEBleHRlbmRzIGZhYnJpYy5UZXh0XG4gICAqIEBtaXhlcyBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKlxuICAgKiBAZmlyZXMgY2hhbmdlZFxuICAgKiBAZmlyZXMgc2VsZWN0aW9uOmNoYW5nZWRcbiAgICogQGZpcmVzIGVkaXRpbmc6ZW50ZXJlZFxuICAgKiBAZmlyZXMgZWRpdGluZzpleGl0ZWRcbiAgICpcbiAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JVGV4dCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKlxuICAgKiA8cD5TdXBwb3J0ZWQga2V5IGNvbWJpbmF0aW9uczo8L3A+XG4gICAqIDxwcmU+XG4gICAqICAgTW92ZSBjdXJzb3I6ICAgICAgICAgICAgICAgICAgICBsZWZ0LCByaWdodCwgdXAsIGRvd25cbiAgICogICBTZWxlY3QgY2hhcmFjdGVyOiAgICAgICAgICAgICAgIHNoaWZ0ICsgbGVmdCwgc2hpZnQgKyByaWdodFxuICAgKiAgIFNlbGVjdCB0ZXh0IHZlcnRpY2FsbHk6ICAgICAgICAgc2hpZnQgKyB1cCwgc2hpZnQgKyBkb3duXG4gICAqICAgTW92ZSBjdXJzb3IgYnkgd29yZDogICAgICAgICAgICBhbHQgKyBsZWZ0LCBhbHQgKyByaWdodFxuICAgKiAgIFNlbGVjdCB3b3JkczogICAgICAgICAgICAgICAgICAgc2hpZnQgKyBhbHQgKyBsZWZ0LCBzaGlmdCArIGFsdCArIHJpZ2h0XG4gICAqICAgTW92ZSBjdXJzb3IgdG8gbGluZSBzdGFydC9lbmQ6ICBjbWQgKyBsZWZ0LCBjbWQgKyByaWdodCBvciBob21lLCBlbmRcbiAgICogICBTZWxlY3QgdGlsbCBzdGFydC9lbmQgb2YgbGluZTogIGNtZCArIHNoaWZ0ICsgbGVmdCwgY21kICsgc2hpZnQgKyByaWdodCBvciBzaGlmdCArIGhvbWUsIHNoaWZ0ICsgZW5kXG4gICAqICAgSnVtcCB0byBzdGFydC9lbmQgb2YgdGV4dDogICAgICBjbWQgKyB1cCwgY21kICsgZG93blxuICAgKiAgIFNlbGVjdCB0aWxsIHN0YXJ0L2VuZCBvZiB0ZXh0OiAgY21kICsgc2hpZnQgKyB1cCwgY21kICsgc2hpZnQgKyBkb3duIG9yIHNoaWZ0ICsgcGdVcCwgc2hpZnQgKyBwZ0Rvd25cbiAgICogICBEZWxldGUgY2hhcmFjdGVyOiAgICAgICAgICAgICAgIGJhY2tzcGFjZVxuICAgKiAgIERlbGV0ZSB3b3JkOiAgICAgICAgICAgICAgICAgICAgYWx0ICsgYmFja3NwYWNlXG4gICAqICAgRGVsZXRlIGxpbmU6ICAgICAgICAgICAgICAgICAgICBjbWQgKyBiYWNrc3BhY2VcbiAgICogICBGb3J3YXJkIGRlbGV0ZTogICAgICAgICAgICAgICAgIGRlbGV0ZVxuICAgKiAgIENvcHkgdGV4dDogICAgICAgICAgICAgICAgICAgICAgY3RybC9jbWQgKyBjXG4gICAqICAgUGFzdGUgdGV4dDogICAgICAgICAgICAgICAgICAgICBjdHJsL2NtZCArIHZcbiAgICogICBDdXQgdGV4dDogICAgICAgICAgICAgICAgICAgICAgIGN0cmwvY21kICsgeFxuICAgKiAgIFNlbGVjdCBlbnRpcmUgdGV4dDogICAgICAgICAgICAgY3RybC9jbWQgKyBhXG4gICAqICAgUXVpdCBlZGl0aW5nICAgICAgICAgICAgICAgICAgICB0YWIgb3IgZXNjXG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiA8cD5TdXBwb3J0ZWQgbW91c2UvdG91Y2ggY29tYmluYXRpb248L3A+XG4gICAqIDxwcmU+XG4gICAqICAgUG9zaXRpb24gY3Vyc29yOiAgICAgICAgICAgICAgICBjbGljay90b3VjaFxuICAgKiAgIENyZWF0ZSBzZWxlY3Rpb246ICAgICAgICAgICAgICAgY2xpY2svdG91Y2ggJiBkcmFnXG4gICAqICAgQ3JlYXRlIHNlbGVjdGlvbjogICAgICAgICAgICAgICBjbGljayAmIHNoaWZ0ICsgY2xpY2tcbiAgICogICBTZWxlY3Qgd29yZDogICAgICAgICAgICAgICAgICAgIGRvdWJsZSBjbGlja1xuICAgKiAgIFNlbGVjdCBsaW5lOiAgICAgICAgICAgICAgICAgICAgdHJpcGxlIGNsaWNrXG4gICAqIDwvcHJlPlxuICAgKi9cbiAgZmFicmljLklUZXh0ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLlRleHQsIGZhYnJpYy5PYnNlcnZhYmxlLCAvKiogQGxlbmRzIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdpLXRleHQnLFxuXG4gICAgLyoqXG4gICAgICogSW5kZXggd2hlcmUgdGV4dCBzZWxlY3Rpb24gc3RhcnRzIChvciB3aGVyZSBjdXJzb3IgaXMgd2hlbiB0aGVyZSBpcyBubyBzZWxlY3Rpb24pXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25TdGFydDogMCxcblxuICAgIC8qKlxuICAgICAqIEluZGV4IHdoZXJlIHRleHQgc2VsZWN0aW9uIGVuZHNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkVuZDogMCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIHRleHQgc2VsZWN0aW9uXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25Db2xvcjogJ3JnYmEoMTcsMTE5LDI1NSwwLjMpJyxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRleHQgaXMgaW4gZWRpdGluZyBtb2RlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaXNFZGl0aW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGEgdGV4dCBjYW4gYmUgZWRpdGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZWRpdGFibGU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBCb3JkZXIgY29sb3Igb2YgdGV4dCBvYmplY3Qgd2hpbGUgaXQncyBpbiBlZGl0aW5nIG1vZGVcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGVkaXRpbmdCb3JkZXJDb2xvcjogJ3JnYmEoMTAyLDE1MywyNTUsMC4yNSknLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgY3Vyc29yIChpbiBweClcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGN1cnNvcldpZHRoOiAyLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgZGVmYXVsdCBjdXJzb3IgKHdoZW4gbm90IG92ZXJ3cml0dGVuIGJ5IGNoYXJhY3RlciBzdHlsZSlcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGN1cnNvckNvbG9yOiAnIzMzMycsXG5cbiAgICAvKipcbiAgICAgKiBEZWxheSBiZXR3ZWVuIGN1cnNvciBibGluayAoaW4gbXMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjdXJzb3JEZWxheTogMTAwMCxcblxuICAgIC8qKlxuICAgICAqIER1cmF0aW9uIG9mIGN1cnNvciBmYWRlaW4gKGluIG1zKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3Vyc29yRHVyYXRpb246IDYwMCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGludGVybmFsIHRleHQgY2hhciB3aWR0aHMgY2FuIGJlIGNhY2hlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNhY2hpbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZVNwYWNlOiAvXFxzfFxcbi8sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jdXJyZW50Q3Vyc29yT3BhY2l0eTogMCxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NlbGVjdGlvbkRpcmVjdGlvbjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Fib3J0Q3Vyc29yQW5pbWF0aW9uOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX193aWR0aE9mU3BhY2U6IFtdLFxuXG4gICAgLyoqXG4gICAgICogSGVscHMgZGV0ZXJtaW5pbmcgd2hlbiB0aGUgdGV4dCBpcyBpbiBjb21wb3NpdGlvbiwgc28gdGhhdCB0aGUgY3Vyc29yXG4gICAgICogcmVuZGVyaW5nIGlzIGFsdGVyZWQuXG4gICAgICovXG4gICAgaW5Db21wb3NpdGlvbk1vZGU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUZXh0IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbih0ZXh0LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIHRleHQsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5pbml0QmVoYXZpb3IoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzZWxlY3Rpb24gc3RhcnQgKGxlZnQgYm91bmRhcnkgb2YgYSBzZWxlY3Rpb24pXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IEluZGV4IHRvIHNldCBzZWxlY3Rpb24gc3RhcnQgdG9cbiAgICAgKi9cbiAgICBzZXRTZWxlY3Rpb25TdGFydDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGluZGV4ID0gTWF0aC5tYXgoaW5kZXgsIDApO1xuICAgICAgdGhpcy5fdXBkYXRlQW5kRmlyZSgnc2VsZWN0aW9uU3RhcnQnLCBpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgc2VsZWN0aW9uIGVuZCAocmlnaHQgYm91bmRhcnkgb2YgYSBzZWxlY3Rpb24pXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IEluZGV4IHRvIHNldCBzZWxlY3Rpb24gZW5kIHRvXG4gICAgICovXG4gICAgc2V0U2VsZWN0aW9uRW5kOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaW5kZXggPSBNYXRoLm1pbihpbmRleCwgdGhpcy50ZXh0Lmxlbmd0aCk7XG4gICAgICB0aGlzLl91cGRhdGVBbmRGaXJlKCdzZWxlY3Rpb25FbmQnLCBpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5ICdzZWxlY3Rpb25TdGFydCcgb3IgJ3NlbGVjdGlvbkVuZCdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggbmV3IHBvc2l0aW9uIG9mIHByb3BlcnR5XG4gICAgICovXG4gICAgX3VwZGF0ZUFuZEZpcmU6IGZ1bmN0aW9uKHByb3BlcnR5LCBpbmRleCkge1xuICAgICAgaWYgKHRoaXNbcHJvcGVydHldICE9PSBpbmRleCkge1xuICAgICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGluZGV4O1xuICAgICAgfVxuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlyZXMgdGhlIGV2ZW4gb2Ygc2VsZWN0aW9uIGNoYW5nZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlU2VsZWN0aW9uQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmZpcmUoJ3NlbGVjdGlvbjpjaGFuZ2VkJyk7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5maXJlKCd0ZXh0OnNlbGVjdGlvbjpjaGFuZ2VkJywgeyB0YXJnZXQ6IHRoaXMgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGV4dCBkaW1lbnNpb25zLiBSZW5kZXIgYWxsIHRleHQgb24gZ2l2ZW4gY29udGV4dFxuICAgICAqIG9yIG9uIGEgb2Zmc2NyZWVuIGNhbnZhcyB0byBnZXQgdGhlIHRleHQgd2lkdGggd2l0aCBtZWFzdXJlVGV4dC5cbiAgICAgKiBVcGRhdGVzIHRoaXMud2lkdGggYW5kIHRoaXMuaGVpZ2h0IHdpdGggdGhlIHByb3BlciB2YWx1ZXMuXG4gICAgICogRG9lcyBub3QgcmV0dXJuIGRpbWVuc2lvbnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzRWRpdGluZyAmJiB0aGlzLmluaXREZWxheWVkQ3Vyc29yKCk7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dFRvcCgpO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXREaW1lbnNpb25zJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dFRvcCgpO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ3JlbmRlcicsIGN0eCk7XG4gICAgICAvLyBjbGVhciB0aGUgY3Vyc29yT2Zmc2V0Q2FjaGUsIHNvIHdlIGVuc3VyZSB0byBjYWxjdWxhdGUgb25jZSBwZXIgcmVuZGVyQ3Vyc29yXG4gICAgICAvLyB0aGUgY29ycmVjdCBwb3NpdGlvbiBidXQgbm90IGF0IGV2ZXJ5IGN1cnNvciBhbmltYXRpb24uXG4gICAgICB0aGlzLmN1cnNvck9mZnNldENhY2hlID0geyB9O1xuICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfcmVuZGVyJywgY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSBhbmQgY2xlYW4gdGhlIGNvbnRleHRUb3BcbiAgICAgKi9cbiAgICBjbGVhckNvbnRleHRUb3A6IGZ1bmN0aW9uKHNraXBSZXN0b3JlKSB7XG4gICAgICBpZiAoIXRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jb250ZXh0VG9wKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLCB2ID0gdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm07XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKGN0eCk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ICYmIGN0eC50cmFuc2Zvcm0uYXBwbHkoY3R4LCB0aGlzLnRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICAgIHRoaXMuX2NsZWFyVGV4dEFyZWEoY3R4KTtcbiAgICAgICAgc2tpcFJlc3RvcmUgfHwgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjdXJzb3Igb3Igc2VsZWN0aW9uIChkZXBlbmRpbmcgb24gd2hhdCBleGlzdHMpXG4gICAgICovXG4gICAgcmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmlzRWRpdGluZyB8fCAhdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGJvdW5kYXJpZXMgPSB0aGlzLl9nZXRDdXJzb3JCb3VuZGFyaWVzKCksIGN0eDtcbiAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jb250ZXh0VG9wKSB7XG4gICAgICAgIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRDb250YWluZXI7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJDdXJzb3IoYm91bmRhcmllcywgY3R4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnJlbmRlclNlbGVjdGlvbihib3VuZGFyaWVzLCBjdHgpO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgX2NsZWFyVGV4dEFyZWE6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgLy8gd2UgYWRkIDQgcGl4ZWwsIHRvIGJlIHN1cmUgdG8gZG8gbm90IGxlYXZlIGFueSBwaXhlbCBvdXRcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGggKyA0LCBoZWlnaHQgPSB0aGlzLmhlaWdodCArIDQ7XG4gICAgICBjdHguY2xlYXJSZWN0KC13aWR0aCAvIDIsIC1oZWlnaHQgLyAyLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjdXJzb3IgYm91bmRhcmllcyAobGVmdCwgdG9wLCBsZWZ0T2Zmc2V0LCB0b3BPZmZzZXQpXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjaGFycyBBcnJheSBvZiBjaGFyYWN0ZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVPZkJvdW5kYXJpZXNcbiAgICAgKi9cbiAgICBfZ2V0Q3Vyc29yQm91bmRhcmllczogZnVuY3Rpb24ocG9zaXRpb24pIHtcblxuICAgICAgLy8gbGVmdC90b3AgYXJlIGxlZnQvdG9wIG9mIGVudGlyZSB0ZXh0IGJveFxuICAgICAgLy8gbGVmdE9mZnNldC90b3BPZmZzZXQgYXJlIG9mZnNldCBmcm9tIHRoYXQgbGVmdC90b3AgcG9pbnQgb2YgYSB0ZXh0IGJveFxuXG4gICAgICBpZiAodHlwZW9mIHBvc2l0aW9uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwb3NpdGlvbiA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZWZ0ID0gdGhpcy5fZ2V0TGVmdE9mZnNldCgpLFxuICAgICAgICAgIHRvcCA9IHRoaXMuX2dldFRvcE9mZnNldCgpLFxuICAgICAgICAgIG9mZnNldHMgPSB0aGlzLl9nZXRDdXJzb3JCb3VuZGFyaWVzT2Zmc2V0cyhwb3NpdGlvbik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICBsZWZ0T2Zmc2V0OiBvZmZzZXRzLmxlZnQsXG4gICAgICAgIHRvcE9mZnNldDogb2Zmc2V0cy50b3BcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEN1cnNvckJvdW5kYXJpZXNPZmZzZXRzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgaWYgKHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgJiYgJ3RvcCcgaW4gdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3JPZmZzZXRDYWNoZTtcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lTGVmdE9mZnNldCxcbiAgICAgICAgICBsaW5lSW5kZXgsXG4gICAgICAgICAgY2hhckluZGV4LFxuICAgICAgICAgIHRvcE9mZnNldCA9IDAsXG4gICAgICAgICAgbGVmdE9mZnNldCA9IDAsXG4gICAgICAgICAgYm91bmRhcmllcyxcbiAgICAgICAgICBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihwb3NpdGlvbik7XG4gICAgICBjaGFySW5kZXggPSBjdXJzb3JQb3NpdGlvbi5jaGFySW5kZXg7XG4gICAgICBsaW5lSW5kZXggPSBjdXJzb3JQb3NpdGlvbi5saW5lSW5kZXg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVJbmRleDsgaSsrKSB7XG4gICAgICAgIHRvcE9mZnNldCArPSB0aGlzLmdldEhlaWdodE9mTGluZShpKTtcbiAgICAgIH1cbiAgICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQobGluZUluZGV4KTtcbiAgICAgIHZhciBib3VuZCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1bY2hhckluZGV4XTtcbiAgICAgIGJvdW5kICYmIChsZWZ0T2Zmc2V0ID0gYm91bmQubGVmdCk7XG4gICAgICBpZiAodGhpcy5jaGFyU3BhY2luZyAhPT0gMCAmJiBjaGFySW5kZXggPT09IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLmxlbmd0aCkge1xuICAgICAgICBsZWZ0T2Zmc2V0IC09IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgfVxuICAgICAgYm91bmRhcmllcyA9IHtcbiAgICAgICAgdG9wOiB0b3BPZmZzZXQsXG4gICAgICAgIGxlZnQ6IGxpbmVMZWZ0T2Zmc2V0ICsgKGxlZnRPZmZzZXQgPiAwID8gbGVmdE9mZnNldCA6IDApLFxuICAgICAgfTtcbiAgICAgIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgPSBib3VuZGFyaWVzO1xuICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgY3Vyc29yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJvdW5kYXJpZXNcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IHRyYW5zZm9ybWVkIGNvbnRleHQgdG8gZHJhdyBvblxuICAgICAqL1xuICAgIHJlbmRlckN1cnNvcjogZnVuY3Rpb24oYm91bmRhcmllcywgY3R4KSB7XG4gICAgICB2YXIgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oKSxcbiAgICAgICAgICBsaW5lSW5kZXggPSBjdXJzb3JMb2NhdGlvbi5saW5lSW5kZXgsXG4gICAgICAgICAgY2hhckluZGV4ID0gY3Vyc29yTG9jYXRpb24uY2hhckluZGV4ID4gMCA/IGN1cnNvckxvY2F0aW9uLmNoYXJJbmRleCAtIDEgOiAwLFxuICAgICAgICAgIGNoYXJIZWlnaHQgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxpbmVJbmRleCwgY2hhckluZGV4LCAnZm9udFNpemUnKSxcbiAgICAgICAgICBtdWx0aXBsaWVyID0gdGhpcy5zY2FsZVggKiB0aGlzLmNhbnZhcy5nZXRab29tKCksXG4gICAgICAgICAgY3Vyc29yV2lkdGggPSB0aGlzLmN1cnNvcldpZHRoIC8gbXVsdGlwbGllcixcbiAgICAgICAgICB0b3BPZmZzZXQgPSBib3VuZGFyaWVzLnRvcE9mZnNldCxcbiAgICAgICAgICBkeSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobGluZUluZGV4LCBjaGFySW5kZXgsICdkZWx0YVknKTtcblxuICAgICAgdG9wT2Zmc2V0ICs9ICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbikgKiB0aGlzLmdldEhlaWdodE9mTGluZShsaW5lSW5kZXgpIC8gdGhpcy5saW5lSGVpZ2h0XG4gICAgICAgIC0gY2hhckhlaWdodCAqICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbik7XG5cbiAgICAgIGlmICh0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyU2VsZWN0aW9uKGJvdW5kYXJpZXMsIGN0eCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxpbmVJbmRleCwgY2hhckluZGV4LCAnZmlsbCcpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5fX2lzTW91c2Vkb3duID8gMSA6IHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5O1xuICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICBib3VuZGFyaWVzLmxlZnQgKyBib3VuZGFyaWVzLmxlZnRPZmZzZXQgLSBjdXJzb3JXaWR0aCAvIDIsXG4gICAgICAgIHRvcE9mZnNldCArIGJvdW5kYXJpZXMudG9wICsgZHksXG4gICAgICAgIGN1cnNvcldpZHRoLFxuICAgICAgICBjaGFySGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0ZXh0IHNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib3VuZGFyaWVzIE9iamVjdCB3aXRoIGxlZnQvdG9wL2xlZnRPZmZzZXQvdG9wT2Zmc2V0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCB0cmFuc2Zvcm1lZCBjb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKi9cbiAgICByZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKGJvdW5kYXJpZXMsIGN0eCkge1xuXG4gICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID8gdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25TdGFydCA6IHRoaXMuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgc2VsZWN0aW9uRW5kID0gdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA/IHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uRW5kIDogdGhpcy5zZWxlY3Rpb25FbmQsXG4gICAgICAgICAgaXNKdXN0aWZ5ID0gdGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSxcbiAgICAgICAgICBzdGFydCA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzZWxlY3Rpb25TdGFydCksXG4gICAgICAgICAgZW5kID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHNlbGVjdGlvbkVuZCksXG4gICAgICAgICAgc3RhcnRMaW5lID0gc3RhcnQubGluZUluZGV4LFxuICAgICAgICAgIGVuZExpbmUgPSBlbmQubGluZUluZGV4LFxuICAgICAgICAgIHN0YXJ0Q2hhciA9IHN0YXJ0LmNoYXJJbmRleCA8IDAgPyAwIDogc3RhcnQuY2hhckluZGV4LFxuICAgICAgICAgIGVuZENoYXIgPSBlbmQuY2hhckluZGV4IDwgMCA/IDAgOiBlbmQuY2hhckluZGV4O1xuXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xuICAgICAgICB2YXIgbGluZU9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGkpIHx8IDAsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSksXG4gICAgICAgICAgICByZWFsTGluZUhlaWdodCA9IDAsIGJveFN0YXJ0ID0gMCwgYm94RW5kID0gMDtcblxuICAgICAgICBpZiAoaSA9PT0gc3RhcnRMaW5lKSB7XG4gICAgICAgICAgYm94U3RhcnQgPSB0aGlzLl9fY2hhckJvdW5kc1tzdGFydExpbmVdW3N0YXJ0Q2hhcl0ubGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+PSBzdGFydExpbmUgJiYgaSA8IGVuZExpbmUpIHtcbiAgICAgICAgICBib3hFbmQgPSBpc0p1c3RpZnkgJiYgIXRoaXMuaXNFbmRPZldyYXBwaW5nKGkpID8gdGhpcy53aWR0aCA6IHRoaXMuZ2V0TGluZVdpZHRoKGkpIHx8IDU7IC8vIFdURiBpcyB0aGlzIDU/XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA9PT0gZW5kTGluZSkge1xuICAgICAgICAgIGlmIChlbmRDaGFyID09PSAwKSB7XG4gICAgICAgICAgICBib3hFbmQgPSB0aGlzLl9fY2hhckJvdW5kc1tlbmRMaW5lXVtlbmRDaGFyXS5sZWZ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjaGFyU3BhY2luZyA9IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgICAgICAgYm94RW5kID0gdGhpcy5fX2NoYXJCb3VuZHNbZW5kTGluZV1bZW5kQ2hhciAtIDFdLmxlZnRcbiAgICAgICAgICAgICAgKyB0aGlzLl9fY2hhckJvdW5kc1tlbmRMaW5lXVtlbmRDaGFyIC0gMV0ud2lkdGggLSBjaGFyU3BhY2luZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVhbExpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5saW5lSGVpZ2h0IDwgMSB8fCAoaSA9PT0gZW5kTGluZSAmJiB0aGlzLmxpbmVIZWlnaHQgPiAxKSkge1xuICAgICAgICAgIGxpbmVIZWlnaHQgLz0gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29tcG9zaXRpb25Db2xvciB8fCAnYmxhY2snO1xuICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgIGJvdW5kYXJpZXMubGVmdCArIGxpbmVPZmZzZXQgKyBib3hTdGFydCxcbiAgICAgICAgICAgIGJvdW5kYXJpZXMudG9wICsgYm91bmRhcmllcy50b3BPZmZzZXQgKyBsaW5lSGVpZ2h0LFxuICAgICAgICAgICAgYm94RW5kIC0gYm94U3RhcnQsXG4gICAgICAgICAgICAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5zZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICBib3VuZGFyaWVzLmxlZnQgKyBsaW5lT2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgICAgICBib3VuZGFyaWVzLnRvcCArIGJvdW5kYXJpZXMudG9wT2Zmc2V0LFxuICAgICAgICAgICAgYm94RW5kIC0gYm94U3RhcnQsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0KTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgYm91bmRhcmllcy50b3BPZmZzZXQgKz0gcmVhbExpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZ2ggbGV2ZWwgZnVuY3Rpb24gdG8ga25vdyB0aGUgaGVpZ2h0IG9mIHRoZSBjdXJzb3IuXG4gICAgICogdGhlIGN1cnJlbnRDaGFyIGlzIHRoZSBvbmUgdGhhdCBwcmVjZWRlcyB0aGUgY3Vyc29yXG4gICAgICogUmV0dXJucyBmb250U2l6ZSBvZiBjaGFyIGF0IHRoZSBjdXJyZW50IGN1cnNvclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gQ2hhcmFjdGVyIGZvbnQgc2l6ZVxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDaGFyRm9udFNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNwID0gdGhpcy5fZ2V0Q3VycmVudENoYXJJbmRleCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoY3AubCwgY3AuYywgJ2ZvbnRTaXplJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZ2ggbGV2ZWwgZnVuY3Rpb24gdG8ga25vdyB0aGUgY29sb3Igb2YgdGhlIGN1cnNvci5cbiAgICAgKiB0aGUgY3VycmVudENoYXIgaXMgdGhlIG9uZSB0aGF0IHByZWNlZGVzIHRoZSBjdXJzb3JcbiAgICAgKiBSZXR1cm5zIGNvbG9yIChmaWxsKSBvZiBjaGFyIGF0IHRoZSBjdXJyZW50IGN1cnNvclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gQ2hhcmFjdGVyIGNvbG9yIChmaWxsKVxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDaGFyQ29sb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNwID0gdGhpcy5fZ2V0Q3VycmVudENoYXJJbmRleCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoY3AubCwgY3AuYywgJ2ZpbGwnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3Vyc29yIHBvc2l0aW9uIGZvciB0aGUgZ2V0Q3VycmVudC4uIGZ1bmN0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEN1cnJlbnRDaGFySW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGN1cnNvclBvc2l0aW9uID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHRoaXMuc2VsZWN0aW9uU3RhcnQsIHRydWUpLFxuICAgICAgICAgIGNoYXJJbmRleCA9IGN1cnNvclBvc2l0aW9uLmNoYXJJbmRleCA+IDAgPyBjdXJzb3JQb3NpdGlvbi5jaGFySW5kZXggLSAxIDogMDtcbiAgICAgIHJldHVybiB7IGw6IGN1cnNvclBvc2l0aW9uLmxpbmVJbmRleCwgYzogY2hhckluZGV4IH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuSVRleHQgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLklUZXh0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gaW52b2tlZCB3aXRoIG5ldyBpbnN0YW5jZSBhcyBhcmd1bWVudFxuICAgKi9cbiAgZmFicmljLklUZXh0LmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcGFyc2VEZWNvcmF0aW9uKG9iamVjdCk7XG4gICAgaWYgKG9iamVjdC5zdHlsZXMpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gb2JqZWN0LnN0eWxlcykge1xuICAgICAgICBmb3IgKHZhciBqIGluIG9iamVjdC5zdHlsZXNbaV0pIHtcbiAgICAgICAgICBwYXJzZURlY29yYXRpb24ob2JqZWN0LnN0eWxlc1tpXVtqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnSVRleHQnLCBvYmplY3QsIGNhbGxiYWNrLCAndGV4dCcpO1xuICB9O1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lO1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLklUZXh0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuSVRleHQucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFsbCB0aGUgaW50ZXJhY3RpdmUgYmVoYXZpb3Igb2YgSVRleHRcbiAgICAgKi9cbiAgICBpbml0QmVoYXZpb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pbml0QWRkZWRIYW5kbGVyKCk7XG4gICAgICB0aGlzLmluaXRSZW1vdmVkSGFuZGxlcigpO1xuICAgICAgdGhpcy5pbml0Q3Vyc29yU2VsZWN0aW9uSGFuZGxlcnMoKTtcbiAgICAgIHRoaXMuaW5pdERvdWJsZUNsaWNrU2ltdWxhdGlvbigpO1xuICAgICAgdGhpcy5tb3VzZU1vdmVIYW5kbGVyID0gdGhpcy5tb3VzZU1vdmVIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgfSxcblxuICAgIG9uRGVzZWxlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pc0VkaXRpbmcgJiYgdGhpcy5leGl0RWRpdGluZygpO1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBcImFkZGVkXCIgZXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIGluaXRBZGRlZEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMub24oJ2FkZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBfdGhpcy5jYW52YXM7XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICBpZiAoIWNhbnZhcy5faGFzSVRleHRIYW5kbGVycykge1xuICAgICAgICAgICAgY2FudmFzLl9oYXNJVGV4dEhhbmRsZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLl9pbml0Q2FudmFzSGFuZGxlcnMoY2FudmFzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FudmFzLl9pVGV4dEluc3RhbmNlcyA9IGNhbnZhcy5faVRleHRJbnN0YW5jZXMgfHwgW107XG4gICAgICAgICAgY2FudmFzLl9pVGV4dEluc3RhbmNlcy5wdXNoKF90aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGluaXRSZW1vdmVkSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5vbigncmVtb3ZlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2FudmFzID0gX3RoaXMuY2FudmFzO1xuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgY2FudmFzLl9pVGV4dEluc3RhbmNlcyA9IGNhbnZhcy5faVRleHRJbnN0YW5jZXMgfHwgW107XG4gICAgICAgICAgZmFicmljLnV0aWwucmVtb3ZlRnJvbUFycmF5KGNhbnZhcy5faVRleHRJbnN0YW5jZXMsIF90aGlzKTtcbiAgICAgICAgICBpZiAoY2FudmFzLl9pVGV4dEluc3RhbmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNhbnZhcy5faGFzSVRleHRIYW5kbGVycyA9IGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMuX3JlbW92ZUNhbnZhc0hhbmRsZXJzKGNhbnZhcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVnaXN0ZXIgY2FudmFzIGV2ZW50IHRvIG1hbmFnZSBleGl0aW5nIG9uIG90aGVyIGluc3RhbmNlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRDYW52YXNIYW5kbGVyczogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICBjYW52YXMuX21vdXNlVXBJVGV4dEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGNhbnZhcy5faVRleHRJbnN0YW5jZXMpIHtcbiAgICAgICAgICBjYW52YXMuX2lUZXh0SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBvYmouX19pc01vdXNlZG93biA9IGZhbHNlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2FudmFzLm9uKCdtb3VzZTp1cCcsIGNhbnZhcy5fbW91c2VVcElUZXh0SGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBjYW52YXMgZXZlbnQgdG8gbWFuYWdlIGV4aXRpbmcgb24gb3RoZXIgaW5zdGFuY2VzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlQ2FudmFzSGFuZGxlcnM6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgY2FudmFzLm9mZignbW91c2U6dXAnLCBjYW52YXMuX21vdXNlVXBJVGV4dEhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90aWNrOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaWNrU3RhdGUgPSB0aGlzLl9hbmltYXRlQ3Vyc29yKHRoaXMsIDEsIHRoaXMuY3Vyc29yRHVyYXRpb24sICdfb25UaWNrQ29tcGxldGUnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYW5pbWF0ZUN1cnNvcjogZnVuY3Rpb24ob2JqLCB0YXJnZXRPcGFjaXR5LCBkdXJhdGlvbiwgY29tcGxldGVNZXRob2QpIHtcblxuICAgICAgdmFyIHRpY2tTdGF0ZTtcblxuICAgICAgdGlja1N0YXRlID0ge1xuICAgICAgICBpc0Fib3J0ZWQ6IGZhbHNlLFxuICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5pc0Fib3J0ZWQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgb2JqLmFuaW1hdGUoJ19jdXJyZW50Q3Vyc29yT3BhY2l0eScsIHRhcmdldE9wYWNpdHksIHtcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIXRpY2tTdGF0ZS5pc0Fib3J0ZWQpIHtcbiAgICAgICAgICAgIG9ialtjb21wbGV0ZU1ldGhvZF0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBhbmltYXRlIGEgc2VsZWN0aW9uLCBvbmx5IGN1cnNvclxuICAgICAgICAgIGlmIChvYmouY2FudmFzICYmIG9iai5zZWxlY3Rpb25TdGFydCA9PT0gb2JqLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgb2JqLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRpY2tTdGF0ZS5pc0Fib3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRpY2tTdGF0ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25UaWNrQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5fY3Vyc29yVGltZW91dDEpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2N1cnNvclRpbWVvdXQxKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2N1cnNvclRpbWVvdXQxID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZSA9IF90aGlzLl9hbmltYXRlQ3Vyc29yKF90aGlzLCAwLCB0aGlzLmN1cnNvckR1cmF0aW9uIC8gMiwgJ190aWNrJyk7XG4gICAgICB9LCAxMDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBkZWxheWVkIGN1cnNvclxuICAgICAqL1xuICAgIGluaXREZWxheWVkQ3Vyc29yOiBmdW5jdGlvbihyZXN0YXJ0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIGRlbGF5ID0gcmVzdGFydCA/IDAgOiB0aGlzLmN1cnNvckRlbGF5O1xuXG4gICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDE7XG4gICAgICB0aGlzLl9jdXJzb3JUaW1lb3V0MiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLl90aWNrKCk7XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFib3J0cyBjdXJzb3IgYW5pbWF0aW9uIGFuZCBjbGVhcnMgYWxsIHRpbWVvdXRzXG4gICAgICovXG4gICAgYWJvcnRDdXJzb3JBbmltYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNob3VsZENsZWFyID0gdGhpcy5fY3VycmVudFRpY2tTdGF0ZSB8fCB0aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUsXG4gICAgICAgICAgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICB0aGlzLl9jdXJyZW50VGlja1N0YXRlICYmIHRoaXMuX2N1cnJlbnRUaWNrU3RhdGUuYWJvcnQoKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZSAmJiB0aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUuYWJvcnQoKTtcblxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2N1cnNvclRpbWVvdXQxKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jdXJzb3JUaW1lb3V0Mik7XG5cbiAgICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMDtcbiAgICAgIC8vIHRvIGNsZWFyIGp1c3QgaXRleHQgYXJlYSB3ZSBuZWVkIHRvIHRyYW5zZm9ybSB0aGUgY29udGV4dFxuICAgICAgLy8gaXQgbWF5IG5vdCBiZSB3b3J0aCBpdFxuICAgICAgaWYgKHNob3VsZENsZWFyICYmIGNhbnZhcykge1xuICAgICAgICBjYW52YXMuY2xlYXJDb250ZXh0KGNhbnZhcy5jb250ZXh0VG9wIHx8IGNhbnZhcy5jb250ZXh0Q29udGFpbmVyKTtcbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGVudGlyZSB0ZXh0XG4gICAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNlbGVjdEFsbDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5fdGV4dC5sZW5ndGg7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHNlbGVjdGVkIHRleHRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U2VsZWN0ZWRUZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl90ZXh0LnNsaWNlKHRoaXMuc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2VsZWN0aW9uRW5kKS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBuZXcgc2VsZWN0aW9uIGluZGV4IHJlcHJlc2VudGluZyBzdGFydCBvZiBjdXJyZW50IHdvcmQgYWNjb3JkaW5nIHRvIGN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0RnJvbSBTdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTmV3IHNlbGVjdGlvbiBpbmRleFxuICAgICAqL1xuICAgIGZpbmRXb3JkQm91bmRhcnlMZWZ0OiBmdW5jdGlvbihzdGFydEZyb20pIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwLCBpbmRleCA9IHN0YXJ0RnJvbSAtIDE7XG5cbiAgICAgIC8vIHJlbW92ZSBzcGFjZSBiZWZvcmUgY3Vyc29yIGZpcnN0XG4gICAgICBpZiAodGhpcy5fcmVTcGFjZS50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSkge1xuICAgICAgICB3aGlsZSAodGhpcy5fcmVTcGFjZS50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSkge1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIGluZGV4LS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgvXFxTLy50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSAmJiBpbmRleCA+IC0xKSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhcnRGcm9tIC0gb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIG5ldyBzZWxlY3Rpb24gaW5kZXggcmVwcmVzZW50aW5nIGVuZCBvZiBjdXJyZW50IHdvcmQgYWNjb3JkaW5nIHRvIGN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0RnJvbSBDdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTmV3IHNlbGVjdGlvbiBpbmRleFxuICAgICAqL1xuICAgIGZpbmRXb3JkQm91bmRhcnlSaWdodDogZnVuY3Rpb24oc3RhcnRGcm9tKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMCwgaW5kZXggPSBzdGFydEZyb207XG5cbiAgICAgIC8vIHJlbW92ZSBzcGFjZSBhZnRlciBjdXJzb3IgZmlyc3RcbiAgICAgIGlmICh0aGlzLl9yZVNwYWNlLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9yZVNwYWNlLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pKSB7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKC9cXFMvLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pICYmIGluZGV4IDwgdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0RnJvbSArIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBuZXcgc2VsZWN0aW9uIGluZGV4IHJlcHJlc2VudGluZyBzdGFydCBvZiBjdXJyZW50IGxpbmUgYWNjb3JkaW5nIHRvIGN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0RnJvbSBDdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTmV3IHNlbGVjdGlvbiBpbmRleFxuICAgICAqL1xuICAgIGZpbmRMaW5lQm91bmRhcnlMZWZ0OiBmdW5jdGlvbihzdGFydEZyb20pIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwLCBpbmRleCA9IHN0YXJ0RnJvbSAtIDE7XG5cbiAgICAgIHdoaWxlICghL1xcbi8udGVzdCh0aGlzLl90ZXh0W2luZGV4XSkgJiYgaW5kZXggPiAtMSkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0RnJvbSAtIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBuZXcgc2VsZWN0aW9uIGluZGV4IHJlcHJlc2VudGluZyBlbmQgb2YgY3VycmVudCBsaW5lIGFjY29yZGluZyB0byBjdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEZyb20gQ3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IE5ldyBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKi9cbiAgICBmaW5kTGluZUJvdW5kYXJ5UmlnaHQ6IGZ1bmN0aW9uKHN0YXJ0RnJvbSkge1xuICAgICAgdmFyIG9mZnNldCA9IDAsIGluZGV4ID0gc3RhcnRGcm9tO1xuXG4gICAgICB3aGlsZSAoIS9cXG4vLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pICYmIGluZGV4IDwgdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0RnJvbSArIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgaW5kZXggY29ycmVzcG9uZGluZyB0byBiZWdpbm5pbmcgb3IgZW5kIG9mIGEgd29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWxlY3Rpb25TdGFydCBJbmRleCBvZiBhIGNoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gMSBvciAtMVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gSW5kZXggb2YgdGhlIGJlZ2lubmluZyBvciBlbmQgb2YgYSB3b3JkXG4gICAgICovXG4gICAgc2VhcmNoV29yZEJvdW5kYXJ5OiBmdW5jdGlvbihzZWxlY3Rpb25TdGFydCwgZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgaW5kZXggICAgID0gdGhpcy5fcmVTcGFjZS50ZXN0KHRoaXMudGV4dC5jaGFyQXQoc2VsZWN0aW9uU3RhcnQpKSA/IHNlbGVjdGlvblN0YXJ0IC0gMSA6IHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgIF9jaGFyICAgICA9IHRoaXMudGV4dC5jaGFyQXQoaW5kZXgpLFxuICAgICAgICAgIHJlTm9uV29yZCA9IC9bIFxcblxcLiw7IVxcP1xcLV0vO1xuXG4gICAgICB3aGlsZSAoIXJlTm9uV29yZC50ZXN0KF9jaGFyKSAmJiBpbmRleCA+IDAgJiYgaW5kZXggPCB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgIGluZGV4ICs9IGRpcmVjdGlvbjtcbiAgICAgICAgX2NoYXIgPSB0aGlzLnRleHQuY2hhckF0KGluZGV4KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZU5vbldvcmQudGVzdChfY2hhcikgJiYgX2NoYXIgIT09ICdcXG4nKSB7XG4gICAgICAgIGluZGV4ICs9IGRpcmVjdGlvbiA9PT0gMSA/IDAgOiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGEgd29yZCBiYXNlZCBvbiB0aGUgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2VsZWN0aW9uU3RhcnQgSW5kZXggb2YgYSBjaGFyYWN0ZXJcbiAgICAgKi9cbiAgICBzZWxlY3RXb3JkOiBmdW5jdGlvbihzZWxlY3Rpb25TdGFydCkge1xuICAgICAgc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb25TdGFydCB8fCB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgdmFyIG5ld1NlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWFyY2hXb3JkQm91bmRhcnkoc2VsZWN0aW9uU3RhcnQsIC0xKSwgLyogc2VhcmNoIGJhY2t3YXJkcyAqL1xuICAgICAgICAgIG5ld1NlbGVjdGlvbkVuZCA9IHRoaXMuc2VhcmNoV29yZEJvdW5kYXJ5KHNlbGVjdGlvblN0YXJ0LCAxKTsgLyogc2VhcmNoIGZvcndhcmQgKi9cblxuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvblN0YXJ0O1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb25FbmQ7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyBhIGxpbmUgYmFzZWQgb24gdGhlIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNlbGVjdGlvblN0YXJ0IEluZGV4IG9mIGEgY2hhcmFjdGVyXG4gICAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNlbGVjdExpbmU6IGZ1bmN0aW9uKHNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICBzZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvblN0YXJ0IHx8IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB2YXIgbmV3U2VsZWN0aW9uU3RhcnQgPSB0aGlzLmZpbmRMaW5lQm91bmRhcnlMZWZ0KHNlbGVjdGlvblN0YXJ0KSxcbiAgICAgICAgICBuZXdTZWxlY3Rpb25FbmQgPSB0aGlzLmZpbmRMaW5lQm91bmRhcnlSaWdodChzZWxlY3Rpb25TdGFydCk7XG5cbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb25TdGFydDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uRW5kO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW50ZXJzIGVkaXRpbmcgc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZW50ZXJFZGl0aW5nOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAodGhpcy5pc0VkaXRpbmcgfHwgIXRoaXMuZWRpdGFibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuY2FsY09mZnNldCgpO1xuICAgICAgICB0aGlzLmV4aXRFZGl0aW5nT25PdGhlcnModGhpcy5jYW52YXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzRWRpdGluZyA9IHRydWU7XG5cbiAgICAgIHRoaXMuaW5pdEhpZGRlblRleHRhcmVhKGUpO1xuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5mb2N1cygpO1xuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZSA9IHRoaXMudGV4dDtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgICB0aGlzLl9zYXZlRWRpdGluZ1Byb3BzKCk7XG4gICAgICB0aGlzLl9zZXRFZGl0aW5nUHJvcHMoKTtcbiAgICAgIHRoaXMuX3RleHRCZWZvcmVFZGl0ID0gdGhpcy50ZXh0O1xuXG4gICAgICB0aGlzLl90aWNrKCk7XG4gICAgICB0aGlzLmZpcmUoJ2VkaXRpbmc6ZW50ZXJlZCcpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbnZhcy5maXJlKCd0ZXh0OmVkaXRpbmc6ZW50ZXJlZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgICAgdGhpcy5pbml0TW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGV4aXRFZGl0aW5nT25PdGhlcnM6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgaWYgKGNhbnZhcy5faVRleHRJbnN0YW5jZXMpIHtcbiAgICAgICAgY2FudmFzLl9pVGV4dEluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgIG9iai5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChvYmouaXNFZGl0aW5nKSB7XG4gICAgICAgICAgICBvYmouZXhpdEVkaXRpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBcIm1vdXNlbW92ZVwiIGV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBpbml0TW91c2VNb3ZlSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNhbnZhcy5vbignbW91c2U6bW92ZScsIHRoaXMubW91c2VNb3ZlSGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbW91c2VNb3ZlSGFuZGxlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLl9faXNNb3VzZWRvd24gfHwgIXRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld1NlbGVjdGlvblN0YXJ0ID0gdGhpcy5nZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyKG9wdGlvbnMuZSksXG4gICAgICAgICAgY3VycmVudFN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICBjdXJyZW50RW5kID0gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgICBpZiAoXG4gICAgICAgIChuZXdTZWxlY3Rpb25TdGFydCAhPT0gdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd24gfHwgY3VycmVudFN0YXJ0ID09PSBjdXJyZW50RW5kKVxuICAgICAgICAmJlxuICAgICAgICAoY3VycmVudFN0YXJ0ID09PSBuZXdTZWxlY3Rpb25TdGFydCB8fCBjdXJyZW50RW5kID09PSBuZXdTZWxlY3Rpb25TdGFydClcbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobmV3U2VsZWN0aW9uU3RhcnQgPiB0aGlzLl9fc2VsZWN0aW9uU3RhcnRPbk1vdXNlRG93bikge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd247XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvblN0YXJ0O1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IGN1cnJlbnRTdGFydCB8fCB0aGlzLnNlbGVjdGlvbkVuZCAhPT0gY3VycmVudEVuZCkge1xuICAgICAgICB0aGlzLnJlc3RhcnRDdXJzb3JJZk5lZWRlZCgpO1xuICAgICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldEVkaXRpbmdQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmhvdmVyQ3Vyc29yID0gJ3RleHQnO1xuXG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuZGVmYXVsdEN1cnNvciA9IHRoaXMuY2FudmFzLm1vdmVDdXJzb3IgPSAndGV4dCc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSB0aGlzLmVkaXRpbmdCb3JkZXJDb2xvcjtcblxuICAgICAgdGhpcy5oYXNDb250cm9scyA9IHRoaXMuc2VsZWN0YWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5sb2NrTW92ZW1lbnRYID0gdGhpcy5sb2NrTW92ZW1lbnRZID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBmcm9tIHRleHRhcmVhIHRvIGdyYXBoZW1lIGluZGV4ZXNcbiAgICAgKi9cbiAgICBmcm9tU3RyaW5nVG9HcmFwaGVtZVNlbGVjdGlvbjogZnVuY3Rpb24oc3RhcnQsIGVuZCwgdGV4dCkge1xuICAgICAgdmFyIHNtYWxsZXJUZXh0U3RhcnQgPSB0ZXh0LnNsaWNlKDAsIHN0YXJ0KSxcbiAgICAgICAgICBncmFwaGVtZVN0YXJ0ID0gZmFicmljLnV0aWwuc3RyaW5nLmdyYXBoZW1lU3BsaXQoc21hbGxlclRleHRTdGFydCkubGVuZ3RoO1xuICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHsgc2VsZWN0aW9uU3RhcnQ6IGdyYXBoZW1lU3RhcnQsIHNlbGVjdGlvbkVuZDogZ3JhcGhlbWVTdGFydCB9O1xuICAgICAgfVxuICAgICAgdmFyIHNtYWxsZXJUZXh0RW5kID0gdGV4dC5zbGljZShzdGFydCwgZW5kKSxcbiAgICAgICAgICBncmFwaGVtZUVuZCA9IGZhYnJpYy51dGlsLnN0cmluZy5ncmFwaGVtZVNwbGl0KHNtYWxsZXJUZXh0RW5kKS5sZW5ndGg7XG4gICAgICByZXR1cm4geyBzZWxlY3Rpb25TdGFydDogZ3JhcGhlbWVTdGFydCwgc2VsZWN0aW9uRW5kOiBncmFwaGVtZVN0YXJ0ICsgZ3JhcGhlbWVFbmQgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBmcm9tIGZhYnJpYyB0byB0ZXh0YXJlYSB2YWx1ZXNcbiAgICAgKi9cbiAgICBmcm9tR3JhcGhlbWVUb1N0cmluZ1NlbGVjdGlvbjogZnVuY3Rpb24oc3RhcnQsIGVuZCwgX3RleHQpIHtcbiAgICAgIHZhciBzbWFsbGVyVGV4dFN0YXJ0ID0gX3RleHQuc2xpY2UoMCwgc3RhcnQpLFxuICAgICAgICAgIGdyYXBoZW1lU3RhcnQgPSBzbWFsbGVyVGV4dFN0YXJ0LmpvaW4oJycpLmxlbmd0aDtcbiAgICAgIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgICAgIHJldHVybiB7IHNlbGVjdGlvblN0YXJ0OiBncmFwaGVtZVN0YXJ0LCBzZWxlY3Rpb25FbmQ6IGdyYXBoZW1lU3RhcnQgfTtcbiAgICAgIH1cbiAgICAgIHZhciBzbWFsbGVyVGV4dEVuZCA9IF90ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpLFxuICAgICAgICAgIGdyYXBoZW1lRW5kID0gc21hbGxlclRleHRFbmQuam9pbignJykubGVuZ3RoO1xuICAgICAgcmV0dXJuIHsgc2VsZWN0aW9uU3RhcnQ6IGdyYXBoZW1lU3RhcnQsIHNlbGVjdGlvbkVuZDogZ3JhcGhlbWVTdGFydCArIGdyYXBoZW1lRW5kIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZVRleHRhcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgPSB7IH07XG4gICAgICBpZiAoIXRoaXMuaGlkZGVuVGV4dGFyZWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICAgIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLmZyb21HcmFwaGVtZVRvU3RyaW5nU2VsZWN0aW9uKHRoaXMuc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2VsZWN0aW9uRW5kLCB0aGlzLl90ZXh0KTtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbi5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb24uc2VsZWN0aW9uRW5kO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVUZXh0YXJlYVBvc2l0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdXBkYXRlRnJvbVRleHRBcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5oaWRkZW5UZXh0YXJlYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmN1cnNvck9mZnNldENhY2hlID0geyB9O1xuICAgICAgdGhpcy50ZXh0ID0gdGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZTtcbiAgICAgIGlmICh0aGlzLl9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlKCkpIHtcbiAgICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuZnJvbVN0cmluZ1RvR3JhcGhlbWVTZWxlY3Rpb24oXG4gICAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uU3RhcnQsIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uRW5kLCB0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlKTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbi5zZWxlY3Rpb25FbmQ7XG4gICAgICBpZiAoIXRoaXMuaW5Db21wb3NpdGlvbk1vZGUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbi5zZWxlY3Rpb25TdGFydDtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlVGV4dGFyZWFQb3NpdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZVRleHRhcmVhUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX2NhbGNUZXh0YXJlYVBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc3R5bGUubGVmdCA9IHN0eWxlLmxlZnQ7XG4gICAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc3R5bGUudG9wID0gc3R5bGUudG9wO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gc3R5bGUgY29udGFpbnMgc3R5bGUgZm9yIGhpZGRlblRleHRhcmVhXG4gICAgICovXG4gICAgX2NhbGNUZXh0YXJlYVBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMSwgeTogMSB9O1xuICAgICAgfVxuICAgICAgdmFyIGRlc2lyZWRQb3N0aW9uID0gdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA/IHRoaXMuY29tcG9zaXRpb25TdGFydCA6IHRoaXMuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgYm91bmRhcmllcyA9IHRoaXMuX2dldEN1cnNvckJvdW5kYXJpZXMoZGVzaXJlZFBvc3Rpb24pLFxuICAgICAgICAgIGN1cnNvckxvY2F0aW9uID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKGRlc2lyZWRQb3N0aW9uKSxcbiAgICAgICAgICBsaW5lSW5kZXggPSBjdXJzb3JMb2NhdGlvbi5saW5lSW5kZXgsXG4gICAgICAgICAgY2hhckluZGV4ID0gY3Vyc29yTG9jYXRpb24uY2hhckluZGV4LFxuICAgICAgICAgIGNoYXJIZWlnaHQgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxpbmVJbmRleCwgY2hhckluZGV4LCAnZm9udFNpemUnKSAqIHRoaXMubGluZUhlaWdodCxcbiAgICAgICAgICBsZWZ0T2Zmc2V0ID0gYm91bmRhcmllcy5sZWZ0T2Zmc2V0LFxuICAgICAgICAgIG0gPSB0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgICBwID0ge1xuICAgICAgICAgICAgeDogYm91bmRhcmllcy5sZWZ0ICsgbGVmdE9mZnNldCxcbiAgICAgICAgICAgIHk6IGJvdW5kYXJpZXMudG9wICsgYm91bmRhcmllcy50b3BPZmZzZXQgKyBjaGFySGVpZ2h0XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cHBlckNhbnZhcyA9IHRoaXMuY2FudmFzLnVwcGVyQ2FudmFzRWwsXG4gICAgICAgICAgdXBwZXJDYW52YXNXaWR0aCA9IHVwcGVyQ2FudmFzLndpZHRoLFxuICAgICAgICAgIHVwcGVyQ2FudmFzSGVpZ2h0ID0gdXBwZXJDYW52YXMuaGVpZ2h0LFxuICAgICAgICAgIG1heFdpZHRoID0gdXBwZXJDYW52YXNXaWR0aCAtIGNoYXJIZWlnaHQsXG4gICAgICAgICAgbWF4SGVpZ2h0ID0gdXBwZXJDYW52YXNIZWlnaHQgLSBjaGFySGVpZ2h0LFxuICAgICAgICAgIHNjYWxlWCA9IHVwcGVyQ2FudmFzLmNsaWVudFdpZHRoIC8gdXBwZXJDYW52YXNXaWR0aCxcbiAgICAgICAgICBzY2FsZVkgPSB1cHBlckNhbnZhcy5jbGllbnRIZWlnaHQgLyB1cHBlckNhbnZhc0hlaWdodDtcblxuICAgICAgcCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHAsIG0pO1xuICAgICAgcCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHAsIHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtKTtcbiAgICAgIHAueCAqPSBzY2FsZVg7XG4gICAgICBwLnkgKj0gc2NhbGVZO1xuICAgICAgaWYgKHAueCA8IDApIHtcbiAgICAgICAgcC54ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChwLnggPiBtYXhXaWR0aCkge1xuICAgICAgICBwLnggPSBtYXhXaWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChwLnkgPCAwKSB7XG4gICAgICAgIHAueSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocC55ID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgIHAueSA9IG1heEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIGNhbnZhcyBvZmZzZXQgb24gZG9jdW1lbnRcbiAgICAgIHAueCArPSB0aGlzLmNhbnZhcy5fb2Zmc2V0LmxlZnQ7XG4gICAgICBwLnkgKz0gdGhpcy5jYW52YXMuX29mZnNldC50b3A7XG5cbiAgICAgIHJldHVybiB7IGxlZnQ6IHAueCArICdweCcsIHRvcDogcC55ICsgJ3B4JywgZm9udFNpemU6IGNoYXJIZWlnaHQgKyAncHgnLCBjaGFySGVpZ2h0OiBjaGFySGVpZ2h0IH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NhdmVFZGl0aW5nUHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fc2F2ZWRQcm9wcyA9IHtcbiAgICAgICAgaGFzQ29udHJvbHM6IHRoaXMuaGFzQ29udHJvbHMsXG4gICAgICAgIGJvcmRlckNvbG9yOiB0aGlzLmJvcmRlckNvbG9yLFxuICAgICAgICBsb2NrTW92ZW1lbnRYOiB0aGlzLmxvY2tNb3ZlbWVudFgsXG4gICAgICAgIGxvY2tNb3ZlbWVudFk6IHRoaXMubG9ja01vdmVtZW50WSxcbiAgICAgICAgaG92ZXJDdXJzb3I6IHRoaXMuaG92ZXJDdXJzb3IsXG4gICAgICAgIGRlZmF1bHRDdXJzb3I6IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmRlZmF1bHRDdXJzb3IsXG4gICAgICAgIG1vdmVDdXJzb3I6IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLm1vdmVDdXJzb3JcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc3RvcmVFZGl0aW5nUHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9zYXZlZFByb3BzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ob3ZlckN1cnNvciA9IHRoaXMuX3NhdmVkUHJvcHMuaG92ZXJDdXJzb3I7XG4gICAgICB0aGlzLmhhc0NvbnRyb2xzID0gdGhpcy5fc2F2ZWRQcm9wcy5oYXNDb250cm9scztcbiAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSB0aGlzLl9zYXZlZFByb3BzLmJvcmRlckNvbG9yO1xuICAgICAgdGhpcy5sb2NrTW92ZW1lbnRYID0gdGhpcy5fc2F2ZWRQcm9wcy5sb2NrTW92ZW1lbnRYO1xuICAgICAgdGhpcy5sb2NrTW92ZW1lbnRZID0gdGhpcy5fc2F2ZWRQcm9wcy5sb2NrTW92ZW1lbnRZO1xuXG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuZGVmYXVsdEN1cnNvciA9IHRoaXMuX3NhdmVkUHJvcHMuZGVmYXVsdEN1cnNvcjtcbiAgICAgICAgdGhpcy5jYW52YXMubW92ZUN1cnNvciA9IHRoaXMuX3NhdmVkUHJvcHMubW92ZUN1cnNvcjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhpdHMgZnJvbSBlZGl0aW5nIHN0YXRlXG4gICAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGV4aXRFZGl0aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpc1RleHRDaGFuZ2VkID0gKHRoaXMuX3RleHRCZWZvcmVFZGl0ICE9PSB0aGlzLnRleHQpO1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2VsZWN0YWJsZSA9IHRydWU7XG5cbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcblxuICAgICAgaWYgKHRoaXMuaGlkZGVuVGV4dGFyZWEpIHtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5ibHVyICYmIHRoaXMuaGlkZGVuVGV4dGFyZWEuYmx1cigpO1xuICAgICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmhpZGRlblRleHRhcmVhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5oaWRkZW5UZXh0YXJlYSk7XG4gICAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB0aGlzLl9yZXN0b3JlRWRpdGluZ1Byb3BzKCk7XG4gICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDA7XG4gICAgICBpZiAodGhpcy5fc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZSgpKSB7XG4gICAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmlyZSgnZWRpdGluZzpleGl0ZWQnKTtcbiAgICAgIGlzVGV4dENoYW5nZWQgJiYgdGhpcy5maXJlKCdtb2RpZmllZCcpO1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLm9mZignbW91c2U6bW92ZScsIHRoaXMubW91c2VNb3ZlSGFuZGxlcik7XG4gICAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6ZWRpdGluZzpleGl0ZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgICAgaXNUZXh0Q2hhbmdlZCAmJiB0aGlzLmNhbnZhcy5maXJlKCdvYmplY3Q6bW9kaWZpZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0TGluZXNbcHJvcF0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGFuZCByZWZsb3cgYSBzdHlsZSBibG9jayBmcm9tIHN0YXJ0IHRvIGVuZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgbGluZWFyIHN0YXJ0IHBvc2l0aW9uIGZvciByZW1vdmFsIChpbmNsdWRlZCBpbiByZW1vdmFsKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgbGluZWFyIGVuZCBwb3NpdGlvbiBmb3IgcmVtb3ZhbCAoIGV4Y2x1ZGVkIGZyb20gcmVtb3ZhbCApXG4gICAgICovXG4gICAgcmVtb3ZlU3R5bGVGcm9tVG86IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBjdXJzb3JTdGFydCA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzdGFydCwgdHJ1ZSksXG4gICAgICAgICAgY3Vyc29yRW5kID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKGVuZCwgdHJ1ZSksXG4gICAgICAgICAgbGluZVN0YXJ0ID0gY3Vyc29yU3RhcnQubGluZUluZGV4LFxuICAgICAgICAgIGNoYXJTdGFydCA9IGN1cnNvclN0YXJ0LmNoYXJJbmRleCxcbiAgICAgICAgICBsaW5lRW5kID0gY3Vyc29yRW5kLmxpbmVJbmRleCxcbiAgICAgICAgICBjaGFyRW5kID0gY3Vyc29yRW5kLmNoYXJJbmRleCxcbiAgICAgICAgICBpLCBzdHlsZU9iajtcbiAgICAgIGlmIChsaW5lU3RhcnQgIT09IGxpbmVFbmQpIHtcbiAgICAgICAgLy8gc3RlcDEgcmVtb3ZlIHRoZSB0cmFpbGluZyBvZiBsaW5lU3RhcnRcbiAgICAgICAgaWYgKHRoaXMuc3R5bGVzW2xpbmVTdGFydF0pIHtcbiAgICAgICAgICBmb3IgKGkgPSBjaGFyU3RhcnQ7IGkgPCB0aGlzLl91bndyYXBwZWRUZXh0TGluZXNbbGluZVN0YXJ0XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVTdGFydF1baV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHN0ZXAyIG1vdmUgdGhlIHRyYWlsaW5nIG9mIGxpbmVFbmQgdG8gbGluZVN0YXJ0IGlmIG5lZWRlZFxuICAgICAgICBpZiAodGhpcy5zdHlsZXNbbGluZUVuZF0pIHtcbiAgICAgICAgICBmb3IgKGkgPSBjaGFyRW5kOyBpIDwgdGhpcy5fdW53cmFwcGVkVGV4dExpbmVzW2xpbmVFbmRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdHlsZU9iaiA9IHRoaXMuc3R5bGVzW2xpbmVFbmRdW2ldO1xuICAgICAgICAgICAgaWYgKHN0eWxlT2JqKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVTdGFydF0gfHwgKHRoaXMuc3R5bGVzW2xpbmVTdGFydF0gPSB7IH0pO1xuICAgICAgICAgICAgICB0aGlzLnN0eWxlc1tsaW5lU3RhcnRdW2NoYXJTdGFydCArIGkgLSBjaGFyRW5kXSA9IHN0eWxlT2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzdGVwMyBkZXRlY3RzIGxpbmVzIHdpbGwgYmUgY29tcGxldGVseSByZW1vdmVkLlxuICAgICAgICBmb3IgKGkgPSBsaW5lU3RhcnQgKyAxOyBpIDw9IGxpbmVFbmQ7IGkrKykge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGVwNCBzaGlmdCByZW1haW5pbmcgbGluZXMuXG4gICAgICAgIHRoaXMuc2hpZnRMaW5lU3R5bGVzKGxpbmVFbmQsIGxpbmVTdGFydCAtIGxpbmVFbmQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbmQgc2hpZnQgbGVmdCBvbiB0aGUgc2FtZSBsaW5lXG4gICAgICAgIGlmICh0aGlzLnN0eWxlc1tsaW5lU3RhcnRdKSB7XG4gICAgICAgICAgc3R5bGVPYmogPSB0aGlzLnN0eWxlc1tsaW5lU3RhcnRdO1xuICAgICAgICAgIHZhciBkaWZmID0gY2hhckVuZCAtIGNoYXJTdGFydCwgbnVtZXJpY0NoYXIsIF9jaGFyO1xuICAgICAgICAgIGZvciAoaSA9IGNoYXJTdGFydDsgaSA8IGNoYXJFbmQ7IGkrKykge1xuICAgICAgICAgICAgZGVsZXRlIHN0eWxlT2JqW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKF9jaGFyIGluIHRoaXMuc3R5bGVzW2xpbmVTdGFydF0pIHtcbiAgICAgICAgICAgIG51bWVyaWNDaGFyID0gcGFyc2VJbnQoX2NoYXIsIDEwKTtcbiAgICAgICAgICAgIGlmIChudW1lcmljQ2hhciA+PSBjaGFyRW5kKSB7XG4gICAgICAgICAgICAgIHN0eWxlT2JqW251bWVyaWNDaGFyIC0gZGlmZl0gPSBzdHlsZU9ialtfY2hhcl07XG4gICAgICAgICAgICAgIGRlbGV0ZSBzdHlsZU9ialtfY2hhcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNoaWZ0cyBsaW5lIHN0eWxlcyB1cCBvciBkb3duXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBJbmRleCBvZiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IENhbiBhbnkgbnVtYmVyP1xuICAgICAqL1xuICAgIHNoaWZ0TGluZVN0eWxlczogZnVuY3Rpb24obGluZUluZGV4LCBvZmZzZXQpIHtcbiAgICAgIC8vIHNoaWZ0IGFsbCBsaW5lIHN0eWxlcyBieSBvZmZzZXQgdXB3YXJkIG9yIGRvd253YXJkXG4gICAgICAvLyBkbyBub3QgY2xvbmUgZGVlcC4gd2UgbmVlZCBuZXcgYXJyYXksIG5vdCBuZXcgc3R5bGUgb2JqZWN0c1xuICAgICAgdmFyIGNsb25lZFN0eWxlcyA9IGNsb25lKHRoaXMuc3R5bGVzKTtcbiAgICAgIGZvciAodmFyIGxpbmUgaW4gdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgdmFyIG51bWVyaWNMaW5lID0gcGFyc2VJbnQobGluZSwgMTApO1xuICAgICAgICBpZiAobnVtZXJpY0xpbmUgPiBsaW5lSW5kZXgpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlc1tudW1lcmljTGluZSArIG9mZnNldF0gPSBjbG9uZWRTdHlsZXNbbnVtZXJpY0xpbmVdO1xuICAgICAgICAgIGlmICghY2xvbmVkU3R5bGVzW251bWVyaWNMaW5lIC0gb2Zmc2V0XSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW251bWVyaWNMaW5lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVzdGFydEN1cnNvcklmTmVlZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5fY3VycmVudFRpY2tTdGF0ZSB8fCB0aGlzLl9jdXJyZW50VGlja1N0YXRlLmlzQWJvcnRlZFxuICAgICAgICB8fCAhdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlIHx8IHRoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZS5pc0Fib3J0ZWRcbiAgICAgICkge1xuICAgICAgICB0aGlzLmluaXREZWxheWVkQ3Vyc29yKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgbmV3IHN0eWxlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggSW5kZXggb2YgYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCBJbmRleCBvZiBhIGNoYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcXR5IG51bWJlciBvZiBsaW5lcyB0byBhZGRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb3BpZWRTdHlsZSBBcnJheSBvZiBvYmplY3RzIHN0eWxlc1xuICAgICAqL1xuICAgIGluc2VydE5ld2xpbmVTdHlsZU9iamVjdDogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIHF0eSwgY29waWVkU3R5bGUpIHtcbiAgICAgIHZhciBjdXJyZW50Q2hhclN0eWxlLFxuICAgICAgICAgIG5ld0xpbmVTdHlsZXMgPSB7fSxcbiAgICAgICAgICBzb21ldGhpbmdBZGRlZCA9IGZhbHNlO1xuXG4gICAgICBxdHkgfHwgKHF0eSA9IDEpO1xuICAgICAgdGhpcy5zaGlmdExpbmVTdHlsZXMobGluZUluZGV4LCBxdHkpO1xuICAgICAgaWYgKHRoaXMuc3R5bGVzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgY3VycmVudENoYXJTdHlsZSA9IHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4ID09PSAwID8gY2hhckluZGV4IDogY2hhckluZGV4IC0gMV07XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIGNsb25lIHN0eWxlcyBvZiBhbGwgY2hhcnNcbiAgICAgIC8vIGFmdGVyIGN1cnNvciBvbnRvIHRoZSBjdXJyZW50IGxpbmVcbiAgICAgIGZvciAodmFyIGluZGV4IGluIHRoaXMuc3R5bGVzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgdmFyIG51bUluZGV4ID0gcGFyc2VJbnQoaW5kZXgsIDEwKTtcbiAgICAgICAgaWYgKG51bUluZGV4ID49IGNoYXJJbmRleCkge1xuICAgICAgICAgIHNvbWV0aGluZ0FkZGVkID0gdHJ1ZTtcbiAgICAgICAgICBuZXdMaW5lU3R5bGVzW251bUluZGV4IC0gY2hhckluZGV4XSA9IHRoaXMuc3R5bGVzW2xpbmVJbmRleF1baW5kZXhdO1xuICAgICAgICAgIC8vIHJlbW92ZSBsaW5lcyBmcm9tIHRoZSBwcmV2aW91cyBsaW5lIHNpbmNlIHRoZXkncmUgb24gYSBuZXcgbGluZSBub3dcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzb21ldGhpbmdBZGRlZCkge1xuICAgICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXggKyBxdHldID0gbmV3TGluZVN0eWxlcztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4ICsgcXR5XTtcbiAgICAgIH1cbiAgICAgIC8vIGZvciB0aGUgb3RoZXIgbGluZXNcbiAgICAgIC8vIHdlIGNsb25lIGN1cnJlbnQgY2hhciBzdHlsZSBvbnRvIHRoZSBuZXh0IChvdGhlcndpc2UgZW1wdHkpIGxpbmVcbiAgICAgIHdoaWxlIChxdHkgPiAxKSB7XG4gICAgICAgIHF0eS0tO1xuICAgICAgICBpZiAoY29waWVkU3R5bGUgJiYgY29waWVkU3R5bGVbcXR5XSkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleCArIHF0eV0gPSB7IDA6IGNsb25lKGNvcGllZFN0eWxlW3F0eV0pIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudENoYXJTdHlsZSkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleCArIHF0eV0gPSB7IDA6IGNsb25lKGN1cnJlbnRDaGFyU3R5bGUpIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVJbmRleCArIHF0eV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZSA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgc3R5bGUgb2JqZWN0IGZvciBhIGdpdmVuIGxpbmUvY2hhciBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggSW5kZXggb2YgYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCBJbmRleCBvZiBhIGNoYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcXVhbnRpdHkgbnVtYmVyIFN0eWxlIG9iamVjdCB0byBpbnNlcnQsIGlmIGdpdmVuXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29waWVkU3R5bGUgYXJyYXkgb2Ygc3R5bGUgb2JqZWNzXG4gICAgICovXG4gICAgaW5zZXJ0Q2hhclN0eWxlT2JqZWN0OiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgcXVhbnRpdHksIGNvcGllZFN0eWxlKSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzKSB7XG4gICAgICAgIHRoaXMuc3R5bGVzID0ge307XG4gICAgICB9XG4gICAgICB2YXIgY3VycmVudExpbmVTdHlsZXMgICAgICAgPSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdLFxuICAgICAgICAgIGN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkID0gY3VycmVudExpbmVTdHlsZXMgPyBjbG9uZShjdXJyZW50TGluZVN0eWxlcykgOiB7fTtcblxuICAgICAgcXVhbnRpdHkgfHwgKHF1YW50aXR5ID0gMSk7XG4gICAgICAvLyBzaGlmdCBhbGwgY2hhciBzdHlsZXMgYnkgcXVhbnRpdHkgZm9yd2FyZFxuICAgICAgLy8gMCwxLDIsMyAtPiAoY2hhckluZGV4PTIpIC0+IDAsMSwzLDQgLT4gKGluc2VydCAyKSAtPiAwLDEsMiwzLDRcbiAgICAgIGZvciAodmFyIGluZGV4IGluIGN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkKSB7XG4gICAgICAgIHZhciBudW1lcmljSW5kZXggPSBwYXJzZUludChpbmRleCwgMTApO1xuICAgICAgICBpZiAobnVtZXJpY0luZGV4ID49IGNoYXJJbmRleCkge1xuICAgICAgICAgIGN1cnJlbnRMaW5lU3R5bGVzW251bWVyaWNJbmRleCArIHF1YW50aXR5XSA9IGN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkW251bWVyaWNJbmRleF07XG4gICAgICAgICAgLy8gb25seSBkZWxldGUgdGhlIHN0eWxlIGlmIHRoZXJlIHdhcyBub3RoaW5nIG1vdmVkIHRoZXJlXG4gICAgICAgICAgaWYgKCFjdXJyZW50TGluZVN0eWxlc0Nsb25lZFtudW1lcmljSW5kZXggLSBxdWFudGl0eV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjdXJyZW50TGluZVN0eWxlc1tudW1lcmljSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fZm9yY2VDbGVhckNhY2hlID0gdHJ1ZTtcbiAgICAgIGlmIChjb3BpZWRTdHlsZSkge1xuICAgICAgICB3aGlsZSAocXVhbnRpdHktLSkge1xuICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoY29waWVkU3R5bGVbcXVhbnRpdHldKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuc3R5bGVzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXggKyBxdWFudGl0eV0gPSBjbG9uZShjb3BpZWRTdHlsZVtxdWFudGl0eV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghY3VycmVudExpbmVTdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1N0eWxlID0gY3VycmVudExpbmVTdHlsZXNbY2hhckluZGV4ID8gY2hhckluZGV4IC0gMSA6IDFdO1xuICAgICAgd2hpbGUgKG5ld1N0eWxlICYmIHF1YW50aXR5LS0pIHtcbiAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXggKyBxdWFudGl0eV0gPSBjbG9uZShuZXdTdHlsZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgc3R5bGUgb2JqZWN0KHMpXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5zZXJ0ZWRUZXh0IENoYXJhY3RlcnMgYXQgdGhlIGxvY2F0aW9uIHdoZXJlIHN0eWxlIGlzIGluc2VydGVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IGN1cnNvciBpbmRleCBmb3IgaW5zZXJ0aW5nIHN0eWxlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvcGllZFN0eWxlXSBhcnJheSBvZiBzdHlsZSBvYmplY3RzIHRvIGluc2VydC5cbiAgICAgKi9cbiAgICBpbnNlcnROZXdTdHlsZUJsb2NrOiBmdW5jdGlvbihpbnNlcnRlZFRleHQsIHN0YXJ0LCBjb3BpZWRTdHlsZSkge1xuICAgICAgdmFyIGN1cnNvckxvYyA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzdGFydCwgdHJ1ZSksXG4gICAgICAgICAgYWRkZWRMaW5lcyA9IFswXSwgbGluZXNMZW5naHQgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnNlcnRlZFRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGluc2VydGVkVGV4dFtpXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICBsaW5lc0xlbmdodCsrO1xuICAgICAgICAgIGFkZGVkTGluZXNbbGluZXNMZW5naHRdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhZGRlZExpbmVzW2xpbmVzTGVuZ2h0XSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWRkZWRMaW5lc1swXSA+IDApIHtcbiAgICAgICAgdGhpcy5pbnNlcnRDaGFyU3R5bGVPYmplY3QoY3Vyc29yTG9jLmxpbmVJbmRleCwgY3Vyc29yTG9jLmNoYXJJbmRleCwgYWRkZWRMaW5lc1swXSwgY29waWVkU3R5bGUpO1xuICAgICAgICBjb3BpZWRTdHlsZSA9IGNvcGllZFN0eWxlICYmIGNvcGllZFN0eWxlLnNsaWNlKGFkZGVkTGluZXNbMF0gKyAxKTtcbiAgICAgIH1cbiAgICAgIGxpbmVzTGVuZ2h0ICYmIHRoaXMuaW5zZXJ0TmV3bGluZVN0eWxlT2JqZWN0KFxuICAgICAgICBjdXJzb3JMb2MubGluZUluZGV4LCBjdXJzb3JMb2MuY2hhckluZGV4ICsgYWRkZWRMaW5lc1swXSwgbGluZXNMZW5naHQpO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsaW5lc0xlbmdodDsgaSsrKSB7XG4gICAgICAgIGlmIChhZGRlZExpbmVzW2ldID4gMCkge1xuICAgICAgICAgIHRoaXMuaW5zZXJ0Q2hhclN0eWxlT2JqZWN0KGN1cnNvckxvYy5saW5lSW5kZXggKyBpLCAwLCBhZGRlZExpbmVzW2ldLCBjb3BpZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29waWVkU3R5bGUpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlc1tjdXJzb3JMb2MubGluZUluZGV4ICsgaV1bMF0gPSBjb3BpZWRTdHlsZVswXTtcbiAgICAgICAgfVxuICAgICAgICBjb3BpZWRTdHlsZSA9IGNvcGllZFN0eWxlICYmIGNvcGllZFN0eWxlLnNsaWNlKGFkZGVkTGluZXNbaV0gKyAxKTtcbiAgICAgIH1cbiAgICAgIC8vIHdlIHVzZSBpIG91dHNpZGUgdGhlIGxvb3AgdG8gZ2V0IGl0IGxpa2UgbGluZXNMZW5ndGhcbiAgICAgIGlmIChhZGRlZExpbmVzW2ldID4gMCkge1xuICAgICAgICB0aGlzLmluc2VydENoYXJTdHlsZU9iamVjdChjdXJzb3JMb2MubGluZUluZGV4ICsgaSwgMCwgYWRkZWRMaW5lc1tpXSwgY29waWVkU3R5bGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNlbGVjdGlvblN0YXJ0IGFuZCBzZWxlY3Rpb25FbmQgYWNjb3JkaW5nIHRvIHRoZSBuZSBwb3N0aW9uIG9mIGN1cnNvclxuICAgICAqIG1pbWljIHRoZSBrZXkgLSBtb3VzZSBuYXZpZ2F0aW9uIHdoZW4gc2hpZnQgaXMgcHJlc3NlZC5cbiAgICAgKi9cbiAgICBzZXRTZWxlY3Rpb25TdGFydEVuZFdpdGhTaGlmdDogZnVuY3Rpb24oc3RhcnQsIGVuZCwgbmV3U2VsZWN0aW9uKSB7XG4gICAgICBpZiAobmV3U2VsZWN0aW9uIDw9IHN0YXJ0KSB7XG4gICAgICAgIGlmIChlbmQgPT09IHN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb247XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChuZXdTZWxlY3Rpb24gPiBzdGFydCAmJiBuZXdTZWxlY3Rpb24gPCBlbmQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBuZXdTZWxlY3Rpb24gaXMgPiBzZWxlY3Rpb24gc3RhcnQgYW5kIGVuZFxuICAgICAgICBpZiAoZW5kID09PSBzdGFydCkge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAncmlnaHQnO1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb247XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNldFNlbGVjdGlvbkluQm91bmRhcmllczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID4gbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0IDwgMCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbkVuZCA+IGxlbmd0aCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uRW5kIDwgMCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuSVRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUgKi8ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgXCJkYmNsaWNrXCIgZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgaW5pdERvdWJsZUNsaWNrU2ltdWxhdGlvbjogZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBmb3IgZG91YmxlIGNsaWNrXG4gICAgdGhpcy5fX2xhc3RDbGlja1RpbWUgPSArbmV3IERhdGUoKTtcblxuICAgIC8vIGZvciB0cmlwbGUgY2xpY2tcbiAgICB0aGlzLl9fbGFzdExhc3RDbGlja1RpbWUgPSArbmV3IERhdGUoKTtcblxuICAgIHRoaXMuX19sYXN0UG9pbnRlciA9IHsgfTtcblxuICAgIHRoaXMub24oJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGV2ZW50IGhhbmRsZXIgdG8gc2ltdWxhdGUgdHJpcGxlIGNsaWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbk1vdXNlRG93bjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fX25ld0NsaWNrVGltZSA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBuZXdQb2ludGVyID0gb3B0aW9ucy5wb2ludGVyO1xuICAgIGlmICh0aGlzLmlzVHJpcGxlQ2xpY2sobmV3UG9pbnRlcikpIHtcbiAgICAgIHRoaXMuZmlyZSgndHJpcGxlY2xpY2snLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX3N0b3BFdmVudChvcHRpb25zLmUpO1xuICAgIH1cbiAgICB0aGlzLl9fbGFzdExhc3RDbGlja1RpbWUgPSB0aGlzLl9fbGFzdENsaWNrVGltZTtcbiAgICB0aGlzLl9fbGFzdENsaWNrVGltZSA9IHRoaXMuX19uZXdDbGlja1RpbWU7XG4gICAgdGhpcy5fX2xhc3RQb2ludGVyID0gbmV3UG9pbnRlcjtcbiAgICB0aGlzLl9fbGFzdElzRWRpdGluZyA9IHRoaXMuaXNFZGl0aW5nO1xuICAgIHRoaXMuX19sYXN0U2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkO1xuICB9LFxuXG4gIGlzVHJpcGxlQ2xpY2s6IGZ1bmN0aW9uKG5ld1BvaW50ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fX25ld0NsaWNrVGltZSAtIHRoaXMuX19sYXN0Q2xpY2tUaW1lIDwgNTAwICYmXG4gICAgICAgIHRoaXMuX19sYXN0Q2xpY2tUaW1lIC0gdGhpcy5fX2xhc3RMYXN0Q2xpY2tUaW1lIDwgNTAwICYmXG4gICAgICAgIHRoaXMuX19sYXN0UG9pbnRlci54ID09PSBuZXdQb2ludGVyLnggJiZcbiAgICAgICAgdGhpcy5fX2xhc3RQb2ludGVyLnkgPT09IG5ld1BvaW50ZXIueTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zdG9wRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0ICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbiAmJiBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBldmVudCBoYW5kbGVycyByZWxhdGVkIHRvIGN1cnNvciBvciBzZWxlY3Rpb25cbiAgICovXG4gIGluaXRDdXJzb3JTZWxlY3Rpb25IYW5kbGVyczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbml0TW91c2Vkb3duSGFuZGxlcigpO1xuICAgIHRoaXMuaW5pdE1vdXNldXBIYW5kbGVyKCk7XG4gICAgdGhpcy5pbml0Q2xpY2tzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGRvdWJsZSBhbmQgdHJpcGxlIGNsaWNrIGV2ZW50IGhhbmRsZXJzXG4gICAqL1xuICBpbml0Q2xpY2tzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9uKCdtb3VzZWRibGNsaWNrJywgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5zZWxlY3RXb3JkKHRoaXMuZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcihvcHRpb25zLmUpKTtcbiAgICB9KTtcbiAgICB0aGlzLm9uKCd0cmlwbGVjbGljaycsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc2VsZWN0TGluZSh0aGlzLmdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXIob3B0aW9ucy5lKSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllcyBuZWVkZWQgb24gX21vdXNlRG93blxuICAgKiBjYW4gYmUgb3ZlcnJpZGRlbiB0byBkbyBzb21ldGhpbmcgZGlmZmVyZW50LlxuICAgKiBTY29wZSBvZiB0aGlzIGltcGxlbWVudGF0aW9uIGlzOiBmaW5kIHRoZSBjbGljayBwb3NpdGlvbiwgc2V0IHNlbGVjdGlvblN0YXJ0XG4gICAqIGZpbmQgc2VsZWN0aW9uRW5kLCBpbml0aWFsaXplIHRoZSBkcmF3aW5nIG9mIGVpdGhlciBjdXJzb3Igb3Igc2VsZWN0aW9uIGFyZWFcbiAgICovXG4gIF9tb3VzZURvd25IYW5kbGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNhbnZhcyB8fCAhdGhpcy5lZGl0YWJsZSB8fCAob3B0aW9ucy5lLmJ1dHRvbiAmJiBvcHRpb25zLmUuYnV0dG9uICE9PSAxKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX19pc01vdXNlZG93biA9IHRydWU7XG5cbiAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgdGhpcy5zZXRDdXJzb3JCeUNsaWNrKG9wdGlvbnMuZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICB0aGlzLl9fc2VsZWN0aW9uU3RhcnRPbk1vdXNlRG93biA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVmYXVsdCBldmVudCBoYW5kbGVyIGZvciB0aGUgYmFzaWMgZnVuY3Rpb25hbGl0aWVzIG5lZWRlZCBvbiBtb3VzZWRvd246YmVmb3JlXG4gICAqIGNhbiBiZSBvdmVycmlkZGVuIHRvIGRvIHNvbWV0aGluZyBkaWZmZXJlbnQuXG4gICAqIFNjb3BlIG9mIHRoaXMgaW1wbGVtZW50YXRpb24gaXM6IHZlcmlmeSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgc2VsZWN0ZWQgd2hlbiBtb3VzaW5nIGRvd25cbiAgICovXG4gIF9tb3VzZURvd25IYW5kbGVyQmVmb3JlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNhbnZhcyB8fCAhdGhpcy5lZGl0YWJsZSB8fCAob3B0aW9ucy5lLmJ1dHRvbiAmJiBvcHRpb25zLmUuYnV0dG9uICE9PSAxKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcyA9PT0gdGhpcy5jYW52YXMuX2FjdGl2ZU9iamVjdCkge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBcIm1vdXNlZG93blwiIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIGluaXRNb3VzZWRvd25IYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9uKCdtb3VzZWRvd24nLCB0aGlzLl9tb3VzZURvd25IYW5kbGVyKTtcbiAgICB0aGlzLm9uKCdtb3VzZWRvd246YmVmb3JlJywgdGhpcy5fbW91c2VEb3duSGFuZGxlckJlZm9yZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIFwibW91c2V1cFwiIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIGluaXRNb3VzZXVwSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vbignbW91c2V1cCcsIHRoaXMubW91c2VVcEhhbmRsZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzdGFuZGFyZCBoYW5kZXIgZm9yIG1vdXNlIHVwLCBvdmVycmlkYWJsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbW91c2VVcEhhbmRsZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9faXNNb3VzZWRvd24gPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuZWRpdGFibGUgfHxcbiAgICAgIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvcHRpb25zLnRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQpIHx8XG4gICAgICAob3B0aW9ucy5lLmJ1dHRvbiAmJiBvcHRpb25zLmUuYnV0dG9uICE9PSAxKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9fbGFzdFNlbGVjdGVkICYmICF0aGlzLl9fY29ybmVyKSB7XG4gICAgICB0aGlzLmVudGVyRWRpdGluZyhvcHRpb25zLmUpO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IodHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hhbmdlcyBjdXJzb3IgbG9jYXRpb24gaW4gYSB0ZXh0IGRlcGVuZGluZyBvbiBwYXNzZWQgcG9pbnRlciAoeC95KSBvYmplY3RcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIHNldEN1cnNvckJ5Q2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgbmV3U2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyKGUpLFxuICAgICAgICBzdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQsIGVuZCA9IHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICB0aGlzLnNldFNlbGVjdGlvblN0YXJ0RW5kV2l0aFNoaWZ0KHN0YXJ0LCBlbmQsIG5ld1NlbGVjdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBpbmRleCBvZiBhIGNoYXJhY3RlciBjb3JyZXNwb25kaW5nIHRvIHdoZXJlIGFuIG9iamVjdCB3YXMgY2xpY2tlZFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEluZGV4IG9mIGEgY2hhcmFjdGVyXG4gICAqL1xuICBnZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG1vdXNlT2Zmc2V0ID0gdGhpcy5nZXRMb2NhbFBvaW50ZXIoZSksXG4gICAgICAgIHByZXZXaWR0aCA9IDAsXG4gICAgICAgIHdpZHRoID0gMCxcbiAgICAgICAgaGVpZ2h0ID0gMCxcbiAgICAgICAgY2hhckluZGV4ID0gMCxcbiAgICAgICAgbGluZUluZGV4ID0gMCxcbiAgICAgICAgbGluZUxlZnRPZmZzZXQsXG4gICAgICAgIGxpbmU7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoaGVpZ2h0IDw9IG1vdXNlT2Zmc2V0LnkpIHtcbiAgICAgICAgaGVpZ2h0ICs9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpICogdGhpcy5zY2FsZVk7XG4gICAgICAgIGxpbmVJbmRleCA9IGk7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIGNoYXJJbmRleCArPSB0aGlzLl90ZXh0TGluZXNbaSAtIDFdLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgbGluZUxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChsaW5lSW5kZXgpO1xuICAgIHdpZHRoID0gbGluZUxlZnRPZmZzZXQgKiB0aGlzLnNjYWxlWDtcbiAgICBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF07XG4gICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBsaW5lLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgcHJldldpZHRoID0gd2lkdGg7XG4gICAgICAvLyBpIHJlbW92ZWQgc29tZXRoaW5nIGFib3V0IGZsaXBYIGhlcmUsIGNoZWNrLlxuICAgICAgd2lkdGggKz0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtqXS5rZXJuZWRXaWR0aCAqIHRoaXMuc2NhbGVYO1xuICAgICAgaWYgKHdpZHRoIDw9IG1vdXNlT2Zmc2V0LngpIHtcbiAgICAgICAgY2hhckluZGV4Kys7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9nZXROZXdTZWxlY3Rpb25TdGFydEZyb21PZmZzZXQobW91c2VPZmZzZXQsIHByZXZXaWR0aCwgd2lkdGgsIGNoYXJJbmRleCwgamxlbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0TmV3U2VsZWN0aW9uU3RhcnRGcm9tT2Zmc2V0OiBmdW5jdGlvbihtb3VzZU9mZnNldCwgcHJldldpZHRoLCB3aWR0aCwgaW5kZXgsIGpsZW4pIHtcbiAgICAvLyB3ZSBuZWVkIE1hdGguYWJzIGJlY2F1c2Ugd2hlbiB3aWR0aCBpcyBhZnRlciB0aGUgbGFzdCBjaGFyLCB0aGUgb2Zmc2V0IGlzIGdpdmVuIGFzIDEsIHdoaWxlIGlzIDBcbiAgICB2YXIgZGlzdGFuY2VCdHdMYXN0Q2hhckFuZEN1cnNvciA9IG1vdXNlT2Zmc2V0LnggLSBwcmV2V2lkdGgsXG4gICAgICAgIGRpc3RhbmNlQnR3TmV4dENoYXJBbmRDdXJzb3IgPSB3aWR0aCAtIG1vdXNlT2Zmc2V0LngsXG4gICAgICAgIG9mZnNldCA9IGRpc3RhbmNlQnR3TmV4dENoYXJBbmRDdXJzb3IgPiBkaXN0YW5jZUJ0d0xhc3RDaGFyQW5kQ3Vyc29yIHx8XG4gICAgICAgICAgZGlzdGFuY2VCdHdOZXh0Q2hhckFuZEN1cnNvciA8IDAgPyAwIDogMSxcbiAgICAgICAgbmV3U2VsZWN0aW9uU3RhcnQgPSBpbmRleCArIG9mZnNldDtcbiAgICAvLyBpZiBvYmplY3QgaXMgaG9yaXpvbnRhbGx5IGZsaXBwZWQsIG1pcnJvciBjdXJzb3IgbG9jYXRpb24gZnJvbSB0aGUgZW5kXG4gICAgaWYgKHRoaXMuZmxpcFgpIHtcbiAgICAgIG5ld1NlbGVjdGlvblN0YXJ0ID0gamxlbiAtIG5ld1NlbGVjdGlvblN0YXJ0O1xuICAgIH1cblxuICAgIGlmIChuZXdTZWxlY3Rpb25TdGFydCA+IHRoaXMuX3RleHQubGVuZ3RoKSB7XG4gICAgICBuZXdTZWxlY3Rpb25TdGFydCA9IHRoaXMuX3RleHQubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdTZWxlY3Rpb25TdGFydDtcbiAgfVxufSk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuSVRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBoaWRkZW4gdGV4dGFyZWEgKG5lZWRlZCB0byBicmluZyB1cCBrZXlib2FyZCBpbiBpT1MpXG4gICAqL1xuICBpbml0SGlkZGVuVGV4dGFyZWE6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnYXV0b2NhcGl0YWxpemUnLCAnb2ZmJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ2F1dG9jb3JyZWN0JywgJ29mZicpO1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2V0QXR0cmlidXRlKCdhdXRvY29tcGxldGUnLCAnb2ZmJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ3NwZWxsY2hlY2snLCAnZmFsc2UnKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnZGF0YS1mYWJyaWMtaGlkZGVudGV4dGFyZWEnLCAnJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ3dyYXAnLCAnb2ZmJyk7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5fY2FsY1RleHRhcmVhUG9zaXRpb24oKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246IGFic29sdXRlOyB0b3A6ICcgKyBzdHlsZS50b3AgK1xuICAgICc7IGxlZnQ6ICcgKyBzdHlsZS5sZWZ0ICsgJzsgei1pbmRleDogLTk5OTsgb3BhY2l0eTogMDsgd2lkdGg6IDFweDsgaGVpZ2h0OiAxcHg7IGZvbnQtc2l6ZTogMXB4OycgK1xuICAgICcgbGluZS1oZWlnaHQ6IDFweDsgcGFkZGluZ++9sHRvcDogJyArIHN0eWxlLmZvbnRTaXplICsgJzsnO1xuICAgIGZhYnJpYy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuaGlkZGVuVGV4dGFyZWEpO1xuXG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAna2V5dXAnLCB0aGlzLm9uS2V5VXAuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2lucHV0JywgdGhpcy5vbklucHV0LmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjb3B5JywgdGhpcy5jb3B5LmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjdXQnLCB0aGlzLmNvcHkuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ3Bhc3RlJywgdGhpcy5wYXN0ZS5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnY29tcG9zaXRpb25zdGFydCcsIHRoaXMub25Db21wb3NpdGlvblN0YXJ0LmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjb21wb3NpdGlvbnVwZGF0ZScsIHRoaXMub25Db21wb3NpdGlvblVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnY29tcG9zaXRpb25lbmQnLCB0aGlzLm9uQ29tcG9zaXRpb25FbmQuYmluZCh0aGlzKSk7XG5cbiAgICBpZiAoIXRoaXMuX2NsaWNrSGFuZGxlckluaXRpYWxpemVkICYmIHRoaXMuY2FudmFzKSB7XG4gICAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmNhbnZhcy51cHBlckNhbnZhc0VsLCAnY2xpY2snLCB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLl9jbGlja0hhbmRsZXJJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBGb3IgZnVuY3Rpb25hbGl0aWVzIG9uIGtleURvd25cbiAgICogTWFwIGEgc3BlY2lhbCBrZXkgdG8gYSBmdW5jdGlvbiBvZiB0aGUgaW5zdGFuY2UvcHJvdG90eXBlXG4gICAqIElmIHlvdSBuZWVkIGRpZmZlcmVudCBiZWhhdmlvdXIgZm9yIEVTQyBvciBUQUIgb3IgYXJyb3dzLCB5b3UgaGF2ZSB0byBjaGFuZ2VcbiAgICogdGhpcyBtYXAgc2V0dGluZyB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uIHRoYXQgeW91IGJ1aWxkIG9uIHRoZSBmYWJyaWMuSXRleHQgb3JcbiAgICogeW91ciBwcm90b3R5cGUuXG4gICAqIHRoZSBtYXAgY2hhbmdlIHdpbGwgYWZmZWN0IGFsbCBJbnN0YW5jZXMgdW5sZXNzIHlvdSBuZWVkIGZvciBvbmx5IHNvbWUgdGV4dCBJbnN0YW5jZXNcbiAgICogaW4gdGhhdCBjYXNlIHlvdSBoYXZlIHRvIGNsb25lIHRoaXMgb2JqZWN0IGFuZCBhc3NpZ24geW91ciBJbnN0YW5jZS5cbiAgICogdGhpcy5rZXlzTWFwID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKHRoaXMua2V5c01hcCk7XG4gICAqIFRoZSBmdW5jdGlvbiBtdXN0IGJlIGluIGZhYnJpYy5JdGV4dC5wcm90b3R5cGUubXlGdW5jdGlvbiBBbmQgd2lsbCByZWNlaXZlIGV2ZW50IGFzIGFyZ3NbMF1cbiAgICovXG4gIGtleXNNYXA6IHtcbiAgICA5OiAgJ2V4aXRFZGl0aW5nJyxcbiAgICAyNzogJ2V4aXRFZGl0aW5nJyxcbiAgICAzMzogJ21vdmVDdXJzb3JVcCcsXG4gICAgMzQ6ICdtb3ZlQ3Vyc29yRG93bicsXG4gICAgMzU6ICdtb3ZlQ3Vyc29yUmlnaHQnLFxuICAgIDM2OiAnbW92ZUN1cnNvckxlZnQnLFxuICAgIDM3OiAnbW92ZUN1cnNvckxlZnQnLFxuICAgIDM4OiAnbW92ZUN1cnNvclVwJyxcbiAgICAzOTogJ21vdmVDdXJzb3JSaWdodCcsXG4gICAgNDA6ICdtb3ZlQ3Vyc29yRG93bicsXG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvciBmdW5jdGlvbmFsaXRpZXMgb24ga2V5VXAgKyBjdHJsIHx8IGNtZFxuICAgKi9cbiAgY3RybEtleXNNYXBVcDoge1xuICAgIDY3OiAnY29weScsXG4gICAgODg6ICdjdXQnXG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvciBmdW5jdGlvbmFsaXRpZXMgb24ga2V5RG93biArIGN0cmwgfHwgY21kXG4gICAqL1xuICBjdHJsS2V5c01hcERvd246IHtcbiAgICA2NTogJ3NlbGVjdEFsbCdcbiAgfSxcblxuICBvbkNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAvLyBObyBuZWVkIHRvIHRyaWdnZXIgY2xpY2sgZXZlbnQgaGVyZSwgZm9jdXMgaXMgZW5vdWdoIHRvIGhhdmUgdGhlIGtleWJvYXJkIGFwcGVhciBvbiBBbmRyb2lkXG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYSAmJiB0aGlzLmhpZGRlblRleHRhcmVhLmZvY3VzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhbmRsZXMga2V5dXAgZXZlbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG9uS2V5RG93bjogZnVuY3Rpb24oZSkge1xuICAgIGlmICghdGhpcy5pc0VkaXRpbmcgfHwgdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZS5rZXlDb2RlIGluIHRoaXMua2V5c01hcCkge1xuICAgICAgdGhpc1t0aGlzLmtleXNNYXBbZS5rZXlDb2RlXV0oZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChlLmtleUNvZGUgaW4gdGhpcy5jdHJsS2V5c01hcERvd24pICYmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSkge1xuICAgICAgdGhpc1t0aGlzLmN0cmxLZXlzTWFwRG93bltlLmtleUNvZGVdXShlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChlLmtleUNvZGUgPj0gMzMgJiYgZS5rZXlDb2RlIDw9IDQwKSB7XG4gICAgICAvLyBpZiBpIHByZXNzIGFuIGFycm93IGtleSBqdXN0IHVwZGF0ZSBzZWxlY3Rpb25cbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlcyBrZXl1cCBldmVudFxuICAgKiBXZSBoYW5kbGUgS2V5VXAgYmVjYXVzZSBpZTExIGFuZCBlZGdlIGhhdmUgZGlmZmljdWx0aWVzIGNvcHkvcGFzdGluZ1xuICAgKiBpZiBhIGNvcHkvY3V0IGV2ZW50IGZpcmVkLCBrZXl1cCBpcyBkaXNtaXNzZWRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG9uS2V5VXA6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoIXRoaXMuaXNFZGl0aW5nIHx8IHRoaXMuX2NvcHlEb25lIHx8IHRoaXMuaW5Db21wb3NpdGlvbk1vZGUpIHtcbiAgICAgIHRoaXMuX2NvcHlEb25lID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgoZS5rZXlDb2RlIGluIHRoaXMuY3RybEtleXNNYXBVcCkgJiYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpKSB7XG4gICAgICB0aGlzW3RoaXMuY3RybEtleXNNYXBVcFtlLmtleUNvZGVdXShlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlcyBvbklucHV0IGV2ZW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBvbklucHV0OiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGZyb21QYXN0ZSA9IHRoaXMuZnJvbVBhc3RlO1xuICAgIHRoaXMuZnJvbVBhc3RlID0gZmFsc2U7XG4gICAgZSAmJiBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGlmICghdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gZGVjaXNpb25zIGFib3V0IHN0eWxlIGNoYW5nZXMuXG4gICAgdmFyIG5leHRUZXh0ID0gdGhpcy5fc3BsaXRUZXh0SW50b0xpbmVzKHRoaXMuaGlkZGVuVGV4dGFyZWEudmFsdWUpLmdyYXBoZW1lVGV4dCxcbiAgICAgICAgY2hhckNvdW50ID0gdGhpcy5fdGV4dC5sZW5ndGgsXG4gICAgICAgIG5leHRDaGFyQ291bnQgPSBuZXh0VGV4dC5sZW5ndGgsXG4gICAgICAgIHJlbW92ZWRUZXh0LCBpbnNlcnRlZFRleHQsXG4gICAgICAgIGNoYXJEaWZmID0gbmV4dENoYXJDb3VudCAtIGNoYXJDb3VudDtcbiAgICBpZiAodGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZSA9PT0gJycpIHtcbiAgICAgIHRoaXMuc3R5bGVzID0geyB9O1xuICAgICAgdGhpcy51cGRhdGVGcm9tVGV4dEFyZWEoKTtcbiAgICAgIHRoaXMuZmlyZSgnY2hhbmdlZCcpO1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6Y2hhbmdlZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRleHRhcmVhU2VsZWN0aW9uID0gdGhpcy5mcm9tU3RyaW5nVG9HcmFwaGVtZVNlbGVjdGlvbihcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uU3RhcnQsXG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvbkVuZCxcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEudmFsdWVcbiAgICApO1xuICAgIHZhciBiYWNrRGVsZXRlID0gdGhpcy5zZWxlY3Rpb25TdGFydCA+IHRleHRhcmVhU2VsZWN0aW9uLnNlbGVjdGlvblN0YXJ0O1xuXG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICByZW1vdmVkVGV4dCA9IHRoaXMuX3RleHQuc2xpY2UodGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQpO1xuICAgICAgY2hhckRpZmYgKz0gdGhpcy5zZWxlY3Rpb25FbmQgLSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgIH1cbiAgICBlbHNlIGlmIChuZXh0Q2hhckNvdW50IDwgY2hhckNvdW50KSB7XG4gICAgICBpZiAoYmFja0RlbGV0ZSkge1xuICAgICAgICByZW1vdmVkVGV4dCA9IHRoaXMuX3RleHQuc2xpY2UodGhpcy5zZWxlY3Rpb25FbmQgKyBjaGFyRGlmZiwgdGhpcy5zZWxlY3Rpb25FbmQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZWRUZXh0ID0gdGhpcy5fdGV4dC5zbGljZSh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvblN0YXJ0IC0gY2hhckRpZmYpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnNlcnRlZFRleHQgPSBuZXh0VGV4dC5zbGljZSh0ZXh0YXJlYVNlbGVjdGlvbi5zZWxlY3Rpb25FbmQgLSBjaGFyRGlmZiwgdGV4dGFyZWFTZWxlY3Rpb24uc2VsZWN0aW9uRW5kKTtcbiAgICBpZiAocmVtb3ZlZFRleHQgJiYgcmVtb3ZlZFRleHQubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVTdHlsZUZyb21Ubyh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvbkVuZCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChiYWNrRGVsZXRlKSB7XG4gICAgICAgIC8vIGRldGVjdCBkaWZmZXJlbmNpZXMgYmV0d2VlbiBmb3J3YXJkRGVsZXRlIGFuZCBiYWNrRGVsZXRlXG4gICAgICAgIHRoaXMucmVtb3ZlU3R5bGVGcm9tVG8odGhpcy5zZWxlY3Rpb25FbmQgLSByZW1vdmVkVGV4dC5sZW5ndGgsIHRoaXMuc2VsZWN0aW9uRW5kKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZVN0eWxlRnJvbVRvKHRoaXMuc2VsZWN0aW9uRW5kLCB0aGlzLnNlbGVjdGlvbkVuZCArIHJlbW92ZWRUZXh0Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbnNlcnRlZFRleHQubGVuZ3RoKSB7XG4gICAgICBpZiAoZnJvbVBhc3RlICYmIGluc2VydGVkVGV4dC5qb2luKCcnKSA9PT0gZmFicmljLmNvcGllZFRleHQpIHtcbiAgICAgICAgdGhpcy5pbnNlcnROZXdTdHlsZUJsb2NrKGluc2VydGVkVGV4dCwgdGhpcy5zZWxlY3Rpb25TdGFydCwgZmFicmljLmNvcGllZFRleHRTdHlsZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnNlcnROZXdTdHlsZUJsb2NrKGluc2VydGVkVGV4dCwgdGhpcy5zZWxlY3Rpb25TdGFydCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudXBkYXRlRnJvbVRleHRBcmVhKCk7XG4gICAgdGhpcy5maXJlKCdjaGFuZ2VkJyk7XG4gICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcy5maXJlKCd0ZXh0OmNoYW5nZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBDb21wb3NpdGlvbiBzdGFydFxuICAgKi9cbiAgb25Db21wb3NpdGlvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ29tcG9zaXRpb24gZW5kXG4gICAqL1xuICBvbkNvbXBvc2l0aW9uRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID0gZmFsc2U7XG4gIH0sXG5cbiAgLy8gLyoqXG4gIC8vICAqIENvbXBvc2l0aW9uIHVwZGF0ZVxuICAvLyAgKi9cbiAgb25Db21wb3NpdGlvblVwZGF0ZTogZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuY29tcG9zaXRpb25TdGFydCA9IGUudGFyZ2V0LnNlbGVjdGlvblN0YXJ0O1xuICAgIHRoaXMuY29tcG9zaXRpb25FbmQgPSBlLnRhcmdldC5zZWxlY3Rpb25FbmQ7XG4gICAgdGhpcy51cGRhdGVUZXh0YXJlYVBvc2l0aW9uKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvcGllcyBzZWxlY3RlZCB0ZXh0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgIC8vZG8gbm90IGN1dC1jb3B5IGlmIG5vIHNlbGVjdGlvblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZhYnJpYy5jb3BpZWRUZXh0ID0gdGhpcy5nZXRTZWxlY3RlZFRleHQoKTtcbiAgICBmYWJyaWMuY29waWVkVGV4dFN0eWxlID0gdGhpcy5nZXRTZWxlY3Rpb25TdHlsZXModGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQsIHRydWUpO1xuICAgIHRoaXMuX2NvcHlEb25lID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogUGFzdGVzIHRleHRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIHBhc3RlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmZyb21QYXN0ZSA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqIEByZXR1cm4ge09iamVjdH0gQ2xpcGJvYXJkIGRhdGEgb2JqZWN0XG4gICAqL1xuICBfZ2V0Q2xpcGJvYXJkRGF0YTogZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiAoZSAmJiBlLmNsaXBib2FyZERhdGEpIHx8IGZhYnJpYy53aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgdGhlIHdpZHRoIGluIHBpeGVscyBiZWZvcmUgdGhlIGN1cnNvciBvbiB0aGUgc2FtZSBsaW5lXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHdpZHRoQmVmb3JlQ3Vyc29yIHdpZHRoIGJlZm9yZSBjdXJzb3JcbiAgICovXG4gIF9nZXRXaWR0aEJlZm9yZUN1cnNvcjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICB2YXIgd2lkdGhCZWZvcmVDdXJzb3IgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChsaW5lSW5kZXgpLCBib3VuZDtcblxuICAgIGlmIChjaGFySW5kZXggPiAwKSB7XG4gICAgICBib3VuZCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1bY2hhckluZGV4IC0gMV07XG4gICAgICB3aWR0aEJlZm9yZUN1cnNvciArPSBib3VuZC5sZWZ0ICsgYm91bmQud2lkdGg7XG4gICAgfVxuICAgIHJldHVybiB3aWR0aEJlZm9yZUN1cnNvcjtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyBzdGFydCBvZmZzZXQgb2YgYSBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1JpZ2h0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldERvd25DdXJzb3JPZmZzZXQ6IGZ1bmN0aW9uKGUsIGlzUmlnaHQpIHtcbiAgICB2YXIgc2VsZWN0aW9uUHJvcCA9IHRoaXMuX2dldFNlbGVjdGlvbkZvck9mZnNldChlLCBpc1JpZ2h0KSxcbiAgICAgICAgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc2VsZWN0aW9uUHJvcCksXG4gICAgICAgIGxpbmVJbmRleCA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleDtcbiAgICAvLyBpZiBvbiBsYXN0IGxpbmUsIGRvd24gY3Vyc29yIGdvZXMgdG8gZW5kIG9mIGxpbmVcbiAgICBpZiAobGluZUluZGV4ID09PSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoIC0gMSB8fCBlLm1ldGFLZXkgfHwgZS5rZXlDb2RlID09PSAzNCkge1xuICAgICAgLy8gbW92ZSB0byB0aGUgZW5kIG9mIGEgdGV4dFxuICAgICAgcmV0dXJuIHRoaXMuX3RleHQubGVuZ3RoIC0gc2VsZWN0aW9uUHJvcDtcbiAgICB9XG4gICAgdmFyIGNoYXJJbmRleCA9IGN1cnNvckxvY2F0aW9uLmNoYXJJbmRleCxcbiAgICAgICAgd2lkdGhCZWZvcmVDdXJzb3IgPSB0aGlzLl9nZXRXaWR0aEJlZm9yZUN1cnNvcihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgIGluZGV4T25PdGhlckxpbmUgPSB0aGlzLl9nZXRJbmRleE9uTGluZShsaW5lSW5kZXggKyAxLCB3aWR0aEJlZm9yZUN1cnNvciksXG4gICAgICAgIHRleHRBZnRlckN1cnNvciA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLnNsaWNlKGNoYXJJbmRleCk7XG4gICAgcmV0dXJuIHRleHRBZnRlckN1cnNvci5sZW5ndGggKyBpbmRleE9uT3RoZXJMaW5lICsgMjtcbiAgfSxcblxuICAvKipcbiAgICogcHJpdmF0ZVxuICAgKiBIZWxwcyBmaW5kaW5nIGlmIHRoZSBvZmZzZXQgc2hvdWxkIGJlIGNvdW50ZWQgZnJvbSBTdGFydCBvciBFbmRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1JpZ2h0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIF9nZXRTZWxlY3Rpb25Gb3JPZmZzZXQ6IGZ1bmN0aW9uKGUsIGlzUmlnaHQpIHtcbiAgICBpZiAoZS5zaGlmdEtleSAmJiB0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLnNlbGVjdGlvbkVuZCAmJiBpc1JpZ2h0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzUmlnaHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0VXBDdXJzb3JPZmZzZXQ6IGZ1bmN0aW9uKGUsIGlzUmlnaHQpIHtcbiAgICB2YXIgc2VsZWN0aW9uUHJvcCA9IHRoaXMuX2dldFNlbGVjdGlvbkZvck9mZnNldChlLCBpc1JpZ2h0KSxcbiAgICAgICAgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc2VsZWN0aW9uUHJvcCksXG4gICAgICAgIGxpbmVJbmRleCA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleDtcbiAgICBpZiAobGluZUluZGV4ID09PSAwIHx8IGUubWV0YUtleSB8fCBlLmtleUNvZGUgPT09IDMzKSB7XG4gICAgICAvLyBpZiBvbiBmaXJzdCBsaW5lLCB1cCBjdXJzb3IgZ29lcyB0byBzdGFydCBvZiBsaW5lXG4gICAgICByZXR1cm4gLXNlbGVjdGlvblByb3A7XG4gICAgfVxuICAgIHZhciBjaGFySW5kZXggPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXgsXG4gICAgICAgIHdpZHRoQmVmb3JlQ3Vyc29yID0gdGhpcy5fZ2V0V2lkdGhCZWZvcmVDdXJzb3IobGluZUluZGV4LCBjaGFySW5kZXgpLFxuICAgICAgICBpbmRleE9uT3RoZXJMaW5lID0gdGhpcy5fZ2V0SW5kZXhPbkxpbmUobGluZUluZGV4IC0gMSwgd2lkdGhCZWZvcmVDdXJzb3IpLFxuICAgICAgICB0ZXh0QmVmb3JlQ3Vyc29yID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0uc2xpY2UoMCwgY2hhckluZGV4KTtcbiAgICAvLyByZXR1cm4gYSBuZWdhdGl2ZSBvZmZzZXRcbiAgICByZXR1cm4gLXRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXggLSAxXS5sZW5ndGggKyBpbmRleE9uT3RoZXJMaW5lIC0gdGV4dEJlZm9yZUN1cnNvci5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZvciBhIGdpdmVuIHdpZHRoIGl0IGZvdW5kcyB0aGUgbWF0Y2hpbmcgY2hhcmFjdGVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEluZGV4T25MaW5lOiBmdW5jdGlvbihsaW5lSW5kZXgsIHdpZHRoKSB7XG5cbiAgICB2YXIgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLFxuICAgICAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGxpbmVJbmRleCksXG4gICAgICAgIHdpZHRoT2ZDaGFyc09uTGluZSA9IGxpbmVMZWZ0T2Zmc2V0LFxuICAgICAgICBpbmRleE9uTGluZSA9IDAsIGNoYXJXaWR0aCwgZm91bmRNYXRjaDtcblxuICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgIGNoYXJXaWR0aCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1bal0ud2lkdGg7XG4gICAgICB3aWR0aE9mQ2hhcnNPbkxpbmUgKz0gY2hhcldpZHRoO1xuICAgICAgaWYgKHdpZHRoT2ZDaGFyc09uTGluZSA+IHdpZHRoKSB7XG4gICAgICAgIGZvdW5kTWF0Y2ggPSB0cnVlO1xuICAgICAgICB2YXIgbGVmdEVkZ2UgPSB3aWR0aE9mQ2hhcnNPbkxpbmUgLSBjaGFyV2lkdGgsXG4gICAgICAgICAgICByaWdodEVkZ2UgPSB3aWR0aE9mQ2hhcnNPbkxpbmUsXG4gICAgICAgICAgICBvZmZzZXRGcm9tTGVmdEVkZ2UgPSBNYXRoLmFicyhsZWZ0RWRnZSAtIHdpZHRoKSxcbiAgICAgICAgICAgIG9mZnNldEZyb21SaWdodEVkZ2UgPSBNYXRoLmFicyhyaWdodEVkZ2UgLSB3aWR0aCk7XG5cbiAgICAgICAgaW5kZXhPbkxpbmUgPSBvZmZzZXRGcm9tUmlnaHRFZGdlIDwgb2Zmc2V0RnJvbUxlZnRFZGdlID8gaiA6IChqIC0gMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlYWNoZWQgZW5kXG4gICAgaWYgKCFmb3VuZE1hdGNoKSB7XG4gICAgICBpbmRleE9uTGluZSA9IGxpbmUubGVuZ3RoIC0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXhPbkxpbmU7XG4gIH0sXG5cblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIGRvd25cbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG1vdmVDdXJzb3JEb3duOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPj0gdGhpcy5fdGV4dC5sZW5ndGggJiYgdGhpcy5zZWxlY3Rpb25FbmQgPj0gdGhpcy5fdGV4dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbW92ZUN1cnNvclVwT3JEb3duKCdEb3duJywgZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciB1cFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgbW92ZUN1cnNvclVwOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IDAgJiYgdGhpcy5zZWxlY3Rpb25FbmQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbW92ZUN1cnNvclVwT3JEb3duKCdVcCcsIGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgdXAgb3IgZG93biwgZmlyZXMgdGhlIGV2ZW50c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uICdVcCcgb3IgJ0Rvd24nXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBfbW92ZUN1cnNvclVwT3JEb3duOiBmdW5jdGlvbihkaXJlY3Rpb24sIGUpIHtcbiAgICAvLyBnZXRVcEN1cnNvck9mZnNldFxuICAgIC8vIGdldERvd25DdXJzb3JPZmZzZXRcbiAgICB2YXIgYWN0aW9uID0gJ2dldCcgKyBkaXJlY3Rpb24gKyAnQ3Vyc29yT2Zmc2V0JyxcbiAgICAgICAgb2Zmc2V0ID0gdGhpc1thY3Rpb25dKGUsIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jyk7XG4gICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgIHRoaXMubW92ZUN1cnNvcldpdGhTaGlmdChvZmZzZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMubW92ZUN1cnNvcldpdGhvdXRTaGlmdChvZmZzZXQpO1xuICAgIH1cbiAgICBpZiAob2Zmc2V0ICE9PSAwKSB7XG4gICAgICB0aGlzLnNldFNlbGVjdGlvbkluQm91bmRhcmllcygpO1xuICAgICAgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5fY3VycmVudEN1cnNvck9wYWNpdHkgPSAxO1xuICAgICAgdGhpcy5pbml0RGVsYXllZEN1cnNvcigpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3Igd2l0aCBzaGlmdFxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBtb3ZlQ3Vyc29yV2l0aFNoaWZ0OiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICB2YXIgbmV3U2VsZWN0aW9uID0gdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAnbGVmdCdcbiAgICAgID8gdGhpcy5zZWxlY3Rpb25TdGFydCArIG9mZnNldFxuICAgICAgOiB0aGlzLnNlbGVjdGlvbkVuZCArIG9mZnNldDtcbiAgICB0aGlzLnNldFNlbGVjdGlvblN0YXJ0RW5kV2l0aFNoaWZ0KHRoaXMuc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2VsZWN0aW9uRW5kLCBuZXdTZWxlY3Rpb24pO1xuICAgIHJldHVybiBvZmZzZXQgIT09IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciB1cCB3aXRob3V0IHNoaWZ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIG1vdmVDdXJzb3JXaXRob3V0U2hpZnQ6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ICs9IG9mZnNldDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCArPSBvZmZzZXQ7XG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQgIT09IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciBsZWZ0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yTGVmdDogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSAwICYmIHRoaXMuc2VsZWN0aW9uRW5kID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX21vdmVDdXJzb3JMZWZ0T3JSaWdodCgnTGVmdCcsIGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGEgY2hhbmdlIGhhcHBlbmVkXG4gICAqL1xuICBfbW92ZTogZnVuY3Rpb24oZSwgcHJvcCwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIG5ld1ZhbHVlO1xuICAgIGlmIChlLmFsdEtleSkge1xuICAgICAgbmV3VmFsdWUgPSB0aGlzWydmaW5kV29yZEJvdW5kYXJ5JyArIGRpcmVjdGlvbl0odGhpc1twcm9wXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGUubWV0YUtleSB8fCBlLmtleUNvZGUgPT09IDM1IHx8ICBlLmtleUNvZGUgPT09IDM2ICkge1xuICAgICAgbmV3VmFsdWUgPSB0aGlzWydmaW5kTGluZUJvdW5kYXJ5JyArIGRpcmVjdGlvbl0odGhpc1twcm9wXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpc1twcm9wXSArPSBkaXJlY3Rpb24gPT09ICdMZWZ0JyA/IC0xIDogMTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5ld1ZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpc1twcm9wXSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIHRoaXNbcHJvcF0gPSBuZXdWYWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tb3ZlTGVmdDogZnVuY3Rpb24oZSwgcHJvcCkge1xuICAgIHJldHVybiB0aGlzLl9tb3ZlKGUsIHByb3AsICdMZWZ0Jyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbW92ZVJpZ2h0OiBmdW5jdGlvbihlLCBwcm9wKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vdmUoZSwgcHJvcCwgJ1JpZ2h0Jyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciBsZWZ0IHdpdGhvdXQga2VlcGluZyBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgbW92ZUN1cnNvckxlZnRXaXRob3V0U2hpZnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgY2hhbmdlID0gdHJ1ZTtcbiAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAnbGVmdCc7XG5cbiAgICAvLyBvbmx5IG1vdmUgY3Vyc29yIHdoZW4gdGhlcmUgaXMgbm8gc2VsZWN0aW9uLFxuICAgIC8vIG90aGVyd2lzZSB3ZSBkaXNjYXJkIGl0LCBhbmQgbGVhdmUgY3Vyc29yIG9uIHNhbWUgcGxhY2VcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25FbmQgPT09IHRoaXMuc2VsZWN0aW9uU3RhcnQgJiYgdGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gMCkge1xuICAgICAgY2hhbmdlID0gdGhpcy5fbW92ZUxlZnQoZSwgJ3NlbGVjdGlvblN0YXJ0Jyk7XG5cbiAgICB9XG4gICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgIHJldHVybiBjaGFuZ2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciBsZWZ0IHdoaWxlIGtlZXBpbmcgc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIG1vdmVDdXJzb3JMZWZ0V2l0aFNoaWZ0OiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyAmJiB0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vdmVMZWZ0KGUsICdzZWxlY3Rpb25FbmQnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gMCl7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICByZXR1cm4gdGhpcy5fbW92ZUxlZnQoZSwgJ3NlbGVjdGlvblN0YXJ0Jyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgcmlnaHRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG1vdmVDdXJzb3JSaWdodDogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID49IHRoaXMuX3RleHQubGVuZ3RoICYmIHRoaXMuc2VsZWN0aW9uRW5kID49IHRoaXMuX3RleHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX21vdmVDdXJzb3JMZWZ0T3JSaWdodCgnUmlnaHQnLCBlKTtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHJpZ2h0IG9yIExlZnQsIGZpcmVzIGV2ZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gJ0xlZnQnLCAnUmlnaHQnXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBfbW92ZUN1cnNvckxlZnRPclJpZ2h0OiBmdW5jdGlvbihkaXJlY3Rpb24sIGUpIHtcbiAgICB2YXIgYWN0aW9uTmFtZSA9ICdtb3ZlQ3Vyc29yJyArIGRpcmVjdGlvbiArICdXaXRoJztcbiAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDE7XG5cbiAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgYWN0aW9uTmFtZSArPSAnU2hpZnQnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGFjdGlvbk5hbWUgKz0gJ291dFNoaWZ0JztcbiAgICB9XG4gICAgaWYgKHRoaXNbYWN0aW9uTmFtZV0oZSkpIHtcbiAgICAgIHRoaXMuYWJvcnRDdXJzb3JBbmltYXRpb24oKTtcbiAgICAgIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IoKTtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHJpZ2h0IHdoaWxlIGtlZXBpbmcgc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIG1vdmVDdXJzb3JSaWdodFdpdGhTaGlmdDogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdsZWZ0JyAmJiB0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vdmVSaWdodChlLCAnc2VsZWN0aW9uU3RhcnQnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5zZWxlY3Rpb25FbmQgIT09IHRoaXMuX3RleHQubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAncmlnaHQnO1xuICAgICAgcmV0dXJuIHRoaXMuX21vdmVSaWdodChlLCAnc2VsZWN0aW9uRW5kJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgcmlnaHQgd2l0aG91dCBrZWVwaW5nIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgbW92ZUN1cnNvclJpZ2h0V2l0aG91dFNoaWZ0OiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGNoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdyaWdodCc7XG5cbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgIGNoYW5nZWQgPSB0aGlzLl9tb3ZlUmlnaHQoZSwgJ3NlbGVjdGlvblN0YXJ0Jyk7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBjaGFyYWN0ZXJzIGZyb20gc3RhcnQvZW5kXG4gICAqIHN0YXJ0L2VuZCBhciBwZXIgZ3JhcGhlbWUgcG9zaXRpb24gaW4gX3RleHQgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIGRlZmF1bHQgdG8gc3RhcnQgKyAxXG4gICAqL1xuICByZW1vdmVDaGFyczogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZW5kID0gc3RhcnQgKyAxO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZVN0eWxlRnJvbVRvKHN0YXJ0LCBlbmQpO1xuICAgIHRoaXMuX3RleHQuc3BsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCk7XG4gICAgdGhpcy50ZXh0ID0gdGhpcy5fdGV4dC5qb2luKCcnKTtcbiAgICB0aGlzLnNldCgnZGlydHknLCB0cnVlKTtcbiAgICBpZiAodGhpcy5fc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZSgpKSB7XG4gICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgIH1cbiAgICB0aGlzLl9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGluc2VydCBjaGFyYWN0ZXJzIGF0IHN0YXJ0IHBvc2l0aW9uLCBiZWZvcmUgc3RhcnQgcG9zaXRpb24uXG4gICAqIHN0YXJ0ICBlcXVhbCAxIGl0IG1lYW5zIHRoZSB0ZXh0IGdldCBpbnNlcnRlZCBiZXR3ZWVuIGFjdHVhbCBncmFwaGVtZSAwIGFuZCAxXG4gICAqIGlmIHN0eWxlIGFycmF5IGlzIHByb3ZpZGVkLCBpdCBtdXN0IGJlIGFzIHRoZSBzYW1lIGxlbmd0aCBvZiB0ZXh0IGluIGdyYXBoZW1lc1xuICAgKiBpZiBlbmQgaXMgcHJvdmlkZWQgYW5kIGlzIGJpZ2dlciB0aGFuIHN0YXJ0LCBvbGQgdGV4dCBpcyByZXBsYWNlZC5cbiAgICogc3RhcnQvZW5kIGFyIHBlciBncmFwaGVtZSBwb3NpdGlvbiBpbiBfdGV4dCBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgdGV4dCB0byBpbnNlcnRcbiAgICogQHBhcmFtIHtBcnJheX0gc3R5bGUgYXJyYXkgb2Ygc3R5bGUgb2JqZWN0c1xuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBkZWZhdWx0IHRvIHN0YXJ0ICsgMVxuICAgKi9cbiAgaW5zZXJ0Q2hhcnM6IGZ1bmN0aW9uKHRleHQsIHN0eWxlLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICB9XG4gICAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgICB0aGlzLnJlbW92ZVN0eWxlRnJvbVRvKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICB2YXIgZ3JhcGhlbWVzID0gZmFicmljLnV0aWwuc3RyaW5nLmdyYXBoZW1lU3BsaXQodGV4dCk7XG4gICAgdGhpcy5pbnNlcnROZXdTdHlsZUJsb2NrKGdyYXBoZW1lcywgc3RhcnQsIHN0eWxlKTtcbiAgICB0aGlzLl90ZXh0ID0gW10uY29uY2F0KHRoaXMuX3RleHQuc2xpY2UoMCwgc3RhcnQpLCBncmFwaGVtZXMsIHRoaXMuX3RleHQuc2xpY2UoZW5kKSk7XG4gICAgdGhpcy50ZXh0ID0gdGhpcy5fdGV4dC5qb2luKCcnKTtcbiAgICB0aGlzLnNldCgnZGlydHknLCB0cnVlKTtcbiAgICBpZiAodGhpcy5fc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZSgpKSB7XG4gICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgIH1cbiAgICB0aGlzLl9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzKCk7XG4gIH0sXG5cbn0pO1xuXG5cbi8qIF9UT19TVkdfU1RBUlRfICovXG4oZnVuY3Rpb24oKSB7XG4gIHZhciB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgIG11bHRpcGxlU3BhY2VzUmVnZXggPSAvICArL2c7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuVGV4dC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlRleHQucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICB2YXIgbWFya3VwID0gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cCgpLFxuICAgICAgICAgIG9mZnNldHMgPSB0aGlzLl9nZXRTVkdMZWZ0VG9wT2Zmc2V0cygpLFxuICAgICAgICAgIHRleHRBbmRCZyA9IHRoaXMuX2dldFNWR1RleHRBbmRCZyhvZmZzZXRzLnRleHRUb3AsIG9mZnNldHMudGV4dExlZnQpO1xuICAgICAgdGhpcy5fd3JhcFNWR1RleHRBbmRCZyhtYXJrdXAsIHRleHRBbmRCZyk7XG5cbiAgICAgIHJldHVybiByZXZpdmVyID8gcmV2aXZlcihtYXJrdXAuam9pbignJykpIDogbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRTVkdMZWZ0VG9wT2Zmc2V0czogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0TGVmdDogLXRoaXMud2lkdGggLyAyLFxuICAgICAgICB0ZXh0VG9wOiAtdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgICBsaW5lVG9wOiB0aGlzLmdldEhlaWdodE9mTGluZSgwKVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfd3JhcFNWR1RleHRBbmRCZzogZnVuY3Rpb24obWFya3VwLCB0ZXh0QW5kQmcpIHtcbiAgICAgIHZhciBub1NoYWRvdyA9IHRydWUsIGZpbHRlciA9IHRoaXMuZ2V0U3ZnRmlsdGVyKCksXG4gICAgICAgICAgc3R5bGUgPSBmaWx0ZXIgPT09ICcnID8gJycgOiAnIHN0eWxlPVwiJyArIGZpbHRlciArICdcIicsXG4gICAgICAgICAgdGV4dERlY29yYXRpb24gPSB0aGlzLmdldFN2Z1RleHREZWNvcmF0aW9uKHRoaXMpO1xuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICdcXHQ8ZyAnLCB0aGlzLmdldFN2Z0lkKCksICd0cmFuc2Zvcm09XCInLCB0aGlzLmdldFN2Z1RyYW5zZm9ybSgpLCB0aGlzLmdldFN2Z1RyYW5zZm9ybU1hdHJpeCgpLCAnXCInLFxuICAgICAgICBzdHlsZSwgJz5cXG4nLFxuICAgICAgICB0ZXh0QW5kQmcudGV4dEJnUmVjdHMuam9pbignJyksXG4gICAgICAgICdcXHRcXHQ8dGV4dCB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiICcsXG4gICAgICAgICh0aGlzLmZvbnRGYW1pbHkgPyAnZm9udC1mYW1pbHk9XCInICsgdGhpcy5mb250RmFtaWx5LnJlcGxhY2UoL1wiL2csICdcXCcnKSArICdcIiAnIDogJycpLFxuICAgICAgICAodGhpcy5mb250U2l6ZSA/ICdmb250LXNpemU9XCInICsgdGhpcy5mb250U2l6ZSArICdcIiAnIDogJycpLFxuICAgICAgICAodGhpcy5mb250U3R5bGUgPyAnZm9udC1zdHlsZT1cIicgKyB0aGlzLmZvbnRTdHlsZSArICdcIiAnIDogJycpLFxuICAgICAgICAodGhpcy5mb250V2VpZ2h0ID8gJ2ZvbnQtd2VpZ2h0PVwiJyArIHRoaXMuZm9udFdlaWdodCArICdcIiAnIDogJycpLFxuICAgICAgICAodGV4dERlY29yYXRpb24gPyAndGV4dC1kZWNvcmF0aW9uPVwiJyArIHRleHREZWNvcmF0aW9uICsgJ1wiICcgOiAnJyksXG4gICAgICAgICdzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKG5vU2hhZG93KSwgJ1wiJywgdGhpcy5hZGRQYWludE9yZGVyKCksICcgPicsXG4gICAgICAgIHRleHRBbmRCZy50ZXh0U3BhbnMuam9pbignJyksXG4gICAgICAgICc8L3RleHQ+XFxuJyxcbiAgICAgICAgJ1xcdDwvZz5cXG4nXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0ZXh0VG9wT2Zmc2V0IFRleHQgdG9wIG9mZnNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0ZXh0TGVmdE9mZnNldCBUZXh0IGxlZnQgb2Zmc2V0XG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIF9nZXRTVkdUZXh0QW5kQmc6IGZ1bmN0aW9uKHRleHRUb3BPZmZzZXQsIHRleHRMZWZ0T2Zmc2V0KSB7XG4gICAgICB2YXIgdGV4dFNwYW5zID0gW10sXG4gICAgICAgICAgdGV4dEJnUmVjdHMgPSBbXSxcbiAgICAgICAgICBoZWlnaHQgPSB0ZXh0VG9wT2Zmc2V0LCBsaW5lT2Zmc2V0O1xuICAgICAgLy8gYm91bmRpbmctYm94IGJhY2tncm91bmRcbiAgICAgIHRoaXMuX3NldFNWR0JnKHRleHRCZ1JlY3RzKTtcblxuICAgICAgLy8gdGV4dCBhbmQgdGV4dC1iYWNrZ3JvdW5kXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxpbmVPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChpKTtcbiAgICAgICAgaWYgKHRoaXMudGV4dEJhY2tncm91bmRDb2xvciB8fCB0aGlzLnN0eWxlSGFzKCd0ZXh0QmFja2dyb3VuZENvbG9yJywgaSkpIHtcbiAgICAgICAgICB0aGlzLl9zZXRTVkdUZXh0TGluZUJnKHRleHRCZ1JlY3RzLCBpLCB0ZXh0TGVmdE9mZnNldCArIGxpbmVPZmZzZXQsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0U1ZHVGV4dExpbmVUZXh0KHRleHRTcGFucywgaSwgdGV4dExlZnRPZmZzZXQgKyBsaW5lT2Zmc2V0LCBoZWlnaHQpO1xuICAgICAgICBoZWlnaHQgKz0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRleHRTcGFuczogdGV4dFNwYW5zLFxuICAgICAgICB0ZXh0QmdSZWN0czogdGV4dEJnUmVjdHNcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZVRleHRDaGFyU3BhbjogZnVuY3Rpb24oX2NoYXIsIHN0eWxlRGVjbCwgbGVmdCwgdG9wKSB7XG4gICAgICB2YXIgc2hvdWxkVXNlV2hpdGVzcGFjZSA9IF9jaGFyICE9PSBfY2hhci50cmltKCkgfHwgX2NoYXIubWF0Y2gobXVsdGlwbGVTcGFjZXNSZWdleCksXG4gICAgICAgICAgc3R5bGVQcm9wcyA9IHRoaXMuZ2V0U3ZnU3BhblN0eWxlcyhzdHlsZURlY2wsIHNob3VsZFVzZVdoaXRlc3BhY2UpLFxuICAgICAgICAgIGZpbGxTdHlsZXMgPSBzdHlsZVByb3BzID8gJ3N0eWxlPVwiJyArIHN0eWxlUHJvcHMgKyAnXCInIDogJycsXG4gICAgICAgICAgZHkgPSBzdHlsZURlY2wuZGVsdGFZLCBkeVNwYW4gPSAnJyxcbiAgICAgICAgICBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuICAgICAgaWYgKGR5KSB7XG4gICAgICAgIGR5U3BhbiA9ICcgZHk9XCInICsgdG9GaXhlZChkeSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnXCIgJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8dHNwYW4geD1cIicsIHRvRml4ZWQobGVmdCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksICdcIiB5PVwiJyxcbiAgICAgICAgdG9GaXhlZCh0b3AsIE5VTV9GUkFDVElPTl9ESUdJVFMpLCAnXCIgJywgZHlTcGFuLFxuICAgICAgICBmaWxsU3R5bGVzLCAnPicsXG4gICAgICAgIGZhYnJpYy51dGlsLnN0cmluZy5lc2NhcGVYbWwoX2NoYXIpLFxuICAgICAgICAnPC90c3Bhbj4nXG4gICAgICBdLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBfc2V0U1ZHVGV4dExpbmVUZXh0OiBmdW5jdGlvbih0ZXh0U3BhbnMsIGxpbmVJbmRleCwgdGV4dExlZnRPZmZzZXQsIHRleHRUb3BPZmZzZXQpIHtcbiAgICAgIC8vIHNldCBwcm9wZXIgbGluZSBvZmZzZXRcbiAgICAgIHZhciBsaW5lSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUobGluZUluZGV4KSxcbiAgICAgICAgICBpc0p1c3RpZnkgPSB0aGlzLnRleHRBbGlnbi5pbmRleE9mKCdqdXN0aWZ5JykgIT09IC0xLFxuICAgICAgICAgIGFjdHVhbFN0eWxlLFxuICAgICAgICAgIG5leHRTdHlsZSxcbiAgICAgICAgICBjaGFyc1RvUmVuZGVyID0gJycsXG4gICAgICAgICAgY2hhckJveCwgc3R5bGUsXG4gICAgICAgICAgYm94V2lkdGggPSAwLFxuICAgICAgICAgIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XSxcbiAgICAgICAgICB0aW1lVG9SZW5kZXI7XG5cbiAgICAgIHRleHRUb3BPZmZzZXQgKz0gbGluZUhlaWdodCAqICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbikgLyB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZS5sZW5ndGggLSAxOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgIHRpbWVUb1JlbmRlciA9IGkgPT09IGxlbiB8fCB0aGlzLmNoYXJTcGFjaW5nO1xuICAgICAgICBjaGFyc1RvUmVuZGVyICs9IGxpbmVbaV07XG4gICAgICAgIGNoYXJCb3ggPSB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdW2ldO1xuICAgICAgICBpZiAoYm94V2lkdGggPT09IDApIHtcbiAgICAgICAgICB0ZXh0TGVmdE9mZnNldCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoIC0gY2hhckJveC53aWR0aDtcbiAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94LndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJveFdpZHRoICs9IGNoYXJCb3gua2VybmVkV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSnVzdGlmeSAmJiAhdGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3JlU3BhY2VBbmRUYWIudGVzdChsaW5lW2ldKSkge1xuICAgICAgICAgICAgdGltZVRvUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aW1lVG9SZW5kZXIpIHtcbiAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGNoYXJTcGFjaW5nLCB3ZSByZW5kZXIgY2hhciBieSBjaGFyXG4gICAgICAgICAgYWN0dWFsU3R5bGUgPSBhY3R1YWxTdHlsZSB8fCB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGkpO1xuICAgICAgICAgIG5leHRTdHlsZSA9IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgaSArIDEpO1xuICAgICAgICAgIHRpbWVUb1JlbmRlciA9IHRoaXMuX2hhc1N0eWxlQ2hhbmdlZEZvclN2ZyhhY3R1YWxTdHlsZSwgbmV4dFN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgc3R5bGUgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgaSkgfHwgeyB9O1xuICAgICAgICAgIHRleHRTcGFucy5wdXNoKHRoaXMuX2NyZWF0ZVRleHRDaGFyU3BhbihjaGFyc1RvUmVuZGVyLCBzdHlsZSwgdGV4dExlZnRPZmZzZXQsIHRleHRUb3BPZmZzZXQpKTtcbiAgICAgICAgICBjaGFyc1RvUmVuZGVyID0gJyc7XG4gICAgICAgICAgYWN0dWFsU3R5bGUgPSBuZXh0U3R5bGU7XG4gICAgICAgICAgdGV4dExlZnRPZmZzZXQgKz0gYm94V2lkdGg7XG4gICAgICAgICAgYm94V2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9wdXNoVGV4dEJnUmVjdDogZnVuY3Rpb24odGV4dEJnUmVjdHMsIGNvbG9yLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuICAgICAgdGV4dEJnUmVjdHMucHVzaChcbiAgICAgICAgJ1xcdFxcdDxyZWN0ICcsXG4gICAgICAgIHRoaXMuX2dldEZpbGxBdHRyaWJ1dGVzKGNvbG9yKSxcbiAgICAgICAgJyB4PVwiJyxcbiAgICAgICAgdG9GaXhlZChsZWZ0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgJ1wiIHk9XCInLFxuICAgICAgICB0b0ZpeGVkKHRvcCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICdcIiB3aWR0aD1cIicsXG4gICAgICAgIHRvRml4ZWQod2lkdGgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAnXCIgaGVpZ2h0PVwiJyxcbiAgICAgICAgdG9GaXhlZChoZWlnaHQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAnXCI+PC9yZWN0PlxcbicpO1xuICAgIH0sXG5cbiAgICBfc2V0U1ZHVGV4dExpbmVCZzogZnVuY3Rpb24odGV4dEJnUmVjdHMsIGksIGxlZnRPZmZzZXQsIHRleHRUb3BPZmZzZXQpIHtcbiAgICAgIHZhciBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2ldLFxuICAgICAgICAgIGhlaWdodE9mTGluZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpIC8gdGhpcy5saW5lSGVpZ2h0LFxuICAgICAgICAgIGJveFdpZHRoID0gMCxcbiAgICAgICAgICBib3hTdGFydCA9IDAsXG4gICAgICAgICAgY2hhckJveCwgY3VycmVudENvbG9yLFxuICAgICAgICAgIGxhc3RDb2xvciA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgMCwgJ3RleHRCYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgY2hhckJveCA9IHRoaXMuX19jaGFyQm91bmRzW2ldW2pdO1xuICAgICAgICBjdXJyZW50Q29sb3IgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIGosICd0ZXh0QmFja2dyb3VuZENvbG9yJyk7XG4gICAgICAgIGlmIChjdXJyZW50Q29sb3IgIT09IGxhc3RDb2xvcikge1xuICAgICAgICAgIGxhc3RDb2xvciAmJiB0aGlzLl9wdXNoVGV4dEJnUmVjdCh0ZXh0QmdSZWN0cywgbGFzdENvbG9yLCBsZWZ0T2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgICAgICB0ZXh0VG9wT2Zmc2V0LCBib3hXaWR0aCwgaGVpZ2h0T2ZMaW5lKTtcbiAgICAgICAgICBib3hTdGFydCA9IGNoYXJCb3gubGVmdDtcbiAgICAgICAgICBib3hXaWR0aCA9IGNoYXJCb3gud2lkdGg7XG4gICAgICAgICAgbGFzdENvbG9yID0gY3VycmVudENvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJveFdpZHRoICs9IGNoYXJCb3gua2VybmVkV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1cnJlbnRDb2xvciAmJiB0aGlzLl9wdXNoVGV4dEJnUmVjdCh0ZXh0QmdSZWN0cywgY3VycmVudENvbG9yLCBsZWZ0T2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgIHRleHRUb3BPZmZzZXQsIGJveFdpZHRoLCBoZWlnaHRPZkxpbmUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZG9iZSBJbGx1c3RyYXRvciAoYXQgbGVhc3QgQ1M1KSBpcyB1bmFibGUgdG8gcmVuZGVyIHJnYmEoKS1iYXNlZCBmaWxsIHZhbHVlc1xuICAgICAqIHdlIHdvcmsgYXJvdW5kIGl0IGJ5IFwibW92aW5nXCIgYWxwaGEgY2hhbm5lbCBpbnRvIG9wYWNpdHkgYXR0cmlidXRlIGFuZCBzZXR0aW5nIGZpbGwncyBhbHBoYSB0byAxXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgX2dldEZpbGxBdHRyaWJ1dGVzOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZpbGxDb2xvciA9ICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSA/IG5ldyBmYWJyaWMuQ29sb3IodmFsdWUpIDogJyc7XG4gICAgICBpZiAoIWZpbGxDb2xvciB8fCAhZmlsbENvbG9yLmdldFNvdXJjZSgpIHx8IGZpbGxDb2xvci5nZXRBbHBoYSgpID09PSAxKSB7XG4gICAgICAgIHJldHVybiAnZmlsbD1cIicgKyB2YWx1ZSArICdcIic7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ29wYWNpdHk9XCInICsgZmlsbENvbG9yLmdldEFscGhhKCkgKyAnXCIgZmlsbD1cIicgKyBmaWxsQ29sb3Iuc2V0QWxwaGEoMSkudG9SZ2IoKSArICdcIic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFNWR0xpbmVUb3BPZmZzZXQ6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIGxpbmVUb3BPZmZzZXQgPSAwLCBsYXN0SGVpZ2h0ID0gMDtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZUluZGV4OyBqKyspIHtcbiAgICAgICAgbGluZVRvcE9mZnNldCArPSB0aGlzLmdldEhlaWdodE9mTGluZShqKTtcbiAgICAgIH1cbiAgICAgIGxhc3RIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mTGluZShqKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVUb3A6IGxpbmVUb3BPZmZzZXQsXG4gICAgICAgIG9mZnNldDogKHRoaXMuX2ZvbnRTaXplTXVsdCAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pICogbGFzdEhlaWdodCAvICh0aGlzLmxpbmVIZWlnaHQgKiB0aGlzLl9mb250U2l6ZU11bHQpXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0eWxlcy1zdHJpbmcgZm9yIHN2Zy1leHBvcnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBTaGFkb3cgYSBib29sZWFuIHRvIHNraXAgc2hhZG93IGZpbHRlciBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnU3R5bGVzOiBmdW5jdGlvbihza2lwU2hhZG93KSB7XG4gICAgICB2YXIgc3ZnU3R5bGUgPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5nZXRTdmdTdHlsZXMuY2FsbCh0aGlzLCBza2lwU2hhZG93KTtcbiAgICAgIHJldHVybiBzdmdTdHlsZSArICcgd2hpdGUtc3BhY2U6IHByZTsnO1xuICAgIH0sXG4gIH0pO1xufSkoKTtcbi8qIF9UT19TVkdfRU5EXyAqL1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7fSk7XG5cbiAgLyoqXG4gICAqIFRleHRib3ggY2xhc3MsIGJhc2VkIG9uIElUZXh0LCBhbGxvd3MgdGhlIHVzZXIgdG8gcmVzaXplIHRoZSB0ZXh0IHJlY3RhbmdsZVxuICAgKiBhbmQgd3JhcHMgbGluZXMgYXV0b21hdGljYWxseS4gVGV4dGJveGVzIGhhdmUgdGhlaXIgWSBzY2FsaW5nIGxvY2tlZCwgdGhlXG4gICAqIHVzZXIgY2FuIG9ubHkgY2hhbmdlIHdpZHRoLiBIZWlnaHQgaXMgYWRqdXN0ZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiB0aGVcbiAgICogd3JhcHBpbmcgb2YgbGluZXMuXG4gICAqIEBjbGFzcyBmYWJyaWMuVGV4dGJveFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSVRleHRcbiAgICogQG1peGVzIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0Ym94fSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5UZXh0Ym94I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuVGV4dGJveCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5JVGV4dCwgZmFicmljLk9ic2VydmFibGUsIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAndGV4dGJveCcsXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIHdpZHRoIG9mIHRleHRib3gsIGluIHBpeGVscy5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1pbldpZHRoOiAyMCxcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gY2FsY3VsYXRlZCB3aWR0aCBvZiBhIHRleHRib3gsIGluIHBpeGVscy5cbiAgICAgKiBmaXhlZCB0byAyIHNvIHRoYXQgYW4gZW1wdHkgdGV4dGJveCBjYW5ub3QgZ28gdG8gMFxuICAgICAqIGFuZCBpcyBzdGlsbCBzZWxlY3RhYmxlIHdpdGhvdXQgdGV4dC5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGR5bmFtaWNNaW5XaWR0aDogMixcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBhcnJheSBvZiB0ZXh0IHdyYXBwaW5nLlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgX19jYWNoZWRMaW5lczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHN0YW5kYXJkIE9iamVjdCBjbGFzcyB2YWx1ZXNcbiAgICAgKi9cbiAgICBsb2NrU2NhbGluZ0ZsaXA6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBzdGFuZGFyZCBPYmplY3QgY2xhc3MgdmFsdWVzXG4gICAgICogVGV4dGJveCBuZWVkcyB0aGlzIG9uIGZhbHNlXG4gICAgICovXG4gICAgbm9TY2FsZUNhY2hlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgd2hpY2ggd2hlbiBzZXQgY2F1c2Ugb2JqZWN0IHRvIGNoYW5nZSBkaW1lbnNpb25zXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHM6IGZhYnJpYy5UZXh0LnByb3RvdHlwZS5fZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMuY29uY2F0KCd3aWR0aCcpLFxuXG4gICAgLyoqXG4gICAgICogVW5saWtlIHN1cGVyY2xhc3MncyB2ZXJzaW9uIG9mIHRoaXMgZnVuY3Rpb24sIFRleHRib3ggZG9lcyBub3QgdXBkYXRlXG4gICAgICogaXRzIHdpZHRoLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgaW5pdERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX19za2lwRGltZW5zaW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNFZGl0aW5nICYmIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IoKTtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB0aGlzLl9jbGVhckNhY2hlKCk7XG4gICAgICAvLyBjbGVhciBkeW5hbWljTWluV2lkdGggYXMgaXQgd2lsbCBiZSBkaWZmZXJlbnQgYWZ0ZXIgd2UgcmUtd3JhcCBsaW5lXG4gICAgICB0aGlzLmR5bmFtaWNNaW5XaWR0aCA9IDA7XG4gICAgICAvLyB3cmFwIGxpbmVzXG4gICAgICB0aGlzLl9zdHlsZU1hcCA9IHRoaXMuX2dlbmVyYXRlU3R5bGVNYXAodGhpcy5fc3BsaXRUZXh0KCkpO1xuICAgICAgLy8gaWYgYWZ0ZXIgd3JhcHBpbmcsIHRoZSB3aWR0aCBpcyBzbWFsbGVyIHRoYW4gZHluYW1pY01pbldpZHRoLCBjaGFuZ2UgdGhlIHdpZHRoIGFuZCByZS13cmFwXG4gICAgICBpZiAodGhpcy5keW5hbWljTWluV2lkdGggPiB0aGlzLndpZHRoKSB7XG4gICAgICAgIHRoaXMuX3NldCgnd2lkdGgnLCB0aGlzLmR5bmFtaWNNaW5XaWR0aCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSkge1xuICAgICAgICAvLyBvbmNlIHRleHQgaXMgbWVhc3VyZWQgd2UgbmVlZCB0byBtYWtlIHNwYWNlIGZhdHRlciB0byBtYWtlIGp1c3RpZmllZCB0ZXh0LlxuICAgICAgICB0aGlzLmVubGFyZ2VTcGFjZXMoKTtcbiAgICAgIH1cbiAgICAgIC8vIGNsZWFyIGNhY2hlIGFuZCByZS1jYWxjdWxhdGUgaGVpZ2h0XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY2FsY1RleHRIZWlnaHQoKTtcbiAgICAgIHRoaXMuc2F2ZVN0YXRlKHsgcHJvcGVydHlTZXQ6ICdfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMnIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBvYmplY3QgdGhhdCB0cmFuc2xhdGVzIHRoZSBzdHlsZSBvYmplY3Qgc28gdGhhdCBpdCBpc1xuICAgICAqIGJyb2tlbiB1cCBieSB2aXN1YWwgbGluZXMgKG5ldyBsaW5lcyBhbmQgYXV0b21hdGljIHdyYXBwaW5nKS5cbiAgICAgKiBUaGUgb3JpZ2luYWwgdGV4dCBzdHlsZXMgb2JqZWN0IGlzIGJyb2tlbiB1cCBieSBhY3R1YWwgbGluZXMgKG5ldyBsaW5lcyBvbmx5KSxcbiAgICAgKiB3aGljaCBpcyBvbmx5IHN1ZmZpY2llbnQgZm9yIFRleHQgLyBJVGV4dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dlbmVyYXRlU3R5bGVNYXA6IGZ1bmN0aW9uKHRleHRJbmZvKSB7XG4gICAgICB2YXIgcmVhbExpbmVDb3VudCAgICAgPSAwLFxuICAgICAgICAgIHJlYWxMaW5lQ2hhckNvdW50ID0gMCxcbiAgICAgICAgICBjaGFyQ291bnQgICAgICAgICA9IDAsXG4gICAgICAgICAgbWFwICAgICAgICAgICAgICAgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0SW5mby5ncmFwaGVtZUxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0ZXh0SW5mby5ncmFwaGVtZVRleHRbY2hhckNvdW50XSA9PT0gJ1xcbicgJiYgaSA+IDApIHtcbiAgICAgICAgICByZWFsTGluZUNoYXJDb3VudCA9IDA7XG4gICAgICAgICAgY2hhckNvdW50Kys7XG4gICAgICAgICAgcmVhbExpbmVDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3JlU3BhY2VBbmRUYWIudGVzdCh0ZXh0SW5mby5ncmFwaGVtZVRleHRbY2hhckNvdW50XSkgJiYgaSA+IDApIHtcbiAgICAgICAgICAvLyB0aGlzIGNhc2UgZGVhbHMgd2l0aCBzcGFjZSdzIHRoYXQgYXJlIHJlbW92ZWQgZnJvbSBlbmQgb2YgbGluZXMgd2hlbiB3cmFwcGluZ1xuICAgICAgICAgIHJlYWxMaW5lQ2hhckNvdW50Kys7XG4gICAgICAgICAgY2hhckNvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICBtYXBbaV0gPSB7IGxpbmU6IHJlYWxMaW5lQ291bnQsIG9mZnNldDogcmVhbExpbmVDaGFyQ291bnQgfTtcblxuICAgICAgICBjaGFyQ291bnQgKz0gdGV4dEluZm8uZ3JhcGhlbWVMaW5lc1tpXS5sZW5ndGg7XG4gICAgICAgIHJlYWxMaW5lQ2hhckNvdW50ICs9IHRleHRJbmZvLmdyYXBoZW1lTGluZXNbaV0ubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBhIHN0eWxlIHByb3BlcnR5IG9yIGhhcyBpdCBpbmEgc3BlY2lmaWVkIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdHlsZUhhczogZnVuY3Rpb24ocHJvcGVydHksIGxpbmVJbmRleCkge1xuICAgICAgaWYgKHRoaXMuX3N0eWxlTWFwICYmICF0aGlzLmlzV3JhcHBpbmcpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICAgIGlmIChtYXApIHtcbiAgICAgICAgICBsaW5lSW5kZXggPSBtYXAubGluZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhYnJpYy5UZXh0LnByb3RvdHlwZS5zdHlsZUhhcy5jYWxsKHRoaXMsIHByb3BlcnR5LCBsaW5lSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBubyBzdHlsaW5nIG9yIG5vIHN0eWxpbmcgaW4gYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCAsIGxpbmVJbmRleCBpcyBvbiB3cmFwcGVkIGxpbmVzLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbXB0eVN0eWxlczogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMCwgbmV4dExpbmVJbmRleCA9IGxpbmVJbmRleCArIDEsIG5leHRPZmZzZXQsIG9iaiwgc2hvdWxkTGltaXQgPSBmYWxzZTtcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgdmFyIG1hcE5leHRMaW5lID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4ICsgMV07XG4gICAgICBpZiAobWFwKSB7XG4gICAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgICBvZmZzZXQgPSBtYXAub2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKG1hcE5leHRMaW5lKSB7XG4gICAgICAgIG5leHRMaW5lSW5kZXggPSBtYXBOZXh0TGluZS5saW5lO1xuICAgICAgICBzaG91bGRMaW1pdCA9IG5leHRMaW5lSW5kZXggPT09IGxpbmVJbmRleDtcbiAgICAgICAgbmV4dE9mZnNldCA9IG1hcE5leHRMaW5lLm9mZnNldDtcbiAgICAgIH1cbiAgICAgIG9iaiA9IHR5cGVvZiBsaW5lSW5kZXggPT09ICd1bmRlZmluZWQnID8gdGhpcy5zdHlsZXMgOiB7IGxpbmU6IHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gfTtcbiAgICAgIGZvciAodmFyIHAxIGluIG9iaikge1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBvYmpbcDFdKSB7XG4gICAgICAgICAgaWYgKHAyID49IG9mZnNldCAmJiAoIXNob3VsZExpbWl0IHx8IHAyIDwgbmV4dE9mZnNldCkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgZm9yICh2YXIgcDMgaW4gb2JqW3AxXVtwMl0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLl9zdHlsZU1hcCAmJiAhdGhpcy5pc1dyYXBwaW5nKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgICBjaGFySW5kZXggPSBtYXAub2Zmc2V0ICsgY2hhckluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCdfZ2V0U3R5bGVEZWNsYXJhdGlvbicsIGxpbmVJbmRleCwgY2hhckluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgc3R5bGUpIHtcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgbGluZUluZGV4ID0gbWFwLmxpbmU7XG4gICAgICBjaGFySW5kZXggPSBtYXAub2Zmc2V0ICsgY2hhckluZGV4O1xuXG4gICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF0gPSBzdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICBsaW5lSW5kZXggPSBtYXAubGluZTtcbiAgICAgIGNoYXJJbmRleCA9IG1hcC5vZmZzZXQgKyBjaGFySW5kZXg7XG5cbiAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogcHJvYmFibHkgYnJva2VuIG5lZWQgYSBmaXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0TGluZVN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgcmV0dXJuIHRoaXMuc3R5bGVzW21hcC5saW5lXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcHJvYmFibHkgYnJva2VuIG5lZWQgYSBmaXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0TGluZVN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgsIHN0eWxlKSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgIHRoaXMuc3R5bGVzW21hcC5saW5lXSA9IHN0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBwcm9iYWJseSBicm9rZW4gbmVlZCBhIGZpeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVMaW5lU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbWFwLmxpbmVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyB0ZXh0IHVzaW5nIHRoZSAnd2lkdGgnIHByb3BlcnR5IG9mIFRleHRib3guIEZpcnN0IHRoaXMgZnVuY3Rpb25cbiAgICAgKiBzcGxpdHMgdGV4dCBvbiBuZXdsaW5lcywgc28gd2UgcHJlc2VydmUgbmV3bGluZXMgZW50ZXJlZCBieSB0aGUgdXNlci5cbiAgICAgKiBUaGVuIGl0IHdyYXBzIGVhY2ggbGluZSB1c2luZyB0aGUgd2lkdGggb2YgdGhlIFRleHRib3ggYnkgY2FsbGluZ1xuICAgICAqIF93cmFwTGluZSgpLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmVzIFRoZSBzdHJpbmcgYXJyYXkgb2YgdGV4dCB0aGF0IGlzIHNwbGl0IGludG8gbGluZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVzaXJlZFdpZHRoIHdpZHRoIHlvdSB3YW50IHRvIHdyYXAgdG9cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmVzXG4gICAgICovXG4gICAgX3dyYXBUZXh0OiBmdW5jdGlvbihsaW5lcywgZGVzaXJlZFdpZHRoKSB7XG4gICAgICB2YXIgd3JhcHBlZCA9IFtdLCBpO1xuICAgICAgdGhpcy5pc1dyYXBwaW5nID0gdHJ1ZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB3cmFwcGVkID0gd3JhcHBlZC5jb25jYXQodGhpcy5fd3JhcExpbmUobGluZXNbaV0sIGksIGRlc2lyZWRXaWR0aCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5pc1dyYXBwaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gd3JhcHBlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIG1lYXN1cmUgYSBzdHJpbmcgb2YgdGV4dCwgZ2l2ZW4gaXRzIGxpbmVJbmRleCBhbmQgY2hhckluZGV4IG9mZnNldFxuICAgICAqIGl0IGdldHMgY2FsbGVkIHdoZW4gY2hhckJvdW5kcyBhcmUgbm90IGF2YWlsYWJsZSB5ZXQuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFyT2Zmc2V0XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tZWFzdXJlV29yZDogZnVuY3Rpb24od29yZCwgbGluZUluZGV4LCBjaGFyT2Zmc2V0KSB7XG4gICAgICB2YXIgd2lkdGggPSAwLCBwcmV2R3JhcGhlbWUsIHNraXBMZWZ0ID0gdHJ1ZTtcbiAgICAgIGNoYXJPZmZzZXQgPSBjaGFyT2Zmc2V0IHx8IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gd29yZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgYm94ID0gdGhpcy5fZ2V0R3JhcGhlbWVCb3god29yZFtpXSwgbGluZUluZGV4LCBpICsgY2hhck9mZnNldCwgcHJldkdyYXBoZW1lLCBza2lwTGVmdCk7XG4gICAgICAgIHdpZHRoICs9IGJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgcHJldkdyYXBoZW1lID0gd29yZFtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV3JhcHMgYSBsaW5lIG9mIHRleHQgdXNpbmcgdGhlIHdpZHRoIG9mIHRoZSBUZXh0Ym94IGFuZCBhIGNvbnRleHQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGluZSBUaGUgZ3JhcGhlbWUgYXJyYXkgdGhhdCByZXByZXNlbnQgdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlc2lyZWRXaWR0aCB3aWR0aCB5b3Ugd2FudCB0byB3cmFwIHRoZSBsaW5lIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJlc2VydmVkU3BhY2Ugc3BhY2UgdG8gcmVtb3ZlIGZyb20gd3JhcHBpbmcgZm9yIGN1c3RvbSBmdW5jdGlvbmFsaXRpZXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmUocykgaW50byB3aGljaCB0aGUgZ2l2ZW4gdGV4dCBpcyB3cmFwcGVkXG4gICAgICogdG8uXG4gICAgICovXG4gICAgX3dyYXBMaW5lOiBmdW5jdGlvbihfbGluZSwgbGluZUluZGV4LCBkZXNpcmVkV2lkdGgsIHJlc2VydmVkU3BhY2UpIHtcbiAgICAgIHZhciBsaW5lV2lkdGggICAgICAgID0gMCxcbiAgICAgICAgICBncmFwaGVtZUxpbmVzICAgID0gW10sXG4gICAgICAgICAgbGluZSAgICAgICAgICAgICA9IFtdLFxuICAgICAgICAgIC8vIHNwYWNlcyBpbiBkaWZmZXJlbnQgbGFuZ3VnZXM/XG4gICAgICAgICAgd29yZHMgICAgICAgICAgICA9IF9saW5lLnNwbGl0KHRoaXMuX3JlU3BhY2VBbmRUYWIpLFxuICAgICAgICAgIHdvcmQgICAgICAgICAgICAgPSAnJyxcbiAgICAgICAgICBvZmZzZXQgICAgICAgICAgID0gMCxcbiAgICAgICAgICBpbmZpeCAgICAgICAgICAgID0gJyAnLFxuICAgICAgICAgIHdvcmRXaWR0aCAgICAgICAgPSAwLFxuICAgICAgICAgIGluZml4V2lkdGggICAgICAgPSAwLFxuICAgICAgICAgIGxhcmdlc3RXb3JkV2lkdGggPSAwLFxuICAgICAgICAgIGxpbmVKdXN0U3RhcnRlZCA9IHRydWUsXG4gICAgICAgICAgYWRkaXRpb25hbFNwYWNlID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCksXG4gICAgICAgICAgcmVzZXJ2ZWRTcGFjZSA9IHJlc2VydmVkU3BhY2UgfHwgMDtcblxuICAgICAgZGVzaXJlZFdpZHRoIC09IHJlc2VydmVkU3BhY2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGkgd291bGQgYXZvaWQgcmVzcGxpdHRpbmcgdGhlIGdyYXBoZW1lc1xuICAgICAgICB3b3JkID0gZmFicmljLnV0aWwuc3RyaW5nLmdyYXBoZW1lU3BsaXQod29yZHNbaV0pO1xuICAgICAgICB3b3JkV2lkdGggPSB0aGlzLl9tZWFzdXJlV29yZCh3b3JkLCBsaW5lSW5kZXgsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSB3b3JkLmxlbmd0aDtcblxuICAgICAgICBsaW5lV2lkdGggKz0gaW5maXhXaWR0aCArIHdvcmRXaWR0aCAtIGFkZGl0aW9uYWxTcGFjZTtcblxuICAgICAgICBpZiAobGluZVdpZHRoID49IGRlc2lyZWRXaWR0aCAmJiAhbGluZUp1c3RTdGFydGVkKSB7XG4gICAgICAgICAgZ3JhcGhlbWVMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgIGxpbmUgPSBbXTtcbiAgICAgICAgICBsaW5lV2lkdGggPSB3b3JkV2lkdGg7XG4gICAgICAgICAgbGluZUp1c3RTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsaW5lV2lkdGggKz0gYWRkaXRpb25hbFNwYWNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsaW5lSnVzdFN0YXJ0ZWQpIHtcbiAgICAgICAgICBsaW5lLnB1c2goaW5maXgpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgPSBsaW5lLmNvbmNhdCh3b3JkKTtcblxuICAgICAgICBpbmZpeFdpZHRoID0gdGhpcy5fbWVhc3VyZVdvcmQoW2luZml4XSwgbGluZUluZGV4LCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgbGluZUp1c3RTdGFydGVkID0gZmFsc2U7XG4gICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgbGFyZ2VzdCB3b3JkXG4gICAgICAgIGlmICh3b3JkV2lkdGggPiBsYXJnZXN0V29yZFdpZHRoKSB7XG4gICAgICAgICAgbGFyZ2VzdFdvcmRXaWR0aCA9IHdvcmRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpICYmIGdyYXBoZW1lTGluZXMucHVzaChsaW5lKTtcblxuICAgICAgaWYgKGxhcmdlc3RXb3JkV2lkdGggKyByZXNlcnZlZFNwYWNlID4gdGhpcy5keW5hbWljTWluV2lkdGgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljTWluV2lkdGggPSBsYXJnZXN0V29yZFdpZHRoIC0gYWRkaXRpb25hbFNwYWNlICsgcmVzZXJ2ZWRTcGFjZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdyYXBoZW1lTGluZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiB0aGUgdGV4dCBsaW5lIGlzIGVuZGVkIHdpdGggYW4gaGFyZCBicmVha1xuICAgICAqIHRleHQgYW5kIGl0ZXh0IGRvIG5vdCBoYXZlIHdyYXBwaW5nLCByZXR1cm4gZmFsc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IHRleHQgdG8gc3BsaXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRW5kT2ZXcmFwcGluZzogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleCArIDFdKSB7XG4gICAgICAgIC8vIGlzIGxhc3QgbGluZSwgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleCArIDFdLmxpbmUgIT09IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF0ubGluZSkge1xuICAgICAgICAvLyB0aGlzIGlzIGxhc3QgbGluZSBiZWZvcmUgYSBsaW5lIGJyZWFrLCByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogR2V0cyBsaW5lcyBvZiB0ZXh0IHRvIHJlbmRlciBpbiB0aGUgVGV4dGJveC4gVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzXG4gICAgKiB0ZXh0IHdyYXBwaW5nIG9uIHRoZSBmbHkgZXZlcnkgdGltZSBpdCBpcyBjYWxsZWQuXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0ZXh0IHRvIHNwbGl0XG4gICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmVzIGluIHRoZSBUZXh0Ym94LlxuICAgICogQG92ZXJyaWRlXG4gICAgKi9cbiAgICBfc3BsaXRUZXh0SW50b0xpbmVzOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICB2YXIgbmV3VGV4dCA9IGZhYnJpYy5UZXh0LnByb3RvdHlwZS5fc3BsaXRUZXh0SW50b0xpbmVzLmNhbGwodGhpcywgdGV4dCksXG4gICAgICAgICAgZ3JhcGhlbWVMaW5lcyA9IHRoaXMuX3dyYXBUZXh0KG5ld1RleHQubGluZXMsIHRoaXMud2lkdGgpLFxuICAgICAgICAgIGxpbmVzID0gbmV3IEFycmF5KGdyYXBoZW1lTGluZXMubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaGVtZUxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpbmVzW2ldID0gZ3JhcGhlbWVMaW5lc1tpXS5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIG5ld1RleHQubGluZXMgPSBsaW5lcztcbiAgICAgIG5ld1RleHQuZ3JhcGhlbWVMaW5lcyA9IGdyYXBoZW1lTGluZXM7XG4gICAgICByZXR1cm4gbmV3VGV4dDtcbiAgICB9LFxuXG4gICAgZ2V0TWluV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMubWluV2lkdGgsIHRoaXMuZHluYW1pY01pbldpZHRoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kIHRvT2JqZWN0XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ21pbldpZHRoJ10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5UZXh0Ym94IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0Ym94XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlRleHRib3ggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlRleHRib3guZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnVGV4dGJveCcsIG9iamVjdCwgY2FsbGJhY2ssICd0ZXh0Jyk7XG4gIH07XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBfc2V0T2JqZWN0U2NhbGUgYW5kIGFkZCBUZXh0Ym94IHNwZWNpZmljIHJlc2l6aW5nIGJlaGF2aW9yLiBSZXNpemluZ1xuICAgKiBhIFRleHRib3ggZG9lc24ndCBzY2FsZSB0ZXh0LCBpdCBvbmx5IGNoYW5nZXMgd2lkdGggYW5kIG1ha2VzIHRleHQgd3JhcCBhdXRvbWF0aWNhbGx5LlxuICAgKi9cbiAgdmFyIHNldE9iamVjdFNjYWxlT3ZlcnJpZGRlbiA9IGZhYnJpYy5DYW52YXMucHJvdG90eXBlLl9zZXRPYmplY3RTY2FsZTtcblxuICBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZS5fc2V0T2JqZWN0U2NhbGUgPSBmdW5jdGlvbihsb2NhbE1vdXNlLCB0cmFuc2Zvcm0sXG4gICAgbG9ja1NjYWxpbmdYLCBsb2NrU2NhbGluZ1ksIGJ5LCBsb2NrU2NhbGluZ0ZsaXAsIF9kaW0pIHtcblxuICAgIHZhciB0ID0gdHJhbnNmb3JtLnRhcmdldDtcbiAgICBpZiAoYnkgPT09ICd4JyAmJiB0IGluc3RhbmNlb2YgZmFicmljLlRleHRib3gpIHtcbiAgICAgIHZhciB0dyA9IHQuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpLng7XG4gICAgICB2YXIgdyA9IHQud2lkdGggKiAobG9jYWxNb3VzZS54IC8gdHcpO1xuICAgICAgaWYgKHcgPj0gdC5nZXRNaW5XaWR0aCgpKSB7XG4gICAgICAgIHQuc2V0KCd3aWR0aCcsIHcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gc2V0T2JqZWN0U2NhbGVPdmVycmlkZGVuLmNhbGwoZmFicmljLkNhbnZhcy5wcm90b3R5cGUsIGxvY2FsTW91c2UsIHRyYW5zZm9ybSxcbiAgICAgICAgbG9ja1NjYWxpbmdYLCBsb2NrU2NhbGluZ1ksIGJ5LCBsb2NrU2NhbGluZ0ZsaXAsIF9kaW0pO1xuICAgIH1cbiAgfTtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5UZXh0Ym94LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuSVRleHQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5fc3R5bGVNYXApIHtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0TGluZXNbcHJvcF0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbdGhpcy5fc3R5bGVNYXBbcHJvcF0ubGluZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gIH0pO1xufSkoKTtcblxuIiwiZXhwb3J0IGRlZmF1bHQge1xuICBTRUxFQ1RPUjogMCxcbiAgQ0lSQ0xFOiAxLFxuICBURVhUOiAyLFxuICBQRU46IDMsXG4gIE1BUktQRU46IDQsXG4gIEVSQVNFUjogNVxufSIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsInZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICB9XG4gIGVuZCA9IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IGVuZDtcbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuZ3RoO1xuICB9XG4gIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6ICgoZW5kIC0gc3RhcnQpID4+PiAwKTtcbiAgc3RhcnQgPj4+PSAwO1xuXG4gIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleCArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTbGljZTtcbiIsInZhciBiYXNlU2xpY2UgPSByZXF1aXJlKCcuL19iYXNlU2xpY2UnKTtcblxuLyoqXG4gKiBDYXN0cyBgYXJyYXlgIHRvIGEgc2xpY2UgaWYgaXQncyBuZWVkZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBzbGljZS5cbiAqL1xuZnVuY3Rpb24gY2FzdFNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kO1xuICByZXR1cm4gKCFzdGFydCAmJiBlbmQgPj0gbGVuZ3RoKSA/IGFycmF5IDogYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0U2xpY2U7XG4iLCIvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG52YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNVbmljb2RlO1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBhbiBBU0NJSSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXNjaWlUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnNwbGl0KCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc2NpaVRvQXJyYXk7XG4iLCIvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xudmFyIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xuXG4vKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqL1xudmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlKSB8fCBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmljb2RlVG9BcnJheTtcbiIsInZhciBhc2NpaVRvQXJyYXkgPSByZXF1aXJlKCcuL19hc2NpaVRvQXJyYXknKSxcbiAgICBoYXNVbmljb2RlID0gcmVxdWlyZSgnLi9faGFzVW5pY29kZScpLFxuICAgIHVuaWNvZGVUb0FycmF5ID0gcmVxdWlyZSgnLi9fdW5pY29kZVRvQXJyYXknKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgID8gdW5pY29kZVRvQXJyYXkoc3RyaW5nKVxuICAgIDogYXNjaWlUb0FycmF5KHN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nVG9BcnJheTtcbiIsInZhciBjYXN0U2xpY2UgPSByZXF1aXJlKCcuL19jYXN0U2xpY2UnKSxcbiAgICBoYXNVbmljb2RlID0gcmVxdWlyZSgnLi9faGFzVW5pY29kZScpLFxuICAgIHN0cmluZ1RvQXJyYXkgPSByZXF1aXJlKCcuL19zdHJpbmdUb0FycmF5JyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ubG93ZXJGaXJzdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgU3RyaW5nYCBjYXNlIG1ldGhvZCB0byB1c2UuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDYXNlRmlyc3QobWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgIHZhciBzdHJTeW1ib2xzID0gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgY2hyID0gc3RyU3ltYm9sc1xuICAgICAgPyBzdHJTeW1ib2xzWzBdXG4gICAgICA6IHN0cmluZy5jaGFyQXQoMCk7XG5cbiAgICB2YXIgdHJhaWxpbmcgPSBzdHJTeW1ib2xzXG4gICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKCcnKVxuICAgICAgOiBzdHJpbmcuc2xpY2UoMSk7XG5cbiAgICByZXR1cm4gY2hyW21ldGhvZE5hbWVdKCkgKyB0cmFpbGluZztcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVDYXNlRmlyc3Q7XG4iLCJ2YXIgY3JlYXRlQ2FzZUZpcnN0ID0gcmVxdWlyZSgnLi9fY3JlYXRlQ2FzZUZpcnN0Jyk7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVwcGVyRmlyc3QoJ2ZyZWQnKTtcbiAqIC8vID0+ICdGcmVkJ1xuICpcbiAqIF8udXBwZXJGaXJzdCgnRlJFRCcpO1xuICogLy8gPT4gJ0ZSRUQnXG4gKi9cbnZhciB1cHBlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b1VwcGVyQ2FzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVwcGVyRmlyc3Q7XG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyksXG4gICAgdXBwZXJGaXJzdCA9IHJlcXVpcmUoJy4vdXBwZXJGaXJzdCcpO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZSBhbmQgdGhlIHJlbWFpbmluZ1xuICogdG8gbG93ZXIgY2FzZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjYXBpdGFsaXplLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FwaXRhbGl6ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmNhcGl0YWxpemUoJ0ZSRUQnKTtcbiAqIC8vID0+ICdGcmVkJ1xuICovXG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICByZXR1cm4gdXBwZXJGaXJzdCh0b1N0cmluZyhzdHJpbmcpLnRvTG93ZXJDYXNlKCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhcGl0YWxpemU7XG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuICovXG52YXIgaWRDb3VudGVyID0gMDtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQuIElmIGBwcmVmaXhgIGlzIGdpdmVuLCB0aGUgSUQgaXMgYXBwZW5kZWQgdG8gaXQuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4PScnXSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICpcbiAqIF8udW5pcXVlSWQoKTtcbiAqIC8vID0+ICcxMDUnXG4gKi9cbmZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgcmV0dXJuIHRvU3RyaW5nKHByZWZpeCkgKyBpZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmlxdWVJZDtcbiIsImltcG9ydCB1bmlxdWVJZCBmcm9tICdsb2Rhc2gvdW5pcXVlSWQnO1xuaW1wb3J0IHtcbiAgZmFicmljXG59IGZyb20gJ2ZhYnJpYyc7XG5cbmNvbnN0IHBhdGhFdmVudHMgPSBbe1xuICBvcmlnaW46ICdtb3ZpbmcnLFxuICBpbnN0YW5jZTogJ29uTW92aW5nSGFuZGxlJ1xufSwge1xuICBvcmlnaW46ICdzY2FsaW5nJyxcbiAgaW5zdGFuY2U6ICdvblNjYWxpbmdIYW5kbGUnXG59LCB7XG4gIG9yaWdpbjogJ3JvdGF0aW5nJyxcbiAgaW5zdGFuY2U6ICdvblJvdGF0aW5nSGFuZGxlJ1xufV1cblxuY2xhc3MgVG9vbEJhc2Uge1xuICBjb25zdHJ1Y3RvcihjYW52YXMsIHN0eWxlKSB7XG4gICAgdGhpcy5jeHQgPSBjYW52YXM7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMuaXNNb3VzZURvd24gPSBmYWxzZTtcbiAgICB0aGlzLmhhc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5iaW5kRXZlbnQoKTtcbiAgfVxuXG4gIHNldCBzZWxlY3RlZChzZWxlY3RlZCkge1xuICAgIHRoaXMudG9vbEFjdGl2ZSA9IHNlbGVjdGVkO1xuICB9XG5cbiAgYmluZEV2ZW50KCkge1xuICAgIC8vIHRoaXMuY3h0Lm9uKCd0ZXh0OmNoYW5nZWQnLCAoe1xuICAgIC8vICAgdGFyZ2V0XG4gICAgLy8gfSkgPT4ge1xuICAgIC8vICAgY29uc29sZS5sb2codGFyZ2V0LnRleHQpO1xuICAgIC8vIH0pO1xuICB9XG5cbiAgb25Nb3VzZWRvd25IYW5kbGUoZXZlbnQpIHtcbiAgICB0aGlzLmlzTW91c2VEb3duID0gdHJ1ZTtcbiAgfVxuXG4gIG9uTW91c2V1cEhhbmRsZShldmVudCkge1xuICAgIHRoaXMuaXNNb3VzZURvd24gPSBmYWxzZTtcbiAgfVxuXG4gIG9uTW91c2Vtb3ZlSGFuZGxlKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgbW92ZW1lbnRYLFxuICAgICAgbW92ZW1lbnRZXG4gICAgfSA9IGV2ZW50WzBdLmU7XG4gICAgaWYgKG1vdmVtZW50WCA8IDAgJiYgbW92ZW1lbnRZIDwgMCkge1xuICAgICAgdGhpcy5kaXJlY3Rpb24gPSAnbGVmdFRvcCc7XG4gICAgfSBlbHNlIGlmIChtb3ZlbWVudFggPCAwICYmIG1vdmVtZW50WSA+IDApIHtcbiAgICAgIHRoaXMuZGlyZWN0aW9uID0gJ2xlZnRCb3R0b20nO1xuICAgIH0gZWxzZSBpZiAobW92ZW1lbnRYID4gMCAmJiBtb3ZlbWVudFkgPCAwKSB7XG4gICAgICB0aGlzLmRpcmVjdGlvbiA9ICdyaWdodFRvcCc7XG4gICAgfSBlbHNlIGlmIChtb3ZlbWVudFggPiAwICYmIG1vdmVtZW50WSA+IDApIHtcbiAgICAgIHRoaXMuZGlyZWN0aW9uID0gJ3JpZ2h0Qm90dG9tJztcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNNb3VzZURvd24pIHtcbiAgICAgIHRoaXMub25Nb3VzZURyYWdIYW5kbGUoZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIG9uTW91c2VEcmFnSGFuZGxlKGV2ZW50KSB7XG5cbiAgfVxuXG4gIG9uTW92aW5nSGFuZGxlKGUpIHt9XG4gIG9uUm90YXRpbmdIYW5kbGUoZSkge31cbiAgb25TY2FsaW5nSGFuZGxlKGUpIHt9XG5cbiAgcmVuZGVyUGF0aChwYXRoLCBpZ25vcmVSZW5kZXIgPSBmYWxzZSkge1xuICAgIGlmICghcGF0aCkgcmV0dXJuO1xuICAgIHBhdGguaWQgPSB1bmlxdWVJZCgnd2JQYXRoJyk7XG4gICAgcGF0aC50b29sVHlwZSA9IHRoaXMudG9vbFR5cGU7XG4gICAgIWlnbm9yZVJlbmRlciAmJiB0aGlzLmN4dC5hZGQocGF0aCk7XG4gICAgdGhpcy5iaW5kRXZlbnQocGF0aCk7XG4gIH1cblxuICBiaW5kRXZlbnQocGF0aCkge1xuICAgIGlmICghcGF0aCkgcmV0dXJuO1xuICAgIHBhdGhFdmVudHMuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICBwYXRoLm9uKGV2ZW50Lm9yaWdpbiwgdGhpc1tldmVudC5pbnN0YW5jZV0pO1xuICAgIH0pO1xuICAgIHBhdGgub24oJ3NlbGVjdGVkJywgKGUpID0+IHtcbiAgICAgIHRoaXMuaGFzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5sb2cocGF0aClcbiAgICAgIHBhdGguaGFzQ29udHJvbHMgPSB0cnVlO1xuICAgIH0pO1xuICAgIHBhdGgub24oJ2Rlc2VsZWN0ZWQnLCAoZSkgPT4ge1xuICAgICAgdGhpcy5oYXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgcGF0aC5oYXNDb250cm9scyA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBUb29sQmFzZTsiLCJpbXBvcnQgVG9vbEJhc2UgZnJvbSAnLi9Ub29sQmFzZSc7XG5pbXBvcnQge1xuICBmYWJyaWNcbn0gZnJvbSAnZmFicmljJztcbmltcG9ydCB0b29sVHlwZXMgZnJvbSAnLi4vY29uc3RhbnRzL3Rvb2xzJztcblxuY2xhc3MgQ2lyY2xlIGV4dGVuZHMgVG9vbEJhc2Uge1xuICBjb25zdHJ1Y3RvciguLi5hcmcpIHtcbiAgICBzdXBlciguLi5hcmcpO1xuICAgIHRoaXMudG9vbFR5cGUgPSB0b29sVHlwZXMuQ0lSQ0xFO1xuICB9XG5cbiAgb25Nb3VzZWRvd25IYW5kbGUoZXZlbnQpIHtcbiAgICBzdXBlci5vbk1vdXNlZG93bkhhbmRsZShldmVudCk7XG4gICAgdGhpcy5kb3duUG9pbnRlciA9IGV2ZW50WzBdLnBvaW50ZXI7XG4gIH1cblxuICBvbk1vdXNlRHJhZ0hhbmRsZShldmVudCkge1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3RlZCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gdGhpcy5kb3duUG9pbnRlcjtcbiAgICAgIGlmICh0aGlzLmNpcmNsZSkge1xuICAgICAgICB0aGlzLmN4dC5yZW1vdmUodGhpcy5jaXJjbGUpO1xuICAgICAgICB0aGlzLmNpcmNsZSA9IG51bGw7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5hYnMoZXZlbnRbMF0ucG9pbnRlci55IC0gdGhpcy5kb3duUG9pbnRlci55KTtcbiAgICAgIGxldCBiZWdpblBvaW50ZXIgPSB7XG4gICAgICAgIGxlZnQ6IHgsXG4gICAgICAgIHRvcDogeSxcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gKCdsZWZ0VG9wJyB8fCAnbGVmdEJvdHRvbScpKSB7XG4gICAgICAgIGJlZ2luUG9pbnRlciA9IHtcbiAgICAgICAgICBsZWZ0OiBldmVudFswXS5wb2ludGVyLngsXG4gICAgICAgICAgdG9wOiBldmVudFswXS5wb2ludGVyLnksXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0eWxlLCB7XG4gICAgICAgIHJhZGl1cyxcbiAgICAgICAgbGVmdDogYmVnaW5Qb2ludGVyLmxlZnQsXG4gICAgICAgIHRvcDogYmVnaW5Qb2ludGVyLnRvcCxcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmNpcmNsZSA9IG5ldyBmYWJyaWMuQ2lyY2xlKG9wdGlvbnMpO1xuICAgICAgdGhpcy5yZW5kZXJQYXRoKHRoaXMuY2lyY2xlKTtcbiAgICB9XG4gIH1cblxuICBvbk1vdXNldXBIYW5kbGUoZSkge1xuICAgIHN1cGVyLm9uTW91c2V1cEhhbmRsZShlKTtcbiAgICBpZiAoIXRoaXMuY2lyY2xlKSByZXR1cm47XG4gICAgdGhpcy5yZW5kZXJQYXRoKHRoaXMuY2lyY2xlKTtcbiAgICB0aGlzLmNpcmNsZSA9IG51bGw7XG4gICAgdGhpcy5kb3duUG9pbnRlciA9IG51bGw7XG4gIH1cblxuICBnZXRMaW5lTGVuZ3RoKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHN0YXJ0LnggLSBlbmQueCwgMikgKyBNYXRoLnBvdyhzdGFydC55IC0gZW5kLnksIDIpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDaXJjbGU7IiwiaW1wb3J0IFRvb2xCYXNlIGZyb20gJy4vVG9vbEJhc2UnO1xuaW1wb3J0IHtcbiAgZmFicmljXG59IGZyb20gJ2ZhYnJpYyc7XG5pbXBvcnQgdG9vbFR5cGVzIGZyb20gJy4uL2NvbnN0YW50cy90b29scyc7XG5cbmNsYXNzIFRleHQgZXh0ZW5kcyBUb29sQmFzZSB7XG5cbiAgY29uc3RydWN0b3IoLi4uYXJnKSB7XG4gICAgc3VwZXIoLi4uYXJnKTtcbiAgICB0aGlzLmJpbmRMaW50ZW5lcigpO1xuICAgIHRoaXMudG9vbFR5cGUgPSB0b29sVHlwZXMuVEVYVDtcbiAgfVxuXG4gIG9uTW91c2Vkb3duSGFuZGxlKGV2ZW50KSB7XG4gICAgc3VwZXIub25Nb3VzZWRvd25IYW5kbGUoZXZlbnQpO1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3RlZCkge1xuICAgICAgdGhpcy50ZXh0ID0gbmV3IGZhYnJpYy5UZXh0Ym94KCcgJywge1xuICAgICAgICBsZWZ0OiBldmVudFswXS5wb2ludGVyLngsXG4gICAgICAgIHRvcDogZXZlbnRbMF0ucG9pbnRlci55LFxuICAgICAgICB3aWR0aDogMTAwLFxuICAgICAgICBsaW5lSGVpZ2h0OiAwLjksXG4gICAgICAgIGhlaWdodDogNDBcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGJpbmRMaW50ZW5lcigpIHtcbiAgICB0aGlzLmN4dC5vbigndGV4dDpjaGFuZ2VkJywgKHtcbiAgICAgIHRhcmdldFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XG4gICAgfSk7XG4gIH1cblxuICBvbk1vdXNldXBIYW5kbGUoZXZlbnQpIHtcbiAgICBzdXBlci5vbk1vdXNldXBIYW5kbGUoZXZlbnQpO1xuICAgIHRoaXMucmVuZGVyUGF0aCh0aGlzLnRleHQpO1xuICAgIHRoaXMudGV4dC5lbnRlckVkaXRpbmcoZXZlbnQpO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dDsiLCJpbXBvcnQgVG9vbEJhc2UgZnJvbSAnLi9Ub29sQmFzZSc7XG5pbXBvcnQge1xuICBmYWJyaWNcbn0gZnJvbSAnZmFicmljJztcbmltcG9ydCB0b29sVHlwZXMgZnJvbSAnLi4vY29uc3RhbnRzL3Rvb2xzJztcblxuY2xhc3MgUGVuIGV4dGVuZHMgVG9vbEJhc2Uge1xuICBjb25zdHJ1Y3RvciguLi5hcmcpIHtcbiAgICBzdXBlciguLi5hcmcpO1xuICAgIHRoaXMudG9vbFR5cGUgPSB0b29sVHlwZXMuUEVOO1xuICAgIHRoaXMuY3h0Lm9uKCdwYXRoOmNyZWF0ZWQnLCAob2JqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy50b29sQWN0aXZlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyUGF0aChvYmplY3QucGF0aCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXQgc2VsZWN0ZWQoc2VsZWN0ZWQpIHtcbiAgICB0aGlzLnRvb2xBY3RpdmUgPSBzZWxlY3RlZDtcbiAgICB0aGlzLmN4dC5pc0RyYXdpbmdNb2RlID0gc2VsZWN0ZWQ7XG4gIH1cblxuICBzZXQgc3R5bGUoc3R5bGUpIHtcbiAgICB0aGlzLmN4dC5mcmVlRHJhd2luZ0JydXNoLmNvbG9yID0gc3R5bGUuY29sb3I7XG4gICAgdGhpcy5jeHQuZnJlZURyYXdpbmdCcnVzaC53aWR0aCA9IHN0eWxlLndpZHRoO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBlbjsiLCJpbXBvcnQgVG9vbEJhc2UgZnJvbSAnLi9Ub29sQmFzZSc7XG5pbXBvcnQge1xuICBmYWJyaWNcbn0gZnJvbSAnZmFicmljJztcbmltcG9ydCB0b29sVHlwZXMgZnJvbSAnLi4vY29uc3RhbnRzL3Rvb2xzJztcblxuY2xhc3MgTWFya1BlbiBleHRlbmRzIFRvb2xCYXNlIHtcbiAgY29uc3RydWN0b3IoLi4uYXJnKSB7XG4gICAgc3VwZXIoLi4uYXJnKTtcbiAgICB0aGlzLnRvb2xUeXBlID0gdG9vbFR5cGVzLk1BUktQRU47XG4gICAgdGhpcy5jeHQub24oJ3BhdGg6Y3JlYXRlZCcsIChvYmplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLnRvb2xBY3RpdmUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJQYXRoKG9iamVjdC5wYXRoLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHNldCBzZWxlY3RlZChzZWxlY3RlZCkge1xuICAgIHRoaXMudG9vbEFjdGl2ZSA9IHNlbGVjdGVkO1xuICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgdGhpcy5jeHQuaXNEcmF3aW5nTW9kZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgc2V0IHN0eWxlKHN0eWxlKSB7XG4gICAgdGhpcy5jeHQuZnJlZURyYXdpbmdCcnVzaC5jb2xvciA9IHN0eWxlLmNvbG9yO1xuICAgIHRoaXMuY3h0LmZyZWVEcmF3aW5nQnJ1c2gud2lkdGggPSBzdHlsZS53aWR0aDtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hcmtQZW47IiwiaW1wb3J0IFRvb2xCYXNlIGZyb20gJy4vVG9vbEJhc2UnO1xuaW1wb3J0IHtcbiAgZmFicmljXG59IGZyb20gJ2ZhYnJpYyc7XG5pbXBvcnQgdG9vbFR5cGVzIGZyb20gJy4uL2NvbnN0YW50cy90b29scyc7XG5cbmNsYXNzIEVyYXNlciBleHRlbmRzIFRvb2xCYXNlIHtcbiAgY29uc3RydWN0b3IoLi4uYXJnKSB7XG4gICAgc3VwZXIoLi4uYXJnKTtcbiAgICB0aGlzLnRvb2xUeXBlID0gdG9vbFR5cGVzLkVSQVNFUjtcbiAgICB0aGlzLmN4dC5vbigncGF0aDpjcmVhdGVkJywgKG9iamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMudG9vbEFjdGl2ZSkge1xuICAgICAgICBvYmplY3QucGF0aC5zZWxlY3RhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVuZGVyUGF0aChvYmplY3QucGF0aCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXQgc2VsZWN0ZWQoc2VsZWN0ZWQpIHtcbiAgICB0aGlzLnRvb2xBY3RpdmUgPSBzZWxlY3RlZDtcbiAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuY3h0LmZyZWVEcmF3aW5nQnJ1c2guY29sb3IgPSAnI2ZmZic7XG4gICAgICB0aGlzLmN4dC5pc0RyYXdpbmdNb2RlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBzZXQgc3R5bGUoc3R5bGUpIHtcbiAgICB0aGlzLmN4dC5mcmVlRHJhd2luZ0JydXNoLndpZHRoID0gc3R5bGUud2lkdGg7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBFcmFzZXI7IiwiaW1wb3J0IFRvb2xCYXNlIGZyb20gJy4vVG9vbEJhc2UnO1xuaW1wb3J0IHtcbiAgZmFicmljXG59IGZyb20gJ2ZhYnJpYyc7XG5pbXBvcnQgdG9vbFR5cGVzIGZyb20gJy4uL2NvbnN0YW50cy90b29scyc7XG5cbmNsYXNzIEVyYXNlciBleHRlbmRzIFRvb2xCYXNlIHtcbiAgY29uc3RydWN0b3IoLi4uYXJnKSB7XG4gICAgc3VwZXIoLi4uYXJnKTtcbiAgICB0aGlzLnRvb2xUeXBlID0gdG9vbFR5cGVzLlNFTEVDVE9SO1xuICB9XG5cbiAgc2V0IHNlbGVjdGVkKHNlbGVjdGVkKSB7XG4gICAgdGhpcy50b29sQWN0aXZlID0gc2VsZWN0ZWQ7XG4gICAgdGhpcy5jeHQuc2VsZWN0aW9uID0gdHJ1ZTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEVyYXNlcjsiLCJpbXBvcnQgY2FwaXRhbGl6ZSBmcm9tICdsb2Rhc2gvY2FwaXRhbGl6ZSc7XG5cbmltcG9ydCBDaXJjbGUgZnJvbSAnLi9DaXJjbGUnO1xuaW1wb3J0IFRleHQgZnJvbSAnLi9UZXh0JztcbmltcG9ydCBQZW4gZnJvbSAnLi9QZW4nO1xuaW1wb3J0IE1hcmtQZW4gZnJvbSAnLi9NYXJrUGVuJztcbmltcG9ydCBFcmFzZXIgZnJvbSAnLi9FcmFzZXInO1xuaW1wb3J0IFNlbGVjdG9yIGZyb20gJy4vU2VsZWN0b3InO1xuXG5jbGFzcyBUb29scyB7XG4gIGNvbnN0cnVjdG9yKGNhbnZhcywgc3R5bGUpIHtcbiAgICB0aGlzLmN4dCA9IGNhbnZhcztcbiAgICB0aGlzLnN0eWxlID0gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgZmlsbDogJ3RyYW5zcGFyZW50JyxcbiAgICB9LCBzdHlsZSk7XG4gICAgdGhpcy5pbml0VG9vbHMoKTtcbiAgfVxuXG4gIGRyYXdKU09OID0gKGRhdGEpID0+IHtcbiAgICBjb25zdCBjb25zdHJ1Y3RvciA9IGNhcGl0YWxpemUoZGF0YS50eXBlKTtcbiAgICBmYWJyaWNbY29uc3RydWN0b3JdLmZyb21PYmplY3QoZGF0YSwgKHBhdGgpID0+IHtcbiAgICAgIHRoaXMuY3h0LmFkZChwYXRoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGluaXRUb29scygpIHtcbiAgICB0aGlzLnRvb2xMaXN0ID0gW1xuICAgICAgbmV3IENpcmNsZSh0aGlzLmN4dCwgdGhpcy5zdHlsZSksXG4gICAgICBuZXcgVGV4dCh0aGlzLmN4dCwgdGhpcy5zdHlsZSksXG4gICAgICBuZXcgUGVuKHRoaXMuY3h0LCB0aGlzLnN0eWxlKSxcbiAgICAgIG5ldyBNYXJrUGVuKHRoaXMuY3h0LCB0aGlzLnN0eWxlKSxcbiAgICAgIG5ldyBFcmFzZXIodGhpcy5jeHQsIHRoaXMuc3R5bGUpLFxuICAgICAgbmV3IFNlbGVjdG9yKHRoaXMuY3h0LCB0aGlzLnN0eWxlKVxuICAgIF07XG4gIH1cblxuICBnZXQgdG9vbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9vbExpc3Q7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVG9vbHM7IiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RmlsdGVyO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcbiIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG4iLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsInZhciBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5cyA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG4iLCJ2YXIgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yT3duO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VFYWNoO1xuIiwidmFyIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgY3JlYXRlQmFzZUVhY2ggPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRWFjaDtcbiIsInZhciBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsdGVyYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmlsdGVyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG4iLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcbiIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tTZXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbiIsIi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlQWRkO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlSGFzO1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKSxcbiAgICBzZXRDYWNoZUFkZCA9IHJlcXVpcmUoJy4vX3NldENhY2hlQWRkJyksXG4gICAgc2V0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19zZXRDYWNoZUhhcycpO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0Q2FjaGU7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U29tZTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhY2hlSGFzO1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheVNvbWUgPSByZXF1aXJlKCcuL19hcnJheVNvbWUnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxBcnJheXM7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBUb0FycmF5O1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb0FycmF5O1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5JyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIG1hcFRvQXJyYXkgPSByZXF1aXJlKCcuL19tYXBUb0FycmF5JyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEJ5VGFnO1xuIiwiLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UHVzaDtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0QWxsS2V5cztcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkFycmF5O1xuIiwidmFyIGFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXlGaWx0ZXInKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9scztcbiIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5cztcbiIsInZhciBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbE9iamVjdHM7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWFrTWFwO1xuIiwidmFyIERhdGFWaWV3ID0gcmVxdWlyZSgnLi9fRGF0YVZpZXcnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBQcm9taXNlID0gcmVxdWlyZSgnLi9fUHJvbWlzZScpLFxuICAgIFNldCA9IHJlcXVpcmUoJy4vX1NldCcpLFxuICAgIFdlYWtNYXAgPSByZXF1aXJlKCcuL19XZWFrTWFwJyksXG4gICAgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGFnO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgZXF1YWxCeVRhZyA9IHJlcXVpcmUoJy4vX2VxdWFsQnlUYWcnKSxcbiAgICBlcXVhbE9iamVjdHMgPSByZXF1aXJlKCcuL19lcXVhbE9iamVjdHMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWxEZWVwO1xuIiwidmFyIGJhc2VJc0VxdWFsRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsRGVlcCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hdGNoO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpY3RDb21wYXJhYmxlO1xuIiwidmFyIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWF0Y2hEYXRhO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlO1xuIiwidmFyIGJhc2VJc01hdGNoID0gcmVxdWlyZSgnLi9fYmFzZUlzTWF0Y2gnKSxcbiAgICBnZXRNYXRjaERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXRjaERhdGEnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcbiIsInZhciBtZW1vaXplQ2FwcGVkID0gcmVxdWlyZSgnLi9fbWVtb2l6ZUNhcHBlZCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nVG9QYXRoO1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9QYXRoJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldDtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG4iLCJ2YXIgYmFzZUhhc0luID0gcmVxdWlyZSgnLi9fYmFzZUhhc0luJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKSxcbiAgICBnZXQgPSByZXF1aXJlKCcuL2dldCcpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXNQcm9wZXJ0eTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eTtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHlEZWVwO1xuIiwidmFyIGJhc2VQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eScpLFxuICAgIGJhc2VQcm9wZXJ0eURlZXAgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHlEZWVwJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb3BlcnR5O1xuIiwidmFyIGJhc2VNYXRjaGVzID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXMnKSxcbiAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXNQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBwcm9wZXJ0eSA9IHJlcXVpcmUoJy4vcHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXRlcmF0ZWU7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIGJhc2VGaWx0ZXIgPSByZXF1aXJlKCcuL19iYXNlRmlsdGVyJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiAqKk5vdGU6KiogVW5saWtlIGBfLnJlbW92ZWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICogQHNlZSBfLnJlamVjdFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAqIF07XG4gKlxuICogXy5maWx0ZXIodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAqL1xuZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaWx0ZXI7XG4iLCIvKipcbiAqIHByb3BzIFtyZW5kZXJQYXRoID0gYWRkIHBhdGggb24gY2FuY2FzIGZ1bmMsIF1cbiAqL1xuaW1wb3J0IGZpbHRlciBmcm9tICdsb2Rhc2gvZmlsdGVyJztcbmltcG9ydCB7XG4gIGZhYnJpY1xufSBmcm9tICdmYWJyaWMnO1xuY2xhc3MgU3RvcmUge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbmRlclBhdGhcbiAgICB9ID0gcHJvcHM7XG4gICAgdGhpcy5jeHQgPSBwcm9wcy5jeHQ7XG4gICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIHRoaXMucmVkb3MgPSBbXTtcbiAgICB0aGlzLnVuZG9zID0gW107XG4gIH1cblxuICBhZGQocGF0aEluZm8pIHtcbiAgICB0aGlzLml0ZW1zLnB1c2gocGF0aEluZm8pO1xuICB9XG5cbiAgZHJhd1BhdGgocHRhaCkge1xuICAgIHRoaXMuY3h0LmFkZChwYXRoKTtcbiAgfVxuXG4gIGRlbGV0ZShpZCkge1xuICAgIGxldCBwYXRocyA9IFtdXG4gICAgaWYgKCFpZCkgeyAvL2RlbGV0ZSBzZWxlY3RlZFxuICAgICAgcGF0aHMgPSBmaWx0ZXIodGhpcy5pdGVtcywgKGl0ZW0pID0+IGl0ZW0uaGFzQ29udHJvbHMpO1xuICAgIH07XG4gICAgcGF0aHMgPSBmaWx0ZXIodGhpcy5pdGVtcywgKGl0ZW0pID0+IGl0ZW0uaWQgPT09IGlkKTtcbiAgICB0aGlzLml0ZW1zID0gZmlsdGVyKHRoaXMuaXRlbXMsIChpdGVtKSA9PiBpdGVtLmlkICE9PSBpZCk7XG4gICAgcGF0aHMubWFwKChwYXRoKSA9PiB0aGlzLmN4dC5yZW1vdmUocGF0aCkpO1xuICB9XG5cbiAgY2xlYXJBbGwoKSB7XG4gICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIHRoaXMuY3h0LmNsZWFyKCk7XG4gIH1cblxuICByZWRvKCkge1xuICAgIGRlYnVnZ2VyXG4gICAgaWYgKHRoaXMucmVkb3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5yZWRvcy5sZW5ndGg7XG4gICAgICBjb25zdCByZWRvUGF0aCA9IHRoaXMucmVkb3NbbGVuZ3RoIC0gMV07XG4gICAgICB0aGlzLmN4dC5hZGQocmVkb1BhdGgpO1xuICAgICAgdGhpcy5hZGQocmVkb1BhdGgpO1xuICAgICAgdGhpcy5yZWRvcyA9IGZpbHRlcih0aGlzLnJlZG9zLCAoaXRlbSkgPT4gaXRlbS5pZCAhPT0gcmVkb1BhdGguaWQpO1xuICAgIH1cbiAgfVxuXG4gIHVuZG8oKSB7XG4gICAgZGVidWdnZXJcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgY29uc3QgdW5kb1BhdGggPSB0aGlzLml0ZW1zW2xlbmd0aCAtIDFdO1xuICAgIHRoaXMucmVkb3MgPSBbLi4udGhpcy5yZWRvcywgdW5kb1BhdGhdO1xuICAgIHRoaXMuZGVsZXRlKHVuZG9QYXRoLmlkKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTdG9yZTsiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFYWNoO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGNhc3QgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IGlkZW50aXR5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RGdW5jdGlvbjtcbiIsInZhciBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyksXG4gICAgY2FzdEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fY2FzdEZ1bmN0aW9uJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBhbGlhcyBlYWNoXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAqXG4gKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBjYXN0RnVuY3Rpb24oaXRlcmF0ZWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuIiwiaW1wb3J0IHtcbiAgZmluZERvbVxufSBmcm9tICcuL3V0aWxzL2RvbSc7XG5pbXBvcnQgbG9nIGZyb20gJy4vdXRpbHMvZXJyb3InO1xuaW1wb3J0IHtcbiAgZmFicmljXG59IGZyb20gJ2ZhYnJpYyc7XG5pbXBvcnQgdG9vbFR5cGVzIGZyb20gJy4vY29uc3RhbnRzL3Rvb2xzJztcbmltcG9ydCBUb29scyBmcm9tICcuL3Rvb2xzJztcbmltcG9ydCBTdG9yZSBmcm9tICcuL1N0b3JlJztcblxuaW1wb3J0IGZvckVhY2ggZnJvbSAnbG9kYXNoL2ZvckVhY2gnO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGlkOiAnd2hpdGVib2FyZCdcbn1cblxuY29uc3QgbW91c2VFdmVudHMgPSBbe1xuICBvcmlnaW46ICdtb3VzZTp1cCcsXG4gIGluc3RhbmNlOiAnb25Nb3VzZXVwSGFuZGxlJ1xufSwge1xuICBvcmlnaW46ICdtb3VzZTpkb3duJyxcbiAgaW5zdGFuY2U6ICdvbk1vdXNlZG93bkhhbmRsZSdcbn0sIHtcbiAgb3JpZ2luOiAnbW91c2U6bW92ZScsXG4gIGluc3RhbmNlOiAnb25Nb3VzZW1vdmVIYW5kbGUnXG59XVxuXG5jbGFzcyB3aGl0ZWJvYXJkIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIHdpZHRoID0gMTAwMCxcbiAgICAgIGhlaWdodCA9IDcwMFxuICAgIH0gPSBwcm9wcztcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5vcmlnaW5DYW52YXMgPSBmaW5kRG9tKGAjJHtpZH1gKTtcbiAgICB0aGlzLmNhbnZhcyA9IG5ldyBmYWJyaWMuQ2FudmFzKGlkLCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHNlbGVjdGlvbjogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLnN0b3JlID0gbmV3IFN0b3JlKHtcbiAgICAgIGN4dDogdGhpcy5jYW52YXNcbiAgICB9KTtcbiAgICB3aW5kb3cuY3h0ID0gdGhpcy5jYW52YXM7IC8vIG5lZWQgZGVsZXRlXG4gICAgd2luZG93LnN0b3JlID0gdGhpcy5zdG9yZTtcblxuICAgIHRoaXMudG9vbEdyb3VwID0gbmV3IFRvb2xzKHRoaXMuY2FudmFzLCB7XG4gICAgICBib3JkZXJDb2xvcjogJyMwMEI4RkMnLFxuICAgICAgY29ybmVyQ29sb3I6ICcjRkY0QjU5JyxcbiAgICAgIGNvcm5lclNpemU6IDYsXG4gICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgIHN0cm9rZTogJyMwMDAwMDAnLFxuICAgICAgaGFzQ29udHJvbHM6IGZhbHNlLFxuICAgICAgZm9udFNpemU6IDIwLFxuICAgICAgdHJhbnNwYXJlbnRDb3JuZXJzOiB0cnVlLFxuICAgICAgY29sb3I6ICdyZ2JhKDI2LCAyMDksIDI1NSwgLjcpJyxcbiAgICAgIHdpZHRoOiAxMFxuICAgIH0pO1xuICAgIHdpbmRvdy5jaGFuZ2VUb29sID0gdGhpcy5jaGFuZ2VUb29sO1xuICAgIHRoaXMuY2hhbmdlVG9vbCh0b29sVHlwZXMuU0VMRUNUT1IpOyAvLyDliJ3lp4vnlLvnrJRcbiAgICB0aGlzLmJpbmRMaXN0ZW5lcigpO1xuICAgIHRoaXMuY2hlY2tQYXJhbXMoKTtcbiAgfVxuXG4gIHJlZG8oKSB7XG4gICAgdGhpcy5zdG9yZS5yZWRvKCk7XG4gIH1cblxuICB1bmRvKCkge1xuICAgIHRoaXMuc3RvcmUudW5kbygpO1xuICB9XG5cbiAgLyoqXG4gICAqIHRvb2wgaXMgb25lIG9mIHRvb2xUeXBlc1xuICAgKi9cbiAgY2hhbmdlVG9vbCA9ICh0b29sKSA9PiB7XG4gICAgZm9yRWFjaCh0aGlzLnRvb2xHcm91cC50b29scywgKGl0ZW1Ub29sKSA9PiB7XG4gICAgICBpZiAodG9vbCA9PT0gaXRlbVRvb2wudG9vbFR5cGUpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9vbCA9IGl0ZW1Ub29sO1xuICAgICAgICBpdGVtVG9vbC5zZWxlY3RlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtVG9vbC5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRUb29sXG4gIH1cbiAgLyoqXG4gICAqIFxuICAgKiBAcGFyYW0ge0pBU09OfSBkYXRhIHBhdGggaW5zdGFuY2UganNvblxuICAgKiBkcmF3IHJlY2VpdmUgZGF0YVxuICAgKi9cbiAgZHJhd0pTT04oZGF0YSkge1xuICAgIHRoaXMudG9vbEdyb3VwLmRyYXdKU09OKGRhdGEpO1xuICB9XG5cbiAgZGVsZXRlQWxsKCkge1xuICAgIHRoaXMuc3RvcmUuY2xlYXJBbGwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBwYXJhbVtpZF0gcGF0aCBpbnN0YW5jZSBpZFxuICAgKi9cbiAgZGVsZXRlKGlkKSB7XG4gICAgdGhpcy5zdG9yZS5kZWxldGUoaWQpO1xuICB9XG5cbiAgc2V0IGN1cnJlbnRUb29sSW5mbyh0b29sSW5mbykge1xuICAgIGNvbnN0IHtcbiAgICAgIHRvb2xcbiAgICB9ID0gdG9vbEluZm87XG4gICAgdGhpcy5jaGFuZ2VUb29sKHRvb2wpO1xuICB9XG5cbiAgLyoqXG4gICAqIOiuvue9ruWPr+mAiVxuICAgKi9cbiAgc2V0IHNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgICB0aGlzLmNhbnZhcyAmJiAodGhpcy5jYW52YXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uKTtcbiAgfVxuXG4gIGJpbmRMaXN0ZW5lcigpIHtcbiAgICBtb3VzZUV2ZW50cy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgdGhpcy5jYW52YXMub24oaXRlbS5vcmlnaW4sICguLi5hcmcpID0+IHtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9vbCAmJiB0aGlzLmN1cnJlbnRUb29sW2l0ZW0uaW5zdGFuY2VdICYmIHRoaXMuY3VycmVudFRvb2xbaXRlbS5pbnN0YW5jZV0oYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pXG4gICAgdGhpcy5jYW52YXMub24oJ3BhdGg6Y3JlYXRlZCcsIChvYmplY3QpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGF0aFxuICAgICAgfSA9IG9iamVjdDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaWQsXG4gICAgICAgIHRvb2xUeXBlXG4gICAgICB9ID0gcGF0aDtcbiAgICAgIHRoaXMuc3RvcmUuYWRkKHBhdGgpO1xuICAgIH0pO1xuICAgIHRoaXMuY2FudmFzLm9uKCdzZWxlY3Rpb246Y3JlYXRlZCcsIChwYXRoKSA9PiB7fSlcbiAgICB0aGlzLmNhbnZhcy5vbignb2JqZWN0Om1vdmluZycsIChwYXRoKSA9PiB7fSk7XG4gICAgdGhpcy5jYW52YXMub24oJ29iamVjdDpyb3RhdGluZycsIChwYXRoKSA9PiB7fSk7XG4gICAgdGhpcy5jYW52YXMub24oJ29iamVjdDpza2V3aW5nJywgKHBhdGgpID0+IHt9KVxuICB9XG5cbiAgY2hlY2tQYXJhbXMoKSB7XG4gICAgaWYgKCF0aGlzLnByb3BzLmlkKSB7XG4gICAgICBsb2cuZXJyb3IoJ25lZWQgd2hpdGVib2FyZCBJRCcpXG4gICAgfVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgd2hpdGVib2FyZDsiLCJpbXBvcnQgd2hpdGVib3JkIGZyb20gJy4vV2hpdGVib2FyZCc7XG4vLyBUT0RPOiBjaGVjayBFTlYgcHJvZHVjdGlvbiBkZXZlbG9wbWVudFxud2luZG93LndoaXRlYm9yZCA9IHdoaXRlYm9yZDtcbmV4cG9ydCBkZWZhdWx0IHdoaXRlYm9yZDsiXSwibmFtZXMiOlsiZmluZERvbSIsInNlbCIsImVsIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwibG9nTXNnIiwiY29uc29sZSIsImxvZyIsIm1zZyIsImVycm9yIiwiZ2xvYmFsIiwicmVhZCIsIndyaXRlIiwiYmFzZTY0LmZyb21CeXRlQXJyYXkiLCJpZWVlNzU0LnJlYWQiLCJpZWVlNzU0LndyaXRlIiwiYmFzZTY0LnRvQnl0ZUFycmF5IiwicmVxdWlyZSQkMCIsInJlcXVpcmUkJDEiLCJyZXF1aXJlJCQyIiwiU0VMRUNUT1IiLCJDSVJDTEUiLCJURVhUIiwiUEVOIiwiTUFSS1BFTiIsIkVSQVNFUiIsImZyZWVHbG9iYWwiLCJTeW1ib2wiLCJyb290IiwiaXNBcnJheSIsIm9iamVjdFByb3RvIiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJzeW1Ub1N0cmluZ1RhZyIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwiaXNPYmplY3RMaWtlIiwiYmFzZUdldFRhZyIsImFycmF5TWFwIiwiaXNTeW1ib2wiLCJ0b1N0cmluZyIsImJhc2VUb1N0cmluZyIsImJhc2VTbGljZSIsInJzQXN0cmFsUmFuZ2UiLCJyc0NvbWJvTWFya3NSYW5nZSIsInJlQ29tYm9IYWxmTWFya3NSYW5nZSIsInJzQ29tYm9TeW1ib2xzUmFuZ2UiLCJyc0NvbWJvUmFuZ2UiLCJyc1ZhclJhbmdlIiwicnNaV0oiLCJoYXNVbmljb2RlIiwidW5pY29kZVRvQXJyYXkiLCJhc2NpaVRvQXJyYXkiLCJzdHJpbmdUb0FycmF5IiwiY2FzdFNsaWNlIiwiY3JlYXRlQ2FzZUZpcnN0IiwidXBwZXJGaXJzdCIsInBhdGhFdmVudHMiLCJvcmlnaW4iLCJpbnN0YW5jZSIsIlRvb2xCYXNlIiwiY2FudmFzIiwic3R5bGUiLCJjeHQiLCJpc01vdXNlRG93biIsImhhc1NlbGVjdGVkIiwiYmluZEV2ZW50IiwiZXZlbnQiLCJlIiwibW92ZW1lbnRYIiwibW92ZW1lbnRZIiwiZGlyZWN0aW9uIiwib25Nb3VzZURyYWdIYW5kbGUiLCJwYXRoIiwiaWdub3JlUmVuZGVyIiwiaWQiLCJ1bmlxdWVJZCIsInRvb2xUeXBlIiwiYWRkIiwiZm9yRWFjaCIsIm9uIiwiaGFzQ29udHJvbHMiLCJzZWxlY3RlZCIsInRvb2xBY3RpdmUiLCJDaXJjbGUiLCJhcmciLCJ0b29sVHlwZXMiLCJkb3duUG9pbnRlciIsInBvaW50ZXIiLCJ4IiwieSIsImNpcmNsZSIsInJlbW92ZSIsInJhZGl1cyIsIk1hdGgiLCJhYnMiLCJiZWdpblBvaW50ZXIiLCJsZWZ0IiwidG9wIiwib3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsImZhYnJpYyIsInJlbmRlclBhdGgiLCJzdGFydCIsImVuZCIsInNxcnQiLCJwb3ciLCJUZXh0IiwiYmluZExpbnRlbmVyIiwidGV4dCIsIlRleHRib3giLCJ3aWR0aCIsImxpbmVIZWlnaHQiLCJoZWlnaHQiLCJ0YXJnZXQiLCJlbnRlckVkaXRpbmciLCJQZW4iLCJvYmplY3QiLCJpc0RyYXdpbmdNb2RlIiwiZnJlZURyYXdpbmdCcnVzaCIsImNvbG9yIiwiTWFya1BlbiIsIkVyYXNlciIsInNlbGVjdGFibGUiLCJzZWxlY3Rpb24iLCJUb29scyIsImRyYXdKU09OIiwiZGF0YSIsImNvbnN0cnVjdG9yIiwiY2FwaXRhbGl6ZSIsInR5cGUiLCJmcm9tT2JqZWN0IiwiZmlsbCIsImluaXRUb29scyIsInRvb2xMaXN0IiwiU2VsZWN0b3IiLCJjcmVhdGVCYXNlRm9yIiwiaGFzT3duUHJvcGVydHkiLCJiYXNlSXNBcmd1bWVudHMiLCJzdHViRmFsc2UiLCJNQVhfU0FGRV9JTlRFR0VSIiwiYXJnc1RhZyIsImlzTGVuZ3RoIiwibm9kZVV0aWwiLCJiYXNlVW5hcnkiLCJiYXNlSXNUeXBlZEFycmF5IiwiaXNBcmd1bWVudHMiLCJpc0J1ZmZlciIsImlzVHlwZWRBcnJheSIsImJhc2VUaW1lcyIsImlzSW5kZXgiLCJvdmVyQXJnIiwiaXNQcm90b3R5cGUiLCJuYXRpdmVLZXlzIiwiZnVuY1RhZyIsImlzT2JqZWN0IiwiaXNGdW5jdGlvbiIsImlzQXJyYXlMaWtlIiwiYXJyYXlMaWtlS2V5cyIsImJhc2VLZXlzIiwiYmFzZUZvciIsImtleXMiLCJjcmVhdGVCYXNlRWFjaCIsImJhc2VGb3JPd24iLCJiYXNlRWFjaCIsImVxIiwiYXNzb2NJbmRleE9mIiwibGlzdENhY2hlQ2xlYXIiLCJsaXN0Q2FjaGVEZWxldGUiLCJsaXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJsaXN0Q2FjaGVTZXQiLCJMaXN0Q2FjaGUiLCJjb3JlSnNEYXRhIiwiZnVuY1Byb3RvIiwiZnVuY1RvU3RyaW5nIiwiaXNNYXNrZWQiLCJ0b1NvdXJjZSIsImdldFZhbHVlIiwiYmFzZUlzTmF0aXZlIiwiTWFwIiwiZ2V0TmF0aXZlIiwibmF0aXZlQ3JlYXRlIiwiSEFTSF9VTkRFRklORUQiLCJoYXNoQ2xlYXIiLCJoYXNoRGVsZXRlIiwiaGFzaEdldCIsImhhc2hIYXMiLCJoYXNoU2V0IiwiSGFzaCIsImlzS2V5YWJsZSIsImdldE1hcERhdGEiLCJtYXBDYWNoZUNsZWFyIiwibWFwQ2FjaGVEZWxldGUiLCJtYXBDYWNoZUdldCIsIm1hcENhY2hlSGFzIiwibWFwQ2FjaGVTZXQiLCJNYXBDYWNoZSIsInN0YWNrQ2xlYXIiLCJzdGFja0RlbGV0ZSIsInN0YWNrR2V0Iiwic3RhY2tIYXMiLCJzdGFja1NldCIsInNldENhY2hlQWRkIiwic2V0Q2FjaGVIYXMiLCJTZXRDYWNoZSIsImFycmF5U29tZSIsImNhY2hlSGFzIiwiVWludDhBcnJheSIsIkNPTVBBUkVfUEFSVElBTF9GTEFHIiwiQ09NUEFSRV9VTk9SREVSRURfRkxBRyIsImJvb2xUYWciLCJkYXRlVGFnIiwiZXJyb3JUYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJzeW1ib2xUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwic3ltYm9sUHJvdG8iLCJtYXBUb0FycmF5Iiwic2V0VG9BcnJheSIsImVxdWFsQXJyYXlzIiwiYXJyYXlQdXNoIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJzdHViQXJyYXkiLCJhcnJheUZpbHRlciIsImJhc2VHZXRBbGxLZXlzIiwiZ2V0U3ltYm9scyIsImdldEFsbEtleXMiLCJQcm9taXNlIiwib2JqZWN0VGFnIiwid2Vha01hcFRhZyIsIkRhdGFWaWV3IiwiU2V0IiwiV2Vha01hcCIsImFycmF5VGFnIiwiZ2V0VGFnIiwiU3RhY2siLCJlcXVhbEJ5VGFnIiwiZXF1YWxPYmplY3RzIiwiYmFzZUlzRXF1YWxEZWVwIiwiYmFzZUlzRXF1YWwiLCJpc1N0cmljdENvbXBhcmFibGUiLCJnZXRNYXRjaERhdGEiLCJtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSIsImJhc2VJc01hdGNoIiwibWVtb2l6ZSIsIm1lbW9pemVDYXBwZWQiLCJpc0tleSIsInN0cmluZ1RvUGF0aCIsIklORklOSVRZIiwiY2FzdFBhdGgiLCJ0b0tleSIsImJhc2VHZXQiLCJoYXNQYXRoIiwiYmFzZUhhc0luIiwiZ2V0IiwiaGFzSW4iLCJiYXNlUHJvcGVydHkiLCJiYXNlUHJvcGVydHlEZWVwIiwiaWRlbnRpdHkiLCJiYXNlTWF0Y2hlc1Byb3BlcnR5IiwiYmFzZU1hdGNoZXMiLCJwcm9wZXJ0eSIsImJhc2VGaWx0ZXIiLCJiYXNlSXRlcmF0ZWUiLCJTdG9yZSIsInByb3BzIiwiaXRlbXMiLCJyZWRvcyIsInVuZG9zIiwicGF0aEluZm8iLCJwdXNoIiwicHRhaCIsInBhdGhzIiwiZmlsdGVyIiwiaXRlbSIsIm1hcCIsImNsZWFyIiwibGVuZ3RoIiwicmVkb1BhdGgiLCJ1bmRvUGF0aCIsImRlbGV0ZSIsImFycmF5RWFjaCIsImNhc3RGdW5jdGlvbiIsIm1vdXNlRXZlbnRzIiwid2hpdGVib2FyZCIsImNoYW5nZVRvb2wiLCJ0b29sIiwidG9vbEdyb3VwIiwidG9vbHMiLCJpdGVtVG9vbCIsImN1cnJlbnRUb29sIiwib3JpZ2luQ2FudmFzIiwiQ2FudmFzIiwic3RvcmUiLCJ3aW5kb3ciLCJib3JkZXJDb2xvciIsImNvcm5lckNvbG9yIiwiY29ybmVyU2l6ZSIsInN0cm9rZVdpZHRoIiwic3Ryb2tlIiwiZm9udFNpemUiLCJ0cmFuc3BhcmVudENvcm5lcnMiLCJiaW5kTGlzdGVuZXIiLCJjaGVja1BhcmFtcyIsInJlZG8iLCJ1bmRvIiwiY2xlYXJBbGwiLCJ0b29sSW5mbyIsIndoaXRlYm9yZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUEwRE8s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RyxNQUFLO0VBQ2pCLEdBQUc7RUFDSCxFQUFFLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDO0VBQ2pELENBQUM7O0FBRUQsRUFBTyxTQUFTLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRTtFQUNsRSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFDO0VBQ2IsRUFBRSxJQUFJLElBQUksR0FBRyxNQUFNLEdBQUcsQ0FBQyxHQUFHLElBQUksR0FBRyxFQUFDO0VBQ2xDLEVBQUUsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDLElBQUksSUFBSSxJQUFJLEVBQUM7RUFDNUIsRUFBRSxJQUFJLEtBQUssR0FBRyxJQUFJLElBQUksRUFBQztFQUN2QixFQUFFLElBQUksRUFBRSxJQUFJLElBQUksS0FBSyxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBQztFQUNsRSxFQUFFLElBQUksQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLElBQUksTUFBTSxHQUFHLENBQUMsRUFBQztFQUNqQyxFQUFFLElBQUksQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFDO0VBQ3ZCLEVBQUUsSUFBSSxDQUFDLEdBQUcsS0FBSyxHQUFHLENBQUMsS0FBSyxLQUFLLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUM7O0VBRTdELEVBQUUsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFDOztFQUV6QixFQUFFLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLEtBQUssS0FBSyxRQUFRLEVBQUU7RUFDMUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFDO0VBQzVCLElBQUksQ0FBQyxHQUFHLEtBQUk7RUFDWixHQUFHLE1BQU07RUFDVCxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBQztFQUM5QyxJQUFJLElBQUksS0FBSyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFO0VBQzNDLE1BQU0sQ0FBQyxHQUFFO0VBQ1QsTUFBTSxDQUFDLElBQUksRUFBQztFQUNaLEtBQUs7RUFDTCxJQUFJLElBQUksQ0FBQyxHQUFHLEtBQUssSUFBSSxDQUFDLEVBQUU7RUFDeEIsTUFBTSxLQUFLLElBQUksRUFBRSxHQUFHLEVBQUM7RUFDckIsS0FBSyxNQUFNO0VBQ1gsTUFBTSxLQUFLLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUM7RUFDMUMsS0FBSztFQUNMLElBQUksSUFBSSxLQUFLLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtFQUN4QixNQUFNLENBQUMsR0FBRTtFQUNULE1BQU0sQ0FBQyxJQUFJLEVBQUM7RUFDWixLQUFLOztFQUVMLElBQUksSUFBSSxDQUFDLEdBQUcsS0FBSyxJQUFJLElBQUksRUFBRTtFQUMzQixNQUFNLENBQUMsR0FBRyxFQUFDO0VBQ1gsTUFBTSxDQUFDLEdBQUcsS0FBSTtFQUNkLEtBQUssTUFBTSxJQUFJLENBQUMsR0FBRyxLQUFLLElBQUksQ0FBQyxFQUFFO0VBQy9CLE1BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FB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QUMsS0FBSyxHQUFHLEdBQUcsS0FBSyxDQUFDLElBQUksR0FBRyxHQUFHLEtBQUk7S0FDckQ7O0lBRUQsT0FBTyxNQUFNLEdBQUcsVUFBVTtJQUMzQjs7RUFFRCxNQUFNLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxTQUFTLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRTtJQUN4RSxLQUFLLEdBQUcsQ0FBQyxNQUFLO0lBQ2QsTUFBTSxHQUFHLE1BQU0sR0FBRyxFQUFDO0lBQ25CLElBQUksQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUM7SUFDNUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUM7SUFDMUQsSUFBSSxLQUFLLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxJQUFJLEdBQUcsS0FBSyxHQUFHLEVBQUM7SUFDdkMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssR0FBRyxJQUFJLEVBQUM7SUFDN0IsT0FBTyxNQUFNLEdBQUcsQ0FBQztJQUNsQjs7RUFFRCxNQUFNLENBQUMsU0FBUyxDQUFDLFlBQVksR0FBRyxTQUFTLFlBQVksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRTtJQUM5RSxLQUFLLEdBQUcsQ0FBQyxNQUFLO0lBQ2QsTUFBTSxHQUFHLE1BQU0sR0FBRyxFQUFDO0lBQ25CLElBQUksQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxNQUFNLEVBQUM7SUFDaEUsSUFBSSxNQUFNLENBQUMsbUJBQW1CLEVBQUU7TUFDOUIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssR0FBRyxJQUFJLEVBQUM7TUFDN0IsSUFBSSxDQUFDLE1BQU0sR0FBRyxD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RUFBRSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ2pDLEdBQUcsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztPQUN2QztLQUNGLENBQUM7Ozs7Ozs7Ozs7Ozs7O0lBY0YsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLEdBQUcsU0FBUyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTs7TUFFL0UsSUFBSSxLQUFLLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxDQUFDLEVBQUUsS0FBSyxFQUFFLE1BQU0sR0FBRyxFQUFFO1VBQ3hDLElBQUksR0FBRyxhQUFhLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQzs7TUFFdEUsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUMvQyxLQUFLLEdBQUcsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQy9HLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUN4RCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDeEQsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuQixLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO09BQ3BCO01BQ0QsT0FBTyxNQUFNLENBQUM7S0FDZixDQUFDOzs7Ozs7Ozs7Ozs7OztJQWNGLFNBQVMsZ0JBQWdCLENB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QUUsQ0FBQyxDQUFDO1NBQ2xCO09BQ0Y7O01BRUQsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLElBQUksR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDO01BQzNDLE9BQU8sQ0FBQyxFQUFFLEVBQUU7UUFDVixDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2YsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDWCxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEtBQUssQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUM1RixNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDOztRQUVqQixDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEtBQUssQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUM1RixNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO09BQ2xCOztNQUVELE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7TUFDckIsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztNQUNyQixNQUFNLENBQUMsQ0FBQyxD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O1FBQ2pCLElBQUksQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDO1FBQ2pCLE9BQU8sSUFBSSxDQUFDO09BQ2I7Ozs7Ozs7TUFPRCxFQUFFLEVBQUUsVUFBVSxJQUFJLEVBQUU7UUFDbEIsUUFBUSxJQUFJLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxFQUFFO09BQ2pEOzs7Ozs7O01BT0QsRUFBRSxFQUFFLFVBQVUsSUFBSSxFQUFFO1FBQ2xCLFFBQVEsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsRUFBRTtPQUM3Qzs7Ozs7OztNQU9ELEdBQUcsRUFBRSxVQUFVLElBQUksRUFBRTtRQUNuQixRQUFRLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEVBQUU7T0FDL0M7Ozs7Ozs7O01BUUQsRUFBRSxFQUFFLFVBQVUsSUFBSSxFQUFFO1FBQ2xCLFFBQVEsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsRUFBRTtPQUM3Qzs7Ozs7OztNQU9ELEdBQUcsRUFBRSxVQUFVLElBQUksRUFBRTtRQUNuQixRQUFRLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEVBQUU7T0FDL0M7Ozs7Ozs7O01BUUQsSUFBSSxFQUFFLFVBQVUsSUFBSSxFQUFFLENBQUMsRUFBRTtRQUN2QixJQUFJLE9BQU8sQ0FBQyxLQUFLLFdBQVcsRUFBRTtVQUM1QixDQUFDLEdBQUcsR0FBRyxDQUFDO1NBQ1Q7UUFDRCxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENB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RUFBRSxFQUFFLEVBQUU7TUFDaEUsSUFBSSxNQUFNO1VBQ04sR0FBRyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztVQUNuRSxHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO1VBQ25FLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztNQUN2RSxJQUFJLEVBQUUsS0FBSyxDQUFDLEVBQUU7UUFDWixJQUFJLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRTtZQUNiLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDO1FBQ2xCLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRTtVQUM1QyxNQUFNLEdBQUcsSUFBSSxZQUFZLENBQUMsY0FBYyxDQUFDLENBQUM7VUFDMUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFB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QUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUMzQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7UUFFckMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDM0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7O1FBRXJDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzNCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDOztRQUVyQyxPQUFPLENBQUMsQ0FBQyxXQUFXLEVBQUUsR0FBRyxDQUFDLENBQUMsV0FBVyxFQUFFLEdBQUcsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO09BQzVEOzs7Ozs7TUFNRCxNQUFNLEVBQUUsV0FBVztRQUNqQixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFDOztRQUVqQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7UUFDaEMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDbkIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7O1FBRXJDLE9BQU8sSUFBSSxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztPQUN2Qzs7Ozs7O01BTUQsUUFB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R0FBRyxDQUFDLEVBQUU7UUFDYixPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztPQUM1QjtNQUNELElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDYixPQUFPLENBQUMsQ0FBQztPQUNWO01BQ0QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUNiLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztPQUN0QztNQUNELE9BQU8sQ0FBQyxDQUFDO0tBQ1Y7Ozs7Ozs7O0lBUUQsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxLQUFLLEVBQUU7TUFDckMsT0FBTyxLQUFLLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztLQUNyRCxDQUFDOzs7Ozs7OztJQVFGLE1BQU0sQ0FBQyxLQUFLLENBQUMsYUFBYSxHQUFHLFNBQVMsS0FBSyxFQUFFO01BQzNDLElBQUksS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO01BQ3RDLElBQUksS0FBSyxFQUFFO1FBQ1QsSUFBSSxDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7WUFDOUYsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1lBQzlGLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDOztRQUVuRyxPQUFPO1VBQ0wsUUFBUSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7VUFDZixRQUFRLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztVQUNmLFFBQVEsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO1VBQ2YsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO1NBQ3BDLENBQUM7T0FDSDtLQUNGLENBQUM7Ozs7Ozs7Ozs7SUFVRixNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDOzs7Ozs7OztJQVF0QyxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLEtBQUssRUFBRTtNQUNyQyxPQUFPLEtBQUssQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0tBQ3JELENBQUM7Ozs7Ozs7Ozs7SUFVRixNQUFNLENBQUMsS0FBSyxDQUFDLGFBQWEsR0FBRyxTQUFTLEtBQUssRUFBRTtNQUMzQyxJQUFJLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztNQUN0QyxJQUFJLENBQUMsS0FBSyxFQUFFO1FBQ1YsT0FBTztPQUNSOztNQUVELElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHO1VBQ3RELENBQUMsR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1VBQzFELENBQUMsR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1VBQzFELENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDOztNQUVaLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUNYLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztPQUNmO1dBQ0k7UUFDSCxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztZQUMxQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7O1FBRWxCLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQzdCLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNyQixDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztPQUM5Qjs7TUFFRCxPQUFPO1FBQ0wsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBQ25CLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztRQUNuQixJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7UUFDbkIsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO09BQ3BDLENBQUM7S0FDSCxDQUFDOzs7Ozs7Ozs7O0lBVUYsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQzs7Ozs7Ozs7O0lBU3RDLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsS0FBSyxFQUFFO01BQ3JDLE9BQU8sS0FBSyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7S0FDckQsQ0FBQzs7Ozs7Ozs7O0lBU0YsTUFBTSxDQUFDLEtBQUssQ0FBQyxhQUFhLEdBQUcsU0FBUyxLQUFLLEVBQUU7TUFDM0MsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUM1QixJQUFJLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzNDLGVBQWUsSUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQztZQUM1RCxNQUFNLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUM7WUFDbkQsQ0FBQyxHQUFHLGVBQWUsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ2pGLENBQUMsR0FBRyxlQUFlLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNqRixDQUFDLEdBQUcsZUFBZSxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDakYsQ0FBQyxHQUFHLE1BQU0sSUFBSSxlQUFlLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQzs7UUFFeEcsT0FBTztVQUNMLFFBQVEsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO1VBQ2YsUUFBUSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7VUFDZixRQUFRLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztVQUNmLFVBQVUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMvQyxDQUFDO09BQ0g7S0FDRixDQUFDOzs7Ozs7Ozs7SUFTRixNQUFNLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxTQUFTLE1BQU0sRUFBRTtNQUN6QyxJQUFJLE1BQU0sR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO01BQ3pCLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7TUFDekIsT0FBTyxNQUFNLENBQUM7S0FDZixDQUFDOztHQUVILEVBQUUsQUFBaUMsT0FBTyxBQUFPLENBQUMsQ0FBQzs7O0VBR3BELENBQUMsV0FBVzs7O0lBR1YsU0FBUyxZQUFZLENBQUMsRUFBRSxFQUFFO01BQ3hCLElBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDO1VBQ2hDLE1BQU0sR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUM7VUFDdkMsS0FBSyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDOzs7TUFHbEMsTUFBTSxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztNQUM1RCxNQUFNLEdBQUcsTUFBTSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsTUFBTSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsTUFBTSxDQUFDO01BQ2xELElBQUksS0FBSyxFQUFFO1FBQ1QsSUFBSSxhQUFhLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQzs7UUFFM0MsSUFBSSxhQUFhLENBQUMsYUFBYSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUU7VUFDbEQsYUFBYSxDQUFDLEdBQUcsRUFBRSxDQUFDO1NBQ3JCOztRQUVELEtBQUssQ0FBQyxHQUFHLGFBQWEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLElBQUk7O1VBRXBDLElBQUksS0FBSyxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDO2NBQ3pDLEdBQUcsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFO2NBQ3JCLEtBQUssR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7O1VBRTVCLElBQUksR0FBRyxLQUFLLFlBQVksRUFBRTtZQUN4QixLQUFLLEdBQUcsS0FBSyxDQUFDO1dBQ2Y7ZUFDSSxJQUFJLEdBQUcsS0FBSyxjQUFjLEVBQUU7WUFDL0IsT0FBTyxHQUFHLEtBQUssQ0FBQztXQUNqQjtTQUNGO09BQ0Y7O01BRUQsSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNWLEtBQUssR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQyxJQUFJLFlBQVksQ0FBQztPQUN2RDtNQUNELElBQUksQ0FBQyxPQUFPLEVBQUU7UUFDWixPQUFPLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyxjQUFjLENBQUMsQ0FBQztPQUMzQzs7TUFFRCxLQUFLLEdBQUcsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO01BQ2hDLFVBQVUsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7TUFDOUIsT0FBTyxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO01BQy9ELE9BQU8sSUFBSSxVQUFVLENBQUM7O01BRXRCLE9BQU87UUFDTCxNQUFNLEVBQUUsTUFBTTtRQUNkLEtBQUssRUFBRSxLQUFLLENBQUMsS0FBSyxFQUFFO1FBQ3BCLE9BQU8sRUFBRSxPQUFPO09BQ2pCLENBQUM7S0FDSDs7SUFFRCxTQUFTLGVBQWUsQ0FBQyxFQUFFLEVBQUU7TUFDM0IsT0FBTztRQUNMLEVBQUUsRUFBRSxFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDOUIsRUFBRSxFQUFFLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztRQUM5QixFQUFFLEVBQUUsRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxNQUFNO1FBQ25DLEVBQUUsRUFBRSxFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7T0FDL0IsQ0FBQztLQUNIOztJQUVELFNBQVMsZUFBZSxDQUFDLEVBQUUsRUFBRTtNQUMzQixPQUFPO1FBQ0wsRUFBRSxFQUFFLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLO1FBQzNELEVBQUUsRUFBRSxFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSztRQUMzRCxFQUFFLEVBQUUsQ0FBQztRQUNMLEVBQUUsRUFBRSxFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUs7UUFDbEMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSztRQUNsQyxFQUFFLEVBQUUsRUFBRSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxLQUFLO09BQ2xDLENBQUM7S0FDSDs7O0lBR0QsSUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDOzs7Ozs7OztJQVFyQyxNQUFNLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyx5Q0FBeUM7Ozs7Ozs7TUFPaEYsT0FBTyxFQUFFLENBQUM7Ozs7Ozs7TUFPVixPQUFPLEVBQUUsQ0FBQzs7Ozs7OztNQU9WLFVBQVUsRUFBRSxTQUFTLE9BQU8sRUFBRTtRQUM1QixPQUFPLEtBQUssT0FBTyxHQUFHLEdBQUcsQ0FBQyxDQUFDOztRQUUzQixJQUFJLE1BQU0sR0FBRyxHQUFHLENBQUM7O1FBRWpCLElBQUksQ0FBQyxFQUFFLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNoQyxJQUFJLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxJQUFJLElBQUksUUFBUSxDQUFDOztRQUVyQyxNQUFNLEdBQUc7VUFDUCxFQUFFLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFLElBQUksQ0FBQztVQUMxQixFQUFFLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFLElBQUksQ0FBQztVQUMxQixFQUFFLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFLElBQUksQ0FBQztVQUMxQixFQUFFLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFLElBQUksQ0FBQztTQUMzQixDQUFDOztRQUVGLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxRQUFRLEVBQUU7VUFDMUIsTUFBTSxDQUFDLEVBQUUsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7VUFDbkMsTUFBTSxDQUFDLEVBQUUsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDcEM7UUFDRCxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsVUFBVSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDN0MsSUFBSSxPQUFPLENBQUMsaUJBQWlCLEVBQUU7VUFDN0IsSUFBSSxDQUFDLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQztTQUNwRDtRQUNELElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQy9DLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDO09BQ2hEOzs7Ozs7O01BT0QsWUFBWSxFQUFFLFNBQVMsVUFBVSxFQUFFO1FBQ2pDLEtBQUssSUFBSSxRQUFRLElBQUksVUFBVSxFQUFFO1VBQy9CLElBQUksS0FBSyxHQUFHLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztVQUNuRCxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQztZQUNuQixNQUFNLEVBQUUsVUFBVSxDQUFDLFFBQVEsQ0FBQztZQUM1QixLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUssRUFBRTtZQUNwQixPQUFPLEVBQUUsS0FBSyxDQUFDLFFBQVEsRUFBRTtXQUMxQixDQUFDLENBQUM7U0FDSjtRQUNELE9BQU8sSUFBSSxDQUFDO09BQ2I7Ozs7Ozs7TUFPRCxRQUFRLEVBQUUsU0FBUyxtQkFBbUIsRUFBRTtRQUN0QyxJQUFJLE1BQU0sR0FBRztVQUNYLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtVQUNmLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTtVQUNuQixVQUFVLEVBQUUsSUFBSSxDQUFDLFVBQVU7VUFDM0IsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPO1VBQ3JCLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTztVQUNyQixpQkFBaUIsRUFBRSxJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxpQkFBaUI7U0FDckcsQ0FBQztRQUNGLE1BQU0sQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxtQkFBbUIsQ0FBQyxDQUFDOztRQUV0RSxPQUFPLE1BQU0sQ0FBQztPQUNmOzs7Ozs7OztNQVFELEtBQUssRUFBRSxTQUFTLE1BQU0sRUFBRTtRQUN0QixJQUFJLE1BQU0sR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRztZQUN6QyxNQUFNLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQztZQUNuRSxTQUFTLEdBQUcsTUFBTSxDQUFDLEVBQUUsR0FBRyxNQUFNLENBQUMsRUFBRTtZQUNqQyxPQUFPLEdBQUcsTUFBTSxDQUFDLEtBQUssR0FBRyxDQUFDLEVBQUUsT0FBTyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDOztRQUU1RCxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsRUFBRTtVQUM3QixPQUFPLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQztTQUM1QixDQUFDLENBQUM7UUFDSCxJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssTUFBTSxFQUFFO1VBQzFCLE9BQU8sSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztVQUMvQixPQUFPLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7U0FDaEM7O1FBVUQsZ0JBQWdCLEdBQUcsWUFBWSxHQUFHLElBQUksQ0FBQyxFQUFFO3VCQUMxQixrQ0FBa0MsQ0FBQztRQUNsRCxJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtVQUMxQixnQkFBZ0IsSUFBSSw2QkFBNkIsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztTQUM5RjtRQUNELElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxRQUFRLEVBQUU7VUFDMUIsTUFBTSxHQUFHO1lBQ1Asa0JBQWtCO1lBQ2xCLGdCQUFnQjtZQUNoQixPQUFPLEVBQUUsTUFBTSxDQUFDLEVBQUU7WUFDbEIsUUFBUSxFQUFFLE1BQU0sQ0FBQyxFQUFFO1lBQ25CLFFBQVEsRUFBRSxNQUFNLENBQUMsRUFBRTtZQUNuQixRQUFRLEVBQUUsTUFBTSxDQUFDLEVBQUU7WUFDbkIsTUFBTTtXQUNQLENBQUM7U0FDSDthQUNJLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxRQUFRLEVBQUU7O1VBRS9CLE1BQU0sR0FBRztZQUNQLGtCQUFrQjtZQUNsQixnQkFBZ0I7WUFDaEIsT0FBTyxFQUFFLFNBQVMsR0FBRyxNQUFNLENBQUMsRUFBRSxHQUFHLE1BQU0sQ0FBQyxFQUFFO1lBQzFDLFFBQVEsRUFBRSxTQUFTLEdBQUcsTUFBTSxDQUFDLEVBQUUsR0FBRyxNQUFNLENBQUMsRUFBRTtZQUMzQyxPQUFPLEVBQUUsU0FBUyxHQUFHLE1BQU0sQ0FBQyxFQUFFLEdBQUcsTUFBTSxDQUFDLEVBQUU7WUFDMUMsUUFBUSxFQUFFLFNBQVMsR0FBRyxNQUFNLENBQUMsRUFBRSxHQUFHLE1BQU0sQ0FBQyxFQUFFO1lBQzNDLFFBQVEsRUFBRSxTQUFTLEdBQUcsTUFBTSxDQUFDLEVBQUUsR0FBRyxNQUFNLENBQUMsRUFBRTtZQUMzQyxNQUFNO1dBQ1AsQ0FBQztTQUNIOztRQUVELElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxRQUFRLEVBQUU7VUFDMUIsSUFBSSxTQUFTLEVBQUU7O1lBRWIsVUFBVSxHQUFHLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUNqQyxVQUFVLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDckIsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Y0FDakQsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQzthQUNqRDtXQUNGO1VBQ0QsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztVQUMvQyxJQUFJLFNBQVMsR0FBRyxDQUFDLEVBQUU7O1lBRWpCLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsRUFBRSxDQUFDO2dCQUMxQyxlQUFlLEdBQUcsU0FBUyxHQUFHLFNBQVMsQ0FBQztZQUM1QyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtjQUNqRCxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLGVBQWUsSUFBSSxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ3RFO1dBQ0Y7U0FDRjs7UUFFRCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtVQUNqRCxJQUFJLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7VUFDOUIsTUFBTSxDQUFDLElBQUk7WUFDVCxRQUFRO1lBQ1IsVUFBVSxFQUFFLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxHQUFHLElBQUksR0FBRztZQUMxQyxzQkFBc0IsRUFBRSxTQUFTLENBQUMsS0FBSzthQUN0QyxPQUFPLFNBQVMsQ0FBQyxPQUFPLEtBQUssV0FBVyxHQUFHLGlCQUFpQixHQUFHLFNBQVMsQ0FBQyxPQUFPLEdBQUcsR0FBRztZQUN2RixPQUFPO1dBQ1IsQ0FBQztTQUNIOztRQUVELE1BQU0sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksS0FBSyxRQUFRLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEVBQUUsQ0FBQzs7UUFFdEYsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO09BQ3hCOzs7Ozs7OztNQVFELE1BQU0sRUFBRSxTQUFTLEdBQUcsRUFBRTtRQUNwQixJQUFJLFFBQVEsRUFBRSxNQUFNLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDOztRQUVyRSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtVQUNkLE9BQU87U0FDUjs7UUFFRCxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO1VBQzFCLFFBQVEsR0FBRyxHQUFHLENBQUMsb0JBQW9CO1lBQ2pDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUMvQzthQUNJLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxRQUFRLEVBQUU7VUFDL0IsUUFBUSxHQUFHLEdBQUcsQ0FBQyxvQkFBb0I7WUFDakMsTUFBTSxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNyRTs7UUFFRCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7VUFDdEQsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLO2NBQ2hDLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU87Y0FDcEMsTUFBTSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDOztVQUV2QyxJQUFJLE9BQU8sT0FBTyxLQUFLLFdBQVcsRUFBRTtZQUNsQyxLQUFLLEdBQUcsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztXQUM1RDtVQUNELFFBQVEsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQ3RDOztRQUVELE9BQU8sUUFBUSxDQUFDO09BQ2pCO0tBQ0YsQ0FBQyxDQUFDOztJQUVILE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7O01BYXpDLFdBQVcsRUFBRSxTQUFTLEVBQUUsRUFBRSxRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUFrQ2xDLElBQUksWUFBWSxHQUFHLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUM7WUFDOUMsSUFBSTtZQUNKLGFBQWEsR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLGVBQWUsQ0FBQyxJQUFJLG1CQUFtQjtZQUN2RSxpQkFBaUIsR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLG1CQUFtQixDQUFDO1lBQ3hELFVBQVUsR0FBRyxFQUFFO1lBQ2YsTUFBTSxFQUFFLGFBQWEsRUFBRSxDQUFDLENBQUM7O1FBRTdCLElBQUksRUFBRSxDQUFDLFFBQVEsS0FBSyxnQkFBZ0IsSUFBSSxFQUFFLENBQUMsUUFBUSxLQUFLLGdCQUFnQixFQUFFO1VBQ3hFLElBQUksR0FBRyxRQUFRLENBQUM7U0FDakI7YUFDSTtVQUNILElBQUksR0FBRyxRQUFRLENBQUM7U0FDakI7O1FBRUQsSUFBSSxJQUFJLEtBQUssUUFBUSxFQUFFO1VBQ3JCLE1BQU0sR0FBRyxlQUFlLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDOUI7YUFDSSxJQUFJLElBQUksS0FBSyxRQUFRLEVBQUU7VUFDMUIsTUFBTSxHQUFHLGVBQWUsQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUM5Qjs7UUFFRCxLQUFLLENBQUMsR0FBRyxZQUFZLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxJQUFJO1VBQ25DLFVBQVUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDaEQ7O1FBRUQsYUFBYSxHQUFHLDRCQUE0QixDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUUsYUFBYSxDQUFDLENBQUM7O1FBRTlFLElBQUksUUFBUSxHQUFHLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQztVQUNqQyxJQUFJLEVBQUUsSUFBSTtVQUNWLE1BQU0sRUFBRSxNQUFNO1VBQ2QsVUFBVSxFQUFFLFVBQVU7VUFDdEIsT0FBTyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUk7VUFDdkIsT0FBTyxFQUFFLENBQUMsUUFBUSxDQUFDLEdBQUc7U0FDdkIsQ0FBQyxDQUFDOztRQUVILElBQUksaUJBQWlCLElBQUksYUFBYSxLQUFLLEVBQUUsRUFBRTtVQUM3QyxRQUFRLENBQUMsaUJBQWlCLEdBQUcsTUFBTSxDQUFDLHVCQUF1QixDQUFDLENBQUMsaUJBQWlCLElBQUksRUFBRSxJQUFJLGFBQWEsQ0FBQyxDQUFDO1NBQ3hHOztRQUVELE9BQU8sUUFBUSxDQUFDO09BQ2pCOzs7Ozs7Ozs7O01BVUQsU0FBUyxFQUFFLFNBQVMsR0FBRyxFQUFFLE9BQU8sRUFBRTtRQUNoQyxPQUFPLEtBQUssT0FBTyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBQzNCLDRCQUE0QixDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsTUFBTSxFQUFFLGdCQUFnQixDQUFDLENBQUM7UUFDcEUsT0FBTyxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7T0FDckM7S0FDRixDQUFDLENBQUM7Ozs7O0lBS0gsU0FBUyw0QkFBNEIsQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLGFBQWEsRUFBRTtNQUNwRSxJQUFJLFNBQVMsRUFBRSxTQUFTLEdBQUcsQ0FBQyxFQUFFLFVBQVUsR0FBRyxDQUFDLEVBQUUsYUFBYSxHQUFHLEVBQUUsQ0FBQztNQUNqRSxLQUFLLElBQUksSUFBSSxJQUFJLE9BQU8sRUFBRTtRQUN4QixJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxVQUFVLEVBQUU7VUFDaEMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNuQjthQUNJLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLFdBQVcsRUFBRTtVQUN0QyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ25CO1FBQ0QsU0FBUyxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDMUMsSUFBSSxPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxRQUFRLElBQUksc0JBQXNCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFO1VBQ25GLFVBQVUsR0FBRyxJQUFJLENBQUM7U0FDbkI7YUFDSTtVQUNILFVBQVUsR0FBRyxDQUFDLENBQUM7U0FDaEI7UUFDRCxJQUFJLElBQUksS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLElBQUksSUFBSSxJQUFJLEtBQUssSUFBSSxFQUFFO1VBQ25ELFVBQVUsSUFBSSxhQUFhLEtBQUssbUJBQW1CLEdBQUcsTUFBTSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7VUFDdkUsU0FBUyxHQUFHLGFBQWEsS0FBSyxtQkFBbUIsR0FBRyxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDMUU7YUFDSSxJQUFJLElBQUksS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLElBQUksRUFBRTtVQUN2QyxVQUFVLElBQUksYUFBYSxLQUFLLG1CQUFtQixHQUFHLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1VBQ3hFLFNBQVMsR0FBRyxhQUFhLEtBQUssbUJBQW1CLEdBQUcsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3pFO1FBQ0QsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLFNBQVMsR0FBRyxVQUFVLEdBQUcsU0FBUyxDQUFDO09BQ3BEO01BQ0QsSUFBSSxNQUFNLENBQUMsSUFBSSxLQUFLLFNBQVM7VUFDekIsT0FBTyxDQUFDLEVBQUUsS0FBSyxJQUFJO1VBQ25CLGFBQWEsS0FBSyxtQkFBbUI7VUFDckMsTUFBTSxDQUFDLEVBQUUsS0FBSyxNQUFNLENBQUMsRUFBRSxFQUFFOztRQUUzQixJQUFJLFdBQVcsR0FBRyxNQUFNLENBQUMsRUFBRSxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUM7UUFDeEMsYUFBYSxHQUFHLFlBQVksR0FBRyxXQUFXLEdBQUcsR0FBRyxDQUFDO1FBQ2pELElBQUksT0FBTyxDQUFDLEVBQUUsRUFBRTtVQUNkLE9BQU8sQ0FBQyxFQUFFLElBQUksV0FBVyxDQUFDO1NBQzNCO1FBQ0QsSUFBSSxPQUFPLENBQUMsRUFBRSxFQUFFO1VBQ2QsT0FBTyxDQUFDLEVBQUUsSUFBSSxXQUFXLENBQUM7U0FDM0I7T0FDRjtNQUNELE9BQU8sYUFBYSxDQUFDO0tBQ3RCO0dBQ0YsR0FBRyxDQUFDOzs7RUFHTCxDQUFDLFdBQVc7O0lBSVYsSUFBSSxPQUFPLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUM7Ozs7Ozs7Ozs7O0lBV2xDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLHdDQUF3Qzs7Ozs7OztNQU85RSxNQUFNLEVBQUUsUUFBUTs7Ozs7OztNQU9oQixPQUFPLEVBQUUsQ0FBQzs7Ozs7OztNQU9WLE9BQU8sRUFBRSxDQUFDOzs7Ozs7OztNQVFWLFdBQVcsRUFBRSxFQUFFOzs7Ozs7O01BT2YsZ0JBQWdCLEVBQUUsSUFBSTs7Ozs7Ozs7TUFRdEIsVUFBVSxFQUFFLFNBQVMsT0FBTyxFQUFFLFFBQVEsRUFBRTtRQUN0QyxPQUFPLEtBQUssT0FBTyxHQUFHLEdBQUcsQ0FBQyxDQUFDOztRQUUzQixJQUFJLENBQUMsRUFBRSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDaEMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sS0FBSyxPQUFPLENBQUMsTUFBTSxJQUFJLE9BQU8sT0FBTyxDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUMsRUFBRTtVQUM3RSxRQUFRLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1VBQzNCLE9BQU87U0FDUjs7UUFFRCxJQUFJLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLFdBQVcsRUFBRTtVQUN0RSxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1VBQ3hFLFFBQVEsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDNUI7YUFDSTs7VUFFSCxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUM7VUFDakIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1VBQ3hDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsU0FBUyxHQUFHLEVBQUU7WUFDbEQsS0FBSyxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUM7WUFDbkIsUUFBUSxJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztXQUM3QixFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDNUI7T0FDRjs7Ozs7OztNQU9ELFFBQVEsRUFBRSxTQUFTLG1CQUFtQixFQUFFO1FBQ3RDLElBQUksbUJBQW1CLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxtQkFBbUI7WUFDdkQsTUFBTSxFQUFFLE1BQU0sQ0FBQzs7O1FBR25CLElBQUksT0FBTyxJQUFJLENBQUMsTUFBTSxLQUFLLFVBQVUsRUFBRTtVQUNyQyxNQUFNLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUM5Qjs7YUFFSSxJQUFJLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEtBQUssUUFBUSxFQUFFO1VBQzVDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQztTQUMxQjs7YUFFSSxJQUFJLE9BQU8sSUFBSSxDQUFDLE1BQU0sS0FBSyxRQUFRLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUU7VUFDakUsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLENBQUM7U0FDbEM7O1FBRUQsTUFBTSxHQUFHO1VBQ1AsSUFBSSxFQUFFLFNBQVM7VUFDZixNQUFNLEVBQUUsTUFBTTtVQUNkLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTtVQUNuQixXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVc7VUFDN0IsT0FBTyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLG1CQUFtQixDQUFDO1VBQ25ELE9BQU8sRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxtQkFBbUIsQ0FBQztVQUNuRCxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxHQUFHLElBQUk7U0FDaEYsQ0FBQztRQUNGLE1BQU0sQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxtQkFBbUIsQ0FBQyxDQUFDOztRQUV0RSxPQUFPLE1BQU0sQ0FBQztPQUNmOzs7Ozs7OztNQVFELEtBQUssRUFBRSxTQUFTLE1BQU0sRUFBRTtRQUN0QixJQUFJLGFBQWEsR0FBRyxPQUFPLElBQUksQ0FBQyxNQUFNLEtBQUssVUFBVSxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsTUFBTTtZQUMvRSxZQUFZLEdBQUcsYUFBYSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSztZQUNqRCxhQUFhLEdBQUcsYUFBYSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTTtZQUNwRCxjQUFjLEdBQUcsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsS0FBSztZQUM1QyxjQUFjLEdBQUcsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsTUFBTTtZQUM3QyxhQUFhLEdBQUcsRUFBRSxDQUFDO1FBQ3ZCLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxVQUFVLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxXQUFXLEVBQUU7VUFDN0QsYUFBYSxHQUFHLENBQUMsQ0FBQztTQUNuQjtRQUNELElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxVQUFVLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxXQUFXLEVBQUU7VUFDN0QsWUFBWSxHQUFHLENBQUMsQ0FBQztTQUNsQjtRQUNELElBQUksYUFBYSxDQUFDLEdBQUcsRUFBRTtVQUNyQixhQUFhLEdBQUcsYUFBYSxDQUFDLEdBQUcsQ0FBQztTQUNuQzthQUNJLElBQUksYUFBYSxDQUFDLFNBQVMsRUFBRTtVQUNoQyxhQUFhLEdBQUcsYUFBYSxDQUFDLFNBQVMsRUFBRSxDQUFDO1NBQzNDOztRQUVELE9BQU8scUJBQXFCLEdBQUcsSUFBSSxDQUFDLEVBQUU7c0JBQ3hCLE9BQU8sR0FBRyxjQUFjO3NCQUN4QixPQUFPLEdBQUcsY0FBYztzQkFDeEIsV0FBVyxHQUFHLFlBQVk7c0JBQzFCLFlBQVksR0FBRyxhQUFhLEdBQUcsTUFBTTtpQkFDMUMsb0JBQW9CO3dCQUNiLFVBQVUsR0FBRyxhQUFhLENBQUMsS0FBSzt3QkFDaEMsWUFBWSxHQUFHLGFBQWEsQ0FBQyxNQUFNO3dCQUNuQyxnQkFBZ0IsR0FBRyxhQUFhO2lCQUN2QyxjQUFjO2VBQ2hCLGNBQWMsQ0FBQztPQUN2Qjs7O01BR0QsVUFBVSxFQUFFLFNBQVMsT0FBTyxFQUFFO1FBQzVCLEtBQUssSUFBSSxJQUFJLElBQUksT0FBTyxFQUFFO1VBQ3hCLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDNUI7T0FDRjs7Ozs7OztNQU9ELE1BQU0sRUFBRSxTQUFTLEdBQUcsRUFBRTtRQUNwQixJQUFJLE1BQU0sR0FBRyxPQUFPLElBQUksQ0FBQyxNQUFNLEtBQUssVUFBVSxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDOzs7UUFHN0UsSUFBSSxDQUFDLE1BQU0sRUFBRTtVQUNYLE9BQU8sRUFBRSxDQUFDO1NBQ1g7OztRQUdELElBQUksT0FBTyxNQUFNLENBQUMsR0FBRyxLQUFLLFdBQVcsRUFBRTtVQUNyQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRTtZQUNwQixPQUFPLEVBQUUsQ0FBQztXQUNYO1VBQ0QsSUFBSSxNQUFNLENBQUMsWUFBWSxLQUFLLENBQUMsSUFBSSxNQUFNLENBQUMsYUFBYSxLQUFLLENBQUMsRUFBRTtZQUMzRCxPQUFPLEVBQUUsQ0FBQztXQUNYO1NBQ0Y7UUFDRCxPQUFPLEdBQUcsQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztPQUMvQztLQUNGLENBQUMsQ0FBQztHQUNKLEdBQUcsQ0FBQzs7O0VBR0wsQ0FBQyxTQUFTLE1BQU0sRUFBRTs7SUFJaEIsSUFBSSxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sS0FBSyxNQUFNLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBQztRQUMvQyxPQUFPLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUM7O0lBRWxDLElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRTtNQUNqQixNQUFNLENBQUMsSUFBSSxDQUFDLG1DQUFtQyxDQUFDLENBQUM7TUFDakQsT0FBTztLQUNSOzs7Ozs7OztJQVFELE1BQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLHVDQUF1Qzs7Ozs7OztNQU81RSxLQUFLLEVBQUUsWUFBWTs7Ozs7O01BTW5CLElBQUksRUFBRSxDQUFDOzs7Ozs7O01BT1AsT0FBTyxFQUFFLENBQUM7Ozs7Ozs7TUFPVixPQUFPLEVBQUUsQ0FBQzs7Ozs7OztNQU9WLFlBQVksRUFBRSxLQUFLOzs7Ozs7O01BT25CLG9CQUFvQixFQUFFLElBQUk7Ozs7Ozs7TUFPMUIsVUFBVSxFQUFFLFNBQVMsT0FBTyxFQUFFOztRQUU1QixJQUFJLE9BQU8sT0FBTyxLQUFLLFFBQVEsRUFBRTtVQUMvQixPQUFPLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUN0Qzs7UUFFRCxLQUFLLElBQUksSUFBSSxJQUFJLE9BQU8sRUFBRTtVQUN4QixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzVCOztRQUVELElBQUksQ0FBQyxFQUFFLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQztPQUNqQzs7Ozs7OztNQU9ELFlBQVksRUFBRSxTQUFTLE1BQU0sRUFBRTtRQUM3QixJQUFJLFNBQVMsR0FBRyxNQUFNLENBQUMsSUFBSSxFQUFFO1lBQ3pCLGNBQWMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFO1lBQ3JFLEtBQUssR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLEVBQUUsRUFBRSxDQUFDLElBQUksWUFBWSxDQUFDOztRQUVsRixPQUFPO1VBQ0wsS0FBSyxFQUFFLEtBQUssQ0FBQyxJQUFJLEVBQUU7VUFDbkIsT0FBTyxFQUFFLFFBQVEsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQztVQUM3QyxPQUFPLEVBQUUsUUFBUSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDO1VBQzdDLElBQUksRUFBRSxRQUFRLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUM7U0FDM0MsQ0FBQztPQUNIOzs7Ozs7O01BT0QsUUFBUSxFQUFFLFdBQVc7UUFDbkIsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7T0FDeEU7Ozs7Ozs7O01BUUQsS0FBSyxFQUFFLFNBQVMsTUFBTSxFQUFFO1FBQ3RCLElBQUksS0FBSyxHQUFHLEVBQUUsRUFBRSxLQUFLLEdBQUcsRUFBRSxFQUFFLG1CQUFtQixHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsbUJBQW1CO1lBQy9FLE1BQU0sR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVk7Y0FDL0IsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRTtjQUNwQyxNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzlDLFFBQVEsR0FBRyxFQUFFLEVBQUUsS0FBSyxHQUFHLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7O1FBRXhELElBQUksTUFBTSxDQUFDLEtBQUssSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFOzs7VUFHakMsS0FBSyxHQUFHLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLElBQUksTUFBTSxDQUFDLEtBQUssRUFBRSxtQkFBbUIsQ0FBQyxHQUFHLEdBQUcsR0FBRyxRQUFRLENBQUM7VUFDdkcsS0FBSyxHQUFHLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRSxtQkFBbUIsQ0FBQyxHQUFHLEdBQUcsR0FBRyxRQUFRLENBQUM7U0FDekc7UUFDRCxJQUFJLE1BQU0sQ0FBQyxLQUFLLEVBQUU7VUFDaEIsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztTQUNoQjtRQUNELElBQUksTUFBTSxDQUFDLEtBQUssRUFBRTtVQUNoQixNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ2hCOztRQUVEO1VBQ0Usb0JBQW9CLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxRQUFRLEdBQUcsS0FBSyxHQUFHLGFBQWEsSUFBSSxHQUFHLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHLEtBQUs7WUFDM0YsTUFBTSxHQUFHLEtBQUssR0FBRyxZQUFZLElBQUksR0FBRyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBRyxLQUFLLEdBQUcsS0FBSztZQUNqRSxtREFBbUQ7Y0FDakQsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLG1CQUFtQixDQUFDLEdBQUcsdUJBQXVCO1lBQ3ZGLGtCQUFrQixHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLG1CQUFtQixDQUFDO1lBQzNELFFBQVEsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxtQkFBbUIsQ0FBQyxHQUFHLGlDQUFpQztZQUNyRiwwQkFBMEIsR0FBRyxLQUFLLENBQUMsS0FBSyxFQUFFLEdBQUcsbUJBQW1CLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxHQUFHLE9BQU87WUFDN0YsK0NBQStDO1lBQy9DLGVBQWU7Y0FDYixtQ0FBbUM7Y0FDbkMsc0RBQXNEO1lBQ3hELGdCQUFnQjtVQUNsQixhQUFhLEVBQUU7T0FDbEI7Ozs7Ozs7TUFPRCxRQUFRLEVBQUUsV0FBVztRQUNuQixJQUFJLElBQUksQ0FBQyxvQkFBb0IsRUFBRTtVQUM3QixPQUFPO1lBQ0wsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLO1lBQ2pCLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtZQUNmLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTztZQUNyQixPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU87WUFDckIsWUFBWSxFQUFFLElBQUksQ0FBQyxZQUFZO1dBQ2hDLENBQUM7U0FDSDtRQUNELElBQUksR0FBRyxHQUFHLEdBQUcsRUFBRSxLQUFLLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUM7O1FBRS9DLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLGNBQWMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxTQUFTLElBQUksRUFBRTtVQUM3RSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDOUIsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztXQUN4QjtTQUNGLEVBQUUsSUFBSSxDQUFDLENBQUM7O1FBRVQsT0FBTyxHQUFHLENBQUM7T0FDWjtLQUNGLENBQUMsQ0FBQzs7Ozs7Ozs7O0lBU0gsTUFBTSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsR0FBRyx3RkFBd0YsQ0FBQzs7R0FFM0gsRUFBRSxBQUFpQyxPQUFPLEFBQU8sQ0FBQyxDQUFDOzs7RUFHcEQsQ0FBQyxZQUFZOztJQUlYLElBQUksTUFBTSxDQUFDLFlBQVksRUFBRTtNQUN2QixNQUFNLENBQUMsSUFBSSxDQUFDLHlDQUF5QyxDQUFDLENBQUM7TUFDdkQsT0FBTztLQUNSOzs7SUFHRCxJQUFJLE1BQU0sR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNO1FBQ2xDLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsZ0JBQWdCO1FBQy9DLGVBQWUsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLGVBQWU7UUFDN0MsT0FBTyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTztRQUM3QixjQUFjLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjO1FBQzNDLGVBQWUsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLGVBQWU7O1FBRTdDLGlCQUFpQixHQUFHLElBQUksS0FBSyxDQUFDLHVDQUF1QyxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7OztJQWUzRSxNQUFNLENBQUMsWUFBWSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxhQUFhLDhDQUE4Qzs7Ozs7Ozs7TUFROUcsVUFBVSxFQUFFLFNBQVMsRUFBRSxFQUFFLE9BQU8sRUFBRTtRQUNoQyxPQUFPLEtBQUssT0FBTyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBQzNCLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMxRCxJQUFJLENBQUMscUJBQXFCLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM5RCxJQUFJLENBQUMsV0FBVyxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztPQUMvQjs7Ozs7Ozs7TUFRRCxlQUFlLEVBQUUsRUFBRTs7Ozs7Ozs7Ozs7TUFXbkIsZUFBZSxFQUFFLElBQUk7Ozs7Ozs7OztNQVNyQixZQUFZLEVBQUUsRUFBRTs7Ozs7Ozs7Ozs7TUFXaEIsWUFBWSxFQUFFLElBQUk7Ozs7Ozs7TUFPbEIsb0JBQW9CLEVBQUUsSUFBSTs7Ozs7OztNQU8xQixRQUFRLEVBQUUsS0FBSzs7Ozs7Ozs7Ozs7O01BWWYsaUJBQWlCLEVBQUUsSUFBSTs7Ozs7Ozs7O01BU3ZCLE1BQU0sRUFBRSxJQUFJOzs7Ozs7O01BT1osb0JBQW9CLEVBQUUsS0FBSzs7Ozs7OztNQU8zQixtQkFBbUIsRUFBRSxLQUFLOzs7Ozs7O01BTzFCLHFCQUFxQixFQUFFLElBQUk7Ozs7Ozs7TUFPM0IsaUJBQWlCLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUU7Ozs7Ozs7O01BUTFDLGFBQWEsRUFBRSxJQUFJOzs7Ozs7OztNQVFuQixVQUFVLEVBQUUsSUFBSTs7Ozs7OztNQU9oQixtQkFBbUIsRUFBRSxZQUFZOztPQUVoQzs7Ozs7OztNQU9ELG1CQUFtQixFQUFFLElBQUk7Ozs7Ozs7Ozs7O01BV3pCLFNBQVMsRUFBRSxHQUFHOzs7Ozs7Ozs7Ozs7TUFZZCxhQUFhLEVBQUUsSUFBSTs7Ozs7OztNQU9uQixXQUFXLEVBQUUsU0FBUyxFQUFFLEVBQUUsT0FBTyxFQUFFO1FBQ2pDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQztRQUNwQyxJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztRQUNuQixJQUFJLENBQUMsa0JBQWtCLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDNUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMzQixJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQzs7UUFFMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7VUFDckIsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7U0FDM0I7O1FBRUQsSUFBSSxPQUFPLENBQUMsWUFBWSxFQUFFO1VBQ3hCLElBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRSxFQUFFLENBQUMsQ0FBQztTQUNoRDtRQUNELElBQUksT0FBTyxDQUFDLGVBQWUsRUFBRTtVQUMzQixJQUFJLENBQUMsa0JBQWtCLENBQUMsT0FBTyxDQUFDLGVBQWUsRUFBRSxFQUFFLENBQUMsQ0FBQztTQUN0RDtRQUNELElBQUksT0FBTyxDQUFDLGVBQWUsRUFBRTtVQUMzQixJQUFJLENBQUMsa0JBQWtCLENBQUMsT0FBTyxDQUFDLGVBQWUsRUFBRSxFQUFFLENBQUMsQ0FBQztTQUN0RDtRQUNELElBQUksT0FBTyxDQUFDLFlBQVksRUFBRTtVQUN4QixJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsRUFBRSxDQUFDLENBQUM7U0FDaEQ7UUFDRCxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7T0FDbkI7Ozs7O01BS0QsZ0JBQWdCLEVBQUUsV0FBVztRQUMzQixRQUFRLE1BQU0sQ0FBQyxnQkFBZ0IsS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLG1CQUFtQixFQUFFO09BQ3BFOzs7Ozs7TUFNRCxnQkFBZ0IsRUFBRSxXQUFXO1FBQzNCLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixFQUFFLEdBQUcsTUFBTSxDQUFDLGdCQUFnQixHQUFHLENBQUMsQ0FBQztPQUM5RDs7Ozs7TUFLRCxrQkFBa0IsRUFBRSxXQUFXO1FBQzdCLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsRUFBRTtVQUM1QixPQUFPO1NBQ1I7UUFDRCxJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUMvRSxJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQzs7UUFFakYsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLEVBQUUsTUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUM7T0FDL0U7Ozs7Ozs7O01BUUQsVUFBVSxFQUFFLFlBQVk7UUFDdEIsSUFBSSxDQUFDLE9BQU8sR0FBRyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDcEQsT0FBTyxJQUFJLENBQUM7T0FDYjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQWlERCxlQUFlLEVBQUUsVUFBVSxLQUFLLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRTtRQUNuRCxPQUFPLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxjQUFjLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztPQUMzRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQWlERCxrQkFBa0IsRUFBRSxVQUFVLEtBQUssRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFO1FBQ3RELE9BQU8sSUFBSSxDQUFDLG1CQUFtQixDQUFDLGlCQUFpQixFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7T0FDOUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BdUJELGVBQWUsRUFBRSxTQUFTLFlBQVksRUFBRSxRQUFRLEVBQUU7UUFDaEQsT0FBTyxJQUFJLENBQUMsbUJBQW1CLENBQUMsY0FBYyxFQUFFLFlBQVksRUFBRSxRQUFRLENBQUMsQ0FBQztPQUN6RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUF1QkQsa0JBQWtCLEVBQUUsU0FBUyxlQUFlLEVBQUUsUUFBUSxFQUFFO1FBQ3RELE9BQU8sSUFBSSxDQUFDLG1CQUFtQixDQUFDLGlCQUFpQixFQUFFLGVBQWUsRUFBRSxRQUFRLENBQUMsQ0FBQztPQUMvRTs7Ozs7O01BTUQsa0JBQWtCLEVBQUUsV0FBVztRQUM3QixJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7O1FBRTVCLEdBQUcsQ0FBQyxxQkFBcUIsR0FBRyxHQUFHLENBQUMscUJBQXFCLElBQUksR0FBRyxDQUFDLDJCQUEyQjthQUNuRixHQUFHLENBQUMsd0JBQXdCLElBQUksR0FBRyxDQUFDLHVCQUF1QixJQUFJLEdBQUcsQ0FBQyxzQkFBc0IsQ0FBQztRQUMvRixHQUFHLENBQUMscUJBQXFCLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixDQUFDO09BQ3hEOzs7Ozs7Ozs7O01BVUQsbUJBQW1CLEVBQUUsU0FBUyxRQUFRLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUU7UUFDaEUsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7VUFDN0IsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLFNBQVMsR0FBRyxFQUFFO1lBQ3pDLEdBQUcsS0FBSyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ3pELFFBQVEsSUFBSSxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7V0FDM0IsRUFBRSxJQUFJLEVBQUUsT0FBTyxJQUFJLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUMxQzthQUNJO1VBQ0gsT0FBTyxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7VUFDckMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQztVQUN2QixRQUFRLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzdCOztRQUVELE9BQU8sSUFBSSxDQUFDO09BQ2I7Ozs7Ozs7OztNQVNELG1CQUFtQixFQUFFLFNBQVMsUUFBUSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUU7UUFDdkQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQztRQUN2QixJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQztRQUNwQyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDN0MsT0FBTyxJQUFJLENBQUM7T0FDYjs7Ozs7TUFLRCxvQkFBb0IsRUFBRSxXQUFXO1FBQy9CLElBQUksT0FBTyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztRQUNoRCxJQUFJLENBQUMsT0FBTyxFQUFFO1VBQ1osTUFBTSxpQkFBaUIsQ0FBQztTQUN6QjtRQUNELElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFO1VBQ2xCLE9BQU8sQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDO1NBQ3JCO1FBQ0QsSUFBSSxPQUFPLE9BQU8sQ0FBQyxVQUFVLEtBQUssV0FBVyxFQUFFO1VBQzdDLE1BQU0saUJBQWlCLENBQUM7U0FDekI7UUFDRCxPQUFPLE9BQU8sQ0FBQztPQUNoQjs7Ozs7O01BTUQsWUFBWSxFQUFFLFVBQVUsT0FBTyxFQUFFO1FBQy9CLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7O1FBRTFCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZFLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDOztRQUUxRSxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUU7VUFDN0IsT0FBTztTQUNSOztRQUVELElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDdEMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQzs7UUFFeEMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO1FBQ25ELElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQzs7UUFFckQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLEVBQUUsQ0FBQztPQUN6RDs7Ozs7OztNQU9ELGtCQUFrQixFQUFFLFVBQVUsUUFBUSxFQUFFOztRQUV0QyxJQUFJLFFBQVEsSUFBSSxRQUFRLENBQUMsVUFBVSxFQUFFO1VBQ25DLElBQUksQ0FBQyxhQUFhLEdBQUcsUUFBUSxDQUFDO1NBQy9CO2FBQ0k7VUFDSCxJQUFJLENBQUMsYUFBYSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1NBQ25GOztRQUVELE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsY0FBYyxDQUFDLENBQUM7O1FBRXpELElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtVQUNwQixJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1NBQzVDOztRQUVELElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztPQUM3RDs7Ozs7O01BTUQsUUFBUSxFQUFFLFlBQVk7UUFDcEIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO09BQ25COzs7Ozs7TUFNRCxTQUFTLEVBQUUsWUFBWTtRQUNyQixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7T0FDcEI7Ozs7Ozs7Ozs7O01BV0QsUUFBUSxFQUFFLFVBQVUsS0FBSyxFQUFFLE9BQU8sRUFBRTtRQUNsQyxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUM7T0FDdEQ7Ozs7Ozs7Ozs7O01BV0QsU0FBUyxFQUFFLFVBQVUsS0FBSyxFQUFFLE9BQU8sRUFBRTtRQUNuQyxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUM7T0FDdkQ7Ozs7Ozs7Ozs7Ozs7TUFhRCxhQUFhLEVBQUUsVUFBVSxVQUFVLEVBQUUsT0FBTyxFQUFFO1FBQzVDLElBQUksUUFBUSxDQUFDOztRQUViLE9BQU8sR0FBRyxPQUFPLElBQUksRUFBRSxDQUFDOztRQUV4QixLQUFLLElBQUksSUFBSSxJQUFJLFVBQVUsRUFBRTtVQUMzQixRQUFRLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDOztVQUU1QixJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRTtZQUNwQixJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ3BELFFBQVEsSUFBSSxJQUFJLENBQUM7WUFDakIsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7V0FDNUI7O1VBRUQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUU7WUFDMUIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztXQUN2QztTQUNGO1FBQ0QsSUFBSSxJQUFJLENBQUMsbUJBQW1CLEVBQUU7VUFDNUIsSUFBSSxDQUFDLGdCQUFnQixJQUFJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxlQUFlLEVBQUUsQ0FBQztTQUNsRTtRQUNELElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBQzFCLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBQzFCLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQzs7UUFFbEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUU7VUFDcEIsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7U0FDekI7O1FBRUQsT0FBTyxJQUFJLENBQUM7T0FDYjs7Ozs7Ozs7OztNQVVELHNCQUFzQixFQUFFLFVBQVUsSUFBSSxFQUFFLEtBQUssRUFBRTtRQUM3QyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQzs7UUFFakMsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFO1VBQ3RCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDO1NBQ2xDOztRQUVELElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRTtVQUN0QixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQztTQUNsQzs7UUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDOztRQUVuQixPQUFPLElBQUksQ0FBQztPQUNiOzs7Ozs7Ozs7O01BVUQsZ0JBQWdCLEVBQUUsVUFBVSxJQUFJLEVBQUUsS0FBSyxFQUFFO1FBQ3ZDLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQzs7UUFFdkMsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFO1VBQ3RCLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQztTQUN4Qzs7UUFFRCxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7VUFDbEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDO1NBQ3BDOztRQUVELE9BQU8sSUFBSSxDQUFDO09BQ2I7Ozs7OztNQU1ELE9BQU8sRUFBRSxZQUFZO1FBQ25CLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDO09BQ2xDOzs7Ozs7OztNQVFELG9CQUFvQixFQUFFLFVBQVUsR0FBRyxFQUFFO1FBQ25DLElBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsTUFBTSxFQUFFLFNBQVMsR0FBRyxLQUFLLEVBQUUsWUFBWSxHQUFHLElBQUksRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQzlGLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxHQUFHLENBQUM7UUFDN0IsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO1VBQ3BELE1BQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1VBQzFCLE1BQU0sQ0FBQyxLQUFLLElBQUksTUFBTSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEVBQUUsWUFBWSxDQUFDLENBQUM7U0FDM0Q7UUFDRCxJQUFJLFlBQVksSUFBSSxZQUFZLENBQUMsSUFBSSxLQUFLLGlCQUFpQixFQUFFO1VBQzNELFlBQVksQ0FBQyxTQUFTLENBQUMsU0FBUyxFQUFFLFlBQVksQ0FBQyxDQUFDO1NBQ2pEO1FBQ0QsSUFBSSxDQUFDLHNCQUFzQixFQUFFLENBQUM7UUFDOUIsSUFBSSxDQUFDLGlCQUFpQixJQUFJLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQ2xELE9BQU8sSUFBSSxDQUFDO09BQ2I7Ozs7Ozs7OztNQVNELFdBQVcsRUFBRSxVQUFVLEtBQUssRUFBRSxLQUFLLEVBQUU7O1FBRW5DLElBQUksTUFBTSxHQUFHLEtBQUssRUFBRSxHQUFHLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxRCxLQUFLLEdBQUcsY0FBYyxDQUFDLEtBQUssRUFBRSxlQUFlLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQztRQUN2RSxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO1FBQ2YsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztRQUNmLElBQUksS0FBSyxHQUFHLGNBQWMsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDdkMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUM3QixHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQzdCLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDLEdBQUcsQ0FBQyxDQUFDO09BQ3ZDOzs7Ozs7OztNQVFELE9BQU8sRUFBRSxVQUFVLEtBQUssRUFBRTtRQUN4QixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDaEQsT0FBTyxJQUFJLENBQUM7T0FDYjs7Ozs7Ozs7TUFRRCxXQUFXLEVBQUUsVUFBVSxLQUFLLEVBQUU7UUFDNUIsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ2xCLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDbEIsT0FBTyxJQUFJLENBQUMsb0JBQW9CLENBQUMsR0FBRyxDQUFDLENBQUM7T0FDdkM7Ozs7Ozs7O01BUUQsV0FBVyxFQUFFLFVBQVUsS0FBSyxFQUFFO1FBQzVCLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxLQUFLO1VBQ3RDLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO1VBQ3BDLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO1NBQ3JDLENBQUMsQ0FBQztPQUNKOzs7Ozs7TUFNRCxVQUFVLEVBQUUsWUFBWTtRQUN0QixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUM7T0FDM0I7Ozs7OztNQU1ELGNBQWMsRUFBRSxTQUFTLEdBQUcsRUFBRTtRQUM1QixJQUFJLENBQUMsUUFBUSxJQUFJLEdBQUcsQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUNsQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUN6QixHQUFHLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUUsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUMzQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO09BQ25COzs7Ozs7TUFNRCxnQkFBZ0IsRUFBRSxTQUFTLEdBQUcsRUFBRTtRQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFDN0MsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNwQixPQUFPLEdBQUcsQ0FBQyxNQUFNLENBQUM7T0FDbkI7Ozs7Ozs7O01BUUQsWUFBWSxFQUFFLFNBQVMsR0FBRyxFQUFFO1FBQzFCLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM3QyxPQUFPLElBQUksQ0FBQztPQUNiOzs7Ozs7TUFNRCxVQUFVLEVBQUUsWUFBWTtRQUN0QixPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQztPQUM5Qjs7Ozs7OztNQU9ELEtBQUssRUFBRSxZQUFZO1FBQ2pCLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQztRQUM1QixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztRQUN6QixJQUFJLENBQUMsZUFBZSxHQUFHLEVBQUUsQ0FBQztRQUMxQixJQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQztRQUN2QixJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtVQUMxQixJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQztVQUNoRCxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQztVQUM1QixJQUFJLENBQUMsaUJBQWlCLEdBQUcsS0FBSyxDQUFDO1NBQ2hDO1FBQ0QsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUN6QyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDNUIsSUFBSSxDQUFDLGlCQUFpQixJQUFJLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQ2xELE9BQU8sSUFBSSxDQUFDO09BQ2I7Ozs7Ozs7TUFPRCxTQUFTLEVBQUUsWUFBWTtRQUNyQixJQUFJLGNBQWMsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUM7UUFDM0MsSUFBSSxDQUFDLFlBQVksQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2pELE9BQU8sSUFBSSxDQUFDO09BQ2I7Ozs7Ozs7O01BUUQsY0FBYyxFQUFFLFdBQVc7UUFDekIsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUM7UUFDckIsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO09BQ2xCOzs7Ozs7OztNQVFELGdCQUFnQixFQUFFLFlBQVk7UUFDNUIsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7VUFDckIsSUFBSSxDQUFDLFdBQVcsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1NBQzNFO1FBQ0QsT0FBTyxJQUFJLENBQUM7T0FDYjs7Ozs7Ozs7O01BU0Qsc0JBQXNCLEVBQUUsV0FBVztRQUNqQyxJQUFJLE1BQU0sR0FBRyxHQUFHLEVBQUUsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLEVBQUUsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNO1lBQ3RELElBQUksR0FBRyxlQUFlLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFDbkQsTUFBTSxDQUFDLEVBQUUsR0FBRyxjQUFjLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNqRCxNQUFNLENBQUMsRUFBRSxHQUFHLGNBQWMsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzFELE1BQU0sQ0FBQyxFQUFFLEdBQUcsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdkQsTUFBTSxDQUFDLEVBQUUsR0FBRyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2RCxJQUFJLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQztRQUN4QixPQUFPLE1BQU0sQ0FBQztPQUNmOzs7Ozs7Ozs7TUFTRCxZQUFZLEVBQUUsU0FBUyxHQUFHLEVBQUUsT0FBTyxFQUFFO1FBQ25DLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQztRQUMvQixJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUU7VUFDcEIsTUFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1VBQzlDLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDO1NBQ3RCO1FBQ0QsSUFBSSxDQUFDLHNCQUFzQixFQUFFLENBQUM7UUFDOUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQzNCLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtVQUNmLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztTQUNwQztRQUNELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsQ0FBQzs7UUFFNUIsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDOztRQUVYLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNsRCxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNsQyxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDZCxJQUFJLENBQUMsSUFBSSxDQUFDLG9CQUFvQixJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUU7VUFDbEQsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUN4QjtRQUNELElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtVQUNmLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUNmO1FBQ0QsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN6QixJQUFJLElBQUksQ0FBQyxvQkFBb0IsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFO1VBQ2pELElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDeEI7UUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO09BQzNCOzs7Ozs7O01BT0QsY0FBYyxFQUFFLFNBQVMsR0FBRyxFQUFFLE9BQU8sRUFBRTtRQUNyQyxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDWCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRTtVQUM5QyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUN0QztPQUNGOzs7Ozs7O01BT0QsMEJBQTBCLEVBQUUsU0FBUyxHQUFHLEVBQUUsUUFBUSxFQUFFO1FBQ2xELElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3pDLElBQUksTUFBTSxFQUFFO1VBQ1YsR0FBRyxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsTUFBTTtjQUN6QixNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUM7Y0FDeEIsTUFBTSxDQUFDOztVQUVYLEdBQUcsQ0FBQyxRQUFRO1lBQ1YsTUFBTSxDQUFDLE9BQU8sSUFBSSxDQUFDO1lBQ25CLE1BQU0sQ0FBQyxPQUFPLElBQUksQ0FBQztZQUNuQixJQUFJLENBQUMsS0FBSztZQUNWLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNoQjtRQUNELE1BQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxDQUFDO1FBQ2xDLElBQUksTUFBTSxFQUFFO1VBQ1YsSUFBSSxJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQyxFQUFFO1lBQzFCLENBQUMsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUM7WUFDM0IsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ1gsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1dBQ25EO1VBQ0QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztVQUNuQixJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQyxJQUFJLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUN6QztPQUNGOzs7Ozs7TUFNRCxpQkFBaUIsRUFBRSxTQUFTLEdBQUcsRUFBRTtRQUMvQixJQUFJLENBQUMsMEJBQTBCLENBQUMsR0FBRyxFQUFFLFlBQVksQ0FBQyxDQUFDO09BQ3BEOzs7Ozs7TUFNRCxjQUFjLEVBQUUsU0FBUyxHQUFHLEVBQUU7UUFDNUIsSUFBSSxDQUFDLDBCQUEwQixDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztPQUNqRDs7Ozs7OztNQU9ELFNBQVMsRUFBRSxZQUFZO1FBQ3JCLE9BQU87VUFDTCxHQUFHLEVBQUUsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDO1VBQ3BCLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUM7U0FDckIsQ0FBQztPQUNIOzs7Ozs7O01BT0QsYUFBYSxFQUFFLFVBQVUsTUFBTSxFQUFFO1FBQy9CLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7T0FDdkc7Ozs7Ozs7O01BUUQsYUFBYSxFQUFFLFVBQVUsTUFBTSxFQUFFO1FBQy9CLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7T0FDdEc7Ozs7Ozs7O01BUUQsWUFBWSxFQUFFLFNBQVMsTUFBTSxFQUFFO1FBQzdCLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQzs7UUFFOUIsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sRUFBRSxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztPQUM5RTs7Ozs7Ozs7TUFRRCxvQkFBb0IsRUFBRSxTQUFTLE1BQU0sRUFBRTtRQUNyQyxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7O1FBRWxDLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7T0FDN0M7Ozs7Ozs7O01BUUQscUJBQXFCLEVBQUUsU0FBUyxNQUFNLEVBQUU7UUFDdEMsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ2xDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BGLE9BQU8sSUFBSSxDQUFDO09BQ2I7Ozs7Ozs7O01BUUQscUJBQXFCLEVBQUUsU0FBUyxNQUFNLEVBQUU7UUFDdEMsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDOztRQUVsQyxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO09BQzVGOzs7Ozs7O01BT0QsV0FBVyxFQUFFLFdBQVc7UUFDdEIsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUN6QixJQUFJLEdBQUcsZUFBZSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBQ25ELE9BQU8sY0FBYyxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxHQUFHLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztPQUNoRTs7Ozs7Ozs7O01BU0QsYUFBYSxFQUFFLFNBQVMsTUFBTSxFQUFFLE1BQU0sRUFBRTtRQUN0QyxNQUFNLENBQUMsbUJBQW1CLENBQUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUN2RCxNQUFNLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDbkIsSUFBSSxDQUFDLGlCQUFpQixJQUFJLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQ2xELE9BQU8sSUFBSSxDQUFDO09BQ2I7Ozs7Ozs7TUFPRCxjQUFjLEVBQUUsVUFBVSxtQkFBbUIsRUFBRTtRQUM3QyxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO09BQ25EOzs7Ozs7O01BT0QsUUFBUSxFQUFFLFVBQVUsbUJBQW1CLEVBQUU7UUFDdkMsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLFVBQVUsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO09BQzlEOzs7Ozs7O01BT0QsZ0JBQWdCLEVBQUUsVUFBVSxtQkFBbUIsRUFBRTtRQUMvQyxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsa0JBQWtCLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztPQUN0RTs7Ozs7TUFLRCxlQUFlLEVBQUUsVUFBVSxVQUFVLEVBQUUsbUJBQW1CLEVBQUU7O1FBRTFELElBQUksSUFBSSxHQUFHO1VBQ1QsT0FBTyxFQUFFLE1BQU0sQ0FBQyxPQUFPO1VBQ3ZCLE9BQU8sRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsRUFBRSxtQkFBbUIsQ0FBQztTQUMxRCxDQUFDOztRQUVGLE1BQU0sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLG9CQUFvQixDQUFDLFVBQVUsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDLENBQUM7O1FBRXpFLE1BQU0sQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxtQkFBbUIsQ0FBQyxDQUFDOztRQUVwRSxPQUFPLElBQUksQ0FBQztPQUNiOzs7OztNQUtELFVBQVUsRUFBRSxTQUFTLFVBQVUsRUFBRSxtQkFBbUIsRUFBRTtRQUNwRCxPQUFPLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxNQUFNLENBQUMsU0FBUyxNQUFNLEVBQUU7VUFDL0MsT0FBTyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQztTQUNsQyxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsUUFBUSxFQUFFO1VBQ3hCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsVUFBVSxFQUFFLG1CQUFtQixDQUFDLENBQUM7U0FDbEUsRUFBRSxJQUFJLENBQUMsQ0FBQztPQUNWOzs7OztNQUtELFNBQVMsRUFBRSxTQUFTLFFBQVEsRUFBRSxVQUFVLEVBQUUsbUJBQW1CLEVBQUU7UUFDN0QsSUFBSSxhQUFhLENBQUM7O1FBRWxCLElBQUksQ0FBQyxJQUFJLENBQUMsb0JBQW9CLEVBQUU7VUFDOUIsYUFBYSxHQUFHLFFBQVEsQ0FBQyxvQkFBb0IsQ0FBQztVQUM5QyxRQUFRLENBQUMsb0JBQW9CLEdBQUcsS0FBSyxDQUFDO1NBQ3ZDOztRQUVELElBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQ3ZELElBQUksQ0FBQyxJQUFJLENBQUMsb0JBQW9CLEVBQUU7VUFDOUIsUUFBUSxDQUFDLG9CQUFvQixHQUFHLGFBQWEsQ0FBQztTQUMvQztRQUNELE9BQU8sTUFBTSxDQUFDO09BQ2Y7Ozs7O01BS0Qsb0JBQW9CLEVBQUUsU0FBUyxVQUFVLEVBQUUsbUJBQW1CLEVBQUU7UUFDOUQsSUFBSSxJQUFJLEdBQUcsR0FBRyxFQUFFLE9BQU8sR0FBRyxJQUFJLENBQUMsZUFBZSxFQUFFLE9BQU8sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDOztRQUU1RSxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUU7VUFDeEIsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVE7Y0FDM0MsSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsbUJBQW1CLENBQUM7Y0FDbEQsSUFBSSxDQUFDLGVBQWUsQ0FBQztTQUMxQjs7UUFFRCxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7VUFDckIsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVE7Y0FDckMsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsbUJBQW1CLENBQUM7Y0FDL0MsSUFBSSxDQUFDLFlBQVksQ0FBQztTQUN2QjtRQUNELElBQUksT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLGlCQUFpQixFQUFFO1VBQ3pDLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsVUFBVSxFQUFFLG1CQUFtQixDQUFDLENBQUM7U0FDakY7UUFDRCxJQUFJLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRTtVQUN6QyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLFVBQVUsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO1NBQzlFOztRQUVELE9BQU8sSUFBSSxDQUFDO09BQ2I7Ozs7Ozs7OztNQVNELHlCQUF5QixFQUFFLElBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQXVDL0IsS0FBSyxFQUFFLFNBQVMsT0FBTyxFQUFFLE9BQU8sRUFBRTtRQUNoQyxPQUFPLEtBQUssT0FBTyxHQUFHLEdBQUcsQ0FBQyxDQUFDOztRQUUzQixJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7O1FBRWhCLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3RDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDOztRQUVwQyxJQUFJLENBQUMscUJBQXFCLENBQUMsTUFBTSxFQUFFLGlCQUFpQixDQUFDLENBQUM7UUFDdEQsSUFBSSxDQUFDLHFCQUFxQixDQUFDLE1BQU0sRUFBRSxpQkFBaUIsRUFBRSxPQUFPLENBQUMsQ0FBQzs7UUFFL0QsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7O1FBRXJDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxNQUFNLEVBQUUsY0FBYyxDQUFDLENBQUM7UUFDbkQsSUFBSSxDQUFDLHFCQUFxQixDQUFDLE1BQU0sRUFBRSxjQUFjLEVBQUUsT0FBTyxDQUFDLENBQUM7O1FBRTVELE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7O1FBRXRCLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztPQUN4Qjs7Ozs7TUFLRCxlQUFlLEVBQUUsU0FBUyxNQUFNLEVBQUUsT0FBTyxFQUFFO1FBQ3pDLElBQUksT0FBTyxDQUFDLGdCQUFnQixFQUFFO1VBQzVCLE9BQU87U0FDUjtRQUNELE1BQU0sQ0FBQyxJQUFJO1VBQ1QsZ0NBQWdDLEdBQUcsT0FBTyxDQUFDLFFBQVEsSUFBSSxPQUFPLEdBQUcsd0JBQXdCO1VBQ3pGLGlEQUFpRDtVQUNqRCx1REFBdUQ7U0FDeEQsQ0FBQztPQUNIOzs7OztNQUtELGFBQWEsRUFBRSxTQUFTLE1BQU0sRUFBRSxPQUFPLEVBQUU7UUFDdkMsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSztZQUNuQyxNQUFNLEdBQUcsT0FBTyxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsTUFBTTtZQUN0QyxHQUFHLEVBQUUsT0FBTyxHQUFHLGVBQWUsR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUk7WUFDdEUsbUJBQW1CLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQzs7UUFFNUQsSUFBSSxPQUFPLENBQUMsT0FBTyxFQUFFO1VBQ25CLE9BQU8sR0FBRyxXQUFXO2tCQUNiLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLEdBQUc7a0JBQ3ZCLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLEdBQUc7a0JBQ3ZCLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxHQUFHLEdBQUc7a0JBQzNCLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztTQUN2QzthQUNJO1VBQ0gsSUFBSSxJQUFJLENBQUMseUJBQXlCLEVBQUU7WUFDbEMsR0FBRyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQztZQUM3QixPQUFPLEdBQUcsV0FBVztvQkFDYixPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLG1CQUFtQixDQUFDLEdBQUcsR0FBRztvQkFDcEQsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxtQkFBbUIsQ0FBQyxHQUFHLEdBQUc7b0JBQ3BELE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxtQkFBbUIsQ0FBQyxHQUFHLEdBQUc7b0JBQ3ZELE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxtQkFBbUIsQ0FBQyxHQUFHLElBQUksQ0FBQztXQUNuRTtTQUNGOztRQUVELE1BQU0sQ0FBQyxJQUFJO1VBQ1QsT0FBTztVQUNQLHFDQUFxQztVQUNyQyw2Q0FBNkM7VUFDN0MsZ0JBQWdCO1VBQ2hCLFNBQVMsRUFBRSxLQUFLLEVBQUUsSUFBSTtVQUN0QixVQUFVLEVBQUUsTUFBTSxFQUFFLElBQUk7VUFDeEIsT0FBTztVQUNQLHlCQUF5QjtVQUN6QiwrQkFBK0IsRUFBRSxNQUFNLENBQUMsT0FBTyxFQUFFLFdBQVc7VUFDNUQsVUFBVTtVQUNWLElBQUksQ0FBQyx3QkFBd0IsRUFBRTtVQUMvQixJQUFJLENBQUMsMEJBQTBCLEVBQUU7VUFDakMsV0FBVztTQUNaLENBQUM7T0FDSDs7Ozs7O01BTUQsMEJBQTBCLEVBQUUsV0FBVztRQUNyQyxJQUFJLEtBQUssR0FBRyxJQUFJO1lBQ1osTUFBTSxHQUFHLENBQUMsaUJBQWlCLEVBQUUsY0FBYyxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsSUFBSSxFQUFFO2NBQzlELElBQUksSUFBSSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztjQUN2QixJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO2dCQUN2QixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO2VBQ2pDO2FBQ0YsQ0FBQyxDQUFDO1FBQ1AsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO09BQ3hCOzs7Ozs7Ozs7TUFTRCx3QkFBd0IsRUFBRSxXQUFXO1FBQ25DLElBQUksTUFBTSxHQUFHLEVBQUUsRUFBRSxRQUFRLEdBQUcsR0FBRyxFQUFFLEdBQUcsRUFBRSxVQUFVO1lBQzVDLEtBQUssRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxFQUFFLEdBQUc7WUFDOUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLEVBQUUsT0FBTyxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQzs7UUFFOUQsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7VUFDOUMsR0FBRyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztVQUNqQixVQUFVLEdBQUcsR0FBRyxDQUFDLFVBQVUsQ0FBQztVQUM1QixJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUNyRixTQUFTO1dBQ1Y7VUFDRCxRQUFRLENBQUMsVUFBVSxDQUFDLEdBQUcsSUFBSSxDQUFDO1VBQzVCLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFO1lBQ2YsU0FBUztXQUNWO1VBQ0QsS0FBSyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUM7VUFDbkIsS0FBSyxRQUFRLElBQUksS0FBSyxFQUFFO1lBQ3RCLEdBQUcsR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDdEIsS0FBSyxTQUFTLElBQUksR0FBRyxFQUFFO2NBQ3JCLEtBQUssR0FBRyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7Y0FDdkIsVUFBVSxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUM7Y0FDOUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsSUFBSSxTQUFTLENBQUMsVUFBVSxDQUFDLEVBQUU7Z0JBQ2xELFFBQVEsQ0FBQyxVQUFVLENBQUMsR0FBRyxJQUFJLENBQUM7ZUFDN0I7YUFDRjtXQUNGO1NBQ0Y7O1FBRUQsS0FBSyxJQUFJLENBQUMsSUFBSSxRQUFRLEVBQUU7VUFDdEIsTUFBTSxJQUFJO1lBQ1Isb0JBQW9CO1lBQ3BCLHVCQUF1QixFQUFFLENBQUMsRUFBRSxPQUFPO1lBQ25DLG1CQUFtQixFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRO1lBQzNDLFNBQVM7V0FDVixDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNaOztRQUVELElBQUksTUFBTSxFQUFFO1VBQ1YsTUFBTSxHQUFHO1lBQ1AsMkJBQTJCO1lBQzNCLGFBQWE7WUFDYixNQUFNO1lBQ04sS0FBSztZQUNMLFlBQVk7V0FDYixDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNaOztRQUVELE9BQU8sTUFBTSxDQUFDO09BQ2Y7Ozs7O01BS0QsY0FBYyxFQUFFLFNBQVMsTUFBTSxFQUFFLE9BQU8sRUFBRTtRQUN4QyxJQUFJLFFBQVEsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDbEQsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7VUFDOUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztVQUN0QixJQUFJLFFBQVEsQ0FBQyxpQkFBaUIsRUFBRTtZQUM5QixTQUFTO1dBQ1Y7VUFDRCxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDL0M7T0FDRjs7Ozs7TUFLRCxhQUFhLEVBQUUsU0FBUyxNQUFNLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRTtRQUNqRCxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztPQUN0Qzs7Ozs7TUFLRCxxQkFBcUIsRUFBRSxTQUFTLE1BQU0sRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFO1FBQ3pELElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxLQUFLLEVBQUU7VUFDMUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7U0FDNUM7T0FDRjs7Ozs7TUFLRCxxQkFBcUIsRUFBRSxTQUFTLE1BQU0sRUFBRSxRQUFRLEVBQUU7UUFDaEQsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLEdBQUcsR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUN2RixXQUFXLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdkMsSUFBSSxDQUFDLE1BQU0sRUFBRTtVQUNYLE9BQU87U0FDUjtRQUNELElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRTtVQUNqQixJQUFJLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1VBQzNCLE1BQU0sQ0FBQyxJQUFJO1lBQ1QsNkJBQTZCLEVBQUUsVUFBVSxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsV0FBVyxHQUFHLENBQUMsRUFBRSxJQUFJO1lBQ3pFLE1BQU0sRUFBRSxNQUFNLENBQUMsT0FBTyxHQUFHLFVBQVUsR0FBRyxDQUFDLEVBQUUsT0FBTyxFQUFFLE1BQU0sQ0FBQyxPQUFPLEdBQUcsV0FBVyxHQUFHLENBQUMsRUFBRSxJQUFJO1lBQ3hGLFNBQVM7YUFDUixNQUFNLEtBQUssVUFBVSxJQUFJLE1BQU0sS0FBSyxXQUFXO2dCQUM1QyxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUs7Z0JBQ25CLFVBQVU7WUFDZCxZQUFZO2FBQ1gsTUFBTSxLQUFLLFVBQVUsSUFBSSxNQUFNLEtBQUssV0FBVztnQkFDNUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNO2dCQUNwQixXQUFXO1lBQ2YscUJBQXFCLEdBQUcsTUFBTSxDQUFDLEVBQUUsR0FBRyxJQUFJO1lBQ3hDLFlBQVk7V0FDYixDQUFDO1NBQ0g7YUFDSTtVQUNILE1BQU0sQ0FBQyxJQUFJO1lBQ1QsK0NBQStDO1lBQy9DLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsR0FBRztZQUM3QixZQUFZO1dBQ2IsQ0FBQztTQUNIO09BQ0Y7Ozs7Ozs7Ozs7TUFVRCxVQUFVLEVBQUUsVUFBVSxNQUFNLEVBQUU7UUFDNUIsSUFBSSxDQUFDLE1BQU0sRUFBRTtVQUNYLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFDRCxJQUFJLGVBQWUsR0FBRyxJQUFJLENBQUMsYUFBYTtZQUNwQyxDQUFDLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQztRQUNqQixJQUFJLE1BQU0sS0FBSyxlQUFlLElBQUksTUFBTSxDQUFDLElBQUksS0FBSyxpQkFBaUIsRUFBRTtVQUNuRSxJQUFJLEdBQUcsZUFBZSxDQUFDLFFBQVEsQ0FBQztVQUNoQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxHQUFHO1lBQzFCLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDZCxlQUFlLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQztZQUNwQyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztXQUM1QjtTQUNGO2FBQ0k7VUFDSCxlQUFlLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztVQUN2QyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUMvQjtRQUNELElBQUksQ0FBQyxpQkFBaUIsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUNsRCxPQUFPLElBQUksQ0FBQztPQUNiOzs7Ozs7Ozs7TUFTRCxZQUFZLEVBQUUsVUFBVSxNQUFNLEVBQUU7UUFDOUIsSUFBSSxDQUFDLE1BQU0sRUFBRTtVQUNYLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFDRCxJQUFJLGVBQWUsR0FBRyxJQUFJLENBQUMsYUFBYTtZQUNwQyxDQUFDLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQztRQUNqQixJQUFJLE1BQU0sS0FBSyxlQUFlLElBQUksTUFBTSxDQUFDLElBQUksS0FBSyxpQkFBaUIsRUFBRTtVQUNuRSxJQUFJLEdBQUcsZUFBZSxDQUFDLFFBQVEsQ0FBQztVQUNoQyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDaEMsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNkLGVBQWUsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ3BDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1dBQ3pCO1NBQ0Y7YUFDSTtVQUNILGVBQWUsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1VBQ3ZDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQzVCO1FBQ0QsSUFBSSxDQUFDLGlCQUFpQixJQUFJLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQ2xELE9BQU8sSUFBSSxDQUFDO09BQ2I7Ozs7Ozs7Ozs7Ozs7TUFhRCxhQUFhLEVBQUUsVUFBVSxNQUFNLEVBQUUsWUFBWSxFQUFFO1FBQzdDLElBQUksQ0FBQyxNQUFNLEVBQUU7VUFDWCxPQUFPLElBQUksQ0FBQztTQUNiO1FBQ0QsSUFBSSxlQUFlLEdBQUcsSUFBSSxDQUFDLGFBQWE7WUFDcEMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxTQUFTLEdBQUcsQ0FBQyxDQUFDOztRQUU3QyxJQUFJLE1BQU0sS0FBSyxlQUFlLElBQUksTUFBTSxDQUFDLElBQUksS0FBSyxpQkFBaUIsRUFBRTtVQUNuRSxJQUFJLEdBQUcsZUFBZSxDQUFDLFFBQVEsQ0FBQztVQUNoQyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDaEMsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNkLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNqQyxJQUFJLEdBQUcsR0FBRyxDQUFDLEdBQUcsU0FBUyxFQUFFO2NBQ3ZCLE1BQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2NBQ2pCLGVBQWUsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO2NBQ3BDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7YUFDdEM7WUFDRCxTQUFTLEVBQUUsQ0FBQztXQUNiO1NBQ0Y7YUFDSTtVQUNILEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztVQUNwQyxJQUFJLEdBQUcsS0FBSyxDQUFDLEVBQUU7O1lBRWIsTUFBTSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLFlBQVksQ0FBQyxDQUFDO1lBQzVELGVBQWUsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQ3ZDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7V0FDekM7U0FDRjtRQUNELElBQUksQ0FBQyxpQkFBaUIsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUNsRCxPQUFPLElBQUksQ0FBQztPQUNiOzs7OztNQUtELGtCQUFrQixFQUFFLFNBQVMsTUFBTSxFQUFFLEdBQUcsRUFBRSxZQUFZLEVBQUU7UUFDdEQsSUFBSSxNQUFNLEVBQUUsQ0FBQyxDQUFDOztRQUVkLElBQUksWUFBWSxFQUFFO1VBQ2hCLE1BQU0sR0FBRyxHQUFHLENBQUM7OztVQUdiLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRTs7WUFFN0IsSUFBSSxjQUFjLEdBQUcsTUFBTSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7aUNBQzdDLE1BQU0sQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO2lDQUNoRCxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLHVCQUF1QixDQUFDLE1BQU0sQ0FBQyxDQUFDOztZQUV0RSxJQUFJLGNBQWMsRUFBRTtjQUNsQixNQUFNLEdBQUcsQ0FBQyxDQUFDO2NBQ1gsTUFBTTthQUNQO1dBQ0Y7U0FDRjthQUNJO1VBQ0gsTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7U0FDbEI7O1FBRUQsT0FBTyxNQUFNLENBQUM7T0FDZjs7Ozs7Ozs7Ozs7OztNQWFELFlBQVksRUFBRSxVQUFVLE1BQU0sRUFBRSxZQUFZLEVBQUU7UUFDNUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtVQUNYLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFDRCxJQUFJLGVBQWUsR0FBRyxJQUFJLENBQUMsYUFBYTtZQUNwQyxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFNBQVMsR0FBRyxDQUFDLENBQUM7O1FBRTdDLElBQUksTUFBTSxLQUFLLGVBQWUsSUFBSSxNQUFNLENBQUMsSUFBSSxLQUFLLGlCQUFpQixFQUFFO1VBQ25FLElBQUksR0FBRyxlQUFlLENBQUMsUUFBUSxDQUFDO1VBQ2hDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEdBQUc7WUFDMUIsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNkLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNqQyxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsU0FBUyxFQUFFO2NBQzlDLE1BQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2NBQ2pCLGVBQWUsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO2NBQ3BDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7YUFDdEM7WUFDRCxTQUFTLEVBQUUsQ0FBQztXQUNiO1NBQ0Y7YUFDSTtVQUNILEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztVQUNwQyxJQUFJLEdBQUcsS0FBSyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7O1lBRXBDLE1BQU0sR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxZQUFZLENBQUMsQ0FBQztZQUM1RCxlQUFlLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztZQUN2QyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1dBQ3pDO1NBQ0Y7UUFDRCxJQUFJLENBQUMsaUJBQWlCLElBQUksSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFDbEQsT0FBTyxJQUFJLENBQUM7T0FDYjs7Ozs7TUFLRCxrQkFBa0IsRUFBRSxTQUFTLE1BQU0sRUFBRSxHQUFHLEVBQUUsWUFBWSxFQUFFO1FBQ3RELElBQUksTUFBTSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUM7O1FBRW5CLElBQUksWUFBWSxFQUFFO1VBQ2hCLE1BQU0sR0FBRyxHQUFHLENBQUM7OztVQUdiLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUU7O1lBRTFELElBQUksY0FBYyxHQUFHLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO2lDQUM3QyxNQUFNLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQ0FDaEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyx1QkFBdUIsQ0FBQyxNQUFNLENBQUMsQ0FBQzs7WUFFdEUsSUFBSSxjQUFjLEVBQUU7Y0FDbEIsTUFBTSxHQUFHLENBQUMsQ0FBQztjQUNYLE1BQU07YUFDUDtXQUNGO1NBQ0Y7YUFDSTtVQUNILE1BQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1NBQ2xCOztRQUVELE9BQU8sTUFBTSxDQUFDO09BQ2Y7Ozs7Ozs7OztNQVNELE1BQU0sRUFBRSxVQUFVLE1BQU0sRUFBRSxLQUFLLEVBQUU7UUFDL0IsZUFBZSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDdkMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUN2QyxPQUFPLElBQUksQ0FBQyxpQkFBaUIsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztPQUMxRDs7Ozs7OztNQU9ELE9BQU8sRUFBRSxZQUFZOztRQUVuQixJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUU7VUFDcEIsTUFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1VBQzlDLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDO1NBQ3RCO1FBQ0QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLE1BQU0sRUFBRTtVQUNsQyxNQUFNLENBQUMsT0FBTyxJQUFJLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUNwQyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztRQUNuQixJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQztRQUM1QixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztRQUN6QixJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQztRQUM1QixJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQztRQUMxQixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDO1FBQzdCLE9BQU8sSUFBSSxDQUFDO09BQ2I7Ozs7OztNQU1ELFFBQVEsRUFBRSxZQUFZO1FBQ3BCLE9BQU8sbUJBQW1CLEdBQUcsSUFBSSxDQUFDLFVBQVUsRUFBRSxHQUFHLEtBQUs7aUJBQzdDLGFBQWEsR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztPQUMzRDtLQUNGLENBQUMsQ0FBQzs7SUFFSCxNQUFNLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3pELE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDekQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQzs7SUFFOUQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxZQUFZLG9DQUFvQzs7Ozs7OztNQU81RCxVQUFVLEVBQUUsd0NBQXdDOzs7Ozs7Ozs7OztNQVdwRCxRQUFRLEVBQUUsVUFBVSxVQUFVLEVBQUU7UUFDOUIsSUFBSSxFQUFFLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDOztRQUUzQyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRTtVQUN6QixPQUFPLElBQUksQ0FBQztTQUNiOztRQUVELElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDOUIsSUFBSSxDQUFDLEdBQUcsRUFBRTtVQUNSLE9BQU8sSUFBSSxDQUFDO1NBQ2I7O1FBRUQsUUFBUSxVQUFVOztVQUVoQixLQUFLLGNBQWM7WUFDakIsT0FBTyxPQUFPLEdBQUcsQ0FBQyxZQUFZLEtBQUssV0FBVyxDQUFDOztVQUVqRCxLQUFLLGFBQWE7WUFDaEIsT0FBTyxPQUFPLEdBQUcsQ0FBQyxXQUFXLEtBQUssV0FBVyxDQUFDOztVQUVoRCxLQUFLLFdBQVc7WUFDZCxPQUFPLE9BQU8sRUFBRSxDQUFDLFNBQVMsS0FBSyxXQUFXLENBQUM7O1VBRTdDLEtBQUssc0JBQXNCO1lBQ3pCLElBQUk7Y0FDRixFQUFFLENBQUMsU0FBUyxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQztjQUM5QixPQUFPLElBQUksQ0FBQzthQUNiO1lBQ0QsT0FBTyxDQUFDLEVBQUUsR0FBRztZQUNiLE9BQU8sS0FBSyxDQUFDOztVQUVmO1lBQ0UsT0FBTyxJQUFJLENBQUM7U0FDZjtPQUNGO0tBQ0YsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztJQWlCSCxNQUFNLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDOztJQUU5RSxJQUFJLE1BQU0sQ0FBQyxZQUFZLEVBQUU7TUFDdkIsTUFBTSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsZUFBZSxHQUFHLFdBQVc7UUFDekQsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ3pELE9BQU8sSUFBSSxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztPQUN2QyxDQUFDO01BQ0YsTUFBTSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLEdBQUcsU0FBUyxJQUFJLEVBQUU7UUFDOUQsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ3pELE9BQU8sSUFBSSxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztPQUM1QyxDQUFDO0tBQ0g7R0FDRixHQUFHLENBQUM7Ozs7Ozs7O0VBUUwsTUFBTSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsMENBQTBDOzs7Ozs7O0lBT2xGLEtBQUssRUFBRSxjQUFjOzs7Ozs7O0lBT3JCLEtBQUssRUFBRSxDQUFDOzs7Ozs7Ozs7SUFTUixNQUFNLEVBQUUsSUFBSTs7Ozs7OztJQU9aLGFBQWEsRUFBRSxPQUFPOzs7Ozs7O0lBT3RCLGNBQWMsRUFBRSxPQUFPOzs7Ozs7O0lBT3ZCLGdCQUFnQixVQUFVLEVBQUU7Ozs7Ozs7SUFPNUIsZUFBZSxFQUFFLElBQUk7Ozs7Ozs7O0lBUXJCLFNBQVMsRUFBRSxTQUFTLE9BQU8sRUFBRTtNQUMzQixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztNQUN6QyxPQUFPLElBQUksQ0FBQztLQUNiOzs7Ozs7SUFNRCxlQUFlLEVBQUUsV0FBVztNQUMxQixJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQztNQUNqQyxHQUFHLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7TUFDN0IsR0FBRyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO01BQzNCLEdBQUcsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQztNQUNqQyxHQUFHLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQztNQUN2QyxHQUFHLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUM7TUFDbkMsSUFBSSxNQUFNLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsRUFBRTtRQUMvQyxHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxlQUFlLElBQUksRUFBRSxDQUFDLENBQUM7T0FDN0M7S0FDRjs7Ozs7OztJQU9ELGlCQUFpQixFQUFFLFNBQVMsR0FBRyxFQUFFO01BQy9CLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUM7TUFDdEMsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDO01BQ1gsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ25EOzs7Ozs7SUFNRCxVQUFVLEVBQUUsV0FBVztNQUNyQixJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtRQUNoQixPQUFPO09BQ1I7O01BRUQsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVO1VBQzVCLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDOztNQUVqQyxHQUFHLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO01BQ3BDLEdBQUcsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO01BQ3pDLEdBQUcsQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO01BQy9DLEdBQUcsQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO0tBQ2hEOzs7Ozs7SUFNRCxZQUFZLEVBQUUsV0FBVztNQUN2QixJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQzs7TUFFakMsR0FBRyxDQUFDLFdBQVcsR0FBRyxFQUFFLENBQUM7TUFDckIsR0FBRyxDQUFDLFVBQVUsR0FBRyxHQUFHLENBQUMsYUFBYSxHQUFHLEdBQUcsQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDO0tBQzVEO0dBQ0YsQ0FBQyxDQUFDOzs7RUFHSCxDQUFDLFdBQVc7Ozs7Ozs7SUFPVixNQUFNLENBQUMsV0FBVyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxTQUFTLDZDQUE2Qzs7Ozs7OztNQU94RyxVQUFVLEVBQUUsU0FBUyxNQUFNLEVBQUU7UUFDM0IsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7T0FDbkI7Ozs7OztNQU1ELFlBQVksRUFBRSxVQUFVLEdBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO1FBQ25DLElBQUksUUFBUSxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDbkMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN6RCxPQUFPLFFBQVEsQ0FBQztPQUNqQjs7Ozs7O01BTUQsV0FBVyxFQUFFLFNBQVMsT0FBTyxFQUFFO1FBQzdCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7O1FBR2pDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNsQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7T0FDaEI7Ozs7OztNQU1ELFdBQVcsRUFBRSxTQUFTLE9BQU8sRUFBRTtRQUM3QixJQUFJLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7VUFDaEUsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFOzs7WUFHeEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUNqRCxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7V0FDaEI7ZUFDSTtZQUNILElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDOztZQUVoRixJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDNUIsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO2NBQ2YsR0FBRyxDQUFDLFNBQVMsRUFBRSxDQUFDO2NBQ2hCLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUMxQztZQUNELElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ25GLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUNiLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztXQUNmO1NBQ0Y7T0FDRjs7Ozs7TUFLRCxTQUFTLEVBQUUsV0FBVztRQUNwQixJQUFJLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQztRQUN4QixJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztPQUM1Qjs7Ozs7O01BTUQsa0JBQWtCLEVBQUUsU0FBUyxPQUFPLEVBQUU7O1FBRXBDLElBQUksQ0FBQyxHQUFHLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQzs7UUFFL0MsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ2QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNsQixJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7T0FDekM7Ozs7OztNQU1ELFNBQVMsRUFBRSxTQUFTLEtBQUssRUFBRTtRQUN6QixJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTtVQUM5RSxPQUFPLEtBQUssQ0FBQztTQUNkO1FBQ0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDekIsT0FBTyxJQUFJLENBQUM7T0FDYjs7Ozs7O01BTUQsTUFBTSxFQUFFLFdBQVc7UUFDakIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN2QixJQUFJLEtBQUssR0FBRyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxlQUFlLElBQUksS0FBSyxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztPQUNuQjs7Ozs7O01BTUQsbUJBQW1CLEVBQUUsU0FBUyxPQUFPLEVBQUU7UUFDckMsSUFBSSxZQUFZLEdBQUcsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzFELE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQztPQUNyQzs7Ozs7O01BTUQsT0FBTyxFQUFFLFdBQVc7UUFDbEIsSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLEdBQUc7WUFDckMsRUFBRSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ3BCLEVBQUUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDOztRQUV6QixJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDNUIsR0FBRyxDQUFDLFNBQVMsRUFBRSxDQUFDOzs7OztRQUtoQixJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxFQUFFO1VBQy9ELElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO1VBQzlCLEVBQUUsR0FBRyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7VUFDbEMsRUFBRSxHQUFHLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztVQUNsQyxFQUFFLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQztVQUNkLEVBQUUsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDO1NBQ2Y7UUFDRCxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDOztRQUV2QixLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7OztVQUduRCxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7VUFDL0IsRUFBRSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7VUFDckIsRUFBRSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQzFCOzs7O1FBSUQsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2QixHQUFHLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDYixHQUFHLENBQUMsT0FBTyxFQUFFLENBQUM7T0FDZjs7Ozs7OztNQU9ELHNCQUFzQixFQUFFLFNBQVMsTUFBTSxFQUFFO1FBQ3ZDLElBQUksSUFBSSxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSTtZQUN2QyxFQUFFLEdBQUcsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMvQyxFQUFFLEdBQUcsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMvQyxHQUFHLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxTQUFTLEdBQUcsQ0FBQyxFQUFFLFNBQVMsR0FBRyxDQUFDLEVBQUUsVUFBVSxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7O1FBRTVFLElBQUksVUFBVSxFQUFFO1VBQ2QsU0FBUyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztVQUNuRSxTQUFTLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3BFO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxTQUFTLEdBQUcsS0FBSyxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLFNBQVMsR0FBRyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDOUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7VUFD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QUFDO1lBQzFELElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQztXQUMvRDtlQUNJO1lBQ0gsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDaEIsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUNqRSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUNyRSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUMxRSxJQUFJLENBQUMs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QUcsRUFBRSxDQUFDLENBQUM7Y0FDL0IsTUFBTTtZQUNSLEtBQUssVUFBVTtjQUNiLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDO2NBQ2pCLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztjQUNyQixJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUM7Y0FDckIsTUFBTTtZQUNSLEtBQUssUUFBUTtjQUNYLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztjQUMxQixJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO2NBQzlCLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7Y0FDOUIsTUFBTTtZQUNSLEtBQUssU0FBUztjQUNaLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztjQUMxQixJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO2NBQzlCLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7Y0FDOUIsTUFBTTtZQUNSLEtBQUssU0FBUztjQUNaLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7Y0FDbkYsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7Y0FDdkYsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7Y0FDdkYsTUFBTTtZQUNSLEtBQUssV0FBVztjQUNkLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7Y0FDeEMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7Y0FDNUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7Y0FDNUMsTUFBTTtZQUNSLEtBQUssTUFBTTtjQUNULElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLE1BQU0sQ0FBQztjQUMxQixJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMs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RyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ3hDLElBQUksR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQzs7UUFFM0IsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUU7O1VBRWYsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQzs7VUFFakMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQzs7VUFFakMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNsQzs7OztRQUlELEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7VUFDbkMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDO1VBQzlDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQztVQUM5QyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUM7U0FDL0M7UUFDRCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFO1VBQzlDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1VBQzlCLElBQUks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QUksQ0FBQyxNQUFNLEdBQUc7VUFDWixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztVQUNiLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1VBQ2IsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7VUFDYixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztTQUNkLENBQUM7UUFDRixJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxXQUFXLEdBQUcsQ0FBQyxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxHQUFHLFdBQVcsR0FBRyxZQUFZLENBQUM7UUFDckQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLEdBQUcsV0FBVyxHQUFHLFlBQVksQ0FBQztRQUNyRCxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sR0FBRyxXQUFXLEdBQUcsWUFBWSxDQUFDO1FBQ3JELElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLE1BQU0sR0FBRyxXQUFXLENBQUM7UUFDNUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLEdBQUcsV0FBVyxHQUFHLFlBQVksQ0FBQztRQUNyRCxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sR0FBRyxXQUFXLEdBQUcsWUFBWSxDQUFDO1FBQ3RELElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxHQUFHLFdBQVcsR0FBRyxZQUFZLENBQUM7UUFDdEQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLEdBQUcsTUFBTSxHQUFHLFdBQVcsQ0FBQztPQUM5Qzs7Ozs7Ozs7Ozs7Ozs7O01BZUQsT0FBTyxFQUFF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
